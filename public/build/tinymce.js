(self["webpackChunk"] = self["webpackChunk"] || []).push([["tinymce"],{

/***/ "./node_modules/tinymce/tinymce.js":
/*!*****************************************!*\
  !*** ./node_modules/tinymce/tinymce.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * TinyMCE version 6.7.0 (2023-08-30)
 */

(function () {
    'use strict';

    var typeOf$1 = function (x) {
      if (x === null) {
        return 'null';
      }
      if (x === undefined) {
        return 'undefined';
      }
      var t = typeof x;
      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
      }
      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
      }
      return t;
    };
    var isEquatableType = function (x) {
      return [
        'undefined',
        'boolean',
        'number',
        'string',
        'function',
        'xml',
        'null'
      ].indexOf(x) !== -1;
    };

    var sort$1 = function (xs, compareFn) {
      var clone = Array.prototype.slice.call(xs);
      return clone.sort(compareFn);
    };

    var contramap = function (eqa, f) {
      return eq$2(function (x, y) {
        return eqa.eq(f(x), f(y));
      });
    };
    var eq$2 = function (f) {
      return { eq: f };
    };
    var tripleEq = eq$2(function (x, y) {
      return x === y;
    });
    var eqString = tripleEq;
    var eqArray = function (eqa) {
      return eq$2(function (x, y) {
        if (x.length !== y.length) {
          return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
          if (!eqa.eq(x[i], y[i])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqSortedArray = function (eqa, compareFn) {
      return contramap(eqArray(eqa), function (xs) {
        return sort$1(xs, compareFn);
      });
    };
    var eqRecord = function (eqa) {
      return eq$2(function (x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
          return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
          var q = kx[i];
          if (!eqa.eq(x[q], y[q])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqAny = eq$2(function (x, y) {
      if (x === y) {
        return true;
      }
      var tx = typeOf$1(x);
      var ty = typeOf$1(y);
      if (tx !== ty) {
        return false;
      }
      if (isEquatableType(tx)) {
        return x === y;
      } else if (tx === 'array') {
        return eqArray(eqAny).eq(x, y);
      } else if (tx === 'object') {
        return eqRecord(eqAny).eq(x, y);
      }
      return false;
    });

    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
      var _a;
      if (predicate(v, constructor.prototype)) {
        return true;
      } else {
        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
      }
    };
    const typeOf = x => {
      const t = typeof x;
      if (x === null) {
        return 'null';
      } else if (t === 'object' && Array.isArray(x)) {
        return 'array';
      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
        return 'string';
      } else {
        return t;
      }
    };
    const isType$1 = type => value => typeOf(value) === type;
    const isSimpleType = type => value => typeof value === type;
    const eq$1 = t => a => t === a;
    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString = isType$1('string');
    const isObject = isType$1('object');
    const isPlainObject = value => is$4(value, Object);
    const isArray$1 = isType$1('array');
    const isNull = eq$1(null);
    const isBoolean = isSimpleType('boolean');
    const isUndefined = eq$1(undefined);
    const isNullable = a => a === null || a === undefined;
    const isNonNullable = a => !isNullable(a);
    const isFunction = isSimpleType('function');
    const isNumber = isSimpleType('number');
    const isArrayOf = (value, pred) => {
      if (isArray$1(value)) {
        for (let i = 0, len = value.length; i < len; ++i) {
          if (!pred(value[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    const noop = () => {
    };
    const compose = (fa, fb) => {
      return (...args) => {
        return fa(fb.apply(null, args));
      };
    };
    const compose1 = (fbc, fab) => a => fbc(fab(a));
    const constant = value => {
      return () => {
        return value;
      };
    };
    const identity = x => {
      return x;
    };
    const tripleEquals = (a, b) => {
      return a === b;
    };
    function curry(fn, ...initialArgs) {
      return (...restArgs) => {
        const all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    const not = f => t => !f(t);
    const die = msg => {
      return () => {
        throw new Error(msg);
      };
    };
    const apply$1 = f => {
      return f();
    };
    const call = f => {
      f();
    };
    const never = constant(false);
    const always = constant(true);

    class Optional {
      constructor(tag, value) {
        this.tag = tag;
        this.value = value;
      }
      static some(value) {
        return new Optional(true, value);
      }
      static none() {
        return Optional.singletonNone;
      }
      fold(onNone, onSome) {
        if (this.tag) {
          return onSome(this.value);
        } else {
          return onNone();
        }
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(mapper) {
        if (this.tag) {
          return Optional.some(mapper(this.value));
        } else {
          return Optional.none();
        }
      }
      bind(binder) {
        if (this.tag) {
          return binder(this.value);
        } else {
          return Optional.none();
        }
      }
      exists(predicate) {
        return this.tag && predicate(this.value);
      }
      forall(predicate) {
        return !this.tag || predicate(this.value);
      }
      filter(predicate) {
        if (!this.tag || predicate(this.value)) {
          return this;
        } else {
          return Optional.none();
        }
      }
      getOr(replacement) {
        return this.tag ? this.value : replacement;
      }
      or(replacement) {
        return this.tag ? this : replacement;
      }
      getOrThunk(thunk) {
        return this.tag ? this.value : thunk();
      }
      orThunk(thunk) {
        return this.tag ? this : thunk();
      }
      getOrDie(message) {
        if (!this.tag) {
          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');
        } else {
          return this.value;
        }
      }
      static from(value) {
        return isNonNullable(value) ? Optional.some(value) : Optional.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(worker) {
        if (this.tag) {
          worker(this.value);
        }
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${ this.value })` : 'none()';
      }
    }
    Optional.singletonNone = new Optional(false);

    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf$1 = (xs, x) => {
      const r = rawIndexOf(xs, x);
      return r === -1 ? Optional.none() : Optional.some(r);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    const map$3 = (xs, f) => {
      const len = xs.length;
      const r = new Array(len);
      for (let i = 0; i < len; i++) {
        const x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    const each$e = (xs, f) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        f(x, i);
      }
    };
    const eachr = (xs, f) => {
      for (let i = xs.length - 1; i >= 0; i--) {
        const x = xs[i];
        f(x, i);
      }
    };
    const partition$2 = (xs, pred) => {
      const pass = [];
      const fail = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        const arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass,
        fail
      };
    };
    const filter$5 = (xs, pred) => {
      const r = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    const foldr = (xs, f, acc) => {
      eachr(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const foldl = (xs, f, acc) => {
      each$e(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const findUntil$1 = (xs, pred, until) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    const find$2 = (xs, pred) => {
      return findUntil$1(xs, pred, never);
    };
    const findIndex$2 = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    const flatten = xs => {
      const r = [];
      for (let i = 0, len = xs.length; i < len; ++i) {
        if (!isArray$1(xs[i])) {
          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    const bind$3 = (xs, f) => flatten(map$3(xs, f));
    const forall = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; ++i) {
        const x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    const reverse = xs => {
      const r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
      const r = {};
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    const sort = (xs, comparator) => {
      const copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = xs => get$b(xs, 0);
    const last$3 = xs => get$b(xs, xs.length - 1);
    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);
    const findMap = (arr, f) => {
      for (let i = 0; i < arr.length; i++) {
        const r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Optional.none();
    };
    const unique$1 = (xs, comparator) => {
      const r = [];
      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (!isDuplicated(x)) {
          r.push(x);
        }
      }
      return r;
    };

    const keys = Object.keys;
    const hasOwnProperty$2 = Object.hasOwnProperty;
    const each$d = (obj, f) => {
      const props = keys(obj);
      for (let k = 0, len = props.length; k < len; k++) {
        const i = props[k];
        const x = obj[i];
        f(x, i);
      }
    };
    const map$2 = (obj, f) => {
      return tupleMap(obj, (x, i) => ({
        k: i,
        v: f(x, i)
      }));
    };
    const tupleMap = (obj, f) => {
      const r = {};
      each$d(obj, (x, i) => {
        const tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    const objAcc = r => (x, i) => {
      r[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
      each$d(obj, (x, i) => {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
    };
    const bifilter = (obj, pred) => {
      const t = {};
      const f = {};
      internalFilter(obj, pred, objAcc(t), objAcc(f));
      return {
        t,
        f
      };
    };
    const filter$4 = (obj, pred) => {
      const t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    const mapToArray = (obj, f) => {
      const r = [];
      each$d(obj, (value, name) => {
        r.push(f(value, name));
      });
      return r;
    };
    const values = obj => {
      return mapToArray(obj, identity);
    };
    const get$a = (obj, key) => {
      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);

    const stringArray = a => {
      const all = {};
      each$e(a, key => {
        all[key] = {};
      });
      return keys(all);
    };

    const isArrayLike = o => o.length !== undefined;
    const isArray = Array.isArray;
    const toArray$1 = obj => {
      if (!isArray(obj)) {
        const array = [];
        for (let i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
        return array;
      } else {
        return obj;
      }
    };
    const each$c = (o, cb, s) => {
      if (!o) {
        return false;
      }
      s = s || o;
      if (isArrayLike(o)) {
        for (let n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      } else {
        for (const n in o) {
          if (has$2(o, n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return false;
            }
          }
        }
      }
      return true;
    };
    const map$1 = (array, callback) => {
      const out = [];
      each$c(array, (item, index) => {
        out.push(callback(item, index, array));
      });
      return out;
    };
    const filter$3 = (a, f) => {
      const o = [];
      each$c(a, (v, index) => {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });
      return o;
    };
    const indexOf = (a, v) => {
      if (a) {
        for (let i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }
      return -1;
    };
    const reduce = (collection, iteratee, accumulator, thisArg) => {
      let acc = isUndefined(accumulator) ? collection[0] : accumulator;
      for (let i = 0; i < collection.length; i++) {
        acc = iteratee.call(thisArg, acc, collection[i], i);
      }
      return acc;
    };
    const findIndex$1 = (array, predicate, thisArg) => {
      for (let i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    const last$2 = collection => collection[collection.length - 1];

    const cached = f => {
      let called = false;
      let r;
      return (...args) => {
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    const DeviceType = (os, browser, userAgent, mediaMatch) => {
      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
      const isiPhone = os.isiOS() && !isiPad;
      const isMobile = os.isiOS() || os.isAndroid();
      const isTouch = isMobile || mediaMatch('(pointer:coarse)');
      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
      const isPhone = isiPhone || isMobile && !isTablet;
      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
      const isDesktop = !isPhone && !isTablet && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    const firstMatch = (regexes, s) => {
      for (let i = 0; i < regexes.length; i++) {
        const x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    const find$1 = (regexes, agent) => {
      const r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      const group = i => {
        return Number(agent.replace(r, '$' + i));
      };
      return nu$3(group(1), group(2));
    };
    const detect$5 = (versionRegexes, agent) => {
      const cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find$1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = () => {
      return nu$3(0, 0);
    };
    const nu$3 = (major, minor) => {
      return {
        major,
        minor
      };
    };
    const Version = {
      nu: nu$3,
      detect: detect$5,
      unknown: unknown$2
    };

    const detectBrowser$1 = (browsers, userAgentData) => {
      return findMap(userAgentData.brands, uaBrand => {
        const lcBrand = uaBrand.brand.toLowerCase();
        return find$2(browsers, browser => {
          var _a;
          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map(info => ({
          current: info.name,
          version: Version.nu(parseInt(uaBrand.version, 10), 0)
        }));
      });
    };

    const detect$4 = (candidates, userAgent) => {
      const agent = String(userAgent).toLowerCase();
      return find$2(candidates, candidate => {
        return candidate.search(agent);
      });
    };
    const detectBrowser = (browsers, userAgent) => {
      return detect$4(browsers, userAgent).map(browser => {
        const version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version
        };
      });
    };
    const detectOs = (oses, userAgent) => {
      return detect$4(oses, userAgent).map(os => {
        const version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version
        };
      });
    };

    const removeFromStart = (str, numChars) => {
      return str.substring(numChars);
    };

    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
    const removeLeading = (str, prefix) => {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const contains$1 = (str, substr, start = 0, end) => {
      const idx = str.indexOf(substr, start);
      if (idx !== -1) {
        return isUndefined(end) ? true : idx + substr.length <= end;
      } else {
        return false;
      }
    };
    const startsWith = (str, prefix) => {
      return checkRange(str, prefix, 0);
    };
    const endsWith = (str, suffix) => {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = r => s => s.replace(r, '');
    const trim$3 = blank(/^\s+|\s+$/g);
    const lTrim = blank(/^\s+/g);
    const rTrim = blank(/\s+$/g);
    const isNotEmpty = s => s.length > 0;
    const isEmpty$3 = s => !isNotEmpty(s);
    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);
    const toInt = (value, radix = 10) => {
      const num = parseInt(value, radix);
      return isNaN(num) ? Optional.none() : Optional.some(num);
    };

    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = target => {
      return uastring => {
        return contains$1(uastring, target);
      };
    };
    const browsers = [
      {
        name: 'Edge',
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: uastring => {
          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
        }
      },
      {
        name: 'Chromium',
        brand: 'Chromium',
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: uastring => {
          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
        }
      },
      {
        name: 'IE',
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: uastring => {
          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
        }
      },
      {
        name: 'Opera',
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains('opera')
      },
      {
        name: 'Firefox',
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains('firefox')
      },
      {
        name: 'Safari',
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: uastring => {
          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
        }
      }
    ];
    const oses = [
      {
        name: 'Windows',
        search: checkContains('win'),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'iOS',
        search: uastring => {
          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: 'Android',
        search: checkContains('android'),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: 'macOS',
        search: checkContains('mac os x'),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: 'Linux',
        search: checkContains('linux'),
        versionRegexes: []
      },
      {
        name: 'Solaris',
        search: checkContains('sunos'),
        versionRegexes: []
      },
      {
        name: 'FreeBSD',
        search: checkContains('freebsd'),
        versionRegexes: []
      },
      {
        name: 'ChromeOS',
        search: checkContains('cros'),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    const PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    const edge = 'Edge';
    const chromium = 'Chromium';
    const ie = 'IE';
    const opera = 'Opera';
    const firefox = 'Firefox';
    const safari = 'Safari';
    const unknown$1 = () => {
      return nu$2({
        current: undefined,
        version: Version.unknown()
      });
    };
    const nu$2 = info => {
      const current = info.current;
      const version = info.version;
      const isBrowser = name => () => current === name;
      return {
        current,
        version,
        isEdge: isBrowser(edge),
        isChromium: isBrowser(chromium),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    const Browser = {
      unknown: unknown$1,
      nu: nu$2,
      edge: constant(edge),
      chromium: constant(chromium),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    const windows = 'Windows';
    const ios = 'iOS';
    const android = 'Android';
    const linux = 'Linux';
    const macos = 'macOS';
    const solaris = 'Solaris';
    const freebsd = 'FreeBSD';
    const chromeos = 'ChromeOS';
    const unknown = () => {
      return nu$1({
        current: undefined,
        version: Version.unknown()
      });
    };
    const nu$1 = info => {
      const current = info.current;
      const version = info.version;
      const isOS = name => () => current === name;
      return {
        current,
        version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isMacOS: isOS(macos),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    const OperatingSystem = {
      unknown,
      nu: nu$1,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      macos: constant(macos),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {
      const browsers = PlatformInfo.browsers();
      const oses = PlatformInfo.oses();
      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);
      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser,
        os,
        deviceType
      };
    };
    const PlatformDetection = { detect: detect$3 };

    const mediaMatch = query => window.matchMedia(query).matches;
    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
    const detect$2 = () => platform$4();

    const userAgent = navigator.userAgent;
    const platform$3 = detect$2();
    const browser$3 = platform$3.browser;
    const os$1 = platform$3.os;
    const deviceType = platform$3.deviceType;
    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
    const Env = {
      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !browser$3.isIE(),
      windowsPhone,
      browser: {
        current: browser$3.current,
        version: browser$3.version,
        isChromium: browser$3.isChromium,
        isEdge: browser$3.isEdge,
        isFirefox: browser$3.isFirefox,
        isIE: browser$3.isIE,
        isOpera: browser$3.isOpera,
        isSafari: browser$3.isSafari
      },
      os: {
        current: os$1.current,
        version: os$1.version,
        isAndroid: os$1.isAndroid,
        isChromeOS: os$1.isChromeOS,
        isFreeBSD: os$1.isFreeBSD,
        isiOS: os$1.isiOS,
        isLinux: os$1.isLinux,
        isMacOS: os$1.isMacOS,
        isSolaris: os$1.isSolaris,
        isWindows: os$1.isWindows
      },
      deviceType: {
        isDesktop: deviceType.isDesktop,
        isiPad: deviceType.isiPad,
        isiPhone: deviceType.isiPhone,
        isPhone: deviceType.isPhone,
        isTablet: deviceType.isTablet,
        isTouch: deviceType.isTouch,
        isWebView: deviceType.isWebView
      }
    };

    const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
    const trim$2 = str => {
      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');
    };
    const is$3 = (obj, type) => {
      if (!type) {
        return obj !== undefined;
      }
      if (type === 'array' && isArray(obj)) {
        return true;
      }
      return typeof obj === type;
    };
    const makeMap$4 = (items, delim, map = {}) => {
      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];
      let i = resolvedItems.length;
      while (i--) {
        map[resolvedItems[i]] = {};
      }
      return map;
    };
    const hasOwnProperty$1 = has$2;
    const extend$3 = (obj, ...exts) => {
      for (let i = 0; i < exts.length; i++) {
        const ext = exts[i];
        for (const name in ext) {
          if (has$2(ext, name)) {
            const value = ext[name];
            if (value !== undefined) {
              obj[name] = value;
            }
          }
        }
      }
      return obj;
    };
    const walk$4 = function (o, f, n, s) {
      s = s || this;
      if (o) {
        if (n) {
          o = o[n];
        }
        each$c(o, (o, i) => {
          if (f.call(s, o, i, n) === false) {
            return false;
          } else {
            walk$4(o, f, n, s);
            return true;
          }
        });
      }
    };
    const resolve$3 = (n, o = window) => {
      const path = n.split('.');
      for (let i = 0, l = path.length; i < l; i++) {
        o = o[path[i]];
        if (!o) {
          break;
        }
      }
      return o;
    };
    const explode$3 = (s, d) => {
      if (isArray$1(s)) {
        return s;
      } else if (s === '') {
        return [];
      } else {
        return map$1(s.split(d || ','), trim$2);
      }
    };
    const _addCacheSuffix = url => {
      const cacheSuffix = Env.cacheSuffix;
      if (cacheSuffix) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
      }
      return url;
    };
    const Tools = {
      trim: trim$2,
      isArray: isArray,
      is: is$3,
      toArray: toArray$1,
      makeMap: makeMap$4,
      each: each$c,
      map: map$1,
      grep: filter$3,
      inArray: indexOf,
      hasOwn: hasOwnProperty$1,
      extend: extend$3,
      walk: walk$4,
      resolve: resolve$3,
      explode: explode$3,
      _addCacheSuffix
    };

    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));
    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
    const cat = arr => {
      const r = [];
      const push = x => {
        r.push(x);
      };
      for (let i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();

    const Global = typeof window !== 'undefined' ? window : Function('return this;')();

    const path = (parts, scope) => {
      let o = scope !== undefined && scope !== null ? scope : Global;
      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {
        o = o[parts[i]];
      }
      return o;
    };
    const resolve$2 = (p, scope) => {
      const parts = p.split('.');
      return path(parts, scope);
    };

    const unsafe = (name, scope) => {
      return resolve$2(name, scope);
    };
    const getOrDie = (name, scope) => {
      const actual = unsafe(name, scope);
      if (actual === undefined || actual === null) {
        throw new Error(name + ' not available on this browser');
      }
      return actual;
    };

    const getPrototypeOf$1 = Object.getPrototypeOf;
    const sandHTMLElement = scope => {
      return getOrDie('HTMLElement', scope);
    };
    const isPrototypeOf = x => {
      const scope = resolve$2('ownerDocument.defaultView', x);
      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };

    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;

    const name = element => {
      const r = element.dom.nodeName;
      return r.toLowerCase();
    };
    const type$1 = element => element.dom.nodeType;
    const isType = t => element => type$1(element) === t;
    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';
    const isHTMLElement = element => isElement$7(element) && isPrototypeOf(element.dom);
    const isElement$7 = isType(ELEMENT);
    const isText$b = isType(TEXT);
    const isDocument$2 = isType(DOCUMENT);
    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    const isTag = tag => e => isElement$7(e) && name(e) === tag;

    const rawSet = (dom, key, value) => {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + '');
      } else {
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
      }
    };
    const set$3 = (element, key, value) => {
      rawSet(element.dom, key, value);
    };
    const setAll$1 = (element, attrs) => {
      const dom = element.dom;
      each$d(attrs, (v, k) => {
        rawSet(dom, k, v);
      });
    };
    const get$9 = (element, key) => {
      const v = element.dom.getAttribute(key);
      return v === null ? undefined : v;
    };
    const getOpt = (element, key) => Optional.from(get$9(element, key));
    const has$1 = (element, key) => {
      const dom = element.dom;
      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    const remove$a = (element, key) => {
      element.dom.removeAttribute(key);
    };
    const hasNone = element => {
      const attrs = element.dom.attributes;
      return attrs === undefined || attrs === null || attrs.length === 0;
    };
    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {
      acc[attr.name] = attr.value;
      return acc;
    }, {});

    const read$4 = (element, attr) => {
      const value = get$9(element, attr);
      return value === undefined || value === '' ? [] : value.split(' ');
    };
    const add$4 = (element, attr, id) => {
      const old = read$4(element, attr);
      const nu = old.concat([id]);
      set$3(element, attr, nu.join(' '));
      return true;
    };
    const remove$9 = (element, attr, id) => {
      const nu = filter$5(read$4(element, attr), v => v !== id);
      if (nu.length > 0) {
        set$3(element, attr, nu.join(' '));
      } else {
        remove$a(element, attr);
      }
      return false;
    };

    const supports = element => element.dom.classList !== undefined;
    const get$8 = element => read$4(element, 'class');
    const add$3 = (element, clazz) => add$4(element, 'class', clazz);
    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);
    const toggle$2 = (element, clazz) => {
      if (contains$2(get$8(element), clazz)) {
        return remove$8(element, clazz);
      } else {
        return add$3(element, clazz);
      }
    };

    const add$2 = (element, clazz) => {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$3(element, clazz);
      }
    };
    const cleanClass = element => {
      const classList = supports(element) ? element.dom.classList : get$8(element);
      if (classList.length === 0) {
        remove$a(element, 'class');
      }
    };
    const remove$7 = (element, clazz) => {
      if (supports(element)) {
        const classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$8(element, clazz);
      }
      cleanClass(element);
    };
    const toggle$1 = (element, clazz) => {
      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
      cleanClass(element);
      return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);

    const fromHtml$1 = (html, scope) => {
      const doc = scope || document;
      const div = doc.createElement('div');
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        const message = 'HTML does not have a single root node';
        console.error(message, html);
        throw new Error(message);
      }
      return fromDom$2(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
      const doc = scope || document;
      const node = doc.createElement(tag);
      return fromDom$2(node);
    };
    const fromText = (text, scope) => {
      const doc = scope || document;
      const node = doc.createTextNode(text);
      return fromDom$2(node);
    };
    const fromDom$2 = node => {
      if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
      }
      return { dom: node };
    };
    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    const SugarElement = {
      fromHtml: fromHtml$1,
      fromTag,
      fromText,
      fromDom: fromDom$2,
      fromPoint: fromPoint$2
    };

    const toArray = (target, f) => {
      const r = [];
      const recurse = e => {
        r.push(e);
        return f(e);
      };
      let cur = f(target);
      do {
        cur = cur.bind(recurse);
      } while (cur.isSome());
      return r;
    };

    const is$1 = (element, selector) => {
      const dom = element.dom;
      if (dom.nodeType !== ELEMENT) {
        return false;
      } else {
        const elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error('Browser lacks native selectors');
        }
      }
    };
    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
    const all = (selector, scope) => {
      const base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
      const base = scope === undefined ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };

    const eq = (e1, e2) => e1.dom === e2.dom;
    const contains = (e1, e2) => {
      const d1 = e1.dom;
      const d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };

    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);
    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);
    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents$1 = (element, isRoot) => {
      const stop = isFunction(isRoot) ? isRoot : never;
      let dom = element.dom;
      const ret = [];
      while (dom.parentNode !== null && dom.parentNode !== undefined) {
        const rawParent = dom.parentNode;
        const p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
          break;
        } else {
          dom = rawParent;
        }
      }
      return ret;
    };
    const siblings = element => {
      const filterSelf = elements => filter$5(elements, x => !eq(element, x));
      return parent(element).map(children$1).map(filterSelf).getOr([]);
    };
    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    const prevSiblings = element => reverse(toArray(element, prevSibling));
    const nextSiblings = element => toArray(element, nextSibling);
    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);
    const child$1 = (element, index) => {
      const cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = element => child$1(element, 0);
    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);
    const childNodesCount = element => element.dom.childNodes.length;
    const hasChildNodes = element => element.dom.hasChildNodes();

    const getHead = doc => {
      const b = doc.dom.head;
      if (b === null || b === undefined) {
        throw new Error('Head is not available yet');
      }
      return SugarElement.fromDom(b);
    };

    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
    const isSupported$1 = constant(supported);
    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));
    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    const getShadowRoot = e => {
      const r = getRootNode(e);
      return isShadowRoot(r) ? Optional.some(r) : Optional.none();
    };
    const getShadowHost = e => SugarElement.fromDom(e.dom.host);
    const getOriginalEventTarget = event => {
      if (isSupported$1() && isNonNullable(event.target)) {
        const el = SugarElement.fromDom(event.target);
        if (isElement$7(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            const composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);

    const inBody = element => {
      const dom = isText$b(element) ? element.dom.parentNode : element.dom;
      if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
      }
      const doc = dom.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
    };

    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {
      if (is(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction(isRoot) && isRoot(scope)) {
        return Optional.none();
      } else {
        return ancestor(scope, a, isRoot);
      }
    };

    const ancestor$4 = (scope, predicate, isRoot) => {
      let element = scope.dom;
      const stop = isFunction(isRoot) ? isRoot : never;
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot) => {
      const is = (s, test) => test(s);
      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);
    };
    const sibling$1 = (scope, predicate) => {
      const element = scope.dom;
      if (!element.parentNode) {
        return Optional.none();
      }
      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));
    };
    const child = (scope, predicate) => {
      const pred = node => predicate(SugarElement.fromDom(node));
      const result = find$2(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate) => {
      const descend = node => {
        for (let i = 0; i < node.childNodes.length; i++) {
          const child = SugarElement.fromDom(node.childNodes[i]);
          if (predicate(child)) {
            return Optional.some(child);
          }
          const res = descend(node.childNodes[i]);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope.dom);
    };

    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);
    const descendant = (scope, selector) => one(selector, scope);
    const closest$3 = (scope, selector, isRoot) => {
      const is = (element, selector) => is$1(element, selector);
      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);
    };

    const closest$2 = target => closest$3(target, '[contenteditable]');
    const isEditable$3 = (element, assumeEditable = false) => {
      if (inBody(element)) {
        return element.dom.isContentEditable;
      } else {
        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');
      }
    };
    const getRaw$1 = element => element.dom.contentEditable;

    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);

    const internalSet = (dom, property, value) => {
      if (!isString(value)) {
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    const internalRemove = (dom, property) => {
      if (isSupported(dom)) {
        dom.style.removeProperty(property);
      }
    };
    const set$2 = (element, property, value) => {
      const dom = element.dom;
      internalSet(dom, property, value);
    };
    const setAll = (element, css) => {
      const dom = element.dom;
      each$d(css, (v, k) => {
        internalSet(dom, k, v);
      });
    };
    const get$7 = (element, property) => {
      const dom = element.dom;
      const styles = window.getComputedStyle(dom);
      const r = styles.getPropertyValue(property);
      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';
    const getRaw = (element, property) => {
      const dom = element.dom;
      const raw = getUnsafeProperty(dom, property);
      return Optional.from(raw).filter(r => r.length > 0);
    };
    const getAllRaw = element => {
      const css = {};
      const dom = element.dom;
      if (isSupported(dom)) {
        for (let i = 0; i < dom.style.length; i++) {
          const ruleName = dom.style.item(i);
          css[ruleName] = dom.style[ruleName];
        }
      }
      return css;
    };
    const remove$6 = (element, property) => {
      const dom = element.dom;
      internalRemove(dom, property);
      if (is$2(getOpt(element, 'style').map(trim$3), '')) {
        remove$a(element, 'style');
      }
    };
    const reflow = e => e.dom.offsetWidth;

    const before$3 = (marker, element) => {
      const parent$1 = parent(marker);
      parent$1.each(v => {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    const after$4 = (marker, element) => {
      const sibling = nextSibling(marker);
      sibling.fold(() => {
        const parent$1 = parent(marker);
        parent$1.each(v => {
          append$1(v, element);
        });
      }, v => {
        before$3(v, element);
      });
    };
    const prepend = (parent, element) => {
      const firstChild$1 = firstChild(parent);
      firstChild$1.fold(() => {
        append$1(parent, element);
      }, v => {
        parent.dom.insertBefore(element.dom, v.dom);
      });
    };
    const append$1 = (parent, element) => {
      parent.dom.appendChild(element.dom);
    };
    const wrap$2 = (element, wrapper) => {
      before$3(element, wrapper);
      append$1(wrapper, element);
    };

    const after$3 = (marker, elements) => {
      each$e(elements, (x, i) => {
        const e = i === 0 ? marker : elements[i - 1];
        after$4(e, x);
      });
    };
    const append = (parent, elements) => {
      each$e(elements, x => {
        append$1(parent, x);
      });
    };

    const empty = element => {
      element.dom.textContent = '';
      each$e(children$1(element), rogue => {
        remove$5(rogue);
      });
    };
    const remove$5 = element => {
      const dom = element.dom;
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    const unwrap = wrapper => {
      const children = children$1(wrapper);
      if (children.length > 0) {
        after$3(wrapper, children);
      }
      remove$5(wrapper);
    };

    const fromHtml = (html, scope) => {
      const doc = scope || document;
      const div = doc.createElement('div');
      div.innerHTML = html;
      return children$1(SugarElement.fromDom(div));
    };
    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);

    const get$6 = element => element.dom.innerHTML;
    const set$1 = (element, content) => {
      const owner = owner$1(element);
      const docDom = owner.dom;
      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      const contentElements = fromHtml(content, docDom);
      append(fragment, contentElements);
      empty(element);
      append$1(element, fragment);
    };
    const getOuter = element => {
      const container = SugarElement.fromTag('div');
      const clone = SugarElement.fromDom(element.dom.cloneNode(true));
      append$1(container, clone);
      return get$6(container);
    };

    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({
      target,
      x,
      y,
      stop,
      prevent,
      kill,
      raw
    });
    const fromRawEvent = rawEvent => {
      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      const stop = () => rawEvent.stopPropagation();
      const prevent = () => rawEvent.preventDefault();
      const kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    const handle$1 = (filter, handler) => rawEvent => {
      if (filter(rawEvent)) {
        handler(fromRawEvent(rawEvent));
      }
    };
    const binder = (element, event, filter, handler, useCapture) => {
      const wrapped = handle$1(filter, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);
    const unbind = (element, event, handler, useCapture) => {
      element.dom.removeEventListener(event, handler, useCapture);
    };

    const r = (left, top) => {
      const translate = (x, y) => r(left + x, top + y);
      return {
        left,
        top,
        translate
      };
    };
    const SugarPosition = r;

    const boxPosition = dom => {
      const box = dom.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    const firstDefinedOrZero = (a, b) => {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    const absolute = element => {
      const doc = element.dom.ownerDocument;
      const body = doc.body;
      const win = doc.defaultView;
      const html = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    const viewport = element => {
      const dom = element.dom;
      const doc = dom.ownerDocument;
      const body = doc.body;
      if (body === dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom);
    };

    const get$5 = _DOC => {
      const doc = _DOC !== undefined ? _DOC.dom : document;
      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      const y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    const to = (x, y, _DOC) => {
      const doc = _DOC !== undefined ? _DOC.dom : document;
      const win = doc.defaultView;
      if (win) {
        win.scrollTo(x, y);
      }
    };
    const intoView = (element, alignToTop) => {
      const isSafari = detect$2().browser.isSafari();
      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {
        element.dom.scrollIntoViewIfNeeded(false);
      } else {
        element.dom.scrollIntoView(alignToTop);
      }
    };

    const get$4 = _win => {
      const win = _win === undefined ? window : _win;
      if (detect$2().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win.visualViewport);
      }
    };
    const bounds = (x, y, width, height) => ({
      x,
      y,
      width,
      height,
      right: x + width,
      bottom: y + height
    });
    const getBounds = _win => {
      const win = _win === undefined ? window : _win;
      const doc = win.document;
      const scroll = get$5(SugarElement.fromDom(doc));
      return get$4(win).fold(() => {
        const html = win.document.documentElement;
        const width = html.clientWidth;
        const height = html.clientHeight;
        return bounds(scroll.left, scroll.top, width, height);
      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };

    const children = (scope, predicate) => filter$5(children$1(scope), predicate);
    const descendants$1 = (scope, predicate) => {
      let result = [];
      each$e(children$1(scope), x => {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants$1(x, predicate));
      });
      return result;
    };

    const descendants = (scope, selector) => all(selector, scope);

    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();

    class DomTreeWalker {
      constructor(startNode, rootNode) {
        this.node = startNode;
        this.rootNode = rootNode;
        this.current = this.current.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(shallow) {
        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
        return this.node;
      }
      prev(shallow) {
        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
        return this.node;
      }
      prev2(shallow) {
        this.node = this.findPreviousNode(this.node, shallow);
        return this.node;
      }
      findSibling(node, startName, siblingName, shallow) {
        if (node) {
          if (!shallow && node[startName]) {
            return node[startName];
          }
          if (node !== this.rootNode) {
            let sibling = node[siblingName];
            if (sibling) {
              return sibling;
            }
            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
              sibling = parent[siblingName];
              if (sibling) {
                return sibling;
              }
            }
          }
        }
        return undefined;
      }
      findPreviousNode(node, shallow) {
        if (node) {
          const sibling = node.previousSibling;
          if (this.rootNode && sibling === this.rootNode) {
            return;
          }
          if (sibling) {
            if (!shallow) {
              for (let child = sibling.lastChild; child; child = child.lastChild) {
                if (!child.lastChild) {
                  return child;
                }
              }
            }
            return sibling;
          }
          const parent = node.parentNode;
          if (parent && parent !== this.rootNode) {
            return parent;
          }
        }
        return undefined;
      }
    }

    const isNodeType = type => {
      return node => {
        return !!node && node.nodeType === type;
      };
    };
    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);
    const isElement$6 = isNodeType(1);
    const matchNodeName = name => {
      const lowerCasedName = name.toLowerCase();
      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
    };
    const matchNodeNames = names => {
      const lowerCasedNames = names.map(s => s.toLowerCase());
      return node => {
        if (node && node.nodeName) {
          const nodeName = node.nodeName.toLowerCase();
          return contains$2(lowerCasedNames, nodeName);
        }
        return false;
      };
    };
    const matchStyleValues = (name, values) => {
      const items = values.toLowerCase().split(' ');
      return node => {
        if (isElement$6(node)) {
          const win = node.ownerDocument.defaultView;
          if (win) {
            for (let i = 0; i < items.length; i++) {
              const computed = win.getComputedStyle(node, null);
              const cssValue = computed ? computed.getPropertyValue(name) : null;
              if (cssValue === items[i]) {
                return true;
              }
            }
          }
        }
        return false;
      };
    };
    const hasAttribute = attrName => {
      return node => {
        return isElement$6(node) && node.hasAttribute(attrName);
      };
    };
    const hasAttributeValue = (attrName, attrValue) => {
      return node => {
        return isElement$6(node) && node.getAttribute(attrName) === attrValue;
      };
    };
    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');
    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';
    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';
    const hasContentEditableState = value => {
      return node => {
        if (isElement$6(node)) {
          if (node.contentEditable === value) {
            return true;
          }
          if (node.getAttribute('data-mce-contenteditable') === value) {
            return true;
          }
        }
        return false;
      };
    };
    const isTextareaOrInput = matchNodeNames([
      'textarea',
      'input'
    ]);
    const isText$a = isNodeType(3);
    const isCData = isNodeType(4);
    const isPi = isNodeType(7);
    const isComment = isNodeType(8);
    const isDocument$1 = isNodeType(9);
    const isDocumentFragment = isNodeType(11);
    const isBr$6 = matchNodeName('br');
    const isImg = matchNodeName('img');
    const isContentEditableTrue$3 = hasContentEditableState('true');
    const isContentEditableFalse$b = hasContentEditableState('false');
    const isTableCell$3 = matchNodeNames([
      'td',
      'th'
    ]);
    const isTableCellOrCaption = matchNodeNames([
      'td',
      'th',
      'caption'
    ]);
    const isMedia$2 = matchNodeNames([
      'video',
      'audio',
      'object',
      'embed'
    ]);
    const isListItem$2 = matchNodeName('li');
    const isDetails = matchNodeName('details');
    const isSummary = matchNodeName('summary');

    const zeroWidth = '\uFEFF';
    const nbsp = '\xA0';
    const isZwsp$2 = char => char === zeroWidth;
    const removeZwsp = s => s.replace(/\uFEFF/g, '');

    const NodeValue = (is, name) => {
      const get = element => {
        if (!is(element)) {
          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
      };
      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      const set = (element, value) => {
        if (!is(element)) {
          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
      };
      return {
        get,
        getOption,
        set
      };
    };

    const api$1 = NodeValue(isText$b, 'text');
    const get$3 = element => api$1.get(element);
    const getOption = element => api$1.getOption(element);
    const set = (element, value) => api$1.set(element, value);

    const blocks = [
      'article',
      'aside',
      'details',
      'div',
      'dt',
      'figcaption',
      'footer',
      'form',
      'fieldset',
      'header',
      'hgroup',
      'html',
      'main',
      'nav',
      'section',
      'summary',
      'body',
      'p',
      'dl',
      'multicol',
      'dd',
      'figure',
      'address',
      'center',
      'blockquote',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'listing',
      'xmp',
      'pre',
      'plaintext',
      'menu',
      'dir',
      'ul',
      'ol',
      'li',
      'hr',
      'table',
      'tbody',
      'thead',
      'tfoot',
      'th',
      'tr',
      'td',
      'caption'
    ];
    const tableCells = [
      'td',
      'th'
    ];
    const tableSections = [
      'thead',
      'tbody',
      'tfoot'
    ];
    const textBlocks = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'p',
      'div',
      'address',
      'pre',
      'form',
      'blockquote',
      'center',
      'dir',
      'fieldset',
      'header',
      'footer',
      'article',
      'section',
      'hgroup',
      'aside',
      'nav',
      'figure'
    ];
    const headings = [
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6'
    ];
    const listItems$1 = [
      'li',
      'dd',
      'dt'
    ];
    const lists = [
      'ul',
      'ol',
      'dl'
    ];
    const wsElements = [
      'pre',
      'script',
      'textarea',
      'style'
    ];
    const wrapBlockElements = ['pre'].concat(headings);
    const lazyLookup = items => {
      let lookup;
      return node => {
        lookup = lookup ? lookup : mapToObject(items, always);
        return has$2(lookup, name(node));
      };
    };
    const isBlock$2 = lazyLookup(blocks);
    const isTable$1 = node => name(node) === 'table';
    const isInline$1 = node => isElement$7(node) && !isBlock$2(node);
    const isBr$5 = node => isElement$7(node) && name(node) === 'br';
    const isTextBlock$2 = lazyLookup(textBlocks);
    const isList = lazyLookup(lists);
    const isListItem$1 = lazyLookup(listItems$1);
    const isTableSection = lazyLookup(tableSections);
    const isTableCell$2 = lazyLookup(tableCells);
    const isWsPreserveElement = lazyLookup(wsElements);
    const isWrapBlockElement = lazyLookup(wrapBlockElements);
    const isWrapElement = node => isWrapBlockElement(node) || isInline$1(node);

    const getLastChildren$1 = elm => {
      const children = [];
      let rawNode = elm.dom;
      while (rawNode) {
        children.push(SugarElement.fromDom(rawNode));
        rawNode = rawNode.lastChild;
      }
      return children;
    };
    const removeTrailingBr = elm => {
      const allBrs = descendants(elm, 'br');
      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
      if (allBrs.length === brs.length) {
        each$e(brs, remove$5);
      }
    };
    const createPaddingBr = () => {
      const br = SugarElement.fromTag('br');
      set$3(br, 'data-mce-bogus', '1');
      return br;
    };
    const fillWithPaddingBr = elm => {
      empty(elm);
      append$1(elm, createPaddingBr());
    };
    const trimBlockTrailingBr = elm => {
      lastChild(elm).each(lastChild => {
        prevSibling(lastChild).each(lastChildPrevSibling => {
          if (isBlock$2(elm) && isBr$5(lastChild) && isBlock$2(lastChildPrevSibling)) {
            remove$5(lastChild);
          }
        });
      });
    };

    const ZWSP$1 = zeroWidth;
    const isZwsp$1 = isZwsp$2;
    const trim$1 = removeZwsp;

    const isElement$5 = isElement$6;
    const isText$9 = isText$a;
    const isCaretContainerBlock$1 = node => {
      if (isText$9(node)) {
        node = node.parentNode;
      }
      return isElement$5(node) && node.hasAttribute('data-mce-caret');
    };
    const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);
    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
    const insertInline$1 = (node, before) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      const parentNode = node.parentNode;
      if (!before) {
        const sibling = node.nextSibling;
        if (isText$9(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (startsWithCaretContainer$1(sibling)) {
            sibling.splitText(1);
            return sibling;
          }
        }
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
        }
      } else {
        const sibling = node.previousSibling;
        if (isText$9(sibling)) {
          if (isCaretContainer$2(sibling)) {
            return sibling;
          }
          if (endsWithCaretContainer$1(sibling)) {
            return sibling.splitText(sibling.data.length - 1);
          }
        }
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
      }
      return textNode;
    };
    const isBeforeInline = pos => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    const isAfterInline = pos => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    const insertBlock = (blockName, node, before) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const blockNode = doc.createElement(blockName);
      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
      blockNode.setAttribute('data-mce-bogus', 'all');
      blockNode.appendChild(createPaddingBr().dom);
      const parentNode = node.parentNode;
      if (!before) {
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
        }
      } else {
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
      }
      return blockNode;
    };
    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
    const trimBogusBr = elm => {
      var _a;
      const brs = elm.getElementsByTagName('br');
      const lastBr = brs[brs.length - 1];
      if (isBogus$2(lastBr)) {
        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
      }
    };
    const showCaretContainerBlock = caretContainer => {
      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute('data-mce-caret');
        caretContainer.removeAttribute('data-mce-bogus');
        caretContainer.removeAttribute('style');
        caretContainer.removeAttribute('data-mce-style');
        caretContainer.removeAttribute('_moz_abspos');
        return caretContainer;
      }
      return null;
    };
    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);

    const isContentEditableTrue$2 = isContentEditableTrue$3;
    const isContentEditableFalse$a = isContentEditableFalse$b;
    const isBr$4 = isBr$6;
    const isText$8 = isText$a;
    const isInvalidTextElement = matchNodeNames([
      'script',
      'style',
      'textarea'
    ]);
    const isAtomicInline = matchNodeNames([
      'img',
      'input',
      'textarea',
      'hr',
      'iframe',
      'video',
      'audio',
      'object',
      'embed'
    ]);
    const isTable = matchNodeNames(['table']);
    const isCaretContainer$1 = isCaretContainer$2;
    const isCaretCandidate$3 = node => {
      if (isCaretContainer$1(node)) {
        return false;
      }
      if (isText$8(node)) {
        return !isInvalidTextElement(node.parentNode);
      }
      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
    };
    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';
    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);
    const isInEditable = (node, root) => {
      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
        if (isNonUiContentEditableFalse(tempNode)) {
          return false;
        }
        if (isContentEditableTrue$2(tempNode)) {
          return true;
        }
      }
      return true;
    };
    const isAtomicContentEditableFalse = node => {
      if (!isNonUiContentEditableFalse(node)) {
        return false;
      }
      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {
        return result || isContentEditableTrue$2(elm);
      }, false);
    };
    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);
    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);

    const whiteSpaceRegExp = /^[ \t\r\n]*$/;
    const isWhitespaceText = text => whiteSpaceRegExp.test(text);
    const isZwsp = text => {
      for (const c of text) {
        if (!isZwsp$2(c)) {
          return false;
        }
      }
      return true;
    };
    const isCollapsibleWhitespace$1 = c => ' \f\t\x0B'.indexOf(c) !== -1;
    const isNewLineChar = c => c === '\n' || c === '\r';
    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;
    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
      const tabSpace = repeat(' ', tabSpaces);
      const normalizedText = text.replace(/\t/g, tabSpace);
      const result = foldl(normalizedText, (acc, c) => {
        if (isCollapsibleWhitespace$1(c) || c === nbsp) {
          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {
            return {
              pcIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              pcIsSpace: true,
              str: acc.str + ' '
            };
          }
        } else {
          return {
            pcIsSpace: isNewLineChar(c),
            str: acc.str + c
          };
        }
      }, {
        pcIsSpace: false,
        str: ''
      });
      return result.str;
    };

    const hasWhitespacePreserveParent = (node, rootNode) => {
      const rootElement = SugarElement.fromDom(rootNode);
      const startNode = SugarElement.fromDom(node);
      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));
    };
    const isWhitespace$1 = (node, rootNode) => {
      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);
    };
    const isNamedAnchor = node => {
      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));
    };
    const isContent$1 = (node, rootNode) => {
      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);
    };
    const isBookmark = hasAttribute('data-mce-bookmark');
    const isBogus$1 = hasAttribute('data-mce-bogus');
    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');
    const isEmptyNode = (targetNode, skipBogus) => {
      let brCount = 0;
      if (isContent$1(targetNode, targetNode)) {
        return false;
      } else {
        let node = targetNode.firstChild;
        if (!node) {
          return true;
        }
        const walker = new DomTreeWalker(node, targetNode);
        do {
          if (skipBogus) {
            if (isBogusAll(node)) {
              node = walker.next(true);
              continue;
            }
            if (isBogus$1(node)) {
              node = walker.next();
              continue;
            }
          }
          if (isBr$6(node)) {
            brCount++;
            node = walker.next();
            continue;
          }
          if (isContent$1(node, targetNode)) {
            return false;
          }
          node = walker.next();
        } while (node);
        return brCount <= 1;
      }
    };
    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);

    const transparentBlockAttr = 'data-mce-block';
    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));
    const makeSelectorFromSchemaMap = map => elementNames(map).join(',');
    const updateTransparent = (blocksSelector, transparent) => {
      if (isNonNullable(transparent.querySelector(blocksSelector))) {
        transparent.setAttribute(transparentBlockAttr, 'true');
        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {
          transparent.removeAttribute('data-mce-selected');
        }
        return true;
      } else {
        transparent.removeAttribute(transparentBlockAttr);
        return false;
      }
    };
    const updateBlockStateOnChildren = (schema, scope) => {
      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));
    };
    const trimEdge = (el, leftSide) => {
      var _a;
      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';
      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {
        if (isEmpty$2(SugarElement.fromDom(child))) {
          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);
          return;
        }
      }
    };
    const split$2 = (parentElm, splitElm) => {
      const range = document.createRange();
      const parentNode = parentElm.parentNode;
      if (parentNode) {
        range.setStartBefore(parentElm);
        range.setEndBefore(splitElm);
        const beforeFragment = range.extractContents();
        trimEdge(beforeFragment, true);
        range.setStartAfter(splitElm);
        range.setEndAfter(parentElm);
        const afterFragment = range.extractContents();
        trimEdge(afterFragment, false);
        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {
          parentNode.insertBefore(beforeFragment, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {
          parentNode.insertBefore(splitElm, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {
          parentNode.insertBefore(afterFragment, parentElm);
        }
        parentNode.removeChild(parentElm);
      }
    };
    const splitInvalidChildren = (schema, scope, transparentBlocks) => {
      const blocksElements = schema.getBlockElements();
      const rootNode = SugarElement.fromDom(scope);
      const isBlock = el => name(el) in blocksElements;
      const isRoot = el => eq(el, rootNode);
      each$e(fromDom$1(transparentBlocks), transparentBlock => {
        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {
          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));
          if (invalidChildren.length > 0) {
            const stateScope = parentElement(parentBlock);
            each$e(invalidChildren, child => {
              ancestor$4(child, isBlock, isRoot).each(parentBlock => {
                split$2(parentBlock.dom, child.dom);
              });
            });
            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));
          }
        });
      });
    };
    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
      each$e([
        ...transparentBlocks,
        ...isTransparentBlock(schema, scope) ? [scope] : []
      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {
        if (isTransparentInline(schema, elm.dom)) {
          unwrap(elm);
        }
      }));
    };
    const updateChildren = (schema, scope) => {
      const transparentBlocks = updateBlockStateOnChildren(schema, scope);
      splitInvalidChildren(schema, scope, transparentBlocks);
      unwrapInvalidChildren(schema, scope, transparentBlocks);
    };
    const updateElement = (schema, target) => {
      if (isTransparentElement(schema, target)) {
        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
        updateTransparent(blocksSelector, target);
      }
    };
    const updateCaret = (schema, root, caretParent) => {
      const isRoot = el => eq(el, SugarElement.fromDom(root));
      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);
      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));
    };
    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);
    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);
    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));

    const browser$2 = detect$2().browser;
    const firstElement = nodes => find$2(nodes, isElement$7);
    const getTableCaptionDeltaY = elm => {
      if (browser$2.isFirefox() && name(elm) === 'table') {
        return firstElement(children$1(elm)).filter(elm => {
          return name(elm) === 'caption';
        }).bind(caption => {
          return firstElement(nextSiblings(caption)).map(body => {
            const bodyTop = body.dom.offsetTop;
            const captionTop = caption.dom.offsetTop;
            const captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        }).getOr(0);
      } else {
        return 0;
      }
    };
    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);
    const getPos = (body, elm, rootElm) => {
      let x = 0, y = 0;
      const doc = body.ownerDocument;
      rootElm = rootElm ? rootElm : body;
      if (elm) {
        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {
          const pos = elm.getBoundingClientRect();
          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
          return {
            x,
            y
          };
        }
        let offsetParent = elm;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          const castOffsetParent = offsetParent;
          x += castOffsetParent.offsetLeft || 0;
          y += castOffsetParent.offsetTop || 0;
          offsetParent = castOffsetParent.offsetParent;
        }
        offsetParent = elm.parentNode;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x -= offsetParent.scrollLeft || 0;
          y -= offsetParent.scrollTop || 0;
          offsetParent = offsetParent.parentNode;
        }
        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
      }
      return {
        x,
        y
      };
    };

    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
      let idCount = 0;
      const loadedStates = {};
      const edos = SugarElement.fromDom(documentOrShadowRoot);
      const doc = documentOrOwner(edos);
      const _setReferrerPolicy = referrerPolicy => {
        settings.referrerPolicy = referrerPolicy;
      };
      const _setContentCssCors = contentCssCors => {
        settings.contentCssCors = contentCssCors;
      };
      const addStyle = element => {
        append$1(getStyleContainer(edos), element);
      };
      const removeStyle = id => {
        const styleContainer = getStyleContainer(edos);
        descendant(styleContainer, '#' + id).each(remove$5);
      };
      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({
        id: 'mce-u' + idCount++,
        passed: [],
        failed: [],
        count: 0
      }));
      const load = url => new Promise((success, failure) => {
        let link;
        const urlWithSuffix = Tools._addCacheSuffix(url);
        const state = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state;
        state.count++;
        const resolve = (callbacks, status) => {
          each$e(callbacks, call);
          state.status = status;
          state.passed = [];
          state.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        const passed = () => resolve(state.passed, 2);
        const failed = () => resolve(state.failed, 3);
        if (success) {
          state.passed.push(success);
        }
        if (failure) {
          state.failed.push(failure);
        }
        if (state.status === 1) {
          return;
        }
        if (state.status === 2) {
          passed();
          return;
        }
        if (state.status === 3) {
          failed();
          return;
        }
        state.status = 1;
        const linkElem = SugarElement.fromTag('link', doc.dom);
        setAll$1(linkElem, {
          rel: 'stylesheet',
          type: 'text/css',
          id: state.id
        });
        if (settings.contentCssCors) {
          set$3(linkElem, 'crossOrigin', 'anonymous');
        }
        if (settings.referrerPolicy) {
          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = passed;
        link.onerror = failed;
        addStyle(linkElem);
        set$3(linkElem, 'href', urlWithSuffix);
      });
      const loadAll = urls => {
        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));
        return loadedUrls.then(results => {
          const parts = partition$2(results, r => r.status === 'fulfilled');
          if (parts.fail.length > 0) {
            return Promise.reject(map$3(parts.fail, result => result.reason));
          } else {
            return map$3(parts.pass, result => result.value);
          }
        });
      };
      const unload = url => {
        const urlWithSuffix = Tools._addCacheSuffix(url);
        get$a(loadedStates, urlWithSuffix).each(state => {
          const count = --state.count;
          if (count === 0) {
            delete loadedStates[urlWithSuffix];
            removeStyle(state.id);
          }
        });
      };
      const unloadAll = urls => {
        each$e(urls, url => {
          unload(url);
        });
      };
      return {
        load,
        loadAll,
        unload,
        unloadAll,
        _setReferrerPolicy,
        _setContentCssCors
      };
    };

    const create$d = () => {
      const map = new WeakMap();
      const forElement = (referenceElement, settings) => {
        const root = getRootNode(referenceElement);
        const rootDom = root.dom;
        return Optional.from(map.get(rootDom)).getOrThunk(() => {
          const sl = StyleSheetLoader(rootDom, settings);
          map.set(rootDom, sl);
          return sl;
        });
      };
      return { forElement };
    };
    const instance = create$d();

    const isSpan = node => node.nodeName.toLowerCase() === 'span';
    const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));
    const surroundedByInlineContent = (node, root) => {
      const prev = new DomTreeWalker(node, root).prev(false);
      const next = new DomTreeWalker(node, root).next(false);
      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root);
      const nextIsInline = isUndefined(next) || isInlineContent(next, root);
      return prevIsInline && nextIsInline;
    };
    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';
    const isKeepTextNode = (node, root) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;
    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);
    const trimNode = (dom, node, root) => {
      var _a;
      const rootNode = root || node;
      if (isElement$6(node) && isBookmarkNode$2(node)) {
        return node;
      }
      const children = node.childNodes;
      for (let i = children.length - 1; i >= 0; i--) {
        trimNode(dom, children[i], rootNode);
      }
      if (isElement$6(node)) {
        const currentChildren = node.childNodes;
        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
        }
      }
      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
        dom.remove(node);
      }
      return node;
    };

    const makeMap$3 = Tools.makeMap;
    const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const rawCharsRegExp = /[<>&\"\']/g;
    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    const asciiMap = {
      128: '\u20AC',
      130: '\u201A',
      131: '\u0192',
      132: '\u201E',
      133: '\u2026',
      134: '\u2020',
      135: '\u2021',
      136: '\u02c6',
      137: '\u2030',
      138: '\u0160',
      139: '\u2039',
      140: '\u0152',
      142: '\u017d',
      145: '\u2018',
      146: '\u2019',
      147: '\u201C',
      148: '\u201D',
      149: '\u2022',
      150: '\u2013',
      151: '\u2014',
      152: '\u02DC',
      153: '\u2122',
      154: '\u0161',
      155: '\u203A',
      156: '\u0153',
      158: '\u017e',
      159: '\u0178'
    };
    const baseEntities = {
      '"': '&quot;',
      '\'': '&#39;',
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '`': '&#96;'
    };
    const reverseEntities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': `'`
    };
    const nativeDecode = text => {
      const elm = SugarElement.fromTag('div').dom;
      elm.innerHTML = text;
      return elm.textContent || elm.innerText || text;
    };
    const buildEntitiesLookup = (items, radix) => {
      const lookup = {};
      if (items) {
        const itemList = items.split(',');
        radix = radix || 10;
        for (let i = 0; i < itemList.length; i += 2) {
          const chr = String.fromCharCode(parseInt(itemList[i], radix));
          if (!baseEntities[chr]) {
            const entity = '&' + itemList[i + 1] + ';';
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }
        return lookup;
      } else {
        return undefined;
      }
    };
    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
      return baseEntities[chr] || chr;
    });
    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {
      return baseEntities[chr] || chr;
    });
    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
      if (chr.length > 1) {
        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
      }
      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
    });
    const encodeNamed = (text, attr, entities) => {
      const resolveEntities = entities || namedEntities;
      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
        return baseEntities[chr] || resolveEntities[chr] || chr;
      });
    };
    const getEncodeFunc = (name, entities) => {
      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {
        if (baseEntities[chr] !== undefined) {
          return baseEntities[chr];
        }
        if (entitiesMap[chr] !== undefined) {
          return entitiesMap[chr];
        }
        if (chr.length > 1) {
          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
        }
        return '&#' + chr.charCodeAt(0) + ';';
      });
      const encodeCustomNamed = (text, attr) => {
        return encodeNamed(text, attr, entitiesMap);
      };
      const nameMap = makeMap$3(name.replace(/\+/g, ','));
      if (nameMap.named && nameMap.numeric) {
        return encodeNamedAndNumeric;
      }
      if (nameMap.named) {
        if (entities) {
          return encodeCustomNamed;
        }
        return encodeNamed;
      }
      if (nameMap.numeric) {
        return encodeNumeric;
      }
      return encodeRaw;
    };
    const decode = text => text.replace(entityRegExp, (all, numeric) => {
      if (numeric) {
        if (numeric.charAt(0).toLowerCase() === 'x') {
          numeric = parseInt(numeric.substr(1), 16);
        } else {
          numeric = parseInt(numeric, 10);
        }
        if (numeric > 65535) {
          numeric -= 65536;
          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
        }
        return asciiMap[numeric] || String.fromCharCode(numeric);
      }
      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
    });
    const Entities = {
      encodeRaw,
      encodeAllRaw,
      encodeNumeric,
      encodeNamed,
      getEncodeFunc,
      decode
    };

    const split$1 = (items, delim) => {
      items = Tools.trim(items);
      return items ? items.split(delim || ' ') : [];
    };
    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');

    const parseCustomElementsRules = value => {
      const customElementRegExp = /^(~)?(.+)$/;
      return bind$3(split$1(value, ','), rule => {
        const matches = customElementRegExp.exec(rule);
        if (matches) {
          const inline = matches[1] === '~';
          const cloneName = inline ? 'span' : 'div';
          const name = matches[2];
          return [{
              inline,
              cloneName,
              name
            }];
        } else {
          return [];
        }
      });
    };

    const getElementSetsAsStrings = type => {
      let globalAttributes, blockContent;
      let phrasingContent, flowContent;
      globalAttributes = 'id accesskey class dir lang style tabindex title role';
      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';
      if (type !== 'html4') {
        const transparentContent = 'a ins del canvas map';
        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';
        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;
        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';
      }
      if (type !== 'html5-strict') {
        globalAttributes += ' xml:lang';
        const html4PhrasingContent = 'acronym applet basefont big font strike tt';
        phrasingContent = [
          phrasingContent,
          html4PhrasingContent
        ].join(' ');
        const html4BlockContent = 'center dir isindex noframes';
        blockContent = [
          blockContent,
          html4BlockContent
        ].join(' ');
        flowContent = [
          blockContent,
          phrasingContent
        ].join(' ');
      }
      flowContent = flowContent || [
        blockContent,
        phrasingContent
      ].join(' ');
      return {
        globalAttributes,
        blockContent,
        phrasingContent,
        flowContent
      };
    };

    const makeSchema = type => {
      const {globalAttributes, phrasingContent, flowContent} = getElementSetsAsStrings(type);
      const schema = {};
      const add = (name, attributes = '', children = '') => {
        const childNames = split$1(children);
        const names = split$1(name);
        let ni = names.length;
        while (ni--) {
          const attributesOrder = split$1([
            globalAttributes,
            attributes
          ].join(' '));
          schema[names[ni]] = {
            attributes: mapToObject(attributesOrder, constant({})),
            attributesOrder,
            children: mapToObject(childNames, constant({}))
          };
        }
      };
      const addAttrs = (name, attributes) => {
        const names = split$1(name);
        const attrs = split$1(attributes);
        let ni = names.length;
        while (ni--) {
          const schemaItem = schema[names[ni]];
          for (let i = 0, l = attrs.length; i < l; i++) {
            schemaItem.attributes[attrs[i]] = {};
            schemaItem.attributesOrder.push(attrs[i]);
          }
        }
      };
      if (type !== 'html5-strict') {
        const html4PhrasingContent = 'acronym applet basefont big font strike tt';
        each$e(split$1(html4PhrasingContent), name => {
          add(name, '', phrasingContent);
        });
        const html4BlockContent = 'center dir isindex noframes';
        each$e(split$1(html4BlockContent), name => {
          add(name, '', flowContent);
        });
      }
      add('html', 'manifest', 'head body');
      add('head', '', 'base command link meta noscript script style title');
      add('title hr noscript br');
      add('base', 'href target');
      add('link', 'href rel media hreflang type sizes hreflang');
      add('meta', 'name http-equiv content charset');
      add('style', 'media type scoped');
      add('script', 'src async defer type charset');
      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);
      add('dd div', '', flowContent);
      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);
      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
      add('blockquote', 'cite', flowContent);
      add('ol', 'reversed start type', 'li');
      add('ul', '', 'li');
      add('li', 'value', flowContent);
      add('dl', '', 'dt dd');
      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);
      add('q', 'cite', phrasingContent);
      add('ins del', 'cite datetime', flowContent);
      add('img', 'src sizes srcset alt usemap ismap width height');
      add('iframe', 'src name width height', flowContent);
      add('embed', 'src type width height');
      add('object', 'data type typemustmatch name usemap form width height', [
        flowContent,
        'param'
      ].join(' '));
      add('param', 'name value');
      add('map', 'name', [
        flowContent,
        'area'
      ].join(' '));
      add('area', 'alt coords shape href target rel media hreflang type');
      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
      add('colgroup', 'span', 'col');
      add('col', 'span');
      add('tbody thead tfoot', '', 'tr');
      add('tr', '', 'td th');
      add('td', 'colspan rowspan headers', flowContent);
      add('th', 'colspan rowspan headers scope abbr', flowContent);
      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
      add('fieldset', 'disabled form name', [
        flowContent,
        'legend'
      ].join(' '));
      add('label', 'form for', phrasingContent);
      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
      add('select', 'disabled form multiple name required size', 'option optgroup');
      add('optgroup', 'disabled label', 'option');
      add('option', 'disabled label selected value');
      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
      add('menu', 'type label', [
        flowContent,
        'li'
      ].join(' '));
      add('noscript', '', flowContent);
      if (type !== 'html4') {
        add('wbr');
        add('ruby', '', [
          phrasingContent,
          'rt rp'
        ].join(' '));
        add('figcaption', '', flowContent);
        add('mark rt rp summary bdi', '', phrasingContent);
        add('canvas', 'width height', flowContent);
        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [
          flowContent,
          'track source'
        ].join(' '));
        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [
          flowContent,
          'track source'
        ].join(' '));
        add('picture', '', 'img source');
        add('source', 'src srcset type media sizes');
        add('track', 'kind src srclang label default');
        add('datalist', '', [
          phrasingContent,
          'option'
        ].join(' '));
        add('article section nav aside main header footer', '', flowContent);
        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
        add('figure', '', [
          flowContent,
          'figcaption'
        ].join(' '));
        add('time', 'datetime', phrasingContent);
        add('dialog', 'open', flowContent);
        add('command', 'type label icon disabled checked radiogroup command');
        add('output', 'for form name', phrasingContent);
        add('progress', 'value max', phrasingContent);
        add('meter', 'value min max low high optimum', phrasingContent);
        add('details', 'open', [
          flowContent,
          'summary'
        ].join(' '));
        add('keygen', 'autofocus challenge disabled form keytype name');
      }
      if (type !== 'html5-strict') {
        addAttrs('script', 'language xml:space');
        addAttrs('style', 'xml:space');
        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
        addAttrs('embed', 'align name hspace vspace');
        addAttrs('param', 'valuetype type');
        addAttrs('a', 'charset name rev shape coords');
        addAttrs('br', 'clear');
        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
        addAttrs('img', 'name longdesc align border hspace vspace');
        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
        addAttrs('font basefont', 'size color face');
        addAttrs('input', 'usemap align');
        addAttrs('select');
        addAttrs('textarea');
        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
        addAttrs('ul', 'type compact');
        addAttrs('li', 'type');
        addAttrs('ol dl menu dir', 'compact');
        addAttrs('pre', 'width xml:space');
        addAttrs('hr', 'align noshade size width');
        addAttrs('isindex', 'prompt');
        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
        addAttrs('col', 'width align char charoff valign');
        addAttrs('colgroup', 'width align char charoff valign');
        addAttrs('thead', 'align char charoff valign');
        addAttrs('tr', 'align char charoff valign bgcolor');
        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
        addAttrs('form', 'accept');
        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
        addAttrs('tfoot', 'align char charoff valign');
        addAttrs('tbody', 'align char charoff valign');
        addAttrs('area', 'nohref');
        addAttrs('body', 'background bgcolor text link vlink alink');
      }
      if (type !== 'html4') {
        addAttrs('input button select textarea', 'autofocus');
        addAttrs('input textarea', 'placeholder');
        addAttrs('a', 'download');
        addAttrs('link script img', 'crossorigin');
        addAttrs('img', 'loading');
        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');
      }
      if (type !== 'html4') {
        each$e([
          schema.video,
          schema.audio
        ], item => {
          delete item.children.audio;
          delete item.children.video;
        });
      }
      each$e(split$1('a form meter progress dfn'), name => {
        if (schema[name]) {
          delete schema[name].children[name];
        }
      });
      delete schema.caption.children.table;
      delete schema.script;
      return schema;
    };

    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';
    const parseValidChildrenRules = value => {
      const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      return bind$3(split$1(value, ','), rule => {
        const matches = childRuleRegExp.exec(rule);
        if (matches) {
          const prefix = matches[1];
          const operation = prefix ? prefixToOperation(prefix) : 'replace';
          const name = matches[2];
          const validChildren = split$1(matches[3], '|');
          return [{
              operation,
              name,
              validChildren
            }];
        } else {
          return [];
        }
      });
    };

    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {
      const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
      const hasPatternsRegExp = /[*?+]/;
      const {attributes, attributesOrder} = targetElement;
      return each$e(split$1(attrData, '|'), rule => {
        const matches = attrRuleRegExp.exec(rule);
        if (matches) {
          const attr = {};
          const attrType = matches[1];
          const attrName = matches[2].replace(/[\\:]:/g, ':');
          const attrPrefix = matches[3];
          const value = matches[4];
          if (attrType === '!') {
            targetElement.attributesRequired = targetElement.attributesRequired || [];
            targetElement.attributesRequired.push(attrName);
            attr.required = true;
          }
          if (attrType === '-') {
            delete attributes[attrName];
            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);
            return;
          }
          if (attrPrefix) {
            if (attrPrefix === '=') {
              targetElement.attributesDefault = targetElement.attributesDefault || [];
              targetElement.attributesDefault.push({
                name: attrName,
                value
              });
              attr.defaultValue = value;
            } else if (attrPrefix === '~') {
              targetElement.attributesForced = targetElement.attributesForced || [];
              targetElement.attributesForced.push({
                name: attrName,
                value
              });
              attr.forcedValue = value;
            } else if (attrPrefix === '<') {
              attr.validValues = Tools.makeMap(value, '?');
            }
          }
          if (hasPatternsRegExp.test(attrName)) {
            const attrPattern = attr;
            targetElement.attributePatterns = targetElement.attributePatterns || [];
            attrPattern.pattern = patternToRegExp(attrName);
            targetElement.attributePatterns.push(attrPattern);
          } else {
            if (!attributes[attrName]) {
              attributesOrder.push(attrName);
            }
            attributes[attrName] = attr;
          }
        }
      });
    };
    const cloneAttributesInto = (from, to) => {
      each$d(from.attributes, (value, key) => {
        to.attributes[key] = value;
      });
      to.attributesOrder.push(...from.attributesOrder);
    };
    const parseValidElementsRules = (globalElement, validElements) => {
      const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
      return bind$3(split$1(validElements, ','), rule => {
        const matches = elementRuleRegExp.exec(rule);
        if (matches) {
          const prefix = matches[1];
          const elementName = matches[2];
          const outputName = matches[3];
          const attrsPrefix = matches[4];
          const attrData = matches[5];
          const element = {
            attributes: {},
            attributesOrder: []
          };
          globalElement.each(el => cloneAttributesInto(el, element));
          if (prefix === '#') {
            element.paddEmpty = true;
          } else if (prefix === '-') {
            element.removeEmpty = true;
          }
          if (attrsPrefix === '!') {
            element.removeEmptyAttrs = true;
          }
          if (attrData) {
            parseValidElementsAttrDataIntoElement(attrData, element);
          }
          if (outputName) {
            element.outputName = elementName;
          }
          if (elementName === '@') {
            if (globalElement.isNone()) {
              globalElement = Optional.some(element);
            } else {
              return [];
            }
          }
          return [outputName ? {
              name: elementName,
              element,
              aliasName: outputName
            } : {
              name: elementName,
              element
            }];
        } else {
          return [];
        }
      });
    };

    const mapCache = {};
    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;
    const createMap = (defaultValue, extendWith = {}) => {
      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
      return extend$2(value, extendWith);
    };
    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());
    const compileElementMap = (value, mode) => {
      if (value) {
        const styles = {};
        if (isString(value)) {
          value = { '*': value };
        }
        each$b(value, (value, key) => {
          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);
        });
        return styles;
      } else {
        return undefined;
      }
    };
    const Schema = (settings = {}) => {
      var _a;
      const elements = {};
      const children = {};
      let patternElements = [];
      const customElementsMap = {};
      const specialElements = {};
      const createLookupTable = (option, defaultValue, extendWith) => {
        const value = settings[option];
        if (!value) {
          let newValue = mapCache[option];
          if (!newValue) {
            newValue = createMap(defaultValue, extendWith);
            mapCache[option] = newValue;
          }
          return newValue;
        } else {
          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
        }
      };
      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';
      const schemaItems = makeSchema(schemaType);
      if (settings.verify_html === false) {
        settings.valid_elements = '*[*]';
      }
      const validStyles = compileElementMap(settings.valid_styles);
      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');
      const validClasses = compileElementMap(settings.valid_classes, 'map');
      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');
      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');
      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', voidElementsMap);
      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);
      const textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);
      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');
      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');
      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {
        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
      });
      const addValidElements = validElements => {
        const globalElement = Optional.from(elements['@']);
        const hasPatternsRegExp = /[*?+]/;
        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {
          if (aliasName) {
            elements[aliasName] = element;
          }
          if (hasPatternsRegExp.test(name)) {
            const patternElement = element;
            patternElement.pattern = patternToRegExp(name);
            patternElements.push(patternElement);
          } else {
            elements[name] = element;
          }
        });
      };
      const setValidElements = validElements => {
        patternElements = [];
        each$e(keys(elements), name => {
          delete elements[name];
        });
        addValidElements(validElements);
      };
      const addCustomElements = customElements => {
        delete mapCache.text_block_elements;
        delete mapCache.block_elements;
        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({inline, name, cloneName}) => {
          children[name] = children[cloneName];
          customElementsMap[name] = cloneName;
          nonEmptyElementsMap[name.toUpperCase()] = {};
          nonEmptyElementsMap[name] = {};
          if (!inline) {
            blockElementsMap[name.toUpperCase()] = {};
            blockElementsMap[name] = {};
          }
          if (!elements[name]) {
            let customRule = elements[cloneName];
            customRule = extend$2({}, customRule);
            delete customRule.removeEmptyAttrs;
            delete customRule.removeEmpty;
            elements[name] = customRule;
          }
          each$d(children, (element, elmName) => {
            if (element[cloneName]) {
              children[elmName] = element = extend$2({}, children[elmName]);
              element[name] = element[cloneName];
            }
          });
        });
      };
      const addValidChildren = validChildren => {
        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {
          const parent = operation === 'replace' ? { '#comment': {} } : children[name];
          each$e(validChildren, child => {
            if (operation === 'remove') {
              delete parent[child];
            } else {
              parent[child] = {};
            }
          });
          children[name] = parent;
        });
      };
      const getElementRule = name => {
        const element = elements[name];
        if (element) {
          return element;
        }
        let i = patternElements.length;
        while (i--) {
          const patternElement = patternElements[i];
          if (patternElement.pattern.test(name)) {
            return patternElement;
          }
        }
        return undefined;
      };
      if (!settings.valid_elements) {
        each$b(schemaItems, (element, name) => {
          elements[name] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };
          children[name] = element.children;
        });
        each$b(split$1('strong/b em/i'), item => {
          const items = split$1(item, '/');
          elements[items[1]].outputName = items[0];
        });
        each$b(textInlineElementsMap, (_val, name) => {
          if (elements[name]) {
            if (settings.padd_empty_block_inline_children) {
              elements[name].paddInEmptyBlock = true;
            }
            elements[name].removeEmpty = true;
          }
        });
        each$b(split$1('ol ul blockquote a table tbody'), name => {
          if (elements[name]) {
            elements[name].removeEmpty = true;
          }
        });
        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {
          if (elements[name]) {
            elements[name].paddEmpty = true;
          }
        });
        each$b(split$1('span'), name => {
          elements[name].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
        each$b(schemaItems, (element, name) => {
          children[name] = element.children;
        });
      }
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren('+ol[ul|ol],+ul[ul|ol]');
      each$b({
        dd: 'dl',
        dt: 'dl',
        li: 'ul ol',
        td: 'tr',
        th: 'tr',
        tr: 'tbody thead tfoot',
        tbody: 'table',
        thead: 'table',
        tfoot: 'table',
        legend: 'fieldset',
        area: 'map',
        param: 'video audio object'
      }, (parents, item) => {
        if (elements[item]) {
          elements[item].parentsRequired = split$1(parents);
        }
      });
      if (settings.invalid_elements) {
        each$b(explode$2(settings.invalid_elements), item => {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }
      if (!getElementRule('span')) {
        addValidElements('span[!data-mce-type|*]');
      }
      const getValidStyles = constant(validStyles);
      const getInvalidStyles = constant(invalidStyles);
      const getValidClasses = constant(validClasses);
      const getBoolAttrs = constant(boolAttrMap);
      const getBlockElements = constant(blockElementsMap);
      const getTextBlockElements = constant(textBlockElementsMap);
      const getTextInlineElements = constant(textInlineElementsMap);
      const getVoidElements = constant(Object.seal(voidElementsMap));
      const getSelfClosingElements = constant(selfClosingElementsMap);
      const getNonEmptyElements = constant(nonEmptyElementsMap);
      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
      const getWhitespaceElements = constant(whitespaceElementsMap);
      const getTransparentElements = constant(transparentElementsMap);
      const getSpecialElements = constant(Object.seal(specialElements));
      const isValidChild = (name, child) => {
        const parent = children[name.toLowerCase()];
        return !!(parent && parent[child.toLowerCase()]);
      };
      const isValid = (name, attr) => {
        const rule = getElementRule(name);
        if (rule) {
          if (attr) {
            if (rule.attributes[attr]) {
              return true;
            }
            const attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              let i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(attr)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }
        return false;
      };
      const getCustomElements = constant(customElementsMap);
      return {
        type: schemaType,
        children,
        elements,
        getValidStyles,
        getValidClasses,
        getBlockElements,
        getInvalidStyles,
        getVoidElements,
        getTextBlockElements,
        getTextInlineElements,
        getBoolAttrs,
        getElementRule,
        getSelfClosingElements,
        getNonEmptyElements,
        getMoveCaretBeforeOnEnterElements,
        getWhitespaceElements,
        getTransparentElements,
        getSpecialElements,
        isValidChild,
        isValid,
        getCustomElements,
        addValidElements,
        setValidElements,
        addCustomElements,
        addValidChildren
      };
    };

    const Styles = (settings = {}, schema) => {
      const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
      const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
      const trimRightRegExp = /\s+$/;
      const encodingLookup = {};
      let validStyles;
      let invalidStyles;
      const invisibleChar = zeroWidth;
      if (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }
      const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(' ');
      for (let i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }
      const self = {
        parse: css => {
          const styles = {};
          let isEncoded = false;
          const urlConverter = settings.url_converter;
          const urlConverterScope = settings.url_converter_scope || self;
          const compress = (prefix, suffix, noJoin) => {
            const top = styles[prefix + '-top' + suffix];
            if (!top) {
              return;
            }
            const right = styles[prefix + '-right' + suffix];
            if (!right) {
              return;
            }
            const bottom = styles[prefix + '-bottom' + suffix];
            if (!bottom) {
              return;
            }
            const left = styles[prefix + '-left' + suffix];
            if (!left) {
              return;
            }
            const box = [
              top,
              right,
              bottom,
              left
            ];
            let i = box.length - 1;
            while (i--) {
              if (box[i] !== box[i + 1]) {
                break;
              }
            }
            if (i > -1 && noJoin) {
              return;
            }
            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
            delete styles[prefix + '-top' + suffix];
            delete styles[prefix + '-right' + suffix];
            delete styles[prefix + '-bottom' + suffix];
            delete styles[prefix + '-left' + suffix];
          };
          const canCompress = key => {
            const value = styles[key];
            if (!value) {
              return;
            }
            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');
            let i = values.length;
            while (i--) {
              if (values[i] !== values[0]) {
                return false;
              }
            }
            styles[key] = values[0];
            return true;
          };
          const compress2 = (target, a, b, c) => {
            if (!canCompress(a)) {
              return;
            }
            if (!canCompress(b)) {
              return;
            }
            if (!canCompress(c)) {
              return;
            }
            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
            delete styles[a];
            delete styles[b];
            delete styles[c];
          };
          const encode = str => {
            isEncoded = true;
            return encodingLookup[str];
          };
          const decode = (str, keepSlashes) => {
            if (isEncoded) {
              str = str.replace(/\uFEFF[0-9]/g, str => {
                return encodingLookup[str];
              });
            }
            if (!keepSlashes) {
              str = str.replace(/\\([\'\";:])/g, '$1');
            }
            return str;
          };
          const decodeSingleHexSequence = escSeq => {
            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
          };
          const decodeHexSequences = value => {
            return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
          };
          const processUrl = (match, url, url2, url3, str, str2) => {
            str = str || str2;
            if (str) {
              str = decode(str);
              return `'` + str.replace(/\'/g, `\\'`) + `'`;
            }
            url = decode(url || url2 || url3 || '');
            if (!settings.allow_script_urls) {
              const scriptUrl = url.replace(/[\s\r\n]+/g, '');
              if (/(java|vb)script:/i.test(scriptUrl)) {
                return '';
              }
              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                return '';
              }
            }
            if (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, 'style');
            }
            return `url('` + url.replace(/\'/g, `\\'`) + `')`;
          };
          if (css) {
            css = css.replace(/[\u0000-\u001F]/g, '');
            css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, str => {
              return str.replace(/[;:]/g, encode);
            });
            let matches;
            while (matches = styleRegExp.exec(css)) {
              styleRegExp.lastIndex = matches.index + matches[0].length;
              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();
              let value = matches[2].replace(trimRightRegExp, '');
              if (name && value) {
                name = decodeHexSequences(name);
                value = decodeHexSequences(value);
                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
                  continue;
                }
                if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
                  continue;
                }
                if (name === 'font-weight' && value === '700') {
                  value = 'bold';
                } else if (name === 'color' || name === 'background-color') {
                  value = value.toLowerCase();
                }
                value = value.replace(urlOrStrRegExp, processUrl);
                styles[name] = isEncoded ? decode(value, true) : value;
              }
            }
            compress('border', '', true);
            compress('border', '-width');
            compress('border', '-color');
            compress('border', '-style');
            compress('padding', '');
            compress('margin', '');
            compress2('border', 'border-width', 'border-style', 'border-color');
            if (styles.border === 'medium none') {
              delete styles.border;
            }
            if (styles['border-image'] === 'none') {
              delete styles['border-image'];
            }
          }
          return styles;
        },
        serialize: (styles, elementName) => {
          let css = '';
          const serializeStyles = (elemName, validStyleList) => {
            const styleList = validStyleList[elemName];
            if (styleList) {
              for (let i = 0, l = styleList.length; i < l; i++) {
                const name = styleList[i];
                const value = styles[name];
                if (value) {
                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
                }
              }
            }
          };
          const isValid = (name, elemName) => {
            if (!invalidStyles || !elemName) {
              return true;
            }
            let styleMap = invalidStyles['*'];
            if (styleMap && styleMap[name]) {
              return false;
            }
            styleMap = invalidStyles[elemName];
            return !(styleMap && styleMap[name]);
          };
          if (elementName && validStyles) {
            serializeStyles('*', validStyles);
            serializeStyles(elementName, validStyles);
          } else {
            each$d(styles, (value, name) => {
              if (value && isValid(name, elementName)) {
                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
              }
            });
          }
          return css;
        }
      };
      return self;
    };

    const deprecated = {
      keyLocation: true,
      layerX: true,
      layerY: true,
      returnValue: true,
      webkitMovementX: true,
      webkitMovementY: true,
      keyIdentifier: true,
      mozPressure: true
    };
    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);
    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);
    const clone$3 = (originalEvent, data) => {
      const event = data !== null && data !== void 0 ? data : {};
      for (const name in originalEvent) {
        if (!has$2(deprecated, name)) {
          event[name] = originalEvent[name];
        }
      }
      if (isNonNullable(originalEvent.composedPath)) {
        event.composedPath = () => originalEvent.composedPath();
      }
      return event;
    };
    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {
      var _a;
      const event = clone$3(originalEvent, data);
      event.type = type;
      if (isNullable(event.target)) {
        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
      }
      if (needsNormalizing(originalEvent)) {
        event.preventDefault = () => {
          event.defaultPrevented = true;
          event.isDefaultPrevented = always;
          if (isFunction(originalEvent.preventDefault)) {
            originalEvent.preventDefault();
          }
        };
        event.stopPropagation = () => {
          event.cancelBubble = true;
          event.isPropagationStopped = always;
          if (isFunction(originalEvent.stopPropagation)) {
            originalEvent.stopPropagation();
          }
        };
        event.stopImmediatePropagation = () => {
          event.isImmediatePropagationStopped = always;
          event.stopPropagation();
        };
        if (!hasIsDefaultPrevented(event)) {
          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
          event.isPropagationStopped = event.cancelBubble === true ? always : never;
          event.isImmediatePropagationStopped = never;
        }
      }
      return event;
    };

    const eventExpandoPrefix = 'mce-data-';
    const mouseEventRe = /^(?:mouse|contextmenu)|click/;
    const addEvent = (target, name, callback, capture) => {
      target.addEventListener(name, callback, capture || false);
    };
    const removeEvent = (target, name, callback, capture) => {
      target.removeEventListener(name, callback, capture || false);
    };
    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);
    const fix = (originalEvent, data) => {
      const event = normalize$3(originalEvent.type, originalEvent, document, data);
      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
        const eventDoc = event.target.ownerDocument || document;
        const doc = eventDoc.documentElement;
        const body = eventDoc.body;
        const mouseEvent = event;
        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      return event;
    };
    const bindOnReady = (win, callback, eventUtils) => {
      const doc = win.document, event = { type: 'ready' };
      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }
      const isDocReady = () => {
        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;
      };
      const readyHandler = () => {
        removeEvent(win, 'DOMContentLoaded', readyHandler);
        removeEvent(win, 'load', readyHandler);
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
        win = null;
      };
      if (isDocReady()) {
        readyHandler();
      } else {
        addEvent(win, 'DOMContentLoaded', readyHandler);
      }
      if (!eventUtils.domLoaded) {
        addEvent(win, 'load', readyHandler);
      }
    };
    class EventUtils {
      constructor() {
        this.domLoaded = false;
        this.events = {};
        this.count = 1;
        this.expando = eventExpandoPrefix + (+new Date()).toString(32);
        this.hasFocusIn = 'onfocusin' in document.documentElement;
        this.count = 1;
      }
      bind(target, names, callback, scope) {
        const self = this;
        let callbackList;
        const win = window;
        const defaultNativeHandler = evt => {
          self.executeHandlers(fix(evt || win.event), id);
        };
        if (!target || isText$a(target) || isComment(target)) {
          return callback;
        }
        let id;
        if (!target[self.expando]) {
          id = self.count++;
          target[self.expando] = id;
          self.events[id] = {};
        } else {
          id = target[self.expando];
        }
        scope = scope || target;
        const namesList = names.split(' ');
        let i = namesList.length;
        while (i--) {
          let name = namesList[i];
          let nativeHandler = defaultNativeHandler;
          let capture = false;
          let fakeName = false;
          if (name === 'DOMContentLoaded') {
            name = 'ready';
          }
          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
            callback.call(scope, fix({ type: name }));
            continue;
          }
          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
            capture = true;
            fakeName = name === 'focusin' ? 'focus' : 'blur';
            nativeHandler = evt => {
              const event = fix(evt || win.event);
              event.type = event.type === 'focus' ? 'focusin' : 'focusout';
              self.executeHandlers(event, id);
            };
          }
          callbackList = self.events[id][name];
          if (!callbackList) {
            self.events[id][name] = callbackList = [{
                func: callback,
                scope
              }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            callbackList.nativeHandler = nativeHandler;
            if (name === 'ready') {
              bindOnReady(target, nativeHandler, self);
            } else {
              addEvent(target, fakeName || name, nativeHandler, capture);
            }
          } else {
            if (name === 'ready' && self.domLoaded) {
              callback(fix({ type: name }));
            } else {
              callbackList.push({
                func: callback,
                scope
              });
            }
          }
        }
        target = callbackList = null;
        return callback;
      }
      unbind(target, names, callback) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const id = target[this.expando];
        if (id) {
          let eventMap = this.events[id];
          if (names) {
            const namesList = names.split(' ');
            let i = namesList.length;
            while (i--) {
              const name = namesList[i];
              const callbackList = eventMap[name];
              if (callbackList) {
                if (callback) {
                  let ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      const nativeHandler = callbackList.nativeHandler;
                      const fakeName = callbackList.fakeName, capture = callbackList.capture;
                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      newCallbackList.nativeHandler = nativeHandler;
                      newCallbackList.fakeName = fakeName;
                      newCallbackList.capture = capture;
                      eventMap[name] = newCallbackList;
                    }
                  }
                }
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name];
                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            each$d(eventMap, (callbackList, name) => {
              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
            });
            eventMap = {};
          }
          for (const name in eventMap) {
            if (has$2(eventMap, name)) {
              return this;
            }
          }
          delete this.events[id];
          try {
            delete target[this.expando];
          } catch (ex) {
            target[this.expando] = null;
          }
        }
        return this;
      }
      fire(target, name, args) {
        return this.dispatch(target, name, args);
      }
      dispatch(target, name, args) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const event = fix({
          type: name,
          target
        }, args);
        do {
          const id = target[this.expando];
          if (id) {
            this.executeHandlers(event, id);
          }
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !event.isPropagationStopped());
        return this;
      }
      clean(target) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        if (target[this.expando]) {
          this.unbind(target);
        }
        if (!target.getElementsByTagName) {
          target = target.document;
        }
        if (target && target.getElementsByTagName) {
          this.unbind(target);
          const children = target.getElementsByTagName('*');
          let i = children.length;
          while (i--) {
            target = children[i];
            if (target[this.expando]) {
              this.unbind(target);
            }
          }
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        return false;
      }
      executeHandlers(evt, id) {
        const container = this.events[id];
        const callbackList = container && container[evt.type];
        if (callbackList) {
          for (let i = 0, l = callbackList.length; i < l; i++) {
            const callback = callbackList[i];
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      }
    }
    EventUtils.Event = new EventUtils();

    const each$a = Tools.each;
    const grep = Tools.grep;
    const internalStyleName = 'data-mce-style';
    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');
    const legacySetAttribute = (elm, name, value) => {
      if (isNullable(value) || value === '') {
        remove$a(elm, name);
      } else {
        set$3(elm, name, value);
      }
    };
    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());
    const findNodeIndex = (node, normalized) => {
      let idx = 0;
      if (node) {
        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
          const nodeType = tempNode.nodeType;
          if (normalized && isText$a(tempNode)) {
            if (nodeType === lastNodeType || !tempNode.data.length) {
              continue;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }
      return idx;
    };
    const updateInternalStyleAttr = (styles, elm) => {
      const rawValue = get$9(elm, 'style');
      const value = styles.serialize(styles.parse(rawValue), name(elm));
      legacySetAttribute(elm, internalStyleName, value);
    };
    const convertStyleToString = (cssValue, cssName) => {
      if (isNumber(cssValue)) {
        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';
      } else {
        return cssValue;
      }
    };
    const applyStyle$1 = ($elm, cssName, cssValue) => {
      const normalizedName = camelCaseToHyphens(cssName);
      if (isNullable(cssValue) || cssValue === '') {
        remove$6($elm, normalizedName);
      } else {
        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
      }
    };
    const setupAttrHooks = (styles, settings, getContext) => {
      const keepValues = settings.keep_values;
      const keepUrlHook = {
        set: (elm, value, name) => {
          const sugarElm = SugarElement.fromDom(elm);
          if (isFunction(settings.url_converter) && isNonNullable(value)) {
            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);
          }
          const internalName = 'data-mce-' + name;
          legacySetAttribute(sugarElm, internalName, value);
          legacySetAttribute(sugarElm, name, value);
        },
        get: (elm, name) => {
          const sugarElm = SugarElement.fromDom(elm);
          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);
        }
      };
      const attrHooks = {
        style: {
          set: (elm, value) => {
            const sugarElm = SugarElement.fromDom(elm);
            if (keepValues) {
              legacySetAttribute(sugarElm, internalStyleName, value);
            }
            remove$a(sugarElm, 'style');
            if (isString(value)) {
              setAll(sugarElm, styles.parse(value));
            }
          },
          get: elm => {
            const sugarElm = SugarElement.fromDom(elm);
            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');
            return styles.serialize(styles.parse(value), name(sugarElm));
          }
        }
      };
      if (keepValues) {
        attrHooks.href = attrHooks.src = keepUrlHook;
      }
      return attrHooks;
    };
    const DOMUtils = (doc, settings = {}) => {
      const addedStyles = {};
      const win = window;
      const files = {};
      let counter = 0;
      const stdMode = true;
      const boxModel = true;
      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
        contentCssCors: settings.contentCssCors,
        referrerPolicy: settings.referrerPolicy
      });
      const boundEvents = [];
      const schema = settings.schema ? settings.schema : Schema({});
      const styles = Styles({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope
      }, settings.schema);
      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
      const blockElementsMap = schema.getBlockElements();
      const isBlock = node => {
        if (isString(node)) {
          return has$2(blockElementsMap, node);
        } else {
          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
        }
      };
      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;
      const _get = elm => {
        const value = get(elm);
        return isNonNullable(value) ? SugarElement.fromDom(value) : null;
      };
      const getAttrib = (elm, name, defaultVal = '') => {
        let value;
        const $elm = _get(elm);
        if (isNonNullable($elm) && isElement$7($elm)) {
          const hook = attrHooks[name];
          if (hook && hook.get) {
            value = hook.get($elm.dom, name);
          } else {
            value = get$9($elm, name);
          }
        }
        return isNonNullable(value) ? value : defaultVal;
      };
      const getAttribs = elm => {
        const node = get(elm);
        return isNullable(node) ? [] : node.attributes;
      };
      const setAttrib = (elm, name, value) => {
        run(elm, e => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const val = value === '' ? null : value;
            const originalValue = get$9($elm, name);
            const hook = attrHooks[name];
            if (hook && hook.set) {
              hook.set($elm.dom, val, name);
            } else {
              legacySetAttribute($elm, name, val);
            }
            if (originalValue !== val && settings.onSetAttrib) {
              settings.onSetAttrib({
                attrElm: $elm.dom,
                attrName: name,
                attrValue: val
              });
            }
          }
        });
      };
      const clone = (node, deep) => {
        return node.cloneNode(deep);
      };
      const getRoot = () => settings.root_element || doc.body;
      const getViewPort = argWin => {
        const vp = getBounds(argWin);
        return {
          x: vp.x,
          y: vp.y,
          w: vp.width,
          h: vp.height
        };
      };
      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);
      const setStyle = (elm, name, value) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          applyStyle$1($elm, name, value);
          if (settings.update_styles) {
            updateInternalStyleAttr(styles, $elm);
          }
        });
      };
      const setStyles = (elm, stylesArg) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          each$d(stylesArg, (v, n) => {
            applyStyle$1($elm, n, v);
          });
          if (settings.update_styles) {
            updateInternalStyleAttr(styles, $elm);
          }
        });
      };
      const getStyle = (elm, name, computed) => {
        const $elm = get(elm);
        if (isNullable($elm) || !isElement$6($elm)) {
          return undefined;
        }
        if (computed) {
          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));
        } else {
          name = name.replace(/-(\D)/g, (a, b) => b.toUpperCase());
          if (name === 'float') {
            name = 'cssFloat';
          }
          return $elm.style ? $elm.style[name] : undefined;
        }
      };
      const getSize = elm => {
        const $elm = get(elm);
        if (!$elm) {
          return {
            w: 0,
            h: 0
          };
        }
        let w = getStyle($elm, 'width');
        let h = getStyle($elm, 'height');
        if (!w || w.indexOf('px') === -1) {
          w = '0';
        }
        if (!h || h.indexOf('px') === -1) {
          h = '0';
        }
        return {
          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
        };
      };
      const getRect = elm => {
        const $elm = get(elm);
        const pos = getPos$1($elm);
        const size = getSize($elm);
        return {
          x: pos.x,
          y: pos.y,
          w: size.w,
          h: size.h
        };
      };
      const is = (elm, selector) => {
        if (!elm) {
          return false;
        }
        const elms = isArray$1(elm) ? elm : [elm];
        return exists(elms, e => {
          return is$1(SugarElement.fromDom(e), selector);
        });
      };
      const getParents = (elm, selector, root, collect) => {
        const result = [];
        let node = get(elm);
        collect = collect === undefined;
        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
        if (isString(selector)) {
          if (selector === '*') {
            selector = isElement$6;
          } else {
            const selectorVal = selector;
            selector = node => is(node, selectorVal);
          }
        }
        while (node) {
          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
            break;
          }
          if (!selector || selector(node)) {
            if (collect) {
              result.push(node);
            } else {
              return [node];
            }
          }
          node = node.parentNode;
        }
        return collect ? result : null;
      };
      const getParent = (node, selector, root) => {
        const parents = getParents(node, selector, root, false);
        return parents && parents.length > 0 ? parents[0] : null;
      };
      const _findSib = (node, selector, name) => {
        let func = selector;
        if (node) {
          if (isString(selector)) {
            func = node => {
              return is(node, selector);
            };
          }
          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {
            if (isFunction(func) && func(tempNode)) {
              return tempNode;
            }
          }
        }
        return null;
      };
      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');
      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');
      const isParentNode = node => isFunction(node.querySelectorAll);
      const select = (selector, scope) => {
        var _a, _b;
        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
      };
      const run = function (elm, func, scope) {
        const context = scope !== null && scope !== void 0 ? scope : this;
        if (isArray$1(elm)) {
          const result = [];
          each$a(elm, (e, i) => {
            const node = get(e);
            if (node) {
              result.push(func.call(context, node, i));
            }
          });
          return result;
        } else {
          const node = get(elm);
          return !node ? false : func.call(context, node);
        }
      };
      const setAttribs = (elm, attrs) => {
        run(elm, $elm => {
          each$d(attrs, (value, name) => {
            setAttrib($elm, name, value);
          });
        });
      };
      const setHTML = (elm, html) => {
        run(elm, e => {
          const $elm = SugarElement.fromDom(e);
          set$1($elm, html);
        });
      };
      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {
        const newElm = isString(name) ? doc.createElement(name) : name;
        if (isNonNullable(attrs)) {
          setAttribs(newElm, attrs);
        }
        if (html) {
          if (!isString(html) && html.nodeType) {
            newElm.appendChild(html);
          } else if (isString(html)) {
            setHTML(newElm, html);
          }
        }
        return !create ? parentElm.appendChild(newElm) : newElm;
      });
      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);
      const decode = Entities.decode;
      const encode = Entities.encodeAllRaw;
      const createHTML = (name, attrs, html = '') => {
        let outHtml = '<' + name;
        for (const key in attrs) {
          if (hasNonNullableKey(attrs, key)) {
            outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
          }
        }
        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {
          return outHtml + ' />';
        } else {
          return outHtml + '>' + html + '</' + name + '>';
        }
      };
      const createFragment = html => {
        const container = doc.createElement('div');
        const frag = doc.createDocumentFragment();
        frag.appendChild(container);
        if (html) {
          container.innerHTML = html;
        }
        let node;
        while (node = container.firstChild) {
          frag.appendChild(node);
        }
        frag.removeChild(container);
        return frag;
      };
      const remove = (node, keepChildren) => {
        return run(node, n => {
          const $node = SugarElement.fromDom(n);
          if (keepChildren) {
            each$e(children$1($node), child => {
              if (isText$b(child) && child.dom.length === 0) {
                remove$5(child);
              } else {
                before$3($node, child);
              }
            });
          }
          remove$5($node);
          return $node.dom;
        });
      };
      const removeAllAttribs = e => run(e, e => {
        const attrs = e.attributes;
        for (let i = attrs.length - 1; i >= 0; i--) {
          e.removeAttributeNode(attrs.item(i));
        }
      });
      const parseStyle = cssText => styles.parse(cssText);
      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);
      const addStyle = cssText => {
        if (self !== DOMUtils.DOM && doc === document) {
          if (addedStyles[cssText]) {
            return;
          }
          addedStyles[cssText] = true;
        }
        let styleElm = doc.getElementById('mceDefaultStyles');
        if (!styleElm) {
          styleElm = doc.createElement('style');
          styleElm.id = 'mceDefaultStyles';
          styleElm.type = 'text/css';
          const head = doc.head;
          if (head.firstChild) {
            head.insertBefore(styleElm, head.firstChild);
          } else {
            head.appendChild(styleElm);
          }
        }
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      };
      const loadCSS = urls => {
        if (!urls) {
          urls = '';
        }
        each$e(urls.split(','), url => {
          files[url] = true;
          styleSheetLoader.load(url).catch(noop);
        });
      };
      const toggleClass = (elm, cls, state) => {
        run(elm, e => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const classes = cls.split(' ');
            each$e(classes, c => {
              if (isNonNullable(state)) {
                const fn = state ? add$2 : remove$7;
                fn($elm, c);
              } else {
                toggle$1($elm, c);
              }
            });
          }
        });
      };
      const addClass = (elm, cls) => {
        toggleClass(elm, cls, true);
      };
      const removeClass = (elm, cls) => {
        toggleClass(elm, cls, false);
      };
      const hasClass = (elm, cls) => {
        const $elm = _get(elm);
        const classes = cls.split(' ');
        return isNonNullable($elm) && forall(classes, c => has($elm, c));
      };
      const show = elm => {
        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));
      };
      const hide = elm => {
        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));
      };
      const isHidden = elm => {
        const $elm = _get(elm);
        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');
      };
      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;
      const getOuterHTML = elm => {
        const $elm = _get(elm);
        if (isNonNullable($elm)) {
          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
        } else {
          return '';
        }
      };
      const setOuterHTML = (elm, html) => {
        run(elm, $elm => {
          if (isElement$6($elm)) {
            $elm.outerHTML = html;
          }
        });
      };
      const insertAfter = (node, reference) => {
        const referenceNode = get(reference);
        return run(node, node => {
          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
          if (parent) {
            if (nextSibling) {
              parent.insertBefore(node, nextSibling);
            } else {
              parent.appendChild(node);
            }
          }
          return node;
        });
      };
      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {
        var _a;
        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
        if (keepChildren) {
          each$a(grep(elm.childNodes), node => {
            replacee.appendChild(node);
          });
        }
        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
        return elm;
      });
      const rename = (elm, name) => {
        if (elm.nodeName !== name.toUpperCase()) {
          const newElm = create(name);
          each$a(getAttribs(elm), attrNode => {
            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
          });
          replace(newElm, elm, true);
          return newElm;
        } else {
          return elm;
        }
      };
      const findCommonAncestor = (a, b) => {
        let ps = a;
        while (ps) {
          let pe = b;
          while (pe && ps !== pe) {
            pe = pe.parentNode;
          }
          if (ps === pe) {
            break;
          }
          ps = ps.parentNode;
        }
        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        } else {
          return ps;
        }
      };
      const isNonEmptyElement = node => {
        if (isElement$6(node)) {
          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');
          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {
            return true;
          }
        }
        return false;
      };
      const isEmpty = (node, elements, options) => {
        let brCount = 0;
        if (isNonEmptyElement(node)) {
          return false;
        }
        const firstChild = node.firstChild;
        if (firstChild) {
          const walker = new DomTreeWalker(firstChild, node);
          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};
          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);
          let tempNode = firstChild;
          do {
            if (isElement$6(tempNode)) {
              const bogusVal = tempNode.getAttribute('data-mce-bogus');
              if (bogusVal) {
                tempNode = walker.next(bogusVal === 'all');
                continue;
              }
              const name = tempNode.nodeName.toLowerCase();
              if (nonEmptyElements && nonEmptyElements[name]) {
                if (name === 'br') {
                  brCount++;
                  tempNode = walker.next();
                  continue;
                }
                return false;
              }
              if (isNonEmptyElement(tempNode)) {
                return false;
              }
            }
            if (isComment(tempNode)) {
              return false;
            }
            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {
              return false;
            }
            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {
              return false;
            }
            tempNode = walker.next();
          } while (tempNode);
        }
        return brCount <= 1;
      };
      const createRng = () => doc.createRange();
      const split = (parentElm, splitElm, replacementElm) => {
        let range = createRng();
        let beforeFragment;
        let afterFragment;
        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
          const parentNode = parentElm.parentNode;
          range.setStart(parentNode, findNodeIndex(parentElm));
          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
          beforeFragment = range.extractContents();
          range = createRng();
          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);
          afterFragment = range.extractContents();
          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);
          if (replacementElm) {
            parentNode.insertBefore(replacementElm, parentElm);
          } else {
            parentNode.insertBefore(splitElm, parentElm);
          }
          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);
          remove(parentElm);
          return replacementElm || splitElm;
        } else {
          return undefined;
        }
      };
      const bind = (target, name, func, scope) => {
        if (isArray$1(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = bind(target[i], name, func, scope);
          }
          return rv;
        } else {
          if (settings.collect && (target === doc || target === win)) {
            boundEvents.push([
              target,
              name,
              func,
              scope
            ]);
          }
          return events.bind(target, name, func, scope || self);
        }
      };
      const unbind = (target, name, func) => {
        if (isArray$1(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = unbind(target[i], name, func);
          }
          return rv;
        } else {
          if (boundEvents.length > 0 && (target === doc || target === win)) {
            let i = boundEvents.length;
            while (i--) {
              const [boundTarget, boundName, boundFunc] = boundEvents[i];
              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {
                events.unbind(boundTarget, boundName, boundFunc);
              }
            }
          }
          return events.unbind(target, name, func);
        }
      };
      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);
      const fire = (target, name, evt) => events.dispatch(target, name, evt);
      const getContentEditable = node => {
        if (node && isElement$6(node)) {
          const contentEditable = node.getAttribute('data-mce-contenteditable');
          if (contentEditable && contentEditable !== 'inherit') {
            return contentEditable;
          }
          return node.contentEditable !== 'inherit' ? node.contentEditable : null;
        } else {
          return null;
        }
      };
      const getContentEditableParent = node => {
        const root = getRoot();
        let state = null;
        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
          state = getContentEditable(tempNode);
          if (state !== null) {
            break;
          }
        }
        return state;
      };
      const isEditable = node => {
        if (isNonNullable(node)) {
          const scope = isElement$6(node) ? node : node.parentElement;
          return isNonNullable(scope) && isEditable$3(SugarElement.fromDom(scope));
        } else {
          return false;
        }
      };
      const destroy = () => {
        if (boundEvents.length > 0) {
          let i = boundEvents.length;
          while (i--) {
            const [boundTarget, boundName, boundFunc] = boundEvents[i];
            events.unbind(boundTarget, boundName, boundFunc);
          }
        }
        each$d(files, (_, url) => {
          styleSheetLoader.unload(url);
          delete files[url];
        });
      };
      const isChildOf = (node, parent) => {
        return node === parent || parent.contains(node);
      };
      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
      const self = {
        doc,
        settings,
        win,
        files,
        stdMode,
        boxModel,
        styleSheetLoader,
        boundEvents,
        styles,
        schema,
        events,
        isBlock: isBlock,
        root: null,
        clone,
        getRoot,
        getViewPort,
        getRect,
        getSize,
        getParent,
        getParents: getParents,
        get,
        getNext,
        getPrev,
        select,
        is,
        add,
        create,
        createHTML,
        createFragment,
        remove,
        setStyle,
        getStyle: getStyle,
        setStyles,
        removeAllAttribs,
        setAttrib,
        setAttribs,
        getAttrib,
        getPos: getPos$1,
        parseStyle,
        serializeStyle,
        addStyle,
        loadCSS,
        addClass,
        removeClass,
        hasClass,
        toggleClass,
        show,
        hide,
        isHidden,
        uniqueId,
        setHTML,
        getOuterHTML,
        setOuterHTML,
        decode,
        encode,
        insertAfter,
        replace,
        rename,
        findCommonAncestor,
        run,
        getAttribs,
        isEmpty,
        createRng,
        nodeIndex: findNodeIndex,
        split,
        bind: bind,
        unbind: unbind,
        fire,
        dispatch,
        getContentEditable,
        getContentEditableParent,
        isEditable,
        destroy,
        isChildOf,
        dumpRng
      };
      const attrHooks = setupAttrHooks(styles, settings, constant(self));
      return self;
    };
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;

    const DOM$b = DOMUtils.DOM;
    const QUEUED = 0;
    const LOADING = 1;
    const LOADED = 2;
    const FAILED = 3;
    class ScriptLoader {
      constructor(settings = {}) {
        this.states = {};
        this.queue = [];
        this.scriptLoadedCallbacks = {};
        this.queueLoadedCallbacks = [];
        this.loading = false;
        this.settings = settings;
      }
      _setReferrerPolicy(referrerPolicy) {
        this.settings.referrerPolicy = referrerPolicy;
      }
      loadScript(url) {
        return new Promise((resolve, reject) => {
          const dom = DOM$b;
          let elm;
          const cleanup = () => {
            dom.remove(id);
            if (elm) {
              elm.onerror = elm.onload = elm = null;
            }
          };
          const done = () => {
            cleanup();
            resolve();
          };
          const error = () => {
            cleanup();
            reject('Failed to load script: ' + url);
          };
          const id = dom.uniqueId();
          elm = document.createElement('script');
          elm.id = id;
          elm.type = 'text/javascript';
          elm.src = Tools._addCacheSuffix(url);
          if (this.settings.referrerPolicy) {
            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
          }
          elm.onload = done;
          elm.onerror = error;
          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
        });
      }
      isDone(url) {
        return this.states[url] === LOADED;
      }
      markDone(url) {
        this.states[url] = LOADED;
      }
      add(url) {
        const self = this;
        self.queue.push(url);
        const state = self.states[url];
        if (state === undefined) {
          self.states[url] = QUEUED;
        }
        return new Promise((resolve, reject) => {
          if (!self.scriptLoadedCallbacks[url]) {
            self.scriptLoadedCallbacks[url] = [];
          }
          self.scriptLoadedCallbacks[url].push({
            resolve,
            reject
          });
        });
      }
      load(url) {
        return this.add(url);
      }
      remove(url) {
        delete this.states[url];
        delete this.scriptLoadedCallbacks[url];
      }
      loadQueue() {
        const queue = this.queue;
        this.queue = [];
        return this.loadScripts(queue);
      }
      loadScripts(scripts) {
        const self = this;
        const execCallbacks = (name, url) => {
          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {
            each$e(callbacks, callback => callback[name](url));
          });
          delete self.scriptLoadedCallbacks[url];
        };
        const processResults = results => {
          const failures = filter$5(results, result => result.status === 'rejected');
          if (failures.length > 0) {
            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));
          } else {
            return Promise.resolve();
          }
        };
        const load = urls => Promise.allSettled(map$3(urls, url => {
          if (self.states[url] === LOADED) {
            execCallbacks('resolve', url);
            return Promise.resolve();
          } else if (self.states[url] === FAILED) {
            execCallbacks('reject', url);
            return Promise.reject(url);
          } else {
            self.states[url] = LOADING;
            return self.loadScript(url).then(() => {
              self.states[url] = LOADED;
              execCallbacks('resolve', url);
              const queue = self.queue;
              if (queue.length > 0) {
                self.queue = [];
                return load(queue).then(processResults);
              } else {
                return Promise.resolve();
              }
            }, () => {
              self.states[url] = FAILED;
              execCallbacks('reject', url);
              return Promise.reject(url);
            });
          }
        }));
        const processQueue = urls => {
          self.loading = true;
          return load(urls).then(results => {
            self.loading = false;
            const nextQueuedItem = self.queueLoadedCallbacks.shift();
            Optional.from(nextQueuedItem).each(call);
            return processResults(results);
          });
        };
        const uniqueScripts = stringArray(scripts);
        if (self.loading) {
          return new Promise((resolve, reject) => {
            self.queueLoadedCallbacks.push(() => {
              processQueue(uniqueScripts).then(resolve, reject);
            });
          });
        } else {
          return processQueue(uniqueScripts);
        }
      }
    }
    ScriptLoader.ScriptLoader = new ScriptLoader();

    const Cell = initial => {
      let value = initial;
      const get = () => {
        return value;
      };
      const set = v => {
        value = v;
      };
      return {
        get,
        set
      };
    };

    const isDuplicated = (items, item) => {
      const firstIndex = items.indexOf(item);
      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;
    };
    const isRaw = str => isObject(str) && has$2(str, 'raw');
    const isTokenised = str => isArray$1(str) && str.length > 1;
    const data = {};
    const currentCode = Cell('en');
    const getLanguageData = () => get$a(data, currentCode.get());
    const getData$1 = () => map$2(data, value => ({ ...value }));
    const setCode = newCode => {
      if (newCode) {
        currentCode.set(newCode);
      }
    };
    const getCode = () => currentCode.get();
    const add$1 = (code, items) => {
      let langData = data[code];
      if (!langData) {
        data[code] = langData = {};
      }
      const lcNames = map$3(keys(items), name => name.toLowerCase());
      each$d(items, (translation, name) => {
        const lcName = name.toLowerCase();
        if (lcName !== name && isDuplicated(lcNames, lcName)) {
          if (!has$2(items, lcName)) {
            langData[lcName] = translation;
          }
          langData[name] = translation;
        } else {
          langData[lcName] = translation;
        }
      });
    };
    const translate = text => {
      const langData = getLanguageData().getOr({});
      const toString = obj => {
        if (isFunction(obj)) {
          return Object.prototype.toString.call(obj);
        }
        return !isEmpty(obj) ? '' + obj : '';
      };
      const isEmpty = text => text === '' || text === null || text === undefined;
      const getLangData = text => {
        const textStr = toString(text);
        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);
      };
      const removeContext = str => str.replace(/{context:\w+}$/, '');
      if (isEmpty(text)) {
        return '';
      }
      if (isRaw(text)) {
        return toString(text.raw);
      }
      if (isTokenised(text)) {
        const values = text.slice(1);
        const substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);
        return removeContext(substitued);
      }
      return removeContext(getLangData(text));
    };
    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');
    const hasCode = code => has$2(data, code);
    const I18n = {
      getData: getData$1,
      setCode,
      getCode,
      add: add$1,
      translate,
      isRtl: isRtl$1,
      hasCode
    };

    const AddOnManager = () => {
      const items = [];
      const urls = {};
      const lookup = {};
      const _listeners = [];
      const runListeners = (name, state) => {
        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);
        each$e(matchedListeners, listener => listener.resolve());
      };
      const isLoaded = name => has$2(urls, name);
      const isAdded = name => has$2(lookup, name);
      const get = name => {
        if (lookup[name]) {
          return lookup[name].instance;
        }
        return undefined;
      };
      const loadLanguagePack = (name, languages) => {
        const language = I18n.getCode();
        const wrappedLanguages = ',' + (languages || '') + ',';
        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
          return;
        }
        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
      };
      const requireLangPack = (name, languages) => {
        if (AddOnManager.languageLoad !== false) {
          if (isLoaded(name)) {
            loadLanguagePack(name, languages);
          } else {
            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));
          }
        }
      };
      const add = (id, addOn) => {
        items.push(addOn);
        lookup[id] = { instance: addOn };
        runListeners(id, 'added');
        return addOn;
      };
      const remove = name => {
        delete urls[name];
        delete lookup[name];
      };
      const createUrl = (baseUrl, dep) => {
        if (isString(dep)) {
          return isString(baseUrl) ? {
            prefix: '',
            resource: dep,
            suffix: ''
          } : {
            prefix: baseUrl.prefix,
            resource: dep,
            suffix: baseUrl.suffix
          };
        } else {
          return dep;
        }
      };
      const load = (name, addOnUrl) => {
        if (urls[name]) {
          return Promise.resolve();
        }
        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
          urlString = AddOnManager.baseURL + '/' + urlString;
        }
        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
        const done = () => {
          runListeners(name, 'loaded');
          return Promise.resolve();
        };
        if (lookup[name]) {
          return done();
        } else {
          return ScriptLoader.ScriptLoader.add(urlString).then(done);
        }
      };
      const waitFor = (name, state = 'added') => {
        if (state === 'added' && isAdded(name)) {
          return Promise.resolve();
        } else if (state === 'loaded' && isLoaded(name)) {
          return Promise.resolve();
        } else {
          return new Promise(resolve => {
            _listeners.push({
              name,
              state,
              resolve
            });
          });
        }
      };
      return {
        items,
        urls,
        lookup,
        get,
        requireLangPack,
        add,
        remove,
        createUrl,
        load,
        waitFor
      };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = '';
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    AddOnManager.ModelManager = AddOnManager();

    const singleton = doRevoke => {
      const subject = Cell(Optional.none());
      const revoke = () => subject.get().each(doRevoke);
      const clear = () => {
        revoke();
        subject.set(Optional.none());
      };
      const isSet = () => subject.get().isSome();
      const get = () => subject.get();
      const set = s => {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear,
        isSet,
        get,
        set
      };
    };
    const repeatable = delay => {
      const intervalId = Cell(Optional.none());
      const revoke = () => intervalId.get().each(id => clearInterval(id));
      const clear = () => {
        revoke();
        intervalId.set(Optional.none());
      };
      const isSet = () => intervalId.get().isSome();
      const get = () => intervalId.get();
      const set = functionToRepeat => {
        revoke();
        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
      };
      return {
        clear,
        isSet,
        get,
        set
      };
    };
    const value$2 = () => {
      const subject = singleton(noop);
      const on = f => subject.get().each(f);
      return {
        ...subject,
        on
      };
    };

    const first$1 = (fn, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        if (isNull(timer)) {
          timer = setTimeout(() => {
            timer = null;
            fn.apply(null, args);
          }, rate);
        }
      };
      return {
        cancel,
        throttle
      };
    };
    const last$1 = (fn, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        cancel();
        timer = setTimeout(() => {
          timer = null;
          fn.apply(null, args);
        }, rate);
      };
      return {
        cancel,
        throttle
      };
    };

    const annotation = constant('mce-annotation');
    const dataAnnotation = constant('data-mce-annotation');
    const dataAnnotationId = constant('data-mce-annotation-uid');
    const dataAnnotationActive = constant('data-mce-annotation-active');
    const dataAnnotationClasses = constant('data-mce-annotation-classes');
    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');

    const isRoot$1 = root => node => eq(node, root);
    const identify = (editor, annotationName) => {
      const rng = editor.selection.getRng();
      const start = SugarElement.fromDom(rng.startContainer);
      const root = SugarElement.fromDom(editor.getBody());
      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }="${ an }"]`);
      const newStart = child$1(start, rng.startOffset).getOr(start);
      const closest = closest$3(newStart, selector, isRoot$1(root));
      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {
        const elements = findMarkers(editor, uid);
        return {
          uid,
          name,
          elements
        };
      })));
    };
    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());
    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus="all"]', isRoot$1(root));
    const findMarkers = (editor, uid) => {
      const body = SugarElement.fromDom(editor.getBody());
      const descendants$1 = descendants(body, `[${ dataAnnotationId() }="${ uid }"]`);
      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));
    };
    const findAll = (editor, name) => {
      const body = SugarElement.fromDom(editor.getBody());
      const markers = descendants(body, `[${ dataAnnotation() }="${ name }"]`);
      const directory = {};
      each$e(markers, m => {
        if (!isBogusElement(m, body)) {
          const uid = get$9(m, dataAnnotationId());
          const nodesAlready = get$a(directory, uid).getOr([]);
          directory[uid] = nodesAlready.concat([m]);
        }
      });
      return directory;
    };

    const setup$x = (editor, registry) => {
      const changeCallbacks = Cell({});
      const initData = () => ({
        listeners: [],
        previous: value$2()
      });
      const withCallbacks = (name, f) => {
        updateCallbacks(name, data => {
          f(data);
          return data;
        });
      };
      const updateCallbacks = (name, f) => {
        const callbackMap = changeCallbacks.get();
        const data = get$a(callbackMap, name).getOrThunk(initData);
        const outputData = f(data);
        callbackMap[name] = outputData;
        changeCallbacks.set(callbackMap);
      };
      const fireCallbacks = (name, uid, elements) => {
        withCallbacks(name, data => {
          each$e(data.listeners, f => f(true, name, {
            uid,
            nodes: map$3(elements, elem => elem.dom)
          }));
        });
      };
      const fireNoAnnotation = name => {
        withCallbacks(name, data => {
          each$e(data.listeners, f => f(false, name));
        });
      };
      const toggleActiveAttr = (uid, state) => {
        each$e(findMarkers(editor, uid), elem => {
          if (state) {
            set$3(elem, dataAnnotationActive(), 'true');
          } else {
            remove$a(elem, dataAnnotationActive());
          }
        });
      };
      const onNodeChange = last$1(() => {
        const annotations = sort(registry.getNames());
        each$e(annotations, name => {
          updateCallbacks(name, data => {
            const prev = data.previous.get();
            identify(editor, Optional.some(name)).fold(() => {
              prev.each(uid => {
                fireNoAnnotation(name);
                data.previous.clear();
                toggleActiveAttr(uid, false);
              });
            }, ({uid, name, elements}) => {
              if (!is$2(prev, uid)) {
                prev.each(uid => toggleActiveAttr(uid, false));
                fireCallbacks(name, uid, elements);
                data.previous.set(uid);
                toggleActiveAttr(uid, true);
              }
            });
            return {
              previous: data.previous,
              listeners: data.listeners
            };
          });
        });
      }, 30);
      editor.on('remove', () => {
        onNodeChange.cancel();
      });
      editor.on('NodeChange', () => {
        onNodeChange.throttle();
      });
      const addListener = (name, f) => {
        updateCallbacks(name, data => ({
          previous: data.previous,
          listeners: data.listeners.concat([f])
        }));
      };
      return { addListener };
    };

    const setup$w = (editor, registry) => {
      const dataAnnotation$1 = dataAnnotation();
      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);
      const removeDirectAnnotation = node => {
        var _a, _b;
        node.attr(dataAnnotationId(), null);
        node.attr(dataAnnotation(), null);
        node.attr(dataAnnotationActive(), null);
        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);
        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);
        each$e(customAttrNames, name => node.attr(name, null));
        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];
        const newClassList = difference(classList, [annotation()].concat(customClasses));
        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);
        node.attr(dataAnnotationClasses(), null);
        node.attr(dataAnnotationAttributes(), null);
      };
      editor.serializer.addTempAttr(dataAnnotationActive());
      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {
        for (const node of nodes) {
          identifyParserNode(node).each(settings => {
            if (settings.persistent === false) {
              if (node.name === 'span') {
                node.unwrap();
              } else {
                removeDirectAnnotation(node);
              }
            }
          });
        }
      });
    };

    const create$c = () => {
      const annotations = {};
      const register = (name, settings) => {
        annotations[name] = {
          name,
          settings
        };
      };
      const lookup = name => get$a(annotations, name).map(a => a.settings);
      const getNames = () => keys(annotations);
      return {
        register,
        lookup,
        getNames
      };
    };

    let unique = 0;
    const generate$1 = prefix => {
      const date = new Date();
      const time = date.getTime();
      const random = Math.floor(Math.random() * 1000000000);
      unique++;
      return prefix + '_' + random + unique + String(time);
    };

    const add = (element, classes) => {
      each$e(classes, x => {
        add$2(element, x);
      });
    };
    const remove$4 = (element, classes) => {
      each$e(classes, x => {
        remove$7(element, x);
      });
    };

    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    const shallow$1 = original => clone$2(original, false);
    const deep$1 = original => clone$2(original, true);
    const shallowAs = (original, tag) => {
      const nu = SugarElement.fromTag(tag);
      const attributes = clone$4(original);
      setAll$1(nu, attributes);
      return nu;
    };
    const mutate = (original, tag) => {
      const nu = shallowAs(original, tag);
      after$4(original, nu);
      const children = children$1(original);
      append(nu, children);
      remove$5(original);
      return nu;
    };

    const TextWalker = (startNode, rootNode, isBoundary = never) => {
      const walker = new DomTreeWalker(startNode, rootNode);
      const walk = direction => {
        let next;
        do {
          next = walker[direction]();
        } while (next && !isText$a(next) && !isBoundary(next));
        return Optional.from(next).filter(isText$a);
      };
      return {
        current: () => Optional.from(walker.current()).filter(isText$a),
        next: () => walk('next'),
        prev: () => walk('prev'),
        prev2: () => walk('prev2')
      };
    };

    const TextSeeker = (dom, isBoundary) => {
      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
      const walk = (node, offset, walker, process) => {
        if (isText$a(node)) {
          const newOffset = process(node, offset, node.data);
          if (newOffset !== -1) {
            return Optional.some({
              container: node,
              offset: newOffset
            });
          }
        }
        return walker().bind(next => walk(next.container, next.offset, walker, process));
      };
      const backwards = (node, offset, process, root) => {
        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
        return walk(node, offset, () => walker.prev().map(prev => ({
          container: prev,
          offset: prev.length
        })), process).getOrNull();
      };
      const forwards = (node, offset, process, root) => {
        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);
        return walk(node, offset, () => walker.next().map(next => ({
          container: next,
          offset: 0
        })), process).getOrNull();
      };
      return {
        backwards,
        forwards
      };
    };

    const round$2 = Math.round;
    const clone$1 = rect => {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      return {
        left: round$2(rect.left),
        top: round$2(rect.top),
        bottom: round$2(rect.bottom),
        right: round$2(rect.right),
        width: round$2(rect.width),
        height: round$2(rect.height)
      };
    };
    const collapse = (rect, toStart) => {
      rect = clone$1(rect);
      if (toStart) {
        rect.right = rect.left;
      } else {
        rect.left = rect.left + rect.width;
        rect.right = rect.left;
      }
      rect.width = 0;
      return rect;
    };
    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    const isAbove$1 = (rect1, rect2) => {
      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
      if (rect1.bottom - halfHeight < rect2.top) {
        return true;
      }
      if (rect1.top > rect2.bottom) {
        return false;
      }
      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    const isBelow$1 = (rect1, rect2) => {
      if (rect1.top > rect2.bottom) {
        return true;
      }
      if (rect1.bottom < rect2.top) {
        return false;
      }
      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    const boundingClientRectFromRects = rects => {
      return foldl(rects, (acc, rect) => {
        return acc.fold(() => Optional.some(rect), prevRect => {
          const left = Math.min(rect.left, prevRect.left);
          const top = Math.min(rect.top, prevRect.top);
          const right = Math.max(rect.right, prevRect.right);
          const bottom = Math.max(rect.bottom, prevRect.bottom);
          return Optional.some({
            top,
            right,
            bottom,
            left,
            width: right - left,
            height: bottom - top
          });
        });
      }, Optional.none());
    };
    const distanceToRectEdgeFromXY = (rect, x, y) => {
      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    };
    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));

    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);

    const getSelectedNode = range => {
      const startContainer = range.startContainer, startOffset = range.startOffset;
      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
        return startContainer.childNodes[startOffset];
      }
      return null;
    };
    const getNode$1 = (container, offset) => {
      if (isElement$6(container) && container.hasChildNodes()) {
        const childNodes = container.childNodes;
        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);
        return childNodes[safeOffset];
      } else {
        return container;
      }
    };
    const getNodeUnsafe = (container, offset) => {
      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {
        return undefined;
      } else {
        return getNode$1(container, offset);
      }
    };

    const extendingChars = new RegExp('[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a' + '\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0' + '\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c' + '\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3' + '\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc' + '\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57' + '\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56' + '\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44' + '\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9' + '\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97' + '\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074' + '\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5' + '\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18' + '\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34' + '\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9' + '\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9' + '\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1' + '\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1' + '\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc' + '\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1' + '\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]');
    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);

    const or = (...args) => {
      return x => {
        for (let i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }
        return false;
      };
    };
    const and = (...args) => {
      return x => {
        for (let i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }
        return true;
      };
    };

    const isElement$4 = isElement$6;
    const isCaretCandidate$2 = isCaretCandidate$3;
    const isBlock$1 = matchStyleValues('display', 'block table');
    const isFloated = matchStyleValues('float', 'left right');
    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));
    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));
    const isText$7 = isText$a;
    const isBr$3 = isBr$6;
    const nodeIndex$1 = DOMUtils.nodeIndex;
    const resolveIndex$1 = getNodeUnsafe;
    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();
    const isWhiteSpace$1 = chr => isString(chr) && /[\r\n\t ]/.test(chr);
    const isRange = rng => !!rng.setStart && !!rng.setEnd;
    const isHiddenWhiteSpaceRange = range => {
      const container = range.startContainer;
      const offset = range.startOffset;
      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {
        const text = container.data;
        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {
          return true;
        }
      }
      return false;
    };
    const getBrClientRect = brNode => {
      const doc = brNode.ownerDocument;
      const rng = createRange$1(doc);
      const nbsp$1 = doc.createTextNode(nbsp);
      const parentNode = brNode.parentNode;
      parentNode.insertBefore(nbsp$1, brNode);
      rng.setStart(nbsp$1, 0);
      rng.setEnd(nbsp$1, 1);
      const clientRect = clone$1(rng.getBoundingClientRect());
      parentNode.removeChild(nbsp$1);
      return clientRect;
    };
    const getBoundingClientRectWebKitText = rng => {
      const sc = rng.startContainer;
      const ec = rng.endContainer;
      const so = rng.startOffset;
      const eo = rng.endOffset;
      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {
        const newRng = rng.cloneRange();
        newRng.setEndAfter(ec);
        return getBoundingClientRect$1(newRng);
      } else {
        return null;
      }
    };
    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
    const getBoundingClientRect$1 = item => {
      var _a;
      let clientRect;
      const clientRects = item.getClientRects();
      if (clientRects.length > 0) {
        clientRect = clone$1(clientRects[0]);
      } else {
        clientRect = clone$1(item.getBoundingClientRect());
      }
      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
        return getBrClientRect(item);
      }
      if (isZeroRect(clientRect) && isRange(item)) {
        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
      }
      return clientRect;
    };
    const collapseAndInflateWidth = (clientRect, toStart) => {
      const newClientRect = collapse(clientRect, toStart);
      newClientRect.width = 1;
      newClientRect.right = newClientRect.left + 1;
      return newClientRect;
    };
    const getCaretPositionClientRects = caretPosition => {
      const clientRects = [];
      const addUniqueAndValidRect = clientRect => {
        if (clientRect.height === 0) {
          return;
        }
        if (clientRects.length > 0) {
          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }
        clientRects.push(clientRect);
      };
      const addCharacterOffset = (container, offset) => {
        const range = createRange$1(container.ownerDocument);
        if (offset < container.data.length) {
          if (isExtendingChar(container.data[offset])) {
            return;
          }
          if (isExtendingChar(container.data[offset - 1])) {
            range.setStart(container, offset);
            range.setEnd(container, offset + 1);
            if (!isHiddenWhiteSpaceRange(range)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
              return;
            }
          }
        }
        if (offset > 0) {
          range.setStart(container, offset - 1);
          range.setEnd(container, offset);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));
          }
        }
        if (offset < container.data.length) {
          range.setStart(container, offset);
          range.setEnd(container, offset + 1);
          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));
          }
        }
      };
      const container = caretPosition.container();
      const offset = caretPosition.offset();
      if (isText$7(container)) {
        addCharacterOffset(container, offset);
        return clientRects;
      }
      if (isElement$4(container)) {
        if (caretPosition.isAtEnd()) {
          const node = resolveIndex$1(container, offset);
          if (isText$7(node)) {
            addCharacterOffset(node, node.data.length);
          }
          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
          }
        } else {
          const node = resolveIndex$1(container, offset);
          if (isText$7(node)) {
            addCharacterOffset(node, 0);
          }
          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
            return clientRects;
          }
          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
            }
          }
          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
          }
        }
      }
      return clientRects;
    };
    const CaretPosition = (container, offset, clientRects) => {
      const isAtStart = () => {
        if (isText$7(container)) {
          return offset === 0;
        }
        return offset === 0;
      };
      const isAtEnd = () => {
        if (isText$7(container)) {
          return offset >= container.data.length;
        }
        return offset >= container.childNodes.length;
      };
      const toRange = () => {
        const range = createRange$1(container.ownerDocument);
        range.setStart(container, offset);
        range.setEnd(container, offset);
        return range;
      };
      const getClientRects = () => {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
        }
        return clientRects;
      };
      const isVisible = () => getClientRects().length > 0;
      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);
      return {
        container: constant(container),
        offset: constant(offset),
        toRange,
        getClientRects,
        isVisible,
        isAtStart,
        isAtEnd,
        isEqual,
        getNode
      };
    };
    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);
    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);
    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));
    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);
    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;
    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;
    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;
    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);

    const trimEmptyTextNode$1 = (dom, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    const insertNode = (dom, rng, node) => {
      rng.insertNode(node);
      trimEmptyTextNode$1(dom, node.previousSibling);
      trimEmptyTextNode$1(dom, node.nextSibling);
    };
    const insertFragment = (dom, rng, frag) => {
      const firstChild = Optional.from(frag.firstChild);
      const lastChild = Optional.from(frag.lastChild);
      rng.insertNode(frag);
      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));
      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));
    };
    const rangeInsertNode = (dom, rng, node) => {
      if (isDocumentFragment(node)) {
        insertFragment(dom, rng, node);
      } else {
        insertNode(dom, rng, node);
      }
    };

    const isText$6 = isText$a;
    const isBogus = isBogus$2;
    const nodeIndex = DOMUtils.nodeIndex;
    const normalizedParent = node => {
      const parentNode = node.parentNode;
      if (isBogus(parentNode)) {
        return normalizedParent(parentNode);
      }
      return parentNode;
    };
    const getChildNodes = node => {
      if (!node) {
        return [];
      }
      return reduce(node.childNodes, (result, node) => {
        if (isBogus(node) && node.nodeName !== 'BR') {
          result = result.concat(getChildNodes(node));
        } else {
          result.push(node);
        }
        return result;
      }, []);
    };
    const normalizedTextOffset = (node, offset) => {
      let tempNode = node;
      while (tempNode = tempNode.previousSibling) {
        if (!isText$6(tempNode)) {
          break;
        }
        offset += tempNode.data.length;
      }
      return offset;
    };
    const equal = a => b => a === b;
    const normalizedNodeIndex = node => {
      let nodes, index;
      nodes = getChildNodes(normalizedParent(node));
      index = findIndex$1(nodes, equal(node), node);
      nodes = nodes.slice(0, index + 1);
      const numTextFragments = reduce(nodes, (result, node, i) => {
        if (isText$6(node) && isText$6(nodes[i - 1])) {
          result++;
        }
        return result;
      }, 0);
      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
      index = findIndex$1(nodes, equal(node), node);
      return index - numTextFragments;
    };
    const createPathItem = node => {
      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();
      return name + '[' + normalizedNodeIndex(node) + ']';
    };
    const parentsUntil$1 = (root, node, predicate) => {
      const parents = [];
      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
        if (predicate && predicate(tempNode)) {
          break;
        }
        parents.push(tempNode);
      }
      return parents;
    };
    const create$b = (root, caretPosition) => {
      let path = [];
      let container = caretPosition.container();
      let offset = caretPosition.offset();
      let outputOffset;
      if (isText$6(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } else {
        const childNodes = container.childNodes;
        if (offset >= childNodes.length) {
          outputOffset = 'after';
          offset = childNodes.length - 1;
        } else {
          outputOffset = 'before';
        }
        container = childNodes[offset];
      }
      path.push(createPathItem(container));
      let parents = parentsUntil$1(root, container);
      parents = filter$3(parents, not(isBogus$2));
      path = path.concat(map$1(parents, node => {
        return createPathItem(node);
      }));
      return path.reverse().join('/') + ',' + outputOffset;
    };
    const resolvePathItem = (node, name, index) => {
      let nodes = getChildNodes(node);
      nodes = filter$3(nodes, (node, index) => {
        return !isText$6(node) || !isText$6(nodes[index - 1]);
      });
      nodes = filter$3(nodes, matchNodeNames([name]));
      return nodes[index];
    };
    const findTextPosition = (container, offset) => {
      let node = container;
      let targetOffset = 0;
      while (isText$6(node)) {
        const dataLen = node.data.length;
        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          break;
        }
        if (!isText$6(node.nextSibling)) {
          container = node;
          offset = dataLen;
          break;
        }
        targetOffset += dataLen;
        node = node.nextSibling;
      }
      if (isText$6(container) && offset > container.data.length) {
        offset = container.data.length;
      }
      return CaretPosition(container, offset);
    };
    const resolve$1 = (root, path) => {
      if (!path) {
        return null;
      }
      const parts = path.split(',');
      const paths = parts[0].split('/');
      const offset = parts.length > 1 ? parts[1] : 'before';
      const container = reduce(paths, (result, value) => {
        const match = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
        if (!match) {
          return null;
        }
        if (match[1] === 'text()') {
          match[1] = '#text';
        }
        return resolvePathItem(result, match[1], parseInt(match[2], 10));
      }, root);
      if (!container) {
        return null;
      }
      if (!isText$6(container) && container.parentNode) {
        let nodeOffset;
        if (offset === 'after') {
          nodeOffset = nodeIndex(container) + 1;
        } else {
          nodeOffset = nodeIndex(container);
        }
        return CaretPosition(container.parentNode, nodeOffset);
      }
      return findTextPosition(container, parseInt(offset, 10));
    };

    const isContentEditableFalse$9 = isContentEditableFalse$b;
    const getNormalizedTextOffset$1 = (trim, container, offset) => {
      let trimmedOffset = trim(container.data.slice(0, offset)).length;
      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {
        trimmedOffset += trim(node.data).length;
      }
      return trimmedOffset;
    };
    const getPoint = (dom, trim, normalized, rng, start) => {
      const container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      const point = [];
      const root = dom.getRoot();
      if (isText$a(container)) {
        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);
      } else {
        let after = 0;
        const childNodes = container.childNodes;
        if (offset >= childNodes.length && childNodes.length) {
          after = 1;
          offset = Math.max(0, childNodes.length - 1);
        }
        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
      }
      for (let node = container; node && node !== root; node = node.parentNode) {
        point.push(dom.nodeIndex(node, normalized));
      }
      return point;
    };
    const getLocation = (trim, selection, normalized, rng) => {
      const dom = selection.dom;
      const start = getPoint(dom, trim, normalized, rng, true);
      const forward = selection.isForward();
      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
      if (!selection.isCollapsed()) {
        const end = getPoint(dom, trim, normalized, rng, false);
        return {
          start,
          end,
          forward,
          ...fakeCaret
        };
      } else {
        return {
          start,
          forward,
          ...fakeCaret
        };
      }
    };
    const findIndex = (dom, name, element) => {
      let count = 0;
      Tools.each(dom.select(name), node => {
        if (node.getAttribute('data-mce-bogus') === 'all') {
          return;
        } else if (node === element) {
          return false;
        } else {
          count++;
          return;
        }
      });
      return count;
    };
    const moveEndPoint$1 = (rng, start) => {
      let container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      if (isElement$6(container) && container.nodeName === 'TR') {
        const childNodes = container.childNodes;
        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
        if (container) {
          offset = start ? 0 : container.childNodes.length;
          if (start) {
            rng.setStart(container, offset);
          } else {
            rng.setEnd(container, offset);
          }
        }
      }
    };
    const normalizeTableCellSelection = rng => {
      moveEndPoint$1(rng, true);
      moveEndPoint$1(rng, false);
      return rng;
    };
    const findSibling = (node, offset) => {
      if (isElement$6(node)) {
        node = getNode$1(node, offset);
        if (isContentEditableFalse$9(node)) {
          return node;
        }
      }
      if (isCaretContainer$2(node)) {
        if (isText$a(node) && isCaretContainerBlock$1(node)) {
          node = node.parentNode;
        }
        let sibling = node.previousSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
        sibling = node.nextSibling;
        if (isContentEditableFalse$9(sibling)) {
          return sibling;
        }
      }
      return undefined;
    };
    const findAdjacentContentEditableFalseElm = rng => {
      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    const getOffsetBookmark = (trim, normalized, selection) => {
      const element = selection.getNode();
      const rng = selection.getRng();
      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {
        const name = element.nodeName;
        return {
          name,
          index: findIndex(selection.dom, name, element)
        };
      }
      const sibling = findAdjacentContentEditableFalseElm(rng);
      if (sibling) {
        const name = sibling.tagName;
        return {
          name,
          index: findIndex(selection.dom, name, sibling)
        };
      }
      return getLocation(trim, selection, normalized, rng);
    };
    const getCaretBookmark = selection => {
      const rng = selection.getRng();
      return {
        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
        forward: selection.isForward()
      };
    };
    const getRangeBookmark = selection => {
      return {
        rng: selection.getRng(),
        forward: selection.isForward()
      };
    };
    const createBookmarkSpan = (dom, id, filled) => {
      const args = {
        'data-mce-type': 'bookmark',
        id,
        'style': 'overflow:hidden;line-height:0px'
      };
      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
    };
    const getPersistentBookmark = (selection, filled) => {
      const dom = selection.dom;
      let rng = selection.getRng();
      const id = dom.uniqueId();
      const collapsed = selection.isCollapsed();
      const element = selection.getNode();
      const name = element.nodeName;
      const forward = selection.isForward();
      if (name === 'IMG') {
        return {
          name,
          index: findIndex(dom, name, element)
        };
      }
      const rng2 = normalizeTableCellSelection(rng.cloneRange());
      if (!collapsed) {
        rng2.collapse(false);
        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
        rangeInsertNode(dom, rng2, endBookmarkNode);
      }
      rng = normalizeTableCellSelection(rng);
      rng.collapse(true);
      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
      rangeInsertNode(dom, rng, startBookmarkNode);
      selection.moveToBookmark({
        id,
        keep: true,
        forward
      });
      return {
        id,
        forward
      };
    };
    const getBookmark$2 = (selection, type, normalized = false) => {
      if (type === 2) {
        return getOffsetBookmark(trim$1, normalized, selection);
      } else if (type === 3) {
        return getCaretBookmark(selection);
      } else if (type) {
        return getRangeBookmark(selection);
      } else {
        return getPersistentBookmark(selection, false);
      }
    };
    const getUndoBookmark = curry(getOffsetBookmark, identity, true);

    const value$1 = value => {
      const applyHelper = fn => fn(value);
      const constHelper = constant(value);
      const outputHelper = () => output;
      const output = {
        tag: true,
        inner: value,
        fold: (_onError, onValue) => onValue(value),
        isValue: always,
        isError: never,
        map: mapper => Result.value(mapper(value)),
        mapError: outputHelper,
        bind: applyHelper,
        exists: applyHelper,
        forall: applyHelper,
        getOr: constHelper,
        or: outputHelper,
        getOrThunk: constHelper,
        orThunk: outputHelper,
        getOrDie: constHelper,
        each: fn => {
          fn(value);
        },
        toOptional: () => Optional.some(value)
      };
      return output;
    };
    const error = error => {
      const outputHelper = () => output;
      const output = {
        tag: false,
        inner: error,
        fold: (onError, _onValue) => onError(error),
        isValue: never,
        isError: always,
        map: outputHelper,
        mapError: mapper => Result.error(mapper(error)),
        bind: outputHelper,
        exists: never,
        forall: always,
        getOr: identity,
        or: identity,
        getOrThunk: apply$1,
        orThunk: apply$1,
        getOrDie: die(String(error)),
        each: noop,
        toOptional: Optional.none
      };
      return output;
    };
    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);
    const Result = {
      value: value$1,
      error,
      fromOption
    };

    const generate = cases => {
      if (!isArray$1(cases)) {
        throw new Error('cases must be an array');
      }
      if (cases.length === 0) {
        throw new Error('there must be at least one case');
      }
      const constructors = [];
      const adt = {};
      each$e(cases, (acase, count) => {
        const keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error('one and only one name per case');
        }
        const key = keys$1[0];
        const value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error('duplicate key detected:' + key);
        } else if (key === 'cata') {
          throw new Error('cannot have a case named cata (sorry)');
        } else if (!isArray$1(value)) {
          throw new Error('case arguments must be an array');
        }
        constructors.push(key);
        adt[key] = (...args) => {
          const argLength = args.length;
          if (argLength !== value.length) {
            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
          }
          const match = branches => {
            const branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
            }
            const allReqd = forall(constructors, reqKey => {
              return contains$2(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: (...foldArgs) => {
              if (foldArgs.length !== cases.length) {
                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);
              }
              const target = foldArgs[count];
              return target.apply(null, args);
            },
            match,
            log: label => {
              console.log(label, {
                constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    const Adt = { generate };

    Adt.generate([
      {
        bothErrors: [
          'error1',
          'error2'
        ]
      },
      {
        firstError: [
          'error1',
          'value2'
        ]
      },
      {
        secondError: [
          'value1',
          'error2'
        ]
      },
      {
        bothValues: [
          'value1',
          'value2'
        ]
      }
    ]);
    const partition$1 = results => {
      const errors = [];
      const values = [];
      each$e(results, result => {
        result.fold(err => {
          errors.push(err);
        }, value => {
          values.push(value);
        });
      });
      return {
        errors,
        values
      };
    };

    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';
    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';
    const normalizePattern = pattern => {
      const err = message => Result.error({
        message,
        pattern
      });
      const formatOrCmd = (name, onFormat, onCommand) => {
        if (pattern.format !== undefined) {
          let formats;
          if (isArray$1(pattern.format)) {
            if (!forall(pattern.format, isString)) {
              return err(name + ' pattern has non-string items in the `format` array');
            }
            formats = pattern.format;
          } else if (isString(pattern.format)) {
            formats = [pattern.format];
          } else {
            return err(name + ' pattern has non-string `format` parameter');
          }
          return Result.value(onFormat(formats));
        } else if (pattern.cmd !== undefined) {
          if (!isString(pattern.cmd)) {
            return err(name + ' pattern has non-string `cmd` parameter');
          }
          return Result.value(onCommand(pattern.cmd, pattern.value));
        } else {
          return err(name + ' pattern is missing both `format` and `cmd` parameters');
        }
      };
      if (!isObject(pattern)) {
        return err('Raw pattern is not an object');
      }
      if (!isString(pattern.start)) {
        return err('Raw pattern is missing `start` parameter');
      }
      if (pattern.end !== undefined) {
        if (!isString(pattern.end)) {
          return err('Inline pattern has non-string `end` parameter');
        }
        if (pattern.start.length === 0 && pattern.end.length === 0) {
          return err('Inline pattern has empty `start` and `end` parameters');
        }
        let start = pattern.start;
        let end = pattern.end;
        if (end.length === 0) {
          end = start;
          start = '';
        }
        return formatOrCmd('Inline', format => ({
          type: 'inline-format',
          start,
          end,
          format
        }), (cmd, value) => ({
          type: 'inline-command',
          start,
          end,
          cmd,
          value
        }));
      } else if (pattern.replacement !== undefined) {
        if (!isString(pattern.replacement)) {
          return err('Replacement pattern has non-string `replacement` parameter');
        }
        if (pattern.start.length === 0) {
          return err('Replacement pattern has empty `start` parameter');
        }
        return Result.value({
          type: 'inline-command',
          start: '',
          end: pattern.start,
          cmd: 'mceInsertContent',
          value: pattern.replacement
        });
      } else {
        if (pattern.start.length === 0) {
          return err('Block pattern has empty `start` parameter');
        }
        return formatOrCmd('Block', formats => ({
          type: 'block-format',
          start: pattern.start,
          format: formats[0]
        }), (command, commandValue) => ({
          type: 'block-command',
          start: pattern.start,
          cmd: command,
          value: commandValue
        }));
      }
    };
    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);
    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);
    const createPatternSet = (patterns, dynamicPatternsLookup) => ({
      inlinePatterns: getInlinePatterns(patterns),
      blockPatterns: getBlockPatterns(patterns),
      dynamicPatternsLookup
    });
    const fromRawPatterns = patterns => {
      const normalized = partition$1(map$3(patterns, normalizePattern));
      each$e(normalized.errors, err => console.error(err.message, err.pattern));
      return normalized.values;
    };
    const fromRawPatternsLookup = lookupFn => {
      return ctx => {
        const rawPatterns = lookupFn(ctx);
        return fromRawPatterns(rawPatterns);
      };
    };

    const deviceDetection$1 = detect$2().deviceType;
    const isTouch = deviceDetection$1.isTouch();
    const DOM$a = DOMUtils.DOM;
    const getHash = value => {
      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');
      return foldl(items, (output, item) => {
        const arr = item.split('=');
        const key = arr[0];
        const val = arr.length > 1 ? arr[1] : key;
        output[trim$3(key)] = trim$3(val);
        return output;
      }, {});
    };
    const isRegExp = x => is$4(x, RegExp);
    const option = name => editor => editor.options.get(name);
    const stringOrObjectProcessor = value => isString(value) || isObject(value);
    const bodyOptionProcessor = (editor, defaultValue = '') => value => {
      const valid = isString(value);
      if (valid) {
        if (value.indexOf('=') !== -1) {
          const bodyObj = getHash(value);
          return {
            value: get$a(bodyObj, editor.id).getOr(defaultValue),
            valid
          };
        } else {
          return {
            value,
            valid
          };
        }
      } else {
        return {
          valid: false,
          message: 'Must be a string.'
        };
      }
    };
    const register$7 = editor => {
      const registerOption = editor.options.register;
      registerOption('id', {
        processor: 'string',
        default: editor.id
      });
      registerOption('selector', { processor: 'string' });
      registerOption('target', { processor: 'object' });
      registerOption('suffix', { processor: 'string' });
      registerOption('cache_suffix', { processor: 'string' });
      registerOption('base_url', { processor: 'string' });
      registerOption('referrer_policy', {
        processor: 'string',
        default: ''
      });
      registerOption('language_load', {
        processor: 'boolean',
        default: true
      });
      registerOption('inline', {
        processor: 'boolean',
        default: false
      });
      registerOption('iframe_attrs', {
        processor: 'object',
        default: {}
      });
      registerOption('doctype', {
        processor: 'string',
        default: '<!DOCTYPE html>'
      });
      registerOption('document_base_url', {
        processor: 'string',
        default: editor.documentBaseUrl
      });
      registerOption('body_id', {
        processor: bodyOptionProcessor(editor, 'tinymce'),
        default: 'tinymce'
      });
      registerOption('body_class', {
        processor: bodyOptionProcessor(editor),
        default: ''
      });
      registerOption('content_security_policy', {
        processor: 'string',
        default: ''
      });
      registerOption('br_in_pre', {
        processor: 'boolean',
        default: true
      });
      registerOption('forced_root_block', {
        processor: value => {
          const valid = isString(value) && isNotEmpty(value);
          if (valid) {
            return {
              value,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be a non-empty string.'
            };
          }
        },
        default: 'p'
      });
      registerOption('forced_root_block_attrs', {
        processor: 'object',
        default: {}
      });
      registerOption('newline_behavior', {
        processor: value => {
          const valid = contains$2([
            'block',
            'linebreak',
            'invert',
            'default'
          ], value);
          return valid ? {
            value,
            valid
          } : {
            valid: false,
            message: 'Must be one of: block, linebreak, invert or default.'
          };
        },
        default: 'default'
      });
      registerOption('br_newline_selector', {
        processor: 'string',
        default: '.mce-toc h2,figcaption,caption'
      });
      registerOption('no_newline_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('keep_styles', {
        processor: 'boolean',
        default: true
      });
      registerOption('end_container_on_empty_block', {
        processor: value => {
          if (isBoolean(value)) {
            return {
              valid: true,
              value
            };
          } else if (isString(value)) {
            return {
              valid: true,
              value
            };
          } else {
            return {
              valid: false,
              message: 'Must be boolean or a string'
            };
          }
        },
        default: 'blockquote'
      });
      registerOption('font_size_style_values', {
        processor: 'string',
        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'
      });
      registerOption('font_size_legacy_values', {
        processor: 'string',
        default: 'xx-small,small,medium,large,x-large,xx-large,300%'
      });
      registerOption('font_size_classes', {
        processor: 'string',
        default: ''
      });
      registerOption('automatic_uploads', {
        processor: 'boolean',
        default: true
      });
      registerOption('images_reuse_filename', {
        processor: 'boolean',
        default: false
      });
      registerOption('images_replace_blob_uris', {
        processor: 'boolean',
        default: true
      });
      registerOption('icons', {
        processor: 'string',
        default: ''
      });
      registerOption('icons_url', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_url', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_base_path', {
        processor: 'string',
        default: ''
      });
      registerOption('images_upload_credentials', {
        processor: 'boolean',
        default: false
      });
      registerOption('images_upload_handler', { processor: 'function' });
      registerOption('language', {
        processor: 'string',
        default: 'en'
      });
      registerOption('language_url', {
        processor: 'string',
        default: ''
      });
      registerOption('entity_encoding', {
        processor: 'string',
        default: 'named'
      });
      registerOption('indent', {
        processor: 'boolean',
        default: true
      });
      registerOption('indent_before', {
        processor: 'string',
        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
      });
      registerOption('indent_after', {
        processor: 'string',
        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'
      });
      registerOption('indent_use_margin', {
        processor: 'boolean',
        default: false
      });
      registerOption('indentation', {
        processor: 'string',
        default: '40px'
      });
      registerOption('content_css', {
        processor: value => {
          const valid = value === false || isString(value) || isArrayOf(value, isString);
          if (valid) {
            if (isString(value)) {
              return {
                value: map$3(value.split(','), trim$3),
                valid
              };
            } else if (isArray$1(value)) {
              return {
                value,
                valid
              };
            } else if (value === false) {
              return {
                value: [],
                valid
              };
            } else {
              return {
                value,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: 'Must be false, a string or an array of strings.'
            };
          }
        },
        default: isInline(editor) ? [] : ['default']
      });
      registerOption('content_style', { processor: 'string' });
      registerOption('content_css_cors', {
        processor: 'boolean',
        default: false
      });
      registerOption('font_css', {
        processor: value => {
          const valid = isString(value) || isArrayOf(value, isString);
          if (valid) {
            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$3);
            return {
              value: newValue,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be a string or an array of strings.'
            };
          }
        },
        default: []
      });
      registerOption('inline_boundaries', {
        processor: 'boolean',
        default: true
      });
      registerOption('inline_boundaries_selector', {
        processor: 'string',
        default: 'a[href],code,span.mce-annotation'
      });
      registerOption('object_resizing', {
        processor: value => {
          const valid = isBoolean(value) || isString(value);
          if (valid) {
            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
              return {
                value: '',
                valid
              };
            } else {
              return {
                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: 'Must be boolean or a string'
            };
          }
        },
        default: !isTouch
      });
      registerOption('resize_img_proportional', {
        processor: 'boolean',
        default: true
      });
      registerOption('event_root', { processor: 'object' });
      registerOption('service_message', { processor: 'string' });
      registerOption('theme', {
        processor: value => value === false || isString(value) || isFunction(value),
        default: 'silver'
      });
      registerOption('theme_url', { processor: 'string' });
      registerOption('formats', { processor: 'object' });
      registerOption('format_empty_lines', {
        processor: 'boolean',
        default: false
      });
      registerOption('format_noneditable_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('preview_styles', {
        processor: value => {
          const valid = value === false || isString(value);
          if (valid) {
            return {
              value: value === false ? '' : value,
              valid
            };
          } else {
            return {
              valid: false,
              message: 'Must be false or a string'
            };
          }
        },
        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'
      });
      registerOption('custom_ui_selector', {
        processor: 'string',
        default: ''
      });
      registerOption('hidden_input', {
        processor: 'boolean',
        default: true
      });
      registerOption('submit_patch', {
        processor: 'boolean',
        default: true
      });
      registerOption('encoding', { processor: 'string' });
      registerOption('add_form_submit_trigger', {
        processor: 'boolean',
        default: true
      });
      registerOption('add_unload_trigger', {
        processor: 'boolean',
        default: true
      });
      registerOption('custom_undo_redo_levels', {
        processor: 'number',
        default: 0
      });
      registerOption('disable_nodechange', {
        processor: 'boolean',
        default: false
      });
      registerOption('readonly', {
        processor: 'boolean',
        default: false
      });
      registerOption('editable_root', {
        processor: 'boolean',
        default: true
      });
      registerOption('plugins', {
        processor: 'string[]',
        default: []
      });
      registerOption('external_plugins', { processor: 'object' });
      registerOption('forced_plugins', { processor: 'string[]' });
      registerOption('model', {
        processor: 'string',
        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'
      });
      registerOption('model_url', { processor: 'string' });
      registerOption('block_unsupported_drop', {
        processor: 'boolean',
        default: true
      });
      registerOption('visual', {
        processor: 'boolean',
        default: true
      });
      registerOption('visual_table_class', {
        processor: 'string',
        default: 'mce-item-table'
      });
      registerOption('visual_anchor_class', {
        processor: 'string',
        default: 'mce-item-anchor'
      });
      registerOption('iframe_aria_text', {
        processor: 'string',
        default: 'Rich Text Area. Press ALT-0 for help.'
      });
      registerOption('setup', { processor: 'function' });
      registerOption('init_instance_callback', { processor: 'function' });
      registerOption('url_converter', {
        processor: 'function',
        default: editor.convertURL
      });
      registerOption('url_converter_scope', {
        processor: 'object',
        default: editor
      });
      registerOption('urlconverter_callback', { processor: 'function' });
      registerOption('allow_conditional_comments', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_html_data_urls', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_svg_data_urls', { processor: 'boolean' });
      registerOption('allow_html_in_named_anchor', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_script_urls', {
        processor: 'boolean',
        default: false
      });
      registerOption('allow_unsafe_link_target', {
        processor: 'boolean',
        default: false
      });
      registerOption('convert_fonts_to_spans', {
        processor: 'boolean',
        default: true,
        deprecated: true
      });
      registerOption('fix_list_elements', {
        processor: 'boolean',
        default: false
      });
      registerOption('preserve_cdata', {
        processor: 'boolean',
        default: false
      });
      registerOption('remove_trailing_brs', {
        processor: 'boolean',
        default: true
      });
      registerOption('pad_empty_with_br', {
        processor: 'boolean',
        default: false
      });
      registerOption('inline_styles', {
        processor: 'boolean',
        default: true,
        deprecated: true
      });
      registerOption('element_format', {
        processor: 'string',
        default: 'html'
      });
      registerOption('entities', { processor: 'string' });
      registerOption('schema', {
        processor: 'string',
        default: 'html5'
      });
      registerOption('convert_urls', {
        processor: 'boolean',
        default: true
      });
      registerOption('relative_urls', {
        processor: 'boolean',
        default: true
      });
      registerOption('remove_script_host', {
        processor: 'boolean',
        default: true
      });
      registerOption('custom_elements', { processor: 'string' });
      registerOption('extended_valid_elements', { processor: 'string' });
      registerOption('invalid_elements', { processor: 'string' });
      registerOption('invalid_styles', { processor: stringOrObjectProcessor });
      registerOption('valid_children', { processor: 'string' });
      registerOption('valid_classes', { processor: stringOrObjectProcessor });
      registerOption('valid_elements', { processor: 'string' });
      registerOption('valid_styles', { processor: stringOrObjectProcessor });
      registerOption('verify_html', {
        processor: 'boolean',
        default: true
      });
      registerOption('auto_focus', { processor: value => isString(value) || value === true });
      registerOption('browser_spellcheck', {
        processor: 'boolean',
        default: false
      });
      registerOption('protect', { processor: 'array' });
      registerOption('images_file_types', {
        processor: 'string',
        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'
      });
      registerOption('deprecation_warnings', {
        processor: 'boolean',
        default: true
      });
      registerOption('a11y_advanced_options', {
        processor: 'boolean',
        default: false
      });
      registerOption('api_key', { processor: 'string' });
      registerOption('paste_block_drop', {
        processor: 'boolean',
        default: false
      });
      registerOption('paste_data_images', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_preprocess', { processor: 'function' });
      registerOption('paste_postprocess', { processor: 'function' });
      registerOption('paste_webkit_styles', {
        processor: 'string',
        default: 'none'
      });
      registerOption('paste_remove_styles_if_webkit', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_merge_formats', {
        processor: 'boolean',
        default: true
      });
      registerOption('smart_paste', {
        processor: 'boolean',
        default: true
      });
      registerOption('paste_as_text', {
        processor: 'boolean',
        default: false
      });
      registerOption('paste_tab_spaces', {
        processor: 'number',
        default: 4
      });
      registerOption('text_patterns', {
        processor: value => {
          if (isArrayOf(value, isObject) || value === false) {
            const patterns = value === false ? [] : value;
            return {
              value: fromRawPatterns(patterns),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be an array of objects or false.'
            };
          }
        },
        default: [
          {
            start: '*',
            end: '*',
            format: 'italic'
          },
          {
            start: '**',
            end: '**',
            format: 'bold'
          },
          {
            start: '#',
            format: 'h1'
          },
          {
            start: '##',
            format: 'h2'
          },
          {
            start: '###',
            format: 'h3'
          },
          {
            start: '####',
            format: 'h4'
          },
          {
            start: '#####',
            format: 'h5'
          },
          {
            start: '######',
            format: 'h6'
          },
          {
            start: '1. ',
            cmd: 'InsertOrderedList'
          },
          {
            start: '* ',
            cmd: 'InsertUnorderedList'
          },
          {
            start: '- ',
            cmd: 'InsertUnorderedList'
          }
        ]
      });
      registerOption('text_patterns_lookup', {
        processor: value => {
          if (isFunction(value)) {
            return {
              value: fromRawPatternsLookup(value),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be a single function'
            };
          }
        },
        default: _ctx => []
      });
      registerOption('noneditable_class', {
        processor: 'string',
        default: 'mceNonEditable'
      });
      registerOption('editable_class', {
        processor: 'string',
        default: 'mceEditable'
      });
      registerOption('noneditable_regexp', {
        processor: value => {
          if (isArrayOf(value, isRegExp)) {
            return {
              value,
              valid: true
            };
          } else if (isRegExp(value)) {
            return {
              value: [value],
              valid: true
            };
          } else {
            return {
              valid: false,
              message: 'Must be a RegExp or an array of RegExp.'
            };
          }
        },
        default: []
      });
      registerOption('table_tab_navigation', {
        processor: 'boolean',
        default: true
      });
      registerOption('highlight_on_focus', {
        processor: 'boolean',
        default: false
      });
      registerOption('xss_sanitization', {
        processor: 'boolean',
        default: true
      });
      registerOption('details_initial_state', {
        processor: value => {
          const valid = contains$2([
            'inherited',
            'collapsed',
            'expanded'
          ], value);
          return valid ? {
            value,
            valid
          } : {
            valid: false,
            message: 'Must be one of: inherited, collapsed, or expanded.'
          };
        },
        default: 'inherited'
      });
      registerOption('details_serialized_state', {
        processor: value => {
          const valid = contains$2([
            'inherited',
            'collapsed',
            'expanded'
          ], value);
          return valid ? {
            value,
            valid
          } : {
            valid: false,
            message: 'Must be one of: inherited, collapsed, or expanded.'
          };
        },
        default: 'inherited'
      });
      registerOption('init_content_sync', {
        processor: 'boolean',
        default: false
      });
      registerOption('newdocument_content', {
        processor: 'string',
        default: ''
      });
      editor.on('ScriptsLoaded', () => {
        registerOption('directionality', {
          processor: 'string',
          default: I18n.isRtl() ? 'rtl' : undefined
        });
        registerOption('placeholder', {
          processor: 'string',
          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')
        });
      });
    };
    const getIframeAttrs = option('iframe_attrs');
    const getDocType = option('doctype');
    const getDocumentBaseUrl = option('document_base_url');
    const getBodyId = option('body_id');
    const getBodyClass = option('body_class');
    const getContentSecurityPolicy = option('content_security_policy');
    const shouldPutBrInPre$1 = option('br_in_pre');
    const getForcedRootBlock = option('forced_root_block');
    const getForcedRootBlockAttrs = option('forced_root_block_attrs');
    const getNewlineBehavior = option('newline_behavior');
    const getBrNewLineSelector = option('br_newline_selector');
    const getNoNewLineSelector = option('no_newline_selector');
    const shouldKeepStyles = option('keep_styles');
    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');
    const isAutomaticUploadsEnabled = option('automatic_uploads');
    const shouldReuseFileName = option('images_reuse_filename');
    const shouldReplaceBlobUris = option('images_replace_blob_uris');
    const getIconPackName = option('icons');
    const getIconsUrl = option('icons_url');
    const getImageUploadUrl = option('images_upload_url');
    const getImageUploadBasePath = option('images_upload_base_path');
    const getImagesUploadCredentials = option('images_upload_credentials');
    const getImagesUploadHandler = option('images_upload_handler');
    const shouldUseContentCssCors = option('content_css_cors');
    const getReferrerPolicy = option('referrer_policy');
    const getLanguageCode = option('language');
    const getLanguageUrl = option('language_url');
    const shouldIndentUseMargin = option('indent_use_margin');
    const getIndentation = option('indentation');
    const getContentCss = option('content_css');
    const getContentStyle = option('content_style');
    const getFontCss = option('font_css');
    const getDirectionality = option('directionality');
    const getInlineBoundarySelector = option('inline_boundaries_selector');
    const getObjectResizing = option('object_resizing');
    const getResizeImgProportional = option('resize_img_proportional');
    const getPlaceholder = option('placeholder');
    const getEventRoot = option('event_root');
    const getServiceMessage = option('service_message');
    const getTheme = option('theme');
    const getThemeUrl = option('theme_url');
    const getModel = option('model');
    const getModelUrl = option('model_url');
    const isInlineBoundariesEnabled = option('inline_boundaries');
    const getFormats = option('formats');
    const getPreviewStyles = option('preview_styles');
    const canFormatEmptyLines = option('format_empty_lines');
    const getFormatNoneditableSelector = option('format_noneditable_selector');
    const getCustomUiSelector = option('custom_ui_selector');
    const isInline = option('inline');
    const hasHiddenInput = option('hidden_input');
    const shouldPatchSubmit = option('submit_patch');
    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');
    const shouldAddUnloadTrigger = option('add_unload_trigger');
    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');
    const shouldDisableNodeChange = option('disable_nodechange');
    const isReadOnly$1 = option('readonly');
    const hasEditableRoot$1 = option('editable_root');
    const hasContentCssCors = option('content_css_cors');
    const getPlugins = option('plugins');
    const getExternalPlugins$1 = option('external_plugins');
    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');
    const isVisualAidsEnabled = option('visual');
    const getVisualAidsTableClass = option('visual_table_class');
    const getVisualAidsAnchorClass = option('visual_anchor_class');
    const getIframeAriaText = option('iframe_aria_text');
    const getSetupCallback = option('setup');
    const getInitInstanceCallback = option('init_instance_callback');
    const getUrlConverterCallback = option('urlconverter_callback');
    const getAutoFocus = option('auto_focus');
    const shouldBrowserSpellcheck = option('browser_spellcheck');
    const getProtect = option('protect');
    const shouldPasteBlockDrop = option('paste_block_drop');
    const shouldPasteDataImages = option('paste_data_images');
    const getPastePreProcess = option('paste_preprocess');
    const getPastePostProcess = option('paste_postprocess');
    const getNewDocumentContent = option('newdocument_content');
    const getPasteWebkitStyles = option('paste_webkit_styles');
    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');
    const shouldPasteMergeFormats = option('paste_merge_formats');
    const isSmartPasteEnabled = option('smart_paste');
    const isPasteAsTextEnabled = option('paste_as_text');
    const getPasteTabSpaces = option('paste_tab_spaces');
    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');
    const getTextPatterns = option('text_patterns');
    const getTextPatternsLookup = option('text_patterns_lookup');
    const getNonEditableClass = option('noneditable_class');
    const getEditableClass = option('editable_class');
    const getNonEditableRegExps = option('noneditable_regexp');
    const shouldPreserveCData = option('preserve_cdata');
    const shouldHighlightOnFocus = option('highlight_on_focus');
    const shouldSanitizeXss = option('xss_sanitization');
    const shouldUseDocumentWrite = option('init_content_sync');
    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');
    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));
    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));
    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';
    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));
    const hasTableTabNavigation = option('table_tab_navigation');
    const getDetailsInitialState = option('details_initial_state');
    const getDetailsSerializedState = option('details_serialized_state');

    const isElement$3 = isElement$6;
    const isText$5 = isText$a;
    const removeNode$1 = node => {
      const parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };
    const trimCount = text => {
      const trimmedText = trim$1(text);
      return {
        count: text.length - trimmedText.length,
        text: trimmedText
      };
    };
    const deleteZwspChars = caretContainer => {
      let idx;
      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
        caretContainer.deleteData(idx, 1);
      }
    };
    const removeUnchanged = (caretContainer, pos) => {
      remove$3(caretContainer);
      return pos;
    };
    const removeTextAndReposition = (caretContainer, pos) => {
      const before = trimCount(caretContainer.data.substr(0, pos.offset()));
      const after = trimCount(caretContainer.data.substr(pos.offset()));
      const text = before.text + after.text;
      if (text.length > 0) {
        deleteZwspChars(caretContainer);
        return CaretPosition(caretContainer, pos.offset() - before.count);
      } else {
        return pos;
      }
    };
    const removeElementAndReposition = (caretContainer, pos) => {
      const parentNode = pos.container();
      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {
        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove$3(caretContainer);
      return newPosition;
    };
    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    const remove$3 = caretContainerNode => {
      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
        if (hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute('data-mce-caret');
        } else {
          removeNode$1(caretContainerNode);
        }
      }
      if (isText$5(caretContainerNode)) {
        deleteZwspChars(caretContainerNode);
        if (caretContainerNode.data.length === 0) {
          removeNode$1(caretContainerNode);
        }
      }
    };

    const isContentEditableFalse$8 = isContentEditableFalse$b;
    const isMedia$1 = isMedia$2;
    const isTableCell$1 = isTableCell$3;
    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';
    const getAbsoluteClientRect = (root, element, before) => {
      const clientRect = collapse(element.getBoundingClientRect(), before);
      let scrollX;
      let scrollY;
      if (root.tagName === 'BODY') {
        const docElm = root.ownerDocument.documentElement;
        scrollX = root.scrollLeft || docElm.scrollLeft;
        scrollY = root.scrollTop || docElm.scrollTop;
      } else {
        const rootRect = root.getBoundingClientRect();
        scrollX = root.scrollLeft - rootRect.left;
        scrollY = root.scrollTop - rootRect.top;
      }
      clientRect.left += scrollX;
      clientRect.right += scrollX;
      clientRect.top += scrollY;
      clientRect.bottom += scrollY;
      clientRect.width = 1;
      let margin = element.offsetWidth - element.clientWidth;
      if (margin > 0) {
        if (before) {
          margin *= -1;
        }
        clientRect.left += margin;
        clientRect.right += margin;
      }
      return clientRect;
    };
    const trimInlineCaretContainers = root => {
      var _a, _b;
      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
        const node = fakeCaretTargetNodes[i].dom;
        let sibling = node.previousSibling;
        if (endsWithCaretContainer$1(sibling)) {
          const data = sibling.data;
          if (data.length === 1) {
            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);
          } else {
            sibling.deleteData(data.length - 1, 1);
          }
        }
        sibling = node.nextSibling;
        if (startsWithCaretContainer$1(sibling)) {
          const data = sibling.data;
          if (data.length === 1) {
            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);
          } else {
            sibling.deleteData(0, 1);
          }
        }
      }
    };
    const FakeCaret = (editor, root, isBlock, hasFocus) => {
      const lastVisualCaret = value$2();
      let cursorInterval;
      let caretContainerNode;
      const caretBlock = getForcedRootBlock(editor);
      const dom = editor.dom;
      const show = (before, element) => {
        let rng;
        hide();
        if (isTableCell$1(element)) {
          return null;
        }
        if (isBlock(element)) {
          const caretContainer = insertBlock(caretBlock, element, before);
          const clientRect = getAbsoluteClientRect(root, element, before);
          dom.setStyle(caretContainer, 'top', clientRect.top);
          caretContainerNode = caretContainer;
          const caret = dom.create('div', {
            'class': 'mce-visual-caret',
            'data-mce-bogus': 'all'
          });
          dom.setStyles(caret, { ...clientRect });
          dom.add(root, caret);
          lastVisualCaret.set({
            caret,
            element,
            before
          });
          if (before) {
            dom.addClass(caret, 'mce-visual-caret-before');
          }
          startBlink();
          rng = element.ownerDocument.createRange();
          rng.setStart(caretContainer, 0);
          rng.setEnd(caretContainer, 0);
        } else {
          caretContainerNode = insertInline$1(element, before);
          rng = element.ownerDocument.createRange();
          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }
          return rng;
        }
        return rng;
      };
      const hide = () => {
        trimInlineCaretContainers(root);
        if (caretContainerNode) {
          remove$3(caretContainerNode);
          caretContainerNode = null;
        }
        lastVisualCaret.on(caretState => {
          dom.remove(caretState.caret);
          lastVisualCaret.clear();
        });
        if (cursorInterval) {
          clearInterval(cursorInterval);
          cursorInterval = undefined;
        }
      };
      const startBlink = () => {
        cursorInterval = setInterval(() => {
          lastVisualCaret.on(caretState => {
            if (hasFocus()) {
              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');
            } else {
              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');
            }
          });
        }, 500);
      };
      const reposition = () => {
        lastVisualCaret.on(caretState => {
          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
          dom.setStyles(caretState.caret, { ...clientRect });
        });
      };
      const destroy = () => clearInterval(cursorInterval);
      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';
      return {
        show,
        hide,
        getCss,
        reposition,
        destroy
      };
    };
    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);
    const isFakeCaretTarget = node => {
      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();
      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$3);
    };

    const isContentEditableTrue$1 = isContentEditableTrue$3;
    const isContentEditableFalse$7 = isContentEditableFalse$b;
    const isMedia = isMedia$2;
    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');
    const isCaretContainer = isCaretContainer$2;
    const isCaretContainerBlock = isCaretContainerBlock$1;
    const isElement$2 = isElement$6;
    const isText$4 = isText$a;
    const isCaretCandidate$1 = isCaretCandidate$3;
    const isForwards = direction => direction > 0;
    const isBackwards = direction => direction < 0;
    const skipCaretContainers = (walk, shallow) => {
      let node;
      while (node = walk(shallow)) {
        if (!isCaretContainerBlock(node)) {
          return node;
        }
      }
      return null;
    };
    const findNode = (node, direction, predicateFn, rootNode, shallow) => {
      const walker = new DomTreeWalker(node, rootNode);
      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
      let tempNode;
      if (isBackwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.prev.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      if (isForwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.next.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const getEditingHost = (node, rootNode) => {
      const isCETrue = node => isContentEditableTrue$1(node.dom);
      const isRoot = node => node.dom === rootNode;
      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);
    };
    const getParentBlock$3 = (node, rootNode) => {
      while (node && node !== rootNode) {
        if (isBlockLike(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
      if (!caretPosition) {
        return Optional.none();
      }
      const container = caretPosition.container();
      const offset = caretPosition.offset();
      if (!isElement$2(container)) {
        return Optional.none();
      }
      return Optional.from(container.childNodes[offset + relativeOffset]);
    };
    const beforeAfter = (before, node) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const range = doc.createRange();
      if (before) {
        range.setStartBefore(node);
        range.setEndBefore(node);
      } else {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }
      return range;
    };
    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
    const lean = (left, root, node) => {
      const siblingName = left ? 'previousSibling' : 'nextSibling';
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        let sibling = tempNode[siblingName];
        if (sibling && isCaretContainer(sibling)) {
          sibling = sibling[siblingName];
        }
        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {
          if (isNodesInSameBlock(root, sibling, tempNode)) {
            return sibling;
          }
          break;
        }
        if (isCaretCandidate$1(sibling)) {
          break;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };
    const before$2 = curry(beforeAfter, true);
    const after$2 = curry(beforeAfter, false);
    const normalizeRange = (direction, root, range) => {
      let node;
      const leanLeft = curry(lean, true, root);
      const leanRight = curry(lean, false, root);
      const container = range.startContainer;
      const offset = range.startOffset;
      if (isCaretContainerBlock$1(container)) {
        const block = isText$4(container) ? container.parentNode : container;
        const location = block.getAttribute('data-mce-caret');
        if (location === 'before') {
          node = block.nextSibling;
          if (isFakeCaretTarget(node)) {
            return before$2(node);
          }
        }
        if (location === 'after') {
          node = block.previousSibling;
          if (isFakeCaretTarget(node)) {
            return after$2(node);
          }
        }
      }
      if (!range.collapsed) {
        return range;
      }
      if (isText$a(container)) {
        if (isCaretContainer(container)) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before$2(node);
            }
          }
          return range;
        }
        if (startsWithCaretContainer$1(container) && offset <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          return range;
        }
        if (offset === container.data.length) {
          node = leanRight(container);
          if (node) {
            return before$2(node);
          }
          return range;
        }
        if (offset === 0) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
          return range;
        }
      }
      return range;
    };
    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);
    const getNormalizedRangeEndPoint = (direction, root, range) => {
      const normalizedRange = normalizeRange(direction, root, range);
      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
    };
    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);
    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    const getVisualCaretPosition = (walkFn, caretPosition) => {
      let pos = caretPosition;
      while (pos = walkFn(pos)) {
        if (pos.isVisible()) {
          return pos;
        }
      }
      return pos;
    };
    const isMoveInsideSameBlock = (from, to) => {
      const inSameBlock = isInSameBlock(from, to);
      if (!inSameBlock && isBr$6(from.getNode())) {
        return true;
      }
      return inSameBlock;
    };

    var HDirection;
    (function (HDirection) {
      HDirection[HDirection['Backwards'] = -1] = 'Backwards';
      HDirection[HDirection['Forwards'] = 1] = 'Forwards';
    }(HDirection || (HDirection = {})));
    const isContentEditableFalse$6 = isContentEditableFalse$b;
    const isText$3 = isText$a;
    const isElement$1 = isElement$6;
    const isBr$2 = isBr$6;
    const isCaretCandidate = isCaretCandidate$3;
    const isAtomic = isAtomic$1;
    const isEditableCaretCandidate = isEditableCaretCandidate$1;
    const getParents$3 = (node, root) => {
      const parents = [];
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        parents.push(tempNode);
        tempNode = tempNode.parentNode;
      }
      return parents;
    };
    const nodeAtIndex = (container, offset) => {
      if (container.hasChildNodes() && offset < container.childNodes.length) {
        return container.childNodes[offset];
      }
      return null;
    };
    const getCaretCandidatePosition = (direction, node) => {
      if (isForwards(direction)) {
        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
          return CaretPosition.before(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, 0);
        }
      }
      if (isBackwards(direction)) {
        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
          return CaretPosition.after(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, node.data.length);
        }
      }
      if (isBackwards(direction)) {
        if (isBr$2(node)) {
          return CaretPosition.before(node);
        }
        return CaretPosition.after(node);
      }
      return CaretPosition.before(node);
    };
    const moveForwardFromBr = (root, nextNode) => {
      const nextSibling = nextNode.nextSibling;
      if (nextSibling && isCaretCandidate(nextSibling)) {
        if (isText$3(nextSibling)) {
          return CaretPosition(nextSibling, 0);
        } else {
          return CaretPosition.before(nextSibling);
        }
      } else {
        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);
      }
    };
    const findCaretPosition$1 = (direction, startPos, root) => {
      let node;
      let nextNode;
      let innerNode;
      let caretPosition;
      if (!isElement$1(root) || !startPos) {
        return null;
      }
      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
        caretPosition = CaretPosition.after(root.lastChild);
        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {
          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
        }
      } else {
        caretPosition = startPos;
      }
      const container = caretPosition.container();
      let offset = caretPosition.offset();
      if (isText$3(container)) {
        if (isBackwards(direction) && offset > 0) {
          return CaretPosition(container, --offset);
        }
        if (isForwards(direction) && offset < container.length) {
          return CaretPosition(container, ++offset);
        }
        node = container;
      } else {
        if (isBackwards(direction) && offset > 0) {
          nextNode = nodeAtIndex(container, offset - 1);
          if (isCaretCandidate(nextNode)) {
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }
                return CaretPosition.after(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }
            return CaretPosition.before(nextNode);
          }
        }
        if (isForwards(direction) && offset < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          if (isCaretCandidate(nextNode)) {
            if (isBr$2(nextNode)) {
              return moveForwardFromBr(root, nextNode);
            }
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }
                return CaretPosition.before(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, 0);
            }
            return CaretPosition.after(nextNode);
          }
        }
        node = nextNode ? nextNode : caretPosition.getNode();
      }
      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {
        node = findNode(node, direction, always, root, true);
        if (isEditableCaretCandidate(node, root)) {
          return getCaretCandidatePosition(direction, node);
        }
      }
      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }
        return caretPosition;
      }
      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }
      return null;
    };
    const CaretWalker = root => ({
      next: caretPosition => {
        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);
      },
      prev: caretPosition => {
        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);
      }
    });

    const walkToPositionIn = (forward, root, start) => {
      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);
      return fromPosition(forward, root, position);
    };
    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    const isBeforeOrStart = position => {
      if (CaretPosition.isTextPosition(position)) {
        return position.offset() === 0;
      } else {
        return isCaretCandidate$3(position.getNode());
      }
    };
    const isAfterOrEnd = position => {
      if (CaretPosition.isTextPosition(position)) {
        const container = position.container();
        return position.offset() === container.data.length;
      } else {
        return isCaretCandidate$3(position.getNode(true));
      }
    };
    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);
    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
    const shouldSkipPosition = (forward, from, to) => {
      if (forward) {
        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
      } else {
        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
      }
    };
    const fromPosition = (forward, root, pos) => {
      const walker = CaretWalker(root);
      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {
      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
        return fromPosition(forward, root, to);
      } else {
        return Optional.some(to);
      }
    });
    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
    const positionIn = (forward, element) => {
      const startNode = forward ? element.firstChild : element.lastChild;
      if (isText$a(startNode)) {
        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
      } else if (startNode) {
        if (isCaretCandidate$3(startNode)) {
          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
        } else {
          return walkToPositionIn(forward, element, startNode);
        }
      } else {
        return Optional.none();
      }
    };
    const nextPosition = curry(fromPosition, true);
    const prevPosition = curry(fromPosition, false);
    const firstPositionIn = curry(positionIn, true);
    const lastPositionIn = curry(positionIn, false);

    const CARET_ID = '_mce_caret';
    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;
    const getParentCaretContainer = (body, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== body) {
        if (isCaretNode(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };

    const isStringPathBookmark = bookmark => isString(bookmark.start);
    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');
    const isIdBookmark = bookmark => has$2(bookmark, 'id');
    const isIndexBookmark = bookmark => has$2(bookmark, 'name');
    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);

    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
    const addBogus = (dom, node) => {
      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {
        node.innerHTML = '<br data-mce-bogus="1" />';
      }
      return node;
    };
    const resolveCaretPositionBookmark = (dom, bookmark) => {
      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));
      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));
      return lift2(startPos, endPos, (start, end) => {
        const range = dom.createRng();
        range.setStart(start.container(), start.offset());
        range.setEnd(end.container(), end.offset());
        return {
          range,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const insertZwsp = (node, rng) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      node.appendChild(textNode);
      rng.setStart(textNode, 0);
      rng.setEnd(textNode, 0);
    };
    const isEmpty$1 = node => !node.hasChildNodes();
    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      return true;
    });
    const padEmptyCaretContainer = (root, node, rng) => {
      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
        insertZwsp(node, rng);
        return true;
      } else {
        return false;
      }
    };
    const setEndPoint = (dom, start, bookmark, rng) => {
      const point = bookmark[start ? 'start' : 'end'];
      const root = dom.getRoot();
      if (point) {
        let node = root;
        let offset = point[0];
        for (let i = point.length - 1; node && i >= 1; i--) {
          const children = node.childNodes;
          if (padEmptyCaretContainer(root, node, rng)) {
            return true;
          }
          if (point[i] > children.length - 1) {
            if (padEmptyCaretContainer(root, node, rng)) {
              return true;
            }
            return tryFindRangePosition(node, rng);
          }
          node = children[point[i]];
        }
        if (isText$a(node)) {
          offset = Math.min(point[0], node.data.length);
        }
        if (isElement$6(node)) {
          offset = Math.min(point[0], node.childNodes.length);
        }
        if (start) {
          rng.setStart(node, offset);
        } else {
          rng.setEnd(node, offset);
        }
      }
      return true;
    };
    const isValidTextNode = node => isText$a(node) && node.data.length > 0;
    const restoreEndPoint = (dom, suffix, bookmark) => {
      const marker = dom.get(bookmark.id + '_' + suffix);
      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
      const keep = bookmark.keep;
      if (marker && markerParent) {
        let container;
        let offset;
        if (suffix === 'start') {
          if (!keep) {
            container = markerParent;
            offset = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset = 1;
            } else if (isValidTextNode(marker.nextSibling)) {
              container = marker.nextSibling;
              offset = 0;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset = dom.nodeIndex(marker) + 1;
            }
          }
        } else {
          if (!keep) {
            container = markerParent;
            offset = dom.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset = 1;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset = dom.nodeIndex(marker);
            }
          }
        }
        if (!keep) {
          const prev = marker.previousSibling;
          const next = marker.nextSibling;
          Tools.each(Tools.grep(marker.childNodes), node => {
            if (isText$a(node)) {
              node.data = node.data.replace(/\uFEFF/g, '');
            }
          });
          let otherMarker;
          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {
            dom.remove(otherMarker, true);
          }
          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {
            const idx = prev.data.length;
            prev.appendData(next.data);
            dom.remove(next);
            container = prev;
            offset = idx;
          }
        }
        return Optional.some(CaretPosition(container, offset));
      } else {
        return Optional.none();
      }
    };
    const resolvePaths = (dom, bookmark) => {
      const range = dom.createRng();
      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {
        return Optional.some({
          range,
          forward: isForwardBookmark(bookmark)
        });
      } else {
        return Optional.none();
      }
    };
    const resolveId = (dom, bookmark) => {
      const startPos = restoreEndPoint(dom, 'start', bookmark);
      const endPos = restoreEndPoint(dom, 'end', bookmark);
      return lift2(startPos, endPos.or(startPos), (spos, epos) => {
        const range = dom.createRng();
        range.setStart(addBogus(dom, spos.container()), spos.offset());
        range.setEnd(addBogus(dom, epos.container()), epos.offset());
        return {
          range,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {
      const range = dom.createRng();
      range.selectNode(elm);
      return {
        range,
        forward: true
      };
    });
    const resolve = (selection, bookmark) => {
      const dom = selection.dom;
      if (bookmark) {
        if (isPathBookmark(bookmark)) {
          return resolvePaths(dom, bookmark);
        } else if (isStringPathBookmark(bookmark)) {
          return resolveCaretPositionBookmark(dom, bookmark);
        } else if (isIdBookmark(bookmark)) {
          return resolveId(dom, bookmark);
        } else if (isIndexBookmark(bookmark)) {
          return resolveIndex(dom, bookmark);
        } else if (isRangeBookmark(bookmark)) {
          return Optional.some({
            range: bookmark.rng,
            forward: isForwardBookmark(bookmark)
          });
        }
      }
      return Optional.none();
    };

    const getBookmark$1 = (selection, type, normalized) => {
      return getBookmark$2(selection, type, normalized);
    };
    const moveToBookmark = (selection, bookmark) => {
      resolve(selection, bookmark).each(({range, forward}) => {
        selection.setRng(range, forward);
      });
    };
    const isBookmarkNode$1 = node => {
      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    const is = expected => actual => expected === actual;
    const isNbsp = is(nbsp);
    const isWhiteSpace = chr => chr !== '' && ' \f\n\r\t\x0B'.indexOf(chr) !== -1;
    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);

    const hexColour = value => ({ value: normalizeHex(value) });
    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();
    const toHex = component => {
      const hex = component.toString(16);
      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();
    };
    const fromRgba = rgbaColour => {
      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
      return hexColour(value);
    };

    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
      red,
      green,
      blue,
      alpha
    });
    const fromStringValues = (red, green, blue, alpha) => {
      const r = parseInt(red, 10);
      const g = parseInt(green, 10);
      const b = parseInt(blue, 10);
      const a = parseFloat(alpha);
      return rgbaColour(r, g, b, a);
    };
    const fromString = rgbaString => {
      if (rgbaString === 'transparent') {
        return Optional.some(rgbaColour(0, 0, 0, 0));
      }
      const rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
      }
      const rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Optional.none();
    };

    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);

    const getRanges$1 = selection => {
      const ranges = [];
      if (selection) {
        for (let i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
      }
      return ranges;
    };
    const getSelectedNodes = ranges => {
      return bind$3(ranges, range => {
        const node = getSelectedNode(range);
        return node ? [SugarElement.fromDom(node)] : [];
      });
    };
    const hasMultipleRanges = selection => {
      return getRanges$1(selection).length > 1;
    };

    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);
    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');
    const getCellsFromElementOrRanges = (ranges, element) => {
      const selectedCells = getCellsFromElement(element);
      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);

    const getStartNode = rng => {
      const sc = rng.startContainer, so = rng.startOffset;
      if (isText$a(sc)) {
        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
      } else {
        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
      }
    };
    const getEndNode = rng => {
      const ec = rng.endContainer, eo = rng.endOffset;
      if (isText$a(ec)) {
        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
      } else {
        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
      }
    };
    const getFirstChildren = node => {
      return firstChild(node).fold(constant([node]), child => {
        return [node].concat(getFirstChildren(child));
      });
    };
    const getLastChildren = node => {
      return lastChild(node).fold(constant([node]), child => {
        if (name(child) === 'br') {
          return prevSibling(child).map(sibling => {
            return [node].concat(getLastChildren(sibling));
          }).getOr([]);
        } else {
          return [node].concat(getLastChildren(child));
        }
      });
    };
    const hasAllContentsSelected = (elm, rng) => {
      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
        const start = find$2(getFirstChildren(elm), curry(eq, startNode));
        const end = find$2(getLastChildren(elm), curry(eq, endNode));
        return start.isSome() && end.isSome();
      }).getOr(false);
    };
    const moveEndPoint = (dom, rng, node, start) => {
      const root = node;
      const walker = new DomTreeWalker(node, root);
      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([
        'td',
        'th',
        'table'
      ], name.toLowerCase()));
      let currentNode = node;
      do {
        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {
          if (start) {
            rng.setStart(currentNode, 0);
          } else {
            rng.setEnd(currentNode, currentNode.data.length);
          }
          return;
        }
        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
          if (start) {
            rng.setStartBefore(currentNode);
          } else {
            if (currentNode.nodeName === 'BR') {
              rng.setEndBefore(currentNode);
            } else {
              rng.setEndAfter(currentNode);
            }
          }
          return;
        }
      } while (currentNode = start ? walker.next() : walker.prev());
      if (root.nodeName === 'BODY') {
        if (start) {
          rng.setStart(root, 0);
        } else {
          rng.setEnd(root, root.childNodes.length);
        }
      }
    };
    const hasAnyRanges = editor => {
      const sel = editor.selection.getSel();
      return isNonNullable(sel) && sel.rangeCount > 0;
    };
    const runOnRanges = (editor, executor) => {
      const fakeSelectionNodes = getCellsFromEditor(editor);
      if (fakeSelectionNodes.length > 0) {
        each$e(fakeSelectionNodes, elem => {
          const node = elem.dom;
          const fakeNodeRng = editor.dom.createRng();
          fakeNodeRng.setStartBefore(node);
          fakeNodeRng.setEndAfter(node);
          executor(fakeNodeRng, true);
        });
      } else {
        executor(editor.selection.getRng(), false);
      }
    };
    const preserve = (selection, fillBookmark, executor) => {
      const bookmark = getPersistentBookmark(selection, fillBookmark);
      executor(bookmark);
      selection.moveToBookmark(bookmark);
    };

    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const isElementDirectlySelected = (dom, node) => {
      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');
        const value = parseInt(selectedAttr, 10);
        return !isNaN(value) && value > 0;
      } else {
        return false;
      }
    };
    const isEditable$2 = elm => elm.isContentEditable === true;
    const preserveSelection = (editor, action, shouldMoveStart) => {
      const {selection, dom} = editor;
      const selectedNodeBeforeAction = selection.getNode();
      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);
      preserve(selection, true, () => {
        action();
      });
      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);
      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
        editor.selection.select(selectedNodeBeforeAction);
      } else if (shouldMoveStart(selection.getStart())) {
        moveStartToNearestText(dom, selection);
      }
    };
    const moveStartToNearestText = (dom, selection) => {
      var _a, _b;
      const rng = selection.getRng();
      const {startContainer, startOffset} = rng;
      const selectedNode = selection.getNode();
      if (isElementDirectlySelected(dom, selectedNode)) {
        return;
      }
      if (isElement$6(startContainer)) {
        const nodes = startContainer.childNodes;
        const root = dom.getRoot();
        let walker;
        if (startOffset < nodes.length) {
          const startNode = nodes[startOffset];
          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);
        } else {
          const startNode = nodes[nodes.length - 1];
          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);
          walker.next(true);
        }
        for (let node = walker.current(); node; node = walker.next()) {
          if (dom.getContentEditable(node) === 'false') {
            return;
          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {
            rng.setStart(node, 0);
            selection.setRng(rng);
            return;
          }
        }
      }
    };
    const getNonWhiteSpaceSibling = (node, next, inc) => {
      if (node) {
        const nextName = next ? 'nextSibling' : 'previousSibling';
        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
            return node;
          }
        }
      }
      return undefined;
    };
    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
    const isValid = (ed, parent, child) => {
      return ed.schema.isValidChild(parent, child);
    };
    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
      if (isNonNullable(node) && isText$a(node)) {
        const data = allowSpaces ? node.data.replace(/ /g, '\xA0') : node.data;
        return isWhitespaceText(data);
      } else {
        return false;
      }
    };
    const isEmptyTextNode$1 = node => {
      return isNonNullable(node) && isText$a(node) && node.length === 0;
    };
    const isWrapNoneditableTarget = (editor, node) => {
      const baseDataSelector = '[data-mce-cef-wrappable]';
      const formatNoneditableSelector = getFormatNoneditableSelector(editor);
      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;
      return is$1(SugarElement.fromDom(node), selector);
    };
    const isWrappableNoneditable = (editor, node) => {
      const dom = editor.dom;
      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable="true"]', node).length === 0;
    };
    const replaceVars = (value, vars) => {
      if (isFunction(value)) {
        return value(vars);
      } else if (isNonNullable(vars)) {
        value = value.replace(/%(\w+)/g, (str, name) => {
          return vars[name] || str;
        });
      }
      return value;
    };
    const isEq$5 = (str1, str2) => {
      str1 = str1 || '';
      str2 = str2 || '';
      str1 = '' + (str1.nodeName || str1);
      str2 = '' + (str2.nodeName || str2);
      return str1.toLowerCase() === str2.toLowerCase();
    };
    const normalizeStyleValue = (value, name) => {
      if (isNullable(value)) {
        return null;
      } else {
        let strValue = String(value);
        if (name === 'color' || name === 'backgroundColor') {
          strValue = rgbaToHexString(strValue);
        }
        if (name === 'fontWeight' && value === 700) {
          strValue = 'bold';
        }
        if (name === 'fontFamily') {
          strValue = strValue.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
        }
        return strValue;
      }
    };
    const getStyle = (dom, node, name) => {
      const style = dom.getStyle(node, name);
      return normalizeStyleValue(style, name);
    };
    const getTextDecoration = (dom, node) => {
      let decoration;
      dom.getParent(node, n => {
        if (isElement$6(n)) {
          decoration = dom.getStyle(n, 'text-decoration');
          return !!decoration && decoration !== 'none';
        } else {
          return false;
        }
      });
      return decoration;
    };
    const getParents$2 = (dom, node, selector) => {
      return dom.getParents(node, selector, dom.getRoot());
    };
    const isFormatPredicate = (editor, formatName, predicate) => {
      const formats = editor.formatter.get(formatName);
      return isNonNullable(formats) && exists(formats, predicate);
    };
    const isVariableFormatName = (editor, formatName) => {
      const hasVariableValues = format => {
        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';
        return exists([
          'styles',
          'attributes'
        ], key => get$a(format, key).exists(field => {
          const fieldValues = isArray$1(field) ? field : values(field);
          return exists(fieldValues, isVariableValue);
        }));
      };
      return isFormatPredicate(editor, formatName, hasVariableValues);
    };
    const areSimilarFormats = (editor, formatName, otherFormatName) => {
      const validKeys = [
        'inline',
        'block',
        'selector',
        'attributes',
        'styles',
        'classes'
      ];
      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));
      return isFormatPredicate(editor, formatName, fmt1 => {
        const filteredFmt1 = filterObj(fmt1);
        return isFormatPredicate(editor, otherFormatName, fmt2 => {
          const filteredFmt2 = filterObj(fmt2);
          return equal$1(filteredFmt1, filteredFmt2);
        });
      });
    };
    const isBlockFormat = format => hasNonNullableKey(format, 'block');
    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;
    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;
    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');
    const isInlineFormat = format => hasNonNullableKey(format, 'inline');
    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);
    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);

    const isBookmarkNode = isBookmarkNode$1;
    const getParents$1 = getParents$2;
    const isWhiteSpaceNode = isWhiteSpaceNode$1;
    const isTextBlock = isTextBlock$1;
    const isBogusBr = node => {
      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;
    };
    const findParentContentEditable = (dom, node) => {
      let parent = node;
      while (parent) {
        if (isElement$6(parent) && dom.getContentEditable(parent)) {
          return dom.getContentEditable(parent) === 'false' ? parent : node;
        }
        parent = parent.parentNode;
      }
      return node;
    };
    const walkText = (start, node, offset, predicate) => {
      const str = node.data;
      if (start) {
        for (let i = offset; i > 0; i--) {
          if (predicate(str.charAt(i - 1))) {
            return i;
          }
        }
      } else {
        for (let i = offset; i < str.length; i++) {
          if (predicate(str.charAt(i))) {
            return i;
          }
        }
      }
      return -1;
    };
    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));
    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);
    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {
      let lastTextNode;
      const rootNode = dom.getParent(container, dom.isBlock) || body;
      const walk = (container, offset, pred) => {
        const textSeeker = TextSeeker(dom);
        const walker = start ? textSeeker.backwards : textSeeker.forwards;
        return Optional.from(walker(container, offset, (text, textOffset) => {
          if (isBookmarkNode(text.parentNode)) {
            return -1;
          } else {
            lastTextNode = text;
            return pred(start, text, textOffset);
          }
        }, rootNode));
      };
      const spaceResult = walk(container, offset, findSpace);
      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({
        container: lastTextNode,
        offset: start ? 0 : lastTextNode.length
      }) : Optional.none());
    };
    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {
      const sibling = container[siblingName];
      if (isText$a(container) && isEmpty$3(container.data) && sibling) {
        container = sibling;
      }
      const parents = getParents$1(dom, container);
      for (let i = 0; i < parents.length; i++) {
        for (let y = 0; y < formatList.length; y++) {
          const curFormat = formatList[y];
          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
            continue;
          }
          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {
            return parents[i];
          }
        }
      }
      return container;
    };
    const findBlockEndPoint = (dom, formatList, container, siblingName) => {
      var _a;
      let node = container;
      const root = dom.getRoot();
      const format = formatList[0];
      if (isBlockFormat(format)) {
        node = format.wrapper ? null : dom.getParent(container, format.block, root);
      }
      if (!node) {
        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH')) !== null && _a !== void 0 ? _a : root;
        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);
      }
      if (node && isBlockFormat(format) && format.wrapper) {
        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;
      }
      if (!node) {
        node = container;
        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {
          node = node[siblingName];
          if (isEq$5(node, 'br')) {
            break;
          }
        }
      }
      return node || container;
    };
    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {
      const parent = container.parentNode;
      if (isNonNullable(container[siblingName])) {
        return false;
      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {
        return true;
      } else {
        return isAtBlockBoundary$1(dom, root, parent, siblingName);
      }
    };
    const findParentContainer = (dom, formatList, container, offset, start) => {
      let parent = container;
      const siblingName = start ? 'previousSibling' : 'nextSibling';
      const root = dom.getRoot();
      if (isText$a(container) && !isWhiteSpaceNode(container)) {
        if (start ? offset > 0 : offset < container.data.length) {
          return container;
        }
      }
      while (parent) {
        if (!formatList[0].block_expand && dom.isBlock(parent)) {
          return parent;
        }
        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);
          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {
            return parent;
          }
        }
        if (parent === root || parent.parentNode === root) {
          container = parent;
          break;
        }
        parent = parent.parentNode;
      }
      return container;
    };
    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {
      let {startContainer, startOffset, endContainer, endOffset} = rng;
      const format = formatList[0];
      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
        startContainer = getNode$1(startContainer, startOffset);
        if (isText$a(startContainer)) {
          startOffset = 0;
        }
      }
      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
        if (isText$a(endContainer)) {
          endOffset = endContainer.data.length;
        }
      }
      startContainer = findParentContentEditable(dom, startContainer);
      endContainer = findParentContentEditable(dom, endContainer);
      if (isSelfOrParentBookmark(startContainer)) {
        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
        if (rng.collapsed) {
          startContainer = startContainer.previousSibling || startContainer;
        } else {
          startContainer = startContainer.nextSibling || startContainer;
        }
        if (isText$a(startContainer)) {
          startOffset = rng.collapsed ? startContainer.length : 0;
        }
      }
      if (isSelfOrParentBookmark(endContainer)) {
        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
        if (rng.collapsed) {
          endContainer = endContainer.nextSibling || endContainer;
        } else {
          endContainer = endContainer.previousSibling || endContainer;
        }
        if (isText$a(endContainer)) {
          endOffset = rng.collapsed ? 0 : endContainer.length;
        }
      }
      if (rng.collapsed) {
        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);
        startPoint.each(({container, offset}) => {
          startContainer = container;
          startOffset = offset;
        });
        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);
        endPoint.each(({container, offset}) => {
          endContainer = container;
          endOffset = offset;
        });
      }
      if (isInlineFormat(format) || format.block_expand) {
        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {
          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
        }
        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {
          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
        }
      }
      if (shouldExpandToSelector(format)) {
        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');
        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');
      }
      if (isBlockFormat(format) || isSelectorFormat(format)) {
        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');
        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');
        if (isBlockFormat(format)) {
          if (!dom.isBlock(startContainer)) {
            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);
          }
          if (!dom.isBlock(endContainer)) {
            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);
          }
        }
      }
      if (isElement$6(startContainer) && startContainer.parentNode) {
        startOffset = dom.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (isElement$6(endContainer) && endContainer.parentNode) {
        endOffset = dom.nodeIndex(endContainer) + 1;
        endContainer = endContainer.parentNode;
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };

    const walk$3 = (dom, rng, callback) => {
      var _a;
      const startOffset = rng.startOffset;
      const startContainer = getNode$1(rng.startContainer, startOffset);
      const endOffset = rng.endOffset;
      const endContainer = getNode$1(rng.endContainer, endOffset - 1);
      const exclude = nodes => {
        const firstNode = nodes[0];
        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
          nodes.splice(0, 1);
        }
        const lastNode = nodes[nodes.length - 1];
        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {
          nodes.splice(nodes.length - 1, 1);
        }
        return nodes;
      };
      const collectSiblings = (node, name, endNode) => {
        const siblings = [];
        for (; node && node !== endNode; node = node[name]) {
          siblings.push(node);
        }
        return siblings;
      };
      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);
      const walkBoundary = (startNode, endNode, next) => {
        const siblingName = next ? 'nextSibling' : 'previousSibling';
        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {
          parent = node.parentNode;
          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
          if (siblings.length) {
            if (!next) {
              siblings.reverse();
            }
            callback(exclude(siblings));
          }
        }
      };
      if (startContainer === endContainer) {
        return callback(exclude([startContainer]));
      }
      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();
      if (dom.isChildOf(startContainer, endContainer)) {
        return walkBoundary(startContainer, ancestor, true);
      }
      if (dom.isChildOf(endContainer, startContainer)) {
        return walkBoundary(endContainer, ancestor);
      }
      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;
      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;
      walkBoundary(startContainer, startPoint, true);
      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
      if (siblings.length) {
        callback(exclude(siblings));
      }
      walkBoundary(endContainer, endPoint);
    };

    const validBlocks = [
      'pre[class*=language-][contenteditable="false"]',
      'figure.image',
      'div[data-ephox-embed-iri]',
      'div.tiny-pageembed',
      'div.mce-toc',
      'div[data-mce-toc]'
    ];
    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;
    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {
      if (nodeName === 'br' || isZeroWidth(elem)) {
        return 'valid';
      } else if (isAnnotation(elem)) {
        return 'existing';
      } else if (isCaretNode(elem.dom)) {
        return 'caret';
      } else if (exists(validBlocks, selector => is$1(elem, selector))) {
        return 'valid-block';
      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
        return 'invalid-child';
      } else {
        return 'valid';
      }
    });

    const applyWordGrab = (editor, rng) => {
      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);
      rng.setStart(r.startContainer, r.startOffset);
      rng.setEnd(r.endContainer, r.endOffset);
      editor.selection.setRng(rng);
    };
    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {
      const {uid = masterUId, ...otherData} = data;
      add$2(elem, annotation());
      set$3(elem, `${ dataAnnotationId() }`, uid);
      set$3(elem, `${ dataAnnotation() }`, annotationName);
      const {attributes = {}, classes = []} = decorate(uid, otherData);
      setAll$1(elem, attributes);
      add(elem, classes);
      if (directAnnotation) {
        if (classes.length > 0) {
          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));
        }
        const attributeNames = keys(attributes);
        if (attributeNames.length > 0) {
          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));
        }
      }
    };
    const removeDirectAnnotation = elem => {
      remove$7(elem, annotation());
      remove$a(elem, `${ dataAnnotationId() }`);
      remove$a(elem, `${ dataAnnotation() }`);
      remove$a(elem, `${ dataAnnotationActive() }`);
      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);
      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);
      each$e(customAttrNames, name => remove$a(elem, name));
      remove$4(elem, customClasses);
      remove$a(elem, `${ dataAnnotationClasses() }`);
      remove$a(elem, `${ dataAnnotationAttributes() }`);
    };
    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {
      const master = SugarElement.fromTag('span', eDoc);
      applyAnnotation(master, uid, data, annotationName, decorate, false);
      return master;
    };
    const annotate = (editor, rng, uid, annotationName, decorate, data) => {
      const newWrappers = [];
      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);
      const wrapper = value$2();
      const finishWrapper = () => {
        wrapper.clear();
      };
      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
        const nu = shallow$1(master);
        newWrappers.push(nu);
        wrapper.set(nu);
        return nu;
      });
      const processElements = elems => {
        each$e(elems, processElement);
      };
      const processElement = elem => {
        const ctx = context(editor, elem, 'span', name(elem));
        switch (ctx) {
        case 'invalid-child': {
            finishWrapper();
            const children = children$1(elem);
            processElements(children);
            finishWrapper();
            break;
          }
        case 'valid-block': {
            finishWrapper();
            applyAnnotation(elem, uid, data, annotationName, decorate, true);
            break;
          }
        case 'valid': {
            const w = getOrOpenWrapper();
            wrap$2(elem, w);
            break;
          }
        }
      };
      const processNodes = nodes => {
        const elems = map$3(nodes, SugarElement.fromDom);
        processElements(elems);
      };
      walk$3(editor.dom, rng, nodes => {
        finishWrapper();
        processNodes(nodes);
      });
      return newWrappers;
    };
    const annotateWithBookmark = (editor, name, settings, data) => {
      editor.undoManager.transact(() => {
        const selection = editor.selection;
        const initialRng = selection.getRng();
        const hasFakeSelection = getCellsFromEditor(editor).length > 0;
        const masterUid = generate$1('mce-annotation');
        if (initialRng.collapsed && !hasFakeSelection) {
          applyWordGrab(editor, initialRng);
        }
        if (selection.getRng().collapsed && !hasFakeSelection) {
          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);
          set$1(wrapper, nbsp);
          selection.getRng().insertNode(wrapper.dom);
          selection.select(wrapper.dom);
        } else {
          preserve(selection, false, () => {
            runOnRanges(editor, selectionRng => {
              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);
            });
          });
        }
      });
    };

    const Annotator = editor => {
      const registry = create$c();
      setup$w(editor, registry);
      const changes = setup$x(editor, registry);
      const isSpan = isTag('span');
      const removeAnnotations = elements => {
        each$e(elements, element => {
          if (isSpan(element)) {
            unwrap(element);
          } else {
            removeDirectAnnotation(element);
          }
        });
      };
      return {
        register: (name, settings) => {
          registry.register(name, settings);
        },
        annotate: (name, data) => {
          registry.lookup(name).each(settings => {
            annotateWithBookmark(editor, name, settings, data);
          });
        },
        annotationChanged: (name, callback) => {
          changes.addListener(name, callback);
        },
        remove: name => {
          identify(editor, Optional.some(name)).each(({elements}) => {
            const bookmark = editor.selection.getBookmark();
            removeAnnotations(elements);
            editor.selection.moveToBookmark(bookmark);
          });
        },
        removeAll: name => {
          const bookmark = editor.selection.getBookmark();
          each$d(findAll(editor, name), (elements, _) => {
            removeAnnotations(elements);
          });
          editor.selection.moveToBookmark(bookmark);
        },
        getAll: name => {
          const directory = findAll(editor, name);
          return map$2(directory, elems => map$3(elems, elem => elem.dom));
        }
      };
    };

    const BookmarkManager = selection => {
      return {
        getBookmark: curry(getBookmark$1, selection),
        moveToBookmark: curry(moveToBookmark, selection)
      };
    };
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;

    const isXYWithinRange = (clientX, clientY, range) => {
      if (range.collapsed) {
        return false;
      } else {
        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));
      }
    };

    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);
    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);
    const fireRemove = editor => {
      editor.dispatch('remove');
    };
    const fireDetach = editor => {
      editor.dispatch('detach');
    };
    const fireSwitchMode = (editor, mode) => {
      editor.dispatch('SwitchMode', { mode });
    };
    const fireObjectResizeStart = (editor, target, width, height, origin) => {
      editor.dispatch('ObjectResizeStart', {
        target,
        width,
        height,
        origin
      });
    };
    const fireObjectResized = (editor, target, width, height, origin) => {
      editor.dispatch('ObjectResized', {
        target,
        width,
        height,
        origin
      });
    };
    const firePreInit = editor => {
      editor.dispatch('PreInit');
    };
    const firePostRender = editor => {
      editor.dispatch('PostRender');
    };
    const fireInit = editor => {
      editor.dispatch('Init');
    };
    const firePlaceholderToggle = (editor, state) => {
      editor.dispatch('PlaceholderToggle', { state });
    };
    const fireError = (editor, errorType, error) => {
      editor.dispatch(errorType, error);
    };
    const fireFormatApply = (editor, format, node, vars) => {
      editor.dispatch('FormatApply', {
        format,
        node,
        vars
      });
    };
    const fireFormatRemove = (editor, format, node, vars) => {
      editor.dispatch('FormatRemove', {
        format,
        node,
        vars
      });
    };
    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);
    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);
    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);
    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);
    const fireAutocompleterStart = (editor, args) => {
      editor.dispatch('AutocompleterStart', args);
    };
    const fireAutocompleterUpdate = (editor, args) => {
      editor.dispatch('AutocompleterUpdate', args);
    };
    const fireAutocompleterEnd = editor => {
      editor.dispatch('AutocompleterEnd');
    };
    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {
      content: html,
      internal
    });
    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {
      node,
      internal
    });
    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });
    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });

    const VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: e => {
        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
      },
      metaKeyPressed: e => {
        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
      }
    };

    const elementSelectionAttr = 'data-mce-selected';
    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';
    const abs = Math.abs;
    const round$1 = Math.round;
    const resizeHandles = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    };
    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;
    const ControlSelection = (selection, editor) => {
      const dom = editor.dom;
      const editableDoc = editor.getDoc();
      const rootDocument = document;
      const rootElement = editor.getBody();
      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      let width;
      let height;
      let startScrollWidth;
      let startScrollHeight;
      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));
      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');
      const isEventOnImageOutsideRange = (evt, range) => {
        if (isTouchEvent(evt)) {
          const touch = evt.touches[0];
          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);
        } else {
          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);
        }
      };
      const contextMenuSelectImage = evt => {
        const target = evt.target;
        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
          editor.selection.select(target);
        }
      };
      const getResizeTargets = elm => {
        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
          return [
            elm,
            elm.firstElementChild
          ];
        } else if (dom.is(elm, 'figure.image')) {
          return [elm.querySelector('img')];
        } else {
          return [elm];
        }
      };
      const isResizable = elm => {
        const selector = getObjectResizing(editor);
        if (!selector) {
          return false;
        }
        if (elm.getAttribute('data-mce-resize') === 'false') {
          return false;
        }
        if (elm === editor.getBody()) {
          return false;
        }
        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {
          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
        } else {
          return is$1(SugarElement.fromDom(elm), selector);
        }
      };
      const createGhostElement = elm => {
        if (isMedia(elm)) {
          return dom.create('img', { src: Env.transparentSrc });
        } else {
          return elm.cloneNode(true);
        }
      };
      const setSizeProp = (element, name, value) => {
        if (isNonNullable(value)) {
          const targets = getResizeTargets(element);
          each$e(targets, target => {
            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {
              dom.setStyle(target, name, value);
            } else {
              dom.setAttrib(target, name, '' + value);
            }
          });
        }
      };
      const setGhostElmSize = (ghostElm, width, height) => {
        setSizeProp(ghostElm, 'width', width);
        setSizeProp(ghostElm, 'height', height);
      };
      const resizeGhostElement = e => {
        let deltaX, deltaY, proportional;
        let resizeHelperX, resizeHelperY;
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;
        width = deltaX * selectedHandle[2] + startW;
        height = deltaY * selectedHandle[3] + startH;
        width = width < 5 ? 5 : width;
        height = height < 5 ? 5 : height;
        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e);
        }
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height = round$1(width * ratio);
            width = round$1(height / ratio);
          } else {
            width = round$1(height / ratio);
            height = round$1(width * ratio);
          }
        }
        setGhostElmSize(selectedElmGhost, width, height);
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
        dom.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: 'block'
        });
        resizeHelper.innerHTML = width + ' &times; ' + height;
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
        }
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
        }
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;
        if (deltaX + deltaY !== 0) {
          dom.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }
        if (!resizeStarted) {
          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);
          resizeStarted = true;
        }
      };
      const endGhostResize = () => {
        const wasResizeStarted = resizeStarted;
        resizeStarted = false;
        if (wasResizeStarted) {
          setSizeProp(selectedElm, 'width', width);
          setSizeProp(selectedElm, 'height', height);
        }
        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
        dom.unbind(editableDoc, 'mouseup', endGhostResize);
        if (rootDocument !== editableDoc) {
          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
          dom.unbind(rootDocument, 'mouseup', endGhostResize);
        }
        dom.remove(selectedElmGhost);
        dom.remove(resizeHelper);
        dom.remove(resizeBackdrop);
        showResizeRect(selectedElm);
        if (wasResizeStarted) {
          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);
          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
        }
        editor.nodeChanged();
      };
      const showResizeRect = targetElm => {
        unbindResizeHandleEvents();
        const position = dom.getPos(targetElm, rootElement);
        const selectedElmX = position.x;
        const selectedElmY = position.y;
        const rect = targetElm.getBoundingClientRect();
        const targetWidth = rect.width || rect.right - rect.left;
        const targetHeight = rect.height || rect.bottom - rect.top;
        if (selectedElm !== targetElm) {
          hideResizeRect();
          selectedElm = targetElm;
          width = height = 0;
        }
        const e = editor.dispatch('ObjectSelected', { target: targetElm });
        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
          each$d(resizeHandles, (handle, name) => {
            const startDrag = e => {
              const target = getResizeTargets(selectedElm)[0];
              startX = e.screenX;
              startY = e.screenY;
              startW = target.clientWidth;
              startH = target.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle;
              selectedHandle.name = name;
              selectedHandle.startPos = {
                x: targetWidth * handle[0] + selectedElmX,
                y: targetHeight * handle[1] + selectedElmY
              };
              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;
              resizeBackdrop = dom.add(rootElement, 'div', {
                'class': 'mce-resize-backdrop',
                'data-mce-bogus': 'all'
              });
              dom.setStyles(resizeBackdrop, {
                position: 'fixed',
                left: '0',
                top: '0',
                width: '100%',
                height: '100%'
              });
              selectedElmGhost = createGhostElement(selectedElm);
              dom.addClass(selectedElmGhost, 'mce-clonedresizable');
              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
              selectedElmGhost.contentEditable = 'false';
              dom.setStyles(selectedElmGhost, {
                left: selectedElmX,
                top: selectedElmY,
                margin: 0
              });
              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
              selectedElmGhost.removeAttribute(elementSelectionAttr);
              rootElement.appendChild(selectedElmGhost);
              dom.bind(editableDoc, 'mousemove', resizeGhostElement);
              dom.bind(editableDoc, 'mouseup', endGhostResize);
              if (rootDocument !== editableDoc) {
                dom.bind(rootDocument, 'mousemove', resizeGhostElement);
                dom.bind(rootDocument, 'mouseup', endGhostResize);
              }
              resizeHelper = dom.add(rootElement, 'div', {
                'class': 'mce-resize-helper',
                'data-mce-bogus': 'all'
              }, startW + ' &times; ' + startH);
            };
            let handleElm = dom.get('mceResizeHandle' + name);
            if (handleElm) {
              dom.remove(handleElm);
            }
            handleElm = dom.add(rootElement, 'div', {
              'id': 'mceResizeHandle' + name,
              'data-mce-bogus': 'all',
              'class': 'mce-resizehandle',
              'unselectable': true,
              'style': 'cursor:' + name + '-resize; margin:0; padding:0'
            });
            dom.bind(handleElm, 'mousedown', e => {
              e.stopImmediatePropagation();
              e.preventDefault();
              startDrag(e);
            });
            handle.elm = handleElm;
            dom.setStyles(handleElm, {
              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
            });
          });
        } else {
          hideResizeRect(false);
        }
      };
      const throttledShowResizeRect = first$1(showResizeRect, 0);
      const hideResizeRect = (removeSelected = true) => {
        throttledShowResizeRect.cancel();
        unbindResizeHandleEvents();
        if (selectedElm && removeSelected) {
          selectedElm.removeAttribute(elementSelectionAttr);
        }
        each$d(resizeHandles, (value, name) => {
          const handleElm = dom.get('mceResizeHandle' + name);
          if (handleElm) {
            dom.unbind(handleElm);
            dom.remove(handleElm);
          }
        });
      };
      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);
      const updateResizeRect = e => {
        if (resizeStarted || editor.removed || editor.composing) {
          return;
        }
        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();
        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement)).getOrUndefined();
        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';
        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {
          img.removeAttribute(elementSelectionAttr);
        });
        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {
          disableGeckoResize();
          const startElm = selection.getStart(true);
          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);
            throttledShowResizeRect.throttle(controlElm);
            return;
          }
        }
        hideResizeRect();
      };
      const unbindResizeHandleEvents = () => {
        each$d(resizeHandles, handle => {
          if (handle.elm) {
            dom.unbind(handle.elm);
            delete handle.elm;
          }
        });
      };
      const disableGeckoResize = () => {
        try {
          editor.getDoc().execCommand('enableObjectResizing', false, 'false');
        } catch (ex) {
        }
      };
      editor.on('init', () => {
        disableGeckoResize();
        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);
        editor.on('keyup compositionend', e => {
          if (selectedElm && selectedElm.nodeName === 'TABLE') {
            updateResizeRect(e);
          }
        });
        editor.on('hide blur', hideResizeRect);
        editor.on('contextmenu longpress', contextMenuSelectImage, true);
      });
      editor.on('remove', unbindResizeHandleEvents);
      const destroy = () => {
        throttledShowResizeRect.cancel();
        selectedElm = selectedElmGhost = resizeBackdrop = null;
      };
      return {
        isResizable,
        showResizeRect,
        hideResizeRect,
        updateResizeRect,
        destroy
      };
    };

    const setStart = (rng, situ) => {
      situ.fold(e => {
        rng.setStartBefore(e.dom);
      }, (e, o) => {
        rng.setStart(e.dom, o);
      }, e => {
        rng.setStartAfter(e.dom);
      });
    };
    const setFinish = (rng, situ) => {
      situ.fold(e => {
        rng.setEndBefore(e.dom);
      }, (e, o) => {
        rng.setEnd(e.dom, o);
      }, e => {
        rng.setEndAfter(e.dom);
      });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
      const range = win.document.createRange();
      setStart(range, startSitu);
      setFinish(range, finishSitu);
      return range;
    };
    const exactToNative = (win, start, soffset, finish, foffset) => {
      const rng = win.document.createRange();
      rng.setStart(start.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };

    const adt$3 = Adt.generate([
      {
        ltr: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      },
      {
        rtl: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);
    const getRanges = (win, selection) => selection.match({
      domRange: rng => {
        return {
          ltr: constant(rng),
          rtl: Optional.none
        };
      },
      relative: (startSitu, finishSitu) => {
        return {
          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
        };
      },
      exact: (start, soffset, finish, foffset) => {
        return {
          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),
          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))
        };
      }
    });
    const doDiagnose = (win, ranges) => {
      const rng = ranges.ltr();
      if (rng.collapsed) {
        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);
        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
      } else {
        return fromRange(win, adt$3.ltr, rng);
      }
    };
    const diagnose = (win, selection) => {
      const ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    adt$3.ltr;
    adt$3.rtl;

    const create$a = (start, soffset, finish, foffset) => ({
      start,
      soffset,
      finish,
      foffset
    });
    const SimRange = { create: create$a };

    const caretPositionFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {
        if (pos.offsetNode === null) {
          return Optional.none();
        }
        const r = doc.dom.createRange();
        r.setStart(pos.offsetNode, pos.offset);
        r.collapse();
        return Optional.some(r);
      });
    };
    const caretRangeFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
    };
    const availableSearch = (() => {
      if (document.caretPositionFromPoint) {
        return caretPositionFromPoint;
      } else if (document.caretRangeFromPoint) {
        return caretRangeFromPoint;
      } else {
        return Optional.none;
      }
    })();
    const fromPoint$1 = (win, x, y) => {
      const doc = SugarElement.fromDom(win.document);
      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    };

    const adt$2 = Adt.generate([
      { before: ['element'] },
      {
        on: [
          'element',
          'offset'
        ]
      },
      { after: ['element'] }
    ]);
    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$2 = situ => situ.fold(identity, identity, identity);
    const before$1 = adt$2.before;
    const on = adt$2.on;
    const after$1 = adt$2.after;
    const Situ = {
      before: before$1,
      on,
      after: after$1,
      cata,
      getStart: getStart$2
    };

    const adt$1 = Adt.generate([
      { domRange: ['rng'] },
      {
        relative: [
          'startSitu',
          'finishSitu'
        ]
      },
      {
        exact: [
          'start',
          'soffset',
          'finish',
          'foffset'
        ]
      }
    ]);
    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart$1 = selection => selection.match({
      domRange: rng => SugarElement.fromDom(rng.startContainer),
      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
      exact: (start, _soffset, _finish, _foffset) => start
    });
    const domRange = adt$1.domRange;
    const relative = adt$1.relative;
    const exact = adt$1.exact;
    const getWin = selection => {
      const start = getStart$1(selection);
      return defaultView(start);
    };
    const range = SimRange.create;
    const SimSelection = {
      domRange,
      relative,
      exact,
      exactFromRange,
      getWin,
      range
    };

    const beforeSpecial = (element, offset) => {
      const name$1 = name(element);
      if ('input' === name$1) {
        return Situ.after(element);
      } else if (!contains$2([
          'br',
          'img'
        ], name$1)) {
        return Situ.on(element, offset);
      } else {
        return offset === 0 ? Situ.before(element) : Situ.after(element);
      }
    };
    const preprocessRelative = (startSitu, finishSitu) => {
      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
      return SimSelection.relative(start, finish);
    };
    const preprocessExact = (start, soffset, finish, foffset) => {
      const startSitu = beforeSpecial(start, soffset);
      const finishSitu = beforeSpecial(finish, foffset);
      return SimSelection.relative(startSitu, finishSitu);
    };
    const preprocess = selection => selection.match({
      domRange: rng => {
        const start = SugarElement.fromDom(rng.startContainer);
        const finish = SugarElement.fromDom(rng.endContainer);
        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);
      },
      relative: preprocessRelative,
      exact: preprocessExact
    });

    const fromElements = (elements, scope) => {
      const doc = scope || document;
      const fragment = doc.createDocumentFragment();
      each$e(elements, element => {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };

    const toNative = selection => {
      const win = SimSelection.getWin(selection).dom;
      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);
      const filtered = preprocess(selection);
      return diagnose(win, filtered).match({
        ltr: getDomRange,
        rtl: getDomRange
      });
    };
    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);

    const fromPoint = (clientX, clientY, doc) => {
      const win = defaultView(SugarElement.fromDom(doc));
      return getAtPoint(win.dom, clientX, clientY).map(simRange => {
        const rng = doc.createRange();
        rng.setStart(simRange.start.dom, simRange.soffset);
        rng.setEnd(simRange.finish.dom, simRange.foffset);
        return rng;
      }).getOrUndefined();
    };

    const isEq$4 = (rng1, rng2) => {
      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };

    const findParent = (node, rootNode, predicate) => {
      let currentNode = node;
      while (currentNode && currentNode !== rootNode) {
        if (predicate(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);
    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
    const hasBrBeforeAfter = (dom, node, left) => {
      const parentNode = node.parentNode;
      if (parentNode) {
        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());
        let currentNode;
        while (currentNode = walker[left ? 'prev' : 'next']()) {
          if (isBr$6(currentNode)) {
            return true;
          }
        }
      }
      return false;
    };
    const isPrevNode = (node, name) => {
      var _a;
      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;
    };
    const hasContentEditableFalseParent = (root, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== root) {
        if (isContentEditableFalse$b(currentNode)) {
          return true;
        }
        currentNode = currentNode.parentNode;
      }
      return false;
    };
    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {
      const body = dom.getRoot();
      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      const parentNode = startNode.parentNode;
      let lastInlineElement;
      let node;
      if (!parentNode) {
        return Optional.none();
      }
      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;
      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));
      }
      const walker = new DomTreeWalker(startNode, parentBlockContainer);
      while (node = walker[left ? 'prev' : 'next']()) {
        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
          return Optional.none();
        }
        if (isText$a(node) && node.data.length > 0) {
          if (!hasParentWithName(node, body, 'A')) {
            return Optional.some(CaretPosition(node, left ? node.data.length : 0));
          }
          return Optional.none();
        }
        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          return Optional.none();
        }
        lastInlineElement = node;
      }
      if (isComment(lastInlineElement)) {
        return Optional.none();
      }
      if (collapsed && lastInlineElement) {
        return Optional.some(CaretPosition(lastInlineElement, 0));
      }
      return Optional.none();
    };
    const normalizeEndPoint = (dom, collapsed, start, rng) => {
      const body = dom.getRoot();
      let node;
      let normalized = false;
      let container = start ? rng.startContainer : rng.endContainer;
      let offset = start ? rng.startOffset : rng.endOffset;
      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;
      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();
      let directionLeft = start;
      if (isCaretContainer$2(container)) {
        return Optional.none();
      }
      if (isElement$6(container) && offset > container.childNodes.length - 1) {
        directionLeft = false;
      }
      if (isDocument$1(container)) {
        container = body;
        offset = 0;
      }
      if (container === body) {
        if (directionLeft) {
          node = container.childNodes[offset > 0 ? offset - 1 : 0];
          if (node) {
            if (isCaretContainer$2(node)) {
              return Optional.none();
            }
            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
              return Optional.none();
            }
          }
        }
        if (container.hasChildNodes()) {
          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
          container = container.childNodes[offset];
          offset = isText$a(container) && isAfterNode ? container.data.length : 0;
          if (!collapsed && container === body.lastChild && isTable$2(container)) {
            return Optional.none();
          }
          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
            return Optional.none();
          }
          if (container.hasChildNodes() && !isTable$2(container)) {
            node = container;
            const walker = new DomTreeWalker(container, body);
            do {
              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
                normalized = false;
                break;
              }
              if (isText$a(node) && node.data.length > 0) {
                offset = directionLeft ? 0 : node.data.length;
                container = node;
                normalized = true;
                break;
              }
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                offset = dom.nodeIndex(node);
                container = node.parentNode;
                if (!directionLeft) {
                  offset++;
                }
                normalized = true;
                break;
              }
            } while (node = directionLeft ? walker.next() : walker.prev());
          }
        }
      }
      if (collapsed) {
        if (isText$a(container) && offset === 0) {
          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {
            container = pos.container();
            offset = pos.offset();
            normalized = true;
          });
        }
        if (isElement$6(container)) {
          node = container.childNodes[offset];
          if (!node) {
            node = container.childNodes[offset - 1];
          }
          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {
              container = pos.container();
              offset = pos.offset();
              normalized = true;
            });
          }
        }
      }
      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {
        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();
    };
    const normalize$2 = (dom, rng) => {
      const collapsed = rng.collapsed, normRng = rng.cloneRange();
      const startPos = CaretPosition.fromRangeStart(rng);
      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {
        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
          normRng.setStart(pos.container(), pos.offset());
        }
      });
      if (!collapsed) {
        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {
          normRng.setEnd(pos.container(), pos.offset());
        });
      }
      if (collapsed) {
        normRng.collapse(true);
      }
      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };

    const splitText = (node, offset) => {
      return node.splitText(offset);
    };
    const split = rng => {
      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      if (startContainer === endContainer && isText$a(startContainer)) {
        if (startOffset > 0 && startOffset < startContainer.data.length) {
          endContainer = splitText(startContainer, startOffset);
          startContainer = endContainer.previousSibling;
          if (endOffset > startOffset) {
            endOffset = endOffset - startOffset;
            const newContainer = splitText(endContainer, endOffset).previousSibling;
            startContainer = endContainer = newContainer;
            endOffset = newContainer.data.length;
            startOffset = 0;
          } else {
            endOffset = 0;
          }
        }
      } else {
        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
          startContainer = splitText(startContainer, startOffset);
          startOffset = 0;
        }
        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
          const newContainer = splitText(endContainer, endOffset).previousSibling;
          endContainer = newContainer;
          endOffset = newContainer.data.length;
        }
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };

    const RangeUtils = dom => {
      const walk = (rng, callback) => {
        return walk$3(dom, rng, callback);
      };
      const split$1 = split;
      const normalize = rng => {
        return normalize$2(dom, rng).fold(never, normalizedRng => {
          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
          return true;
        });
      };
      const expand = (rng, options = { type: 'word' }) => {
        if (options.type === 'word') {
          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);
          const newRange = dom.createRng();
          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
          return newRange;
        }
        return rng;
      };
      return {
        walk,
        split: split$1,
        expand,
        normalize
      };
    };
    RangeUtils.compareRanges = isEq$4;
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;

    const Dimension = (name, getOffset) => {
      const set = (element, h) => {
        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
        }
        const dom = element.dom;
        if (isSupported(dom)) {
          dom.style[name] = h + 'px';
        }
      };
      const get = element => {
        const r = getOffset(element);
        if (r <= 0 || r === null) {
          const css = get$7(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      const getOuter = get;
      const aggregate = (element, properties) => foldl(properties, (acc, property) => {
        const val = get$7(element, property);
        const value = val === undefined ? 0 : parseInt(val, 10);
        return isNaN(value) ? acc : acc + value;
      }, 0);
      const max = (element, value, properties) => {
        const cumulativeInclusions = aggregate(element, properties);
        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set,
        get,
        getOuter,
        aggregate,
        max
      };
    };

    const api = Dimension('height', element => {
      const dom = element.dom;
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    const get$2 = element => api.get(element);

    const getDocument = () => SugarElement.fromDom(document);

    const walkUp = (navigation, doc) => {
      const frame = navigation.view(doc);
      return frame.fold(constant([]), f => {
        const parent = navigation.owner(f);
        const rest = walkUp(navigation, parent);
        return [f].concat(rest);
      });
    };
    const pathTo = (element, navigation) => {
      const d = navigation.owner(element);
      return walkUp(navigation, d);
    };

    const view = doc => {
      var _a;
      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    const owner = element => documentOrOwner(element);

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner
    });

    const find = element => {
      const doc = getDocument();
      const scroll = get$5(doc);
      const frames = pathTo(element, Navigation);
      const offset = viewport(element);
      const r = foldr(frames, (b, a) => {
        const loc = viewport(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    };

    const excludeFromDescend = element => name(element) === 'textarea';
    const fireScrollIntoViewEvent = (editor, data) => {
      const scrollEvent = editor.dispatch('ScrollIntoView', data);
      return scrollEvent.isDefaultPrevented();
    };
    const fireAfterScrollIntoViewEvent = (editor, data) => {
      editor.dispatch('AfterScrollIntoView', data);
    };
    const descend = (element, offset) => {
      const children = children$1(element);
      if (children.length === 0 || excludeFromDescend(element)) {
        return {
          element,
          offset
        };
      } else if (offset < children.length && !excludeFromDescend(children[offset])) {
        return {
          element: children[offset],
          offset: 0
        };
      } else {
        const last = children[children.length - 1];
        if (excludeFromDescend(last)) {
          return {
            element,
            offset
          };
        } else {
          if (name(last) === 'img') {
            return {
              element: last,
              offset: 1
            };
          } else if (isText$b(last)) {
            return {
              element: last,
              offset: get$3(last).length
            };
          } else {
            return {
              element: last,
              offset: children$1(last).length
            };
          }
        }
      }
    };
    const markerInfo = (element, cleanupFun) => {
      const pos = absolute(element);
      const height = get$2(element);
      return {
        element,
        bottom: pos.top + height,
        height,
        pos,
        cleanup: cleanupFun
      };
    };
    const createMarker$1 = (element, offset) => {
      const startPoint = descend(element, offset);
      const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + '</span>');
      before$3(startPoint.element, span);
      return markerInfo(span, () => remove$5(span));
    };
    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);
    const withMarker = (editor, f, rng, alignToTop) => {
      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
    };
    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
      const data = {
        elm: marker.element.dom,
        alignToTop
      };
      if (fireScrollIntoViewEvent(editor, data)) {
        return;
      }
      const scrollTop = get$5(doc).top;
      f(editor, doc, scrollTop, marker, alignToTop);
      fireAfterScrollIntoViewEvent(editor, data);
    };
    const applyWithMarker = (editor, f, rng, alignToTop) => {
      const body = SugarElement.fromDom(editor.getBody());
      const doc = SugarElement.fromDom(editor.getDoc());
      reflow(body);
      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      withScrollEvents(editor, doc, f, marker, alignToTop);
      marker.cleanup();
    };
    const withElement = (editor, element, f, alignToTop) => {
      const doc = SugarElement.fromDom(editor.getDoc());
      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    const preserveWith = (editor, f, rng) => {
      const startElement = rng.startContainer;
      const startOffset = rng.startOffset;
      const endElement = rng.endContainer;
      const endOffset = rng.endOffset;
      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
      const newRng = editor.dom.createRng();
      newRng.setStart(startElement, startOffset);
      newRng.setEnd(endElement, endOffset);
      editor.selection.setRng(rng);
    };
    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {
      const pos = marker.pos;
      if (alignToTop) {
        to(pos.left, pos.top, doc);
      } else {
        const y = pos.top - viewHeight + marker.height;
        to(-editor.getBody().getBoundingClientRect().left, y, doc);
      }
    };
    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {
      const viewportBottom = viewHeight + scrollTop;
      const markerTop = marker.pos.top;
      const markerBottom = marker.bottom;
      const largerThanViewport = markerBottom - markerTop >= viewHeight;
      if (markerTop < scrollTop) {
        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);
      } else if (markerTop > viewportBottom) {
        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
        scrollToMarker(editor, marker, viewHeight, align, doc);
      } else if (markerBottom > viewportBottom && !largerThanViewport) {
        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);
      }
    };
    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {
      const viewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);
    };
    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {
      const frameViewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);
      const op = find(marker.element);
      const viewportBounds = getBounds(window);
      if (op.top < viewportBounds.y) {
        intoView(marker.element, alignToTop !== false);
      } else if (op.top > viewportBounds.bottom) {
        intoView(marker.element, alignToTop === true);
      }
    };
    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
    const scrollElementIntoView = (editor, element, alignToTop) => {
      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
      scroller(editor, element, alignToTop);
    };
    const scrollRangeIntoView = (editor, rng, alignToTop) => {
      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
      scroller(editor, rng, alignToTop);
    };

    const focus$1 = element => element.dom.focus();
    const hasFocus$1 = element => {
      const root = getRootNode(element).dom;
      return element.dom === root.activeElement;
    };
    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));

    const clamp$1 = (offset, element) => {
      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;
      if (offset > max) {
        return max;
      } else if (offset < 0) {
        return 0;
      }
      return offset;
    };
    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));
    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
    const shouldStore = editor => editor.inline || Env.browser.isFirefox();
    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);
    const readRange = win => {
      const selection = win.getSelection();
      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
      return rng.map(nativeRangeToSelectionRange);
    };
    const getBookmark = root => {
      const win = defaultView(root);
      return readRange(win.dom).filter(isRngInRoot(root));
    };
    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
    const bookmarkToNativeRng = bookmark => {
      const rng = document.createRange();
      try {
        rng.setStart(bookmark.start.dom, bookmark.soffset);
        rng.setEnd(bookmark.finish.dom, bookmark.foffset);
        return Optional.some(rng);
      } catch (_) {
        return Optional.none();
      }
    };
    const store = editor => {
      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    const getRng = editor => {
      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);
    };
    const restore = editor => {
      getRng(editor).each(rng => editor.selection.setRng(rng));
    };

    const isEditorUIElement$1 = elm => {
      const className = elm.className.toString();
      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
    };
    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };

    const wrappedSetTimeout = (callback, time) => {
      if (!isNumber(time)) {
        time = 0;
      }
      return setTimeout(callback, time);
    };
    const wrappedSetInterval = (callback, time) => {
      if (!isNumber(time)) {
        time = 0;
      }
      return setInterval(callback, time);
    };
    const Delay = {
      setEditorTimeout: (editor, callback, time) => {
        return wrappedSetTimeout(() => {
          if (!editor.removed) {
            callback();
          }
        }, time);
      },
      setEditorInterval: (editor, callback, time) => {
        const timer = wrappedSetInterval(() => {
          if (!editor.removed) {
            callback();
          } else {
            clearInterval(timer);
          }
        }, time);
        return timer;
      }
    };

    const isManualNodeChange = e => {
      return e.type === 'nodechange' && e.selectionChange;
    };
    const registerPageMouseUp = (editor, throttledStore) => {
      const mouseUpPage = () => {
        throttledStore.throttle();
      };
      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);
      editor.on('remove', () => {
        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);
      });
    };
    const registerMouseUp = (editor, throttledStore) => {
      editor.on('mouseup touchend', _e => {
        throttledStore.throttle();
      });
    };
    const registerEditorEvents = (editor, throttledStore) => {
      registerMouseUp(editor, throttledStore);
      editor.on('keyup NodeChange AfterSetSelectionRange', e => {
        if (!isManualNodeChange(e)) {
          store(editor);
        }
      });
    };
    const register$6 = editor => {
      const throttledStore = first$1(() => {
        store(editor);
      }, 0);
      editor.on('init', () => {
        if (editor.inline) {
          registerPageMouseUp(editor, throttledStore);
        }
        registerEditorEvents(editor, throttledStore);
      });
      editor.on('remove', () => {
        throttledStore.cancel();
      });
    };

    let documentFocusInHandler;
    const DOM$9 = DOMUtils.DOM;
    const isEditorUIElement = elm => {
      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
    };
    const isEditorContentAreaElement = elm => {
      const classList = elm.classList;
      if (classList !== undefined) {
        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
      } else {
        return false;
      }
    };
    const isUIElement = (editor, elm) => {
      const customSelector = getCustomUiSelector(editor);
      const parent = DOM$9.getParent(elm, elm => {
        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);
      });
      return parent !== null;
    };
    const getActiveElement = editor => {
      try {
        const root = getRootNode(SugarElement.fromDom(editor.getElement()));
        return active$1(root).fold(() => document.body, x => x.dom);
      } catch (ex) {
        return document.body;
      }
    };
    const registerEvents$1 = (editorManager, e) => {
      const editor = e.editor;
      register$6(editor);
      const toggleContentAreaOnFocus = (editor, fn) => {
        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {
          const contentArea = SugarElement.fromDom(editor.getContainer());
          fn(contentArea, 'tox-edit-focus');
        }
      };
      editor.on('focusin', () => {
        const focusedEditor = editorManager.focusedEditor;
        if (isEditorContentAreaElement(getActiveElement(editor))) {
          toggleContentAreaOnFocus(editor, add$2);
        }
        if (focusedEditor !== editor) {
          if (focusedEditor) {
            focusedEditor.dispatch('blur', { focusedEditor: editor });
          }
          editorManager.setActive(editor);
          editorManager.focusedEditor = editor;
          editor.dispatch('focus', { blurredEditor: focusedEditor });
          editor.focus(true);
        }
      });
      editor.on('focusout', () => {
        Delay.setEditorTimeout(editor, () => {
          const focusedEditor = editorManager.focusedEditor;
          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
            toggleContentAreaOnFocus(editor, remove$7);
          }
          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
            editor.dispatch('blur', { focusedEditor: null });
            editorManager.focusedEditor = null;
          }
        });
      });
      if (!documentFocusInHandler) {
        documentFocusInHandler = e => {
          const activeEditor = editorManager.activeEditor;
          if (activeEditor) {
            getOriginalEventTarget(e).each(target => {
              const elem = target;
              if (elem.ownerDocument === document) {
                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.dispatch('blur', { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            });
          }
        };
        DOM$9.bind(document, 'focusin', documentFocusInHandler);
      }
    };
    const unregisterDocumentEvents = (editorManager, e) => {
      if (editorManager.focusedEditor === e.editor) {
        editorManager.focusedEditor = null;
      }
      if (!editorManager.activeEditor && documentFocusInHandler) {
        DOM$9.unbind(document, 'focusin', documentFocusInHandler);
        documentFocusInHandler = null;
      }
    };
    const setup$v = editorManager => {
      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));
      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
    };

    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');
    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {
      if (isTableSection(node)) {
        return Optional.some(node);
      } else if (!contains(root, node)) {
        return Optional.some(root);
      } else {
        return Optional.none();
      }
    });
    const normalizeSelection = (editor, rng) => {
      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {
        return firstPositionIn(elm.dom);
      }).fold(() => {
        editor.selection.normalize();
      }, caretPos => editor.selection.setRng(caretPos.toRange()));
    };
    const focusBody = body => {
      if (body.setActive) {
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();
    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    const hasInlineFocus = editor => {
      const rawBody = editor.getBody();
      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    const hasUiFocus = editor => {
      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();
    };
    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);
    const focusEditor = editor => {
      const selection = editor.selection;
      const body = editor.getBody();
      let rng = selection.getRng();
      editor.quirks.refreshContentEditable();
      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
        getRng(editor).each(bookmarkRng => {
          editor.selection.setRng(bookmarkRng);
          rng = bookmarkRng;
        });
      }
      const contentEditableHost = getContentEditableHost(editor, selection.getNode());
      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
        focusBody(contentEditableHost);
        normalizeSelection(editor, rng);
        activateEditor(editor);
        return;
      }
      if (!editor.inline) {
        if (!Env.browser.isOpera()) {
          focusBody(body);
        }
        editor.getWin().focus();
      }
      if (Env.browser.isFirefox() || editor.inline) {
        focusBody(body);
        normalizeSelection(editor, rng);
      }
      activateEditor(editor);
    };
    const activateEditor = editor => editor.editorManager.setActive(editor);
    const focus = (editor, skipFocus) => {
      if (editor.removed) {
        return;
      }
      if (skipFocus) {
        activateEditor(editor);
      } else {
        focusEditor(editor);
      }
    };

    const getEndpointElement = (root, rng, start, real, resolve) => {
      const container = start ? rng.startContainer : rng.endContainer;
      const offset = start ? rng.startOffset : rng.endOffset;
      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);
    };
    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));
    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);
    const skipEmptyTextNodes = (node, forwards) => {
      const orig = node;
      while (node && isText$a(node) && node.length === 0) {
        node = forwards ? node.nextSibling : node.previousSibling;
      }
      return node || orig;
    };
    const getNode = (root, rng) => {
      if (!rng) {
        return root;
      }
      let startContainer = rng.startContainer;
      let endContainer = rng.endContainer;
      const startOffset = rng.startOffset;
      const endOffset = rng.endOffset;
      let node = rng.commonAncestorContainer;
      if (!rng.collapsed) {
        if (startContainer === endContainer) {
          if (endOffset - startOffset < 2) {
            if (startContainer.hasChildNodes()) {
              node = startContainer.childNodes[startOffset];
            }
          }
        }
        if (isText$a(startContainer) && isText$a(endContainer)) {
          if (startContainer.length === startOffset) {
            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
          } else {
            startContainer = startContainer.parentNode;
          }
          if (endOffset === 0) {
            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
          } else {
            endContainer = endContainer.parentNode;
          }
          if (startContainer && startContainer === endContainer) {
            node = startContainer;
          }
        }
      }
      const elm = isText$a(node) ? node.parentNode : node;
      return isElement$6(elm) ? elm : root;
    };
    const getSelectedBlocks = (dom, rng, startElm, endElm) => {
      const selectedBlocks = [];
      const root = dom.getRoot();
      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);
      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);
      if (start && start !== root) {
        selectedBlocks.push(start);
      }
      if (start && end && start !== end) {
        let node;
        const walker = new DomTreeWalker(start, root);
        while ((node = walker.next()) && node !== end) {
          if (dom.isBlock(node)) {
            selectedBlocks.push(node);
          }
        }
      }
      if (end && start !== end && end !== root) {
        selectedBlocks.push(end);
      }
      return selectedBlocks;
    };
    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {
      const idx = dom.nodeIndex(node);
      const rng = dom.createRng();
      rng.setStart(parent, idx);
      rng.setEnd(parent, idx + 1);
      if (content) {
        moveEndPoint(dom, rng, node, true);
        moveEndPoint(dom, rng, node, false);
      }
      return rng;
    }));

    const processRanges = (editor, ranges) => map$3(ranges, range => {
      const evt = editor.dispatch('GetSelectionRange', { range });
      return evt.range !== range ? evt.range : range;
    });

    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);
    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();
    const isContentEditableFalse$5 = elem => isHTMLElement(elem) && get$9(elem, 'contenteditable') === 'false';
    const elementsWithCursorPosition = [
      'img',
      'br'
    ];
    const isCursorPosition = elem => {
      const hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);
    };

    const first = element => descendant$1(element, isCursorPosition);
    const last = element => descendantRtl(element, isCursorPosition);
    const descendantRtl = (scope, predicate) => {
      const descend = element => {
        const children = children$1(element);
        for (let i = children.length - 1; i >= 0; i--) {
          const child = children[i];
          if (predicate(child)) {
            return Optional.some(child);
          }
          const res = descend(child);
          if (res.isSome()) {
            return res;
          }
        }
        return Optional.none();
      };
      return descend(scope);
    };

    const autocompleteSelector = '[data-mce-autocompleter]';
    const create$9 = (editor, range) => {
      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {
        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', editor.getDoc());
        append$1(wrapper, SugarElement.fromDom(range.extractContents()));
        range.insertNode(wrapper.dom);
        parent(wrapper).each(elm => elm.dom.normalize());
        last(wrapper).map(last => {
          editor.selection.setCursorLocation(last.dom, getEnd(last));
        });
      }
    };
    const detect$1 = elm => closest$3(elm, autocompleteSelector);
    const findIn = elm => descendant(elm, autocompleteSelector);
    const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {
      const bookmark = editor.selection.getBookmark();
      unwrap(wrapper);
      editor.selection.moveToBookmark(bookmark);
    });

    const typeLookup = {
      '#text': 3,
      '#comment': 8,
      '#cdata': 4,
      '#pi': 7,
      '#doctype': 10,
      '#document-fragment': 11
    };
    const walk$2 = (node, root, prev) => {
      const startName = prev ? 'lastChild' : 'firstChild';
      const siblingName = prev ? 'prev' : 'next';
      if (node[startName]) {
        return node[startName];
      }
      if (node !== root) {
        let sibling = node[siblingName];
        if (sibling) {
          return sibling;
        }
        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {
          sibling = parent[siblingName];
          if (sibling) {
            return sibling;
          }
        }
      }
      return undefined;
    };
    const isEmptyTextNode = node => {
      var _a;
      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
      if (!isWhitespaceText(text)) {
        return false;
      }
      const parentNode = node.parent;
      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {
        return false;
      }
      return true;
    };
    const isNonEmptyElement = node => {
      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;
    };
    class AstNode {
      static create(name, attrs) {
        const node = new AstNode(name, typeLookup[name] || 1);
        if (attrs) {
          each$d(attrs, (value, attrName) => {
            node.attr(attrName, value);
          });
        }
        return node;
      }
      constructor(name, type) {
        this.name = name;
        this.type = type;
        if (type === 1) {
          this.attributes = [];
          this.attributes.map = {};
        }
      }
      replace(node) {
        const self = this;
        if (node.parent) {
          node.remove();
        }
        self.insert(node, self);
        self.remove();
        return self;
      }
      attr(name, value) {
        const self = this;
        if (!isString(name)) {
          if (isNonNullable(name)) {
            each$d(name, (value, key) => {
              self.attr(key, value);
            });
          }
          return self;
        }
        const attrs = self.attributes;
        if (attrs) {
          if (value !== undefined) {
            if (value === null) {
              if (name in attrs.map) {
                delete attrs.map[name];
                let i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name) {
                    attrs.splice(i, 1);
                    return self;
                  }
                }
              }
              return self;
            }
            if (name in attrs.map) {
              let i = attrs.length;
              while (i--) {
                if (attrs[i].name === name) {
                  attrs[i].value = value;
                  break;
                }
              }
            } else {
              attrs.push({
                name,
                value
              });
            }
            attrs.map[name] = value;
            return self;
          }
          return attrs.map[name];
        }
        return undefined;
      }
      clone() {
        const self = this;
        const clone = new AstNode(self.name, self.type);
        const selfAttrs = self.attributes;
        if (selfAttrs) {
          const cloneAttrs = [];
          cloneAttrs.map = {};
          for (let i = 0, l = selfAttrs.length; i < l; i++) {
            const selfAttr = selfAttrs[i];
            if (selfAttr.name !== 'id') {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }
          clone.attributes = cloneAttrs;
        }
        clone.value = self.value;
        return clone;
      }
      wrap(wrapper) {
        const self = this;
        if (self.parent) {
          self.parent.insert(wrapper, self);
          wrapper.append(self);
        }
        return self;
      }
      unwrap() {
        const self = this;
        for (let node = self.firstChild; node;) {
          const next = node.next;
          self.insert(node, self, true);
          node = next;
        }
        self.remove();
      }
      remove() {
        const self = this, parent = self.parent, next = self.next, prev = self.prev;
        if (parent) {
          if (parent.firstChild === self) {
            parent.firstChild = next;
            if (next) {
              next.prev = null;
            }
          } else if (prev) {
            prev.next = next;
          }
          if (parent.lastChild === self) {
            parent.lastChild = prev;
            if (prev) {
              prev.next = null;
            }
          } else if (next) {
            next.prev = prev;
          }
          self.parent = self.next = self.prev = null;
        }
        return self;
      }
      append(node) {
        const self = this;
        if (node.parent) {
          node.remove();
        }
        const last = self.lastChild;
        if (last) {
          last.next = node;
          node.prev = last;
          self.lastChild = node;
        } else {
          self.lastChild = self.firstChild = node;
        }
        node.parent = self;
        return node;
      }
      insert(node, refNode, before) {
        if (node.parent) {
          node.remove();
        }
        const parent = refNode.parent || this;
        if (before) {
          if (refNode === parent.firstChild) {
            parent.firstChild = node;
          } else if (refNode.prev) {
            refNode.prev.next = node;
          }
          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } else {
          if (refNode === parent.lastChild) {
            parent.lastChild = node;
          } else if (refNode.next) {
            refNode.next.prev = node;
          }
          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }
        node.parent = parent;
        return node;
      }
      getAll(name) {
        const self = this;
        const collection = [];
        for (let node = self.firstChild; node; node = walk$2(node, self)) {
          if (node.name === name) {
            collection.push(node);
          }
        }
        return collection;
      }
      children() {
        const self = this;
        const collection = [];
        for (let node = self.firstChild; node; node = node.next) {
          collection.push(node);
        }
        return collection;
      }
      empty() {
        const self = this;
        if (self.firstChild) {
          const nodes = [];
          for (let node = self.firstChild; node; node = walk$2(node, self)) {
            nodes.push(node);
          }
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }
        self.firstChild = self.lastChild = null;
        return self;
      }
      isEmpty(elements, whitespace = {}, predicate) {
        var _a;
        const self = this;
        let node = self.firstChild;
        if (isNonEmptyElement(self)) {
          return false;
        }
        if (node) {
          do {
            if (node.type === 1) {
              if (node.attr('data-mce-bogus')) {
                continue;
              }
              if (elements[node.name]) {
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (node.type === 8) {
              return false;
            }
            if (node.type === 3 && !isEmptyTextNode(node)) {
              return false;
            }
            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {
              return false;
            }
            if (predicate && predicate(node)) {
              return false;
            }
          } while (node = walk$2(node, self));
        }
        return true;
      }
      walk(prev) {
        return walk$2(this, null, prev);
      }
    }

    const isConditionalComment = (html, startIndex) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
    const findCommentEndIndex = (html, isBogus, startIndex = 0) => {
      const lcHtml = html.toLowerCase();
      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
        const endIfIndex = lcHtml.indexOf('[endif]', startIndex);
        return lcHtml.indexOf('>', endIfIndex);
      } else {
        if (isBogus) {
          const endIndex = lcHtml.indexOf('>', startIndex);
          return endIndex !== -1 ? endIndex : lcHtml.length;
        } else {
          const endCommentRegexp = /--!?>/g;
          endCommentRegexp.lastIndex = startIndex;
          const match = endCommentRegexp.exec(html);
          return match ? match.index + match[0].length : lcHtml.length;
        }
      }
    };
    const findMatchingEndTagIndex = (schema, html, startIndex) => {
      const startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
      const endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
      const voidElements = schema.getVoidElements();
      let count = 1, index = startIndex;
      while (count !== 0) {
        startTagRegExp.lastIndex = index;
        while (true) {
          const startMatch = startTagRegExp.exec(html);
          if (startMatch === null) {
            return index;
          } else if (startMatch[1] === '!') {
            if (startsWith(startMatch[2], '--')) {
              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);
            } else {
              index = findCommentEndIndex(html, true, startMatch.index + 1);
            }
            break;
          } else {
            endTagRegExp.lastIndex = startTagRegExp.lastIndex;
            const endMatch = endTagRegExp.exec(html);
            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
              continue;
            }
            if (startMatch[1] === '/') {
              count -= 1;
            } else if (!has$2(voidElements, startMatch[2])) {
              count += 1;
            }
            index = startTagRegExp.lastIndex + endMatch[0].length;
            break;
          }
        }
      }
      return index;
    };
    const trimHtml$1 = (tempAttrs, html) => {
      const trimContentRegExp = new RegExp(['\\s?(' + tempAttrs.join('|') + ')="[^"]+"'].join('|'), 'gi');
      return html.replace(trimContentRegExp, '');
    };
    const trimInternal = (serializer, html) => {
      const bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
      const schema = serializer.schema;
      let content = trimHtml$1(serializer.getTempAttrs(), html);
      const voidElements = schema.getVoidElements();
      let matches;
      while (matches = bogusAllRegExp.exec(content)) {
        const index = bogusAllRegExp.lastIndex;
        const matchLength = matches[0].length;
        let endTagIndex;
        if (voidElements[matches[1]]) {
          endTagIndex = index;
        } else {
          endTagIndex = findMatchingEndTagIndex(schema, content, index);
        }
        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
        bogusAllRegExp.lastIndex = index - matchLength;
      }
      return trim$1(content);
    };
    const trimExternal = trimInternal;

    const cleanupBogusElements = parent => {
      const bogusElements = descendants(parent, '[data-mce-bogus]');
      each$e(bogusElements, elem => {
        const bogusValue = get$9(elem, 'data-mce-bogus');
        if (bogusValue === 'all') {
          remove$5(elem);
        } else if (isBr$5(elem)) {
          before$3(elem, SugarElement.fromText(zeroWidth));
          remove$5(elem);
        } else {
          unwrap(elem);
        }
      });
    };
    const cleanupInputNames = parent => {
      const inputs = descendants(parent, 'input');
      each$e(inputs, input => {
        remove$a(input, 'name');
      });
    };

    const trimEmptyContents = (editor, html) => {
      const blockName = getForcedRootBlock(editor);
      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${ blockName }>[\r\n]*|<br \\/>[\r\n]*)$`);
      return html.replace(emptyRegExp, '');
    };
    const getPlainTextContent = (editor, body) => {
      const doc = editor.getDoc();
      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
      const offscreenDiv = SugarElement.fromTag('div', doc);
      set$3(offscreenDiv, 'data-mce-bogus', 'all');
      setAll(offscreenDiv, {
        position: 'fixed',
        left: '-9999999px',
        top: '0'
      });
      set$1(offscreenDiv, body.innerHTML);
      cleanupBogusElements(offscreenDiv);
      cleanupInputNames(offscreenDiv);
      const root = getContentContainer(dos);
      append$1(root, offscreenDiv);
      const content = trim$1(offscreenDiv.dom.innerText);
      remove$5(offscreenDiv);
      return content;
    };
    const getContentFromBody = (editor, args, body) => {
      let content;
      if (args.format === 'raw') {
        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
      } else if (args.format === 'text') {
        content = getPlainTextContent(editor, body);
      } else if (args.format === 'tree') {
        content = editor.serializer.serialize(body, args);
      } else {
        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
      }
      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));
      return shouldTrim && isString(content) ? Tools.trim(content) : content;
    };
    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));

    const makeMap$1 = Tools.makeMap;
    const Writer = settings => {
      const html = [];
      settings = settings || {};
      const indent = settings.indent;
      const indentBefore = makeMap$1(settings.indent_before || '');
      const indentAfter = makeMap$1(settings.indent_after || '');
      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
      const htmlOutput = settings.element_format !== 'xhtml';
      return {
        start: (name, attrs, empty) => {
          if (indent && indentBefore[name] && html.length > 0) {
            const value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
          html.push('<', name);
          if (attrs) {
            for (let i = 0, l = attrs.length; i < l; i++) {
              const attr = attrs[i];
              html.push(' ', attr.name, '="', encode(attr.value, true), '"');
            }
          }
          if (!empty || htmlOutput) {
            html[html.length] = '>';
          } else {
            html[html.length] = ' />';
          }
          if (empty && indent && indentAfter[name] && html.length > 0) {
            const value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        end: name => {
          let value;
          html.push('</', name, '>');
          if (indent && indentAfter[name] && html.length > 0) {
            value = html[html.length - 1];
            if (value.length > 0 && value !== '\n') {
              html.push('\n');
            }
          }
        },
        text: (text, raw) => {
          if (text.length > 0) {
            html[html.length] = raw ? text : encode(text);
          }
        },
        cdata: text => {
          html.push('<![CDATA[', text, ']]>');
        },
        comment: text => {
          html.push('<!--', text, '-->');
        },
        pi: (name, text) => {
          if (text) {
            html.push('<?', name, ' ', encode(text), '?>');
          } else {
            html.push('<?', name, '?>');
          }
          if (indent) {
            html.push('\n');
          }
        },
        doctype: text => {
          html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
        },
        reset: () => {
          html.length = 0;
        },
        getContent: () => {
          return html.join('').replace(/\n$/, '');
        }
      };
    };

    const HtmlSerializer = (settings = {}, schema = Schema()) => {
      const writer = Writer(settings);
      settings.validate = 'validate' in settings ? settings.validate : true;
      const serialize = node => {
        const validate = settings.validate;
        const handlers = {
          3: node => {
            var _a;
            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);
          },
          8: node => {
            var _a;
            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          7: node => {
            writer.pi(node.name, node.value);
          },
          10: node => {
            var _a;
            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          4: node => {
            var _a;
            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');
          },
          11: node => {
            let tempNode = node;
            if (tempNode = tempNode.firstChild) {
              do {
                walk(tempNode);
              } while (tempNode = tempNode.next);
            }
          }
        };
        writer.reset();
        const walk = node => {
          var _a;
          const handler = handlers[node.type];
          if (!handler) {
            const name = node.name;
            const isEmpty = name in schema.getVoidElements();
            let attrs = node.attributes;
            if (validate && attrs && attrs.length > 1) {
              const sortedAttrs = [];
              sortedAttrs.map = {};
              const elementRule = schema.getElementRule(node.name);
              if (elementRule) {
                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                  const attrName = elementRule.attributesOrder[i];
                  if (attrName in attrs.map) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                for (let i = 0, l = attrs.length; i < l; i++) {
                  const attrName = attrs[i].name;
                  if (!(attrName in sortedAttrs.map)) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                attrs = sortedAttrs;
              }
            }
            writer.start(name, attrs, isEmpty);
            if (!isEmpty) {
              let child = node.firstChild;
              if (child) {
                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\n') {
                  writer.text('\n', true);
                }
                do {
                  walk(child);
                } while (child = child.next);
              }
              writer.end(name);
            }
          } else {
            handler(node);
          }
        };
        if (node.type === 1 && !settings.inner) {
          walk(node);
        } else if (node.type === 3) {
          handlers[3](node);
        } else {
          handlers[11](node);
        }
        return writer.getContent();
      };
      return { serialize };
    };

    const nonInheritableStyles = new Set();
    (() => {
      const nonInheritableStylesArr = [
        'margin',
        'margin-left',
        'margin-right',
        'margin-top',
        'margin-bottom',
        'padding',
        'padding-left',
        'padding-right',
        'padding-top',
        'padding-bottom',
        'border',
        'border-width',
        'border-style',
        'border-color',
        'background',
        'background-attachment',
        'background-clip',
        'background-color',
        'background-image',
        'background-origin',
        'background-position',
        'background-repeat',
        'background-size',
        'float',
        'position',
        'left',
        'right',
        'top',
        'bottom',
        'z-index',
        'display',
        'transform',
        'width',
        'max-width',
        'min-width',
        'height',
        'max-height',
        'min-height',
        'overflow',
        'overflow-x',
        'overflow-y',
        'text-overflow',
        'vertical-align',
        'transition',
        'transition-delay',
        'transition-duration',
        'transition-property',
        'transition-timing-function'
      ];
      each$e(nonInheritableStylesArr, style => {
        nonInheritableStyles.add(style);
      });
    })();
    const shorthandStyleProps = [
      'font',
      'text-decoration',
      'text-emphasis'
    ];
    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));
    const isNonInheritableStyle = style => nonInheritableStyles.has(style);
    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));
    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));
    const hasStyleConflict = (dom, node, parentNode) => {
      const nodeStyleProps = getStyleProps(dom, node);
      const parentNodeStyleProps = getStyleProps(dom, parentNode);
      const valueMismatch = prop => {
        var _a, _b;
        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';
        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';
        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
      };
      return exists(nodeStyleProps, nodeStyleProp => {
        const propExists = props => exists(props, prop => prop === nodeStyleProp);
        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
          return exists(longhandProps, valueMismatch);
        } else {
          return valueMismatch(nodeStyleProp);
        }
      });
    };

    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {
      const delta = forward ? 0 : -1;
      return predicate(text.data.charAt(pos.offset() + delta));
    });
    const isBeforeSpace = curry(isChar, true, isWhiteSpace);
    const isAfterSpace = curry(isChar, false, isWhiteSpace);
    const isEmptyText = pos => {
      const container = pos.container();
      return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();
    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';
    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);
    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    const isBeforeMedia = matchesElementPosition(true, isMedia$2);
    const isAfterMedia = matchesElementPosition(false, isMedia$2);
    const isBeforeTable = matchesElementPosition(true, isTable$2);
    const isAfterTable = matchesElementPosition(false, isTable$2);
    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);

    const dropLast = xs => xs.slice(0, -1);
    const parentsUntil = (start, root, predicate) => {
      if (contains(root, start)) {
        return dropLast(parents$1(start, elm => {
          return predicate(elm) || eq(elm, root);
        }));
      } else {
        return [];
      }
    };
    const parents = (start, root) => parentsUntil(start, root, never);
    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));

    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);
    const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
    const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));
    const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());
    const isAtStartOfBlock = curry(isAtBlockBoundary, false);
    const isAtEndOfBlock = curry(isAtBlockBoundary, true);
    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);

    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);
    const findBr = (forward, root, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      const scope = head(parentBlocks).getOr(root);
      return fromPosition(forward, scope.dom, pos).filter(isBr$1);
    };
    const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos).isSome();
    const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos).isSome();
    const findPreviousBr = curry(findBr, false);
    const findNextBr = curry(findBr, true);

    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    const getClosestBlock = (root, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
      return head(parentBlocks).getOr(root);
    };
    const hasSpaceBefore = (root, pos) => {
      if (isInMiddleOfText(pos)) {
        return isAfterSpace(pos);
      } else {
        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);
      }
    };
    const hasSpaceAfter = (root, pos) => {
      if (isInMiddleOfText(pos)) {
        return isBeforeSpace(pos);
      } else {
        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);
      }
    };
    const isPreValue = value => contains$2([
      'pre',
      'pre-wrap'
    ], value);
    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));
    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
    const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);
    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
    const isSiblingCefBlock = (root, direction) => container => {
      return isCefBlock(new DomTreeWalker(container, root)[direction]());
    };
    const isBeforeCefBlock = (root, pos) => {
      const nextPos = nextPosition(root.dom, pos).getOr(pos);
      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');
      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
    };
    const isAfterCefBlock = (root, pos) => {
      const prevPos = prevPosition(root.dom, pos).getOr(pos);
      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');
      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
    };
    const needsToHaveNbsp = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
      }
    };
    const needsToBeNbspLeft = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos) || isAfterCefBlock(root, pos);
      }
    };
    const leanRight = pos => {
      const container = pos.container();
      const offset = pos.offset();
      if (isText$a(container) && offset < container.data.length) {
        return CaretPosition(container, offset + 1);
      } else {
        return pos;
      }
    };
    const needsToBeNbspRight = (root, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos) || isBeforeCefBlock(root, pos);
      }
    };
    const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));
    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));
    const hasNbsp = pos => {
      const container = pos.container();
      return isText$a(container) && contains$1(container.data, nbsp);
    };
    const normalizeNbspMiddle = text => {
      const chars = text.split('');
      return map$3(chars, (chr, i) => {
        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
          return ' ';
        } else {
          return chr;
        }
      }).join('');
    };
    const normalizeNbspAtStart = (root, node, makeNbsp) => {
      const text = node.data;
      const firstPos = CaretPosition(node, 0);
      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
        node.data = ' ' + text.slice(1);
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos)) {
        node.data = nbsp + text.slice(1);
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspInMiddleOfTextNode = node => {
      const text = node.data;
      const newText = normalizeNbspMiddle(text);
      if (newText !== text) {
        node.data = newText;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspAtEnd = (root, node, makeNbsp) => {
      const text = node.data;
      const lastPos = CaretPosition(node, text.length - 1);
      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
        node.data = text.slice(0, -1) + ' ';
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos)) {
        node.data = text.slice(0, -1) + nbsp;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbsps = (root, pos) => {
      const container = pos.container();
      if (!isText$a(container)) {
        return Optional.none();
      }
      if (hasNbsp(pos)) {
        const normalized = normalizeNbspAtStart(root, container, false) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false);
        return someIf(normalized, pos);
      } else if (needsToBeNbsp(root, pos)) {
        const normalized = normalizeNbspAtStart(root, container, true) || normalizeNbspAtEnd(root, container, true);
        return someIf(normalized, pos);
      } else {
        return Optional.none();
      }
    };
    const normalizeNbspsInEditor = editor => {
      const root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(pos => {
          editor.selection.setRng(pos.toRange());
        });
      }
    };

    const normalize$1 = (node, offset, count) => {
      if (count === 0) {
        return;
      }
      const elm = SugarElement.fromDom(node);
      const root = ancestor$4(elm, isBlock$2).getOr(elm);
      const whitespace = node.data.slice(offset, offset + count);
      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
    };
    const normalizeWhitespaceAfter = (node, offset) => {
      const content = node.data.slice(offset);
      const whitespaceCount = content.length - lTrim(content).length;
      normalize$1(node, offset, whitespaceCount);
    };
    const normalizeWhitespaceBefore = (node, offset) => {
      const content = node.data.slice(0, offset);
      const whitespaceCount = content.length - rTrim(content).length;
      normalize$1(node, offset - whitespaceCount, whitespaceCount);
    };
    const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {
      const whitespaceOffset = rTrim(prevNode.data).length;
      const newNode = mergeToPrev ? prevNode : nextNode;
      const removeNode = mergeToPrev ? nextNode : prevNode;
      if (mergeToPrev) {
        newNode.appendData(removeNode.data);
      } else {
        newNode.insertData(0, removeNode.data);
      }
      remove$5(SugarElement.fromDom(removeNode));
      if (normalizeWhitespace) {
        normalizeWhitespaceAfter(newNode, whitespaceOffset);
      }
      return newNode;
    };

    const needsReposition = (pos, elm) => {
      const container = pos.container();
      const offset = pos.offset();
      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();
    };
    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    const getPreviousSiblingCaretPosition = elm => {
      if (isCaretCandidate$3(elm.previousSibling)) {
        return Optional.some(afterOrEndOf(elm.previousSibling));
      } else {
        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
      }
    };
    const getNextSiblingCaretPosition = elm => {
      if (isCaretCandidate$3(elm.nextSibling)) {
        return Optional.some(beforeOrStartOf(elm.nextSibling));
      } else {
        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
      }
    };
    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
    };
    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    const setSelection$1 = (editor, forward, pos) => {
      pos.fold(() => {
        editor.focus();
      }, pos => {
        editor.selection.setRng(pos.toRange(), forward);
      });
    };
    const eqRawNode = rawNode => elm => elm.dom === rawNode;
    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
    const paddEmptyBlock = elm => {
      if (isEmpty$2(elm)) {
        const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
        empty(elm);
        append$1(elm, br);
        return Optional.some(CaretPosition.before(br.dom));
      } else {
        return Optional.none();
      }
    };
    const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {
      const prevTextOpt = prevSibling(elm).filter(isText$b);
      const nextTextOpt = nextSibling(elm).filter(isText$b);
      remove$5(elm);
      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {
        const prevNode = prev.dom, nextNode = next.dom;
        const offset = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;
      }).orThunk(() => {
        if (normalizeWhitespace) {
          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length));
          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0));
        }
        return afterDeletePosOpt;
      });
    };
    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
    const deleteElement$2 = (editor, forward, elm, moveCaret = true) => {
      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('');
        editor.selection.setCursorLocation();
      } else {
        parentBlock.bind(paddEmptyBlock).fold(() => {
          if (moveCaret) {
            setSelection$1(editor, forward, normalizedAfterDeletePos);
          }
        }, paddPos => {
          if (moveCaret) {
            setSelection$1(editor, forward, Optional.some(paddPos));
          }
        });
      }
    };

    const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    const hasStrongRtl = text => strongRtl.test(text);

    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);
    const isRtl = element => {
      var _a;
      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');
    };
    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
    const findRootInline = (isInlineTarget, rootNode, pos) => {
      const parents = findInlineParents(isInlineTarget, rootNode, pos);
      return Optional.from(parents[parents.length - 1]);
    };
    const hasSameParentBlock = (rootNode, node1, node2) => {
      const block1 = getParentBlock$3(node1, rootNode);
      const block2 = getParentBlock$3(node2, rootNode);
      return isNonNullable(block1) && block1 === block2;
    };
    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);
    const normalizePosition = (forward, pos) => {
      const container = pos.container(), offset = pos.offset();
      if (forward) {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.nextSibling)) {
            return CaretPosition(container.nextSibling, 0);
          } else {
            return CaretPosition.after(container);
          }
        } else {
          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;
        }
      } else {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.previousSibling)) {
            return CaretPosition(container.previousSibling, container.previousSibling.data.length);
          } else {
            return CaretPosition.before(container);
          }
        } else {
          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;
        }
      }
    };
    const normalizeForwards = curry(normalizePosition, true);
    const normalizeBackwards = curry(normalizePosition, false);

    const execCommandIgnoreInputEvents = (editor, command) => {
      const inputBlocker = e => e.stopImmediatePropagation();
      editor.on('beforeinput input', inputBlocker, true);
      editor.getDoc().execCommand(command);
      editor.off('beforeinput input', inputBlocker);
    };
    const execEditorDeleteCommand = editor => {
      editor.execCommand('delete');
    };
    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');
    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');
    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);
    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);
    const getParentBlock$2 = (rootNode, elm) => {
      if (contains(rootNode, elm)) {
        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
      } else {
        return Optional.none();
      }
    };
    const paddEmptyBody = (editor, moveSelection = true) => {
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent('', { no_selection: !moveSelection });
      }
    };
    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      const normalizedFromPos = normalizePosition(false, fromPos);
      if (forward) {
        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
      } else {
        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
      }
    }).getOr(true);
    const freefallRtl = root => {
      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);
      return child.bind(freefallRtl).orThunk(() => Optional.some(root));
    };
    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {
      var _a;
      rng.deleteContents();
      const lastNode = freefallRtl(root).getOr(root);
      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
      if (lastBlock.dom === editor.getBody()) {
        paddEmptyBody(editor, moveSelection);
      } else if (isEmpty$2(lastBlock)) {
        fillWithPaddingBr(lastBlock);
        if (moveSelection) {
          editor.selection.setCursorLocation(lastBlock.dom, 0);
        }
      }
      if (!eq(root, lastBlock)) {
        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);
        each$e(additionalCleanupNodes.concat(children$1(root)), node => {
          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {
            remove$5(node);
          }
        });
      }
    };

    const isRootFromElement = root => cur => eq(root, cur);
    const getTableCells = table => descendants(table, 'td,th');
    const getTableDetailsFromRange = (rng, isRoot) => {
      const getTable = node => getClosestTable(SugarElement.fromDom(node), isRoot);
      const startTable = getTable(rng.startContainer);
      const endTable = getTable(rng.endContainer);
      const isStartInTable = startTable.isSome();
      const isEndInTable = endTable.isSome();
      const isSameTable = lift2(startTable, endTable, eq).getOr(false);
      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
      return {
        startTable,
        endTable,
        isStartInTable,
        isEndInTable,
        isSameTable,
        isMultiTable
      };
    };

    const tableCellRng = (start, end) => ({
      start,
      end
    });
    const tableSelection = (rng, table, cells) => ({
      rng,
      table,
      cells
    });
    const deleteAction = Adt.generate([
      {
        singleCellTable: [
          'rng',
          'cell'
        ]
      },
      { fullTable: ['table'] },
      {
        partialTable: [
          'cells',
          'outsideDetails'
        ]
      },
      {
        multiTable: [
          'startTableCells',
          'endTableCells',
          'betweenRng'
        ]
      }
    ]);
    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);
    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);
    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));
    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {
      const rows = table.dom.rows;
      return rows.length === 1 && rows[0].cells.length === 1;
    });
    const getCellRng = (rng, isRoot) => {
      const startCell = getClosestCell$1(rng.startContainer, isRoot);
      const endCell = getClosestCell$1(rng.endContainer, isRoot);
      return lift2(startCell, endCell, tableCellRng);
    };
    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));
    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));
    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));
    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {
      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
        return Optional.none();
      } else if (selectionDetails.isSameTable) {
        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: sameTableSelection,
          end: sameTableSelection
        });
      } else {
        const startCell = getClosestCell$1(rng.startContainer, isRoot);
        const endCell = getClosestCell$1(rng.endContainer, isRoot);
        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));
        return Optional.some({
          start: startTableSelection,
          end: endTableSelection
        });
      }
    };
    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));
    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));
    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));
    const unselectCells = (rng, selectionDetails) => {
      const {startTable, endTable} = selectionDetails;
      const otherContentRng = rng.cloneRange();
      startTable.each(table => otherContentRng.setStartAfter(table.dom));
      endTable.each(table => otherContentRng.setEndBefore(table.dom));
      return otherContentRng;
    };
    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {
      const {isSameTable} = selectionDetails;
      const selectedCells = getSelectedCells(tableSelection).getOr([]);
      if (isSameTable && tableSelection.cells.length === selectedCells.length) {
        return Optional.some(deleteAction.fullTable(tableSelection.table));
      } else if (selectedCells.length > 0) {
        if (isSameTable) {
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
        } else {
          const otherContentRng = unselectCells(rng, selectionDetails);
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
            ...selectionDetails,
            rng: otherContentRng
          })));
        }
      } else {
        return Optional.none();
      }
    });
    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {
      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);
      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);
      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
        const otherContentRng = unselectCells(rng, selectionDetails);
        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
      } else {
        return Optional.none();
      }
    });
    const getActionFromRange = (root, rng) => {
      const isRoot = isRootFromElement(root);
      const optCellRng = getCellRng(rng, isRoot);
      const selectionDetails = getTableDetailsFromRange(rng, isRoot);
      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {
        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));
      } else if (selectionDetails.isMultiTable) {
        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);
      } else {
        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);
      }
    };

    const cleanCells = cells => each$e(cells, cell => {
      remove$a(cell, 'contenteditable');
      fillWithPaddingBr(cell);
    });
    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {
      emptyBlock.each(block => {
        if (startInTable) {
          remove$5(block);
        } else {
          fillWithPaddingBr(block);
          editor.selection.setCursorLocation(block.dom, 0);
        }
      });
    };
    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {
      const insideTableRng = rng.cloneRange();
      if (isFirstCellInSelection) {
        insideTableRng.setStart(rng.startContainer, rng.startOffset);
        insideTableRng.setEndAfter(cell.dom.lastChild);
      } else {
        insideTableRng.setStartBefore(cell.dom.firstChild);
        insideTableRng.setEnd(rng.endContainer, rng.endOffset);
      }
      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());
    };
    const collapseAndRestoreCellSelection = editor => {
      const selectedCells = getCellsFromEditor(editor);
      const selectedNode = SugarElement.fromDom(editor.selection.getNode());
      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {
        editor.selection.setCursorLocation(selectedNode.dom, 0);
      } else {
        editor.selection.collapse(true);
      }
      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {
        set$3(selectedNode, 'data-mce-selected', '1');
      }
    };
    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {
      const editorRng = editor.selection.getRng();
      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {
        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
        rng.deleteContents();
        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];
        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
        if (!isEmpty$2(endPointCell)) {
          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));
        } else {
          return Optional.none();
        }
      }).getOr(cells);
      cleanCells(cellsToClean);
      collapseAndRestoreCellSelection(editor);
    });
    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
      const rng = editor.selection.getRng();
      const startCell = startTableCells[0];
      const endCell = endTableCells[endTableCells.length - 1];
      deleteContentInsideCell(editor, startCell, rng, true);
      deleteContentInsideCell(editor, endCell, rng, false);
      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
      betweenRng.deleteContents();
      collapseAndRestoreCellSelection(editor);
    });
    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {
      deleteRangeContents(editor, rng, cell, moveSelection);
    });
    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));
    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));
    const deleteRange$3 = (editor, startElm, selectedCells) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
    };
    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));
    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));
    const emptyElement = (editor, elm) => Optional.some(() => {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
    });
    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);
    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));
    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));
    const deleteCaretCells = (editor, forward, rootElm, startElm) => {
      const from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));
    };
    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
      const from = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
    };
    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
    const isBeforeOrAfterTable = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));
    };
    const deleteCaret$3 = (editor, forward, startElm) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));
    };
    const backspaceDelete$a = (editor, forward) => {
      const startElm = SugarElement.fromDom(editor.selection.getStart(true));
      const cells = getCellsFromEditor(editor);
      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);
    };

    const getContentEditableRoot$1 = (root, node) => {
      let tempNode = node;
      while (tempNode && tempNode !== root) {
        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {
          return tempNode;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };

    const internalAttributesPrefixes = [
      'data-ephox-',
      'data-mce-',
      'data-alloy-',
      'data-snooker-',
      '_'
    ];
    const each$9 = Tools.each;
    const ElementUtils = editor => {
      const dom = editor.dom;
      const internalAttributes = new Set(editor.serializer.getTempAttrs());
      const compare = (node1, node2) => {
        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
          return false;
        }
        const getAttribs = node => {
          const attribs = {};
          each$9(dom.getAttribs(node), attr => {
            const name = attr.nodeName.toLowerCase();
            if (name !== 'style' && !isAttributeInternal(name)) {
              attribs[name] = dom.getAttrib(node, name);
            }
          });
          return attribs;
        };
        const compareObjects = (obj1, obj2) => {
          for (const name in obj1) {
            if (has$2(obj1, name)) {
              const value = obj2[name];
              if (isUndefined(value)) {
                return false;
              }
              if (obj1[name] !== value) {
                return false;
              }
              delete obj2[name];
            }
          }
          for (const name in obj2) {
            if (has$2(obj2, name)) {
              return false;
            }
          }
          return true;
        };
        if (isElement$6(node1) && isElement$6(node2)) {
          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
            return false;
          }
          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
            return false;
          }
        }
        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
      };
      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);
      return {
        compare,
        isAttributeInternal
      };
    };

    const traverse = (root, fn) => {
      let node = root;
      while (node = node.walk()) {
        fn(node);
      }
    };
    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
      const name = node.name;
      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
        const filter = nodeFilters[ni];
        if (filter.name === name) {
          const match = matches.nodes[name];
          if (match) {
            match.nodes.push(node);
          } else {
            matches.nodes[name] = {
              filter,
              nodes: [node]
            };
          }
        }
      }
      if (node.attributes) {
        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
          const filter = attributeFilters[ai];
          const attrName = filter.name;
          if (attrName in node.attributes.map) {
            const match = matches.attributes[attrName];
            if (match) {
              match.nodes.push(node);
            } else {
              matches.attributes[attrName] = {
                filter,
                nodes: [node]
              };
            }
          }
        }
      }
    };
    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
      const matches = {
        nodes: {},
        attributes: {}
      };
      if (node.firstChild) {
        traverse(node, childNode => {
          matchNode$1(nodeFilters, attributeFilters, childNode, matches);
        });
      }
      return matches;
    };
    const runFilters = (matches, args) => {
      const run = (matchRecord, filteringAttributes) => {
        each$d(matchRecord, match => {
          const nodes = from(match.nodes);
          each$e(match.filter.callbacks, callback => {
            for (let i = nodes.length - 1; i >= 0; i--) {
              const node = nodes[i];
              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;
              if (!valueMatches || isNullable(node.parent)) {
                nodes.splice(i, 1);
              }
            }
            if (nodes.length > 0) {
              callback(nodes, match.filter.name, args);
            }
          });
        });
      };
      run(matches.nodes, false);
      run(matches.attributes, true);
    };
    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
      runFilters(matches, args);
    };

    const paddEmptyNode = (settings, args, isBlock, node) => {
      const brPreferred = settings.pad_empty_with_br || args.insert;
      if (brPreferred && isBlock(node)) {
        const astNode = new AstNode('br', 1);
        if (args.insert) {
          astNode.attr('data-mce-bogus', '1');
        }
        node.empty().append(astNode);
      } else {
        node.empty().append(new AstNode('#text', 3)).value = nbsp;
      }
    };
    const isPaddedWithNbsp = node => {
      var _a;
      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;
    };
    const hasOnlyChild = (node, name) => {
      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;
      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;
    };
    const isPadded = (schema, node) => {
      const rule = schema.getElementRule(node.name);
      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
    };
    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));
    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');
    const findClosestEditingHost = scope => {
      let editableNode;
      for (let node = scope; node; node = node.parent) {
        const contentEditable = node.attr('contenteditable');
        if (contentEditable === 'false') {
          break;
        } else if (contentEditable === 'true') {
          editableNode = node;
        }
      }
      return Optional.from(editableNode);
    };

    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
      if (schema.getSpecialElements()[node.name]) {
        node.empty().remove();
      } else {
        const children = node.children();
        for (const childNode of children) {
          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
          }
        }
        node.unwrap();
      }
    };
    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {
      const textBlockElements = schema.getTextBlockElements();
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');
      const fixed = new Set();
      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];
      for (let ni = 0; ni < nodes.length; ni++) {
        const node = nodes[ni];
        let parent;
        let newParent;
        let tempNode;
        if (!node.parent || fixed.has(node)) {
          continue;
        }
        if (textBlockElements[node.name] && node.parent.name === 'li') {
          let sibling = node.next;
          while (sibling) {
            if (textBlockElements[sibling.name]) {
              sibling.name = 'li';
              fixed.add(sibling);
              node.parent.insert(sibling, node.parent);
            } else {
              break;
            }
            sibling = sibling.next;
          }
          node.unwrap();
          continue;
        }
        const parents = [node];
        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {
          parents.push(parent);
        }
        if (parent && parents.length > 1) {
          if (schema.isValidChild(parent.name, node.name)) {
            parents.reverse();
            newParent = parents[0].clone();
            onCreate(newParent);
            let currentNode = newParent;
            for (let i = 0; i < parents.length - 1; i++) {
              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {
                tempNode = parents[i].clone();
                onCreate(tempNode);
                currentNode.append(tempNode);
              } else {
                tempNode = currentNode;
              }
              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
                const nextNode = childNode.next;
                tempNode.append(childNode);
                childNode = nextNode;
              }
              currentNode = tempNode;
            }
            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
              parent.insert(newParent, parents[0], true);
              parent.insert(node, newParent);
            } else {
              parent.insert(node, parents[0], true);
            }
            parent = parents[0];
            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {
              parent.empty().remove();
            }
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        } else if (node.parent) {
          if (node.name === 'li') {
            let sibling = node.prev;
            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
              sibling.append(node);
              continue;
            }
            sibling = node.next;
            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {
              sibling.insert(node, sibling.firstChild, true);
              continue;
            }
            const wrapper = new AstNode('ul', 1);
            onCreate(wrapper);
            node.wrap(wrapper);
            continue;
          }
          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
            const wrapper = new AstNode('div', 1);
            onCreate(wrapper);
            node.wrap(wrapper);
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        }
      }
    };
    const hasClosest = (node, parentName) => {
      let tempNode = node;
      while (tempNode) {
        if (tempNode.name === parentName) {
          return true;
        }
        tempNode = tempNode.parent;
      }
      return false;
    };
    const isInvalid = (schema, node, parent = node.parent) => {
      if (parent && schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {
        return true;
      } else if (parent && node.name === 'a' && hasClosest(parent, 'a')) {
        return true;
      } else {
        return false;
      }
    };

    const createRange = (sc, so, ec, eo) => {
      const rng = document.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      return rng;
    };
    const normalizeBlockSelectionRange = rng => {
      const startPos = CaretPosition.fromRangeStart(rng);
      const endPos = CaretPosition.fromRangeEnd(rng);
      const rootNode = rng.commonAncestorContainer;
      return fromPosition(false, rootNode, endPos).map(newEndPos => {
        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
        } else {
          return rng;
        }
      }).getOr(rng);
    };
    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);

    const hasOnlyOneChild$1 = node => {
      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
    };
    const isPaddingNode = node => {
      return node.name === 'br' || node.value === nbsp;
    };
    const isPaddedEmptyBlock = (schema, node) => {
      const blockElements = schema.getBlockElements();
      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
    };
    const isEmptyFragmentElement = (schema, node) => {
      const nonEmptyElements = schema.getNonEmptyElements();
      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    const isListFragment = (schema, fragment) => {
      let firstChild = fragment.firstChild;
      let lastChild = fragment.lastChild;
      if (firstChild && firstChild.name === 'meta') {
        firstChild = firstChild.next;
      }
      if (lastChild && lastChild.attr('id') === 'mce_marker') {
        lastChild = lastChild.prev;
      }
      if (isEmptyFragmentElement(schema, lastChild)) {
        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;
      }
      if (!firstChild || firstChild !== lastChild) {
        return false;
      }
      return firstChild.name === 'ul' || firstChild.name === 'ol';
    };
    const cleanupDomFragment = domFragment => {
      var _a, _b;
      const firstChild = domFragment.firstChild;
      const lastChild = domFragment.lastChild;
      if (firstChild && firstChild.nodeName === 'META') {
        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);
      }
      if (lastChild && lastChild.id === 'mce_marker') {
        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);
      }
      return domFragment;
    };
    const toDomFragment = (dom, serializer, fragment) => {
      const html = serializer.serialize(fragment);
      const domFragment = dom.createFragment(html);
      return cleanupDomFragment(domFragment);
    };
    const listItems = elm => {
      var _a;
      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {
        return child.nodeName === 'LI';
      });
    };
    const isPadding = node => {
      return node.data === nbsp || isBr$6(node);
    };
    const isListItemPadded = node => {
      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    const isEmptyOrPadded = elm => {
      return !elm.firstChild || isListItemPadded(elm);
    };
    const trimListItems = elms => {
      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    const getParentLi = (dom, node) => {
      const parentBlock = dom.getParent(node, dom.isBlock);
      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };
    const isParentBlockLi = (dom, node) => {
      return !!getParentLi(dom, node);
    };
    const getSplit = (parentNode, rng) => {
      const beforeRng = rng.cloneRange();
      const afterRng = rng.cloneRange();
      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);
      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };
    const findFirstIn = (node, rootNode) => {
      const caretPos = CaretPosition.before(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.next(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const findLastOf = (node, rootNode) => {
      const caretPos = CaretPosition.after(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.prev(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const insertMiddle = (target, elms, rootNode, rng) => {
      const parts = getSplit(target, rng);
      const parentElm = target.parentNode;
      if (parentElm) {
        parentElm.insertBefore(parts[0], target);
        Tools.each(elms, li => {
          parentElm.insertBefore(li, target);
        });
        parentElm.insertBefore(parts[1], target);
        parentElm.removeChild(target);
      }
      return findLastOf(elms[elms.length - 1], rootNode);
    };
    const insertBefore$2 = (target, elms, rootNode) => {
      const parentElm = target.parentNode;
      if (parentElm) {
        Tools.each(elms, elm => {
          parentElm.insertBefore(elm, target);
        });
      }
      return findFirstIn(target, rootNode);
    };
    const insertAfter$2 = (target, elms, rootNode, dom) => {
      dom.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };
    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {
      const domFragment = toDomFragment(dom, serializer, fragment);
      const liTarget = getParentLi(dom, rng.startContainer);
      const liElms = trimListItems(listItems(domFragment.firstChild));
      const BEGINNING = 1, END = 2;
      const rootNode = dom.getRoot();
      const isAt = location => {
        const caretPos = CaretPosition.fromRangeStart(rng);
        const caretWalker = CaretWalker(dom.getRoot());
        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;
      };
      if (!liTarget) {
        return null;
      } else if (isAt(BEGINNING)) {
        return insertBefore$2(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter$2(liTarget, liElms, rootNode, dom);
      } else {
        return insertMiddle(liTarget, liElms, rootNode, rng);
      }
    };

    const mergeableWrappedElements = ['pre'];
    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {
      var _a;
      const firstNode = fragment.firstChild;
      const lastNode = fragment.lastChild;
      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;
      const isPastingSingleElement = firstNode === last;
      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
      if (isPastingSingleElement && isWrappedElement) {
        const isContentEditable = firstNode.attr('contenteditable') !== 'false';
        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;
      } else {
        return false;
      }
    };
    const isTableCell = isTableCell$3;
    const isTableCellContentSelected = (dom, rng, cell) => {
      if (isNonNullable(cell)) {
        const endCell = dom.getParent(rng.endContainer, isTableCell);
        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);
      } else {
        return false;
      }
    };
    const validInsertion = (editor, value, parentNode) => {
      var _a;
      if (parentNode.getAttribute('data-mce-bogus') === 'all') {
        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);
      } else {
        const node = parentNode.firstChild;
        const node2 = parentNode.lastChild;
        if (!node || node === node2 && node.nodeName === 'BR') {
          editor.dom.setHTML(parentNode, value);
        } else {
          editor.selection.setContent(value, { no_events: true });
        }
      }
    };
    const trimBrsFromTableCell = (dom, elm) => {
      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);
    };
    const reduceInlineTextElements = (editor, merge) => {
      const textInlineElements = editor.schema.getTextInlineElements();
      const dom = editor.dom;
      if (merge) {
        const root = editor.getBody();
        const elementUtils = ElementUtils(editor);
        Tools.each(dom.select('*[data-mce-fragment]'), node => {
          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
          if (isInline && hasInheritableStyles(dom, node)) {
            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {
              const styleConflict = hasStyleConflict(dom, node, parentNode);
              if (styleConflict) {
                break;
              }
              if (elementUtils.compare(parentNode, node)) {
                dom.remove(node, true);
                break;
              }
            }
          }
        });
      }
    };
    const markFragmentElements = fragment => {
      let node = fragment;
      while (node = node.walk()) {
        if (node.type === 1) {
          node.attr('data-mce-fragment', '1');
        }
      }
    };
    const unmarkFragmentElements = elm => {
      Tools.each(elm.getElementsByTagName('*'), elm => {
        elm.removeAttribute('data-mce-fragment');
      });
    };
    const isPartOfFragment = node => {
      return !!node.getAttribute('data-mce-fragment');
    };
    const canHaveChildren = (editor, node) => {
      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
    };
    const moveSelectionToMarker = (editor, marker) => {
      var _a, _b, _c;
      let nextRng;
      const dom = editor.dom;
      const selection = editor.selection;
      if (!marker) {
        return;
      }
      selection.scrollIntoView(marker);
      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {
        dom.remove(marker);
        selection.select(parentEditableElm);
        return;
      }
      let rng = dom.createRng();
      const node = marker.previousSibling;
      if (isText$a(node)) {
        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        const node2 = marker.nextSibling;
        if (isText$a(node2)) {
          node.appendData(node2.data);
          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
        }
      } else {
        rng.setStartBefore(marker);
        rng.setEndBefore(marker);
      }
      const findNextCaretRng = rng => {
        let caretPos = CaretPosition.fromRangeStart(rng);
        const caretWalker = CaretWalker(editor.getBody());
        caretPos = caretWalker.next(caretPos);
        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
      };
      const parentBlock = dom.getParent(marker, dom.isBlock);
      dom.remove(marker);
      if (parentBlock && dom.isEmpty(parentBlock)) {
        const isCell = isTableCell(parentBlock);
        empty(SugarElement.fromDom(parentBlock));
        rng.setStart(parentBlock, 0);
        rng.setEnd(parentBlock, 0);
        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
          rng = nextRng;
          dom.remove(parentBlock);
        } else {
          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));
        }
      }
      selection.setRng(rng);
    };
    const deleteSelectedContent = editor => {
      const dom = editor.dom;
      const rng = normalize(editor.selection.getRng());
      editor.selection.setRng(rng);
      const startCell = dom.getParent(rng.startContainer, isTableCell);
      if (isTableCellContentSelected(dom, rng, startCell)) {
        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {
        rng.deleteContents();
      } else {
        editor.getDoc().execCommand('Delete', false);
      }
    };
    const findMarkerNode = scope => {
      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
        if (markerNode.attr('id') === 'mce_marker') {
          return Optional.some(markerNode);
        }
      }
      return Optional.none();
    };
    const insertHtmlAtCaret = (editor, value, details) => {
      var _a, _b;
      const selection = editor.selection;
      const dom = editor.dom;
      const parser = editor.parser;
      const merge = details.merge;
      const serializer = HtmlSerializer({ validate: true }, editor.schema);
      const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      if (value.indexOf('{$caret}') === -1) {
        value += '{$caret}';
      }
      value = value.replace(/\{\$caret\}/, bookmarkHtml);
      let rng = selection.getRng();
      const caretElement = rng.startContainer;
      const body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
          rng = dom.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }
      if (!selection.isCollapsed()) {
        deleteSelectedContent(editor);
      }
      const parentNode = selection.getNode();
      const parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data,
        insert: true
      };
      const fragment = parser.parse(value, parserArgs);
      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {
        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);
        if (rng) {
          selection.setRng(rng);
        }
        return value;
      }
      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {
        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
      }
      markFragmentElements(fragment);
      let node = fragment.lastChild;
      if (node && node.attr('id') === 'mce_marker') {
        const marker = node;
        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type === 3 || !dom.isBlock(node.name)) {
            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {
              node.parent.insert(marker, node, node.name === 'br');
            }
            break;
          }
        }
      }
      editor._selectionOverrides.showBlockCaretContainer(parentNode);
      if (!parserArgs.invalid) {
        value = serializer.serialize(fragment);
        validInsertion(editor, value, parentNode);
      } else {
        editor.selection.setContent(bookmarkHtml);
        let parentNode = selection.getNode();
        let tempNode;
        const rootNode = editor.getBody();
        if (isDocument$1(parentNode)) {
          parentNode = tempNode = rootNode;
        } else {
          tempNode = parentNode;
        }
        while (tempNode && tempNode !== rootNode) {
          parentNode = tempNode;
          tempNode = tempNode.parentNode;
        }
        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
        const root = parser.parse(value);
        const markerNode = findMarkerNode(root);
        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
        markerNode.each(marker => marker.replace(fragment));
        const toExtract = fragment.children();
        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
        fragment.unwrap();
        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));
        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);
        value = serializer.serialize(root);
        if (parentNode === rootNode) {
          dom.setHTML(rootNode, value);
        } else {
          dom.setOuterHTML(parentNode, value);
        }
      }
      reduceInlineTextElements(editor, merge);
      moveSelectionToMarker(editor, dom.get('mce_marker'));
      unmarkFragmentElements(editor.getBody());
      trimBrsFromTableCell(dom, selection.getStart());
      updateCaret(editor.schema, editor.getBody(), selection.getStart());
      return value;
    };

    const isTreeNode = content => content instanceof AstNode;

    const moveSelection = editor => {
      if (hasFocus(editor)) {
        firstPositionIn(editor.getBody()).each(pos => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const setEditorHtml = (editor, html, noSelection) => {
      editor.dom.setHTML(editor.getBody(), html);
      if (noSelection !== true) {
        moveSelection(editor);
      }
    };
    const setContentString = (editor, body, content, args) => {
      if (content.length === 0 || /^\s+$/.test(content)) {
        const padd = '<br data-mce-bogus="1">';
        if (body.nodeName === 'TABLE') {
          content = '<tr><td>' + padd + '</td></tr>';
        } else if (/^(UL|OL)$/.test(body.nodeName)) {
          content = '<li>' + padd + '</li>';
        }
        const forcedRootBlockName = getForcedRootBlock(editor);
        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
          content = padd;
          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
        } else if (!content) {
          content = padd;
        }
        setEditorHtml(editor, content, args.no_selection);
        return {
          content,
          html: content
        };
      } else {
        if (args.format !== 'raw') {
          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {
            isRootContent: true,
            insert: true
          }));
        }
        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
        setEditorHtml(editor, trimmedHtml, args.no_selection);
        return {
          content: trimmedHtml,
          html: trimmedHtml
        };
      }
    };
    const setContentTree = (editor, body, content, args) => {
      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);
      setEditorHtml(editor, trimmedHtml, args.no_selection);
      return {
        content,
        html: trimmedHtml
      };
    };
    const setContentInternal = (editor, content, args) => {
      return Optional.from(editor.getBody()).map(body => {
        if (isTreeNode(content)) {
          return setContentTree(editor, body, content, args);
        } else {
          return setContentString(editor, body, content, args);
        }
      }).getOr({
        content,
        html: isTreeNode(args.content) ? '' : args.content
      });
    };

    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();
    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();

    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;
    const ancestor = (scope, transform, isRoot) => {
      let element = scope.dom;
      const stop = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        const transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$1 = (scope, transform, isRoot) => {
      const current = transform(scope);
      const stop = ensureIsRoot(isRoot);
      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));
    };

    const isEq$3 = isEq$5;
    const matchesUnInheritedFormatSelector = (ed, node, name) => {
      const formatList = ed.formatter.get(name);
      if (formatList) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
            return true;
          }
        }
      }
      return false;
    };
    const matchParents = (editor, node, name, vars, similar) => {
      const root = editor.dom.getRoot();
      if (node === root) {
        return false;
      }
      const matchedNode = editor.dom.getParent(node, elm => {
        if (matchesUnInheritedFormatSelector(editor, elm, name)) {
          return true;
        }
        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);
      });
      return !!matchNode(editor, matchedNode, name, vars, similar);
    };
    const matchName = (dom, node, format) => {
      if (isInlineFormat(format) && isEq$3(node, format.inline)) {
        return true;
      }
      if (isBlockFormat(format) && isEq$3(node, format.block)) {
        return true;
      }
      if (isSelectorFormat(format)) {
        return isElement$6(node) && dom.is(node, format.selector);
      }
      return false;
    };
    const matchItems = (dom, node, format, itemName, similar, vars) => {
      const items = format[itemName];
      const matchAttributes = itemName === 'attributes';
      if (isFunction(format.onmatch)) {
        return format.onmatch(node, format, itemName);
      }
      if (items) {
        if (!isArrayLike(items)) {
          for (const key in items) {
            if (has$2(items, key)) {
              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);
              const expectedValue = replaceVars(items[key], vars);
              const isEmptyValue = isNullable(value) || isEmpty$3(value);
              if (isEmptyValue && isNullable(expectedValue)) {
                continue;
              }
              if (similar && isEmptyValue && !format.exact) {
                return false;
              }
              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {
                return false;
              }
            }
          }
        } else {
          for (let i = 0; i < items.length; i++) {
            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
              return true;
            }
          }
        }
      }
      return true;
    };
    const matchNode = (ed, node, name, vars, similar) => {
      const formatList = ed.formatter.get(name);
      const dom = ed.dom;
      if (formatList && isElement$6(node)) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
            const classes = format.classes;
            if (classes) {
              for (let x = 0; x < classes.length; x++) {
                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                  return;
                }
              }
            }
            return format;
          }
        }
      }
      return undefined;
    };
    const match$2 = (editor, name, vars, node, similar) => {
      if (node) {
        return matchParents(editor, node, name, vars, similar);
      }
      node = editor.selection.getNode();
      if (matchParents(editor, node, name, vars, similar)) {
        return true;
      }
      const startNode = editor.selection.getStart();
      if (startNode !== node) {
        if (matchParents(editor, startNode, name, vars, similar)) {
          return true;
        }
      }
      return false;
    };
    const matchAll = (editor, names, vars) => {
      const matchedFormatNames = [];
      const checkedMap = {};
      const startElement = editor.selection.getStart();
      editor.dom.getParent(startElement, node => {
        for (let i = 0; i < names.length; i++) {
          const name = names[i];
          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {
            checkedMap[name] = true;
            matchedFormatNames.push(name);
          }
        }
      }, editor.dom.getRoot());
      return matchedFormatNames;
    };
    const closest = (editor, names) => {
      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));
      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();
      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();
    };
    const canApply = (editor, name) => {
      const formatList = editor.formatter.get(name);
      const dom = editor.dom;
      if (formatList && editor.selection.isEditable()) {
        const startNode = editor.selection.getStart();
        const parents = getParents$2(dom, startNode);
        for (let x = formatList.length - 1; x >= 0; x--) {
          const format = formatList[x];
          if (!isSelectorFormat(format)) {
            return true;
          }
          for (let i = parents.length - 1; i >= 0; i--) {
            if (dom.is(parents[i], format.selector)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {
      const matchSimilar = isVariableFormatName(editor, name);
      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {
        return acc.concat([name]);
      } else {
        return acc;
      }
    }, []);

    const ZWSP = ZWSP$1;
    const importNode = (ownerDocument, node) => {
      return ownerDocument.importNode(node, true);
    };
    const getEmptyCaretContainers = node => {
      const nodes = [];
      let tempNode = node;
      while (tempNode) {
        if (isText$a(tempNode) && tempNode.data !== ZWSP || tempNode.childNodes.length > 1) {
          return [];
        }
        if (isElement$6(tempNode)) {
          nodes.push(tempNode);
        }
        tempNode = tempNode.firstChild;
      }
      return nodes;
    };
    const isCaretContainerEmpty = node => {
      return getEmptyCaretContainers(node).length > 0;
    };
    const findFirstTextNode = node => {
      if (node) {
        const walker = new DomTreeWalker(node, node);
        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
          if (isText$a(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const createCaretContainer = fill => {
      const caretContainer = SugarElement.fromTag('span');
      setAll$1(caretContainer, {
        'id': CARET_ID,
        'data-mce-bogus': '1',
        'data-mce-type': 'format-caret'
      });
      if (fill) {
        append$1(caretContainer, SugarElement.fromText(ZWSP));
      }
      return caretContainer;
    };
    const trimZwspFromCaretContainer = caretContainerNode => {
      const textNode = findFirstTextNode(caretContainerNode);
      if (textNode && textNode.data.charAt(0) === ZWSP) {
        textNode.deleteData(0, 1);
      }
      return textNode;
    };
    const removeCaretContainerNode = (editor, node, moveCaret = true) => {
      const dom = editor.dom, selection = editor.selection;
      if (isCaretContainerEmpty(node)) {
        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);
      } else {
        const rng = selection.getRng();
        const block = dom.getParent(node, dom.isBlock);
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        const textNode = trimZwspFromCaretContainer(node);
        dom.remove(node, true);
        if (startContainer === textNode && startOffset > 0) {
          rng.setStart(textNode, startOffset - 1);
        }
        if (endContainer === textNode && endOffset > 0) {
          rng.setEnd(textNode, endOffset - 1);
        }
        if (block && dom.isEmpty(block)) {
          fillWithPaddingBr(SugarElement.fromDom(block));
        }
        selection.setRng(rng);
      }
    };
    const removeCaretContainer = (editor, node, moveCaret = true) => {
      const dom = editor.dom, selection = editor.selection;
      if (!node) {
        node = getParentCaretContainer(editor.getBody(), selection.getStart());
        if (!node) {
          while (node = dom.get(CARET_ID)) {
            removeCaretContainerNode(editor, node, moveCaret);
          }
        }
      } else {
        removeCaretContainerNode(editor, node, moveCaret);
      }
    };
    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
      var _a, _b;
      const dom = editor.dom;
      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));
      if (block && dom.isEmpty(block)) {
        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
      } else {
        removeTrailingBr(SugarElement.fromDom(formatNode));
        if (dom.isEmpty(formatNode)) {
          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
        } else {
          dom.insertAfter(caretContainer, formatNode);
        }
      }
    };
    const appendNode = (parentNode, node) => {
      parentNode.appendChild(node);
      return node;
    };
    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
      var _a;
      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
        return appendNode(parentNode, formatNode.cloneNode(false));
      }, caretContainer);
      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
    };
    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {
      const formatter = editor.formatter;
      const dom = editor.dom;
      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));
      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));
      if (uniqueFormats.length > 0) {
        const clonedFormatNode = formatNode.cloneNode(false);
        dom.add(caretContainer, clonedFormatNode);
        formatter.remove(name, vars, clonedFormatNode, similar);
        dom.remove(clonedFormatNode);
        return Optional.some(clonedFormatNode);
      } else {
        return Optional.none();
      }
    };
    const applyCaretFormat = (editor, name, vars) => {
      let caretContainer;
      const selection = editor.selection;
      const formatList = editor.formatter.get(name);
      if (!formatList) {
        return;
      }
      const selectionRng = selection.getRng();
      let offset = selectionRng.startOffset;
      const container = selectionRng.startContainer;
      const text = container.nodeValue;
      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
      const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
        const bookmark = selection.getBookmark();
        selectionRng.collapse(true);
        let rng = expandRng(editor.dom, selectionRng, formatList);
        rng = split(rng);
        editor.formatter.apply(name, vars, rng);
        selection.moveToBookmark(bookmark);
      } else {
        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
          textNode = caretContainer.firstChild;
          selectionRng.insertNode(caretContainer);
          offset = 1;
          editor.formatter.apply(name, vars, caretContainer);
        } else {
          editor.formatter.apply(name, vars, caretContainer);
        }
        selection.setCursorLocation(textNode, offset);
      }
    };
    const removeCaretFormat = (editor, name, vars, similar) => {
      const dom = editor.dom;
      const selection = editor.selection;
      let hasContentAfter = false;
      const formatList = editor.formatter.get(name);
      if (!formatList) {
        return;
      }
      const rng = selection.getRng();
      const container = rng.startContainer;
      const offset = rng.startOffset;
      let node = container;
      if (isText$a(container)) {
        if (offset !== container.data.length) {
          hasContentAfter = true;
        }
        node = node.parentNode;
      }
      const parents = [];
      let formatNode;
      while (node) {
        if (matchNode(editor, node, name, vars, similar)) {
          formatNode = node;
          break;
        }
        if (node.nextSibling) {
          hasContentAfter = true;
        }
        parents.push(node);
        node = node.parentNode;
      }
      if (!formatNode) {
        return;
      }
      if (hasContentAfter) {
        const bookmark = selection.getBookmark();
        rng.collapse(true);
        let expandedRng = expandRng(dom, rng, formatList, true);
        expandedRng = split(expandedRng);
        editor.formatter.remove(name, vars, expandedRng, similar);
        selection.moveToBookmark(bookmark);
      } else {
        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
        const newCaretContainer = createCaretContainer(false).dom;
        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);
        const caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);
        if (caretContainer) {
          removeCaretContainerNode(editor, caretContainer, false);
        }
        selection.setCursorLocation(caretTextNode, 1);
        if (dom.isEmpty(formatNode)) {
          dom.remove(formatNode);
        }
      }
    };
    const disableCaretContainer = (editor, keyCode, moveCaret) => {
      const selection = editor.selection, body = editor.getBody();
      removeCaretContainer(editor, null, moveCaret);
      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
      if (keyCode === 37 || keyCode === 39) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
    };
    const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);
    const setup$u = editor => {
      editor.on('mouseup keydown', e => {
        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));
      });
    };
    const createCaretFormat = formatNodes => {
      const caretContainer = createCaretContainer(false);
      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
      return {
        caretContainer,
        caretPosition: CaretPosition(innerMost, 0)
      };
    };
    const replaceWithCaretFormat = (targetNode, formatNodes) => {
      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);
      before$3(SugarElement.fromDom(targetNode), caretContainer);
      remove$5(SugarElement.fromDom(targetNode));
      return caretPosition;
    };
    const createCaretFormatAtStart$1 = (rng, formatNodes) => {
      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);
      rng.insertNode(caretContainer.dom);
      return caretPosition;
    };
    const isFormatElement = (editor, element) => {
      const inlineElements = editor.schema.getTextInlineElements();
      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
    };
    const isEmptyCaretFormatElement = element => {
      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };

    const postProcessHooks = {};
    const isPre = matchNodeNames(['pre']);
    const addPostProcessHook = (name, hook) => {
      const hooks = postProcessHooks[name];
      if (!hooks) {
        postProcessHooks[name] = [];
      }
      postProcessHooks[name].push(hook);
    };
    const postProcess$1 = (name, editor) => {
      if (has$2(postProcessHooks, name)) {
        each$e(postProcessHooks[name], hook => {
          hook(editor);
        });
      }
    };
    addPostProcessHook('pre', editor => {
      const rng = editor.selection.getRng();
      const hasPreSibling = blocks => pre => {
        const prev = pre.previousSibling;
        return isPre(prev) && contains$2(blocks, prev);
      };
      const joinPre = (pre1, pre2) => {
        const sPre2 = SugarElement.fromDom(pre2);
        const doc = documentOrOwner(sPre2).dom;
        remove$5(sPre2);
        append(SugarElement.fromDom(pre1), [
          SugarElement.fromTag('br', doc),
          SugarElement.fromTag('br', doc),
          ...children$1(sPre2)
        ]);
      };
      if (!rng.collapsed) {
        const blocks = editor.selection.getSelectedBlocks();
        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));
        each$e(preBlocks, pre => {
          joinPre(pre.previousSibling, pre);
        });
      }
    });

    const listItemStyles = [
      'fontWeight',
      'fontStyle',
      'color',
      'fontSize',
      'fontFamily'
    ];
    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));
    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));
    const getExpandedListItemFormat = (formatter, format) => {
      const formatList = formatter.get(format);
      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
    };
    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
    const isRngEndAtEndOfElement = (rng, elm) => {
      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
    };
    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);
    const getFullySelectedBlocks = selection => {
      const blocks = selection.getSelectedBlocks();
      const rng = selection.getRng();
      if (selection.isCollapsed()) {
        return [];
      }
      if (blocks.length === 1) {
        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];
      } else {
        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();
        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();
        const middle = blocks.slice(1, -1);
        return first.concat(middle).concat(last);
      }
    };
    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));

    const each$8 = Tools.each;
    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const findElementSibling = (node, siblingName) => {
      for (let sibling = node; sibling; sibling = sibling[siblingName]) {
        if (isText$a(sibling) && isNotEmpty(sibling.data)) {
          return node;
        }
        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {
          return sibling;
        }
      }
      return node;
    };
    const mergeSiblingsNodes = (editor, prev, next) => {
      const elementUtils = ElementUtils(editor);
      const isPrevEditable = isElement$6(prev) && isEditable$2(prev);
      const isNextEditable = isElement$6(next) && isEditable$2(next);
      if (isPrevEditable && isNextEditable) {
        const prevSibling = findElementSibling(prev, 'previousSibling');
        const nextSibling = findElementSibling(next, 'nextSibling');
        if (elementUtils.compare(prevSibling, nextSibling)) {
          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {
            const tmpSibling = sibling;
            sibling = sibling.nextSibling;
            prevSibling.appendChild(tmpSibling);
          }
          editor.dom.remove(nextSibling);
          Tools.each(Tools.grep(nextSibling.childNodes), node => {
            prevSibling.appendChild(node);
          });
          return prevSibling;
        }
      }
      return next;
    };
    const mergeSiblings = (editor, format, vars, node) => {
      var _a;
      if (node && format.merge_siblings !== false) {
        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
      }
    };
    const clearChildStyles = (dom, format, node) => {
      if (format.clear_child_styles) {
        const selector = format.links ? '*:not(a)' : '*';
        each$8(dom.select(selector, node), childNode => {
          if (isElementNode(childNode) && isEditable$2(childNode)) {
            each$8(format.styles, (_value, name) => {
              dom.setStyle(childNode, name, '');
            });
          }
        });
      }
    };
    const processChildElements = (node, filter, process) => {
      each$8(node.childNodes, node => {
        if (isElementNode(node)) {
          if (filter(node)) {
            process(node);
          }
          if (node.hasChildNodes()) {
            processChildElements(node, filter, process);
          }
        }
      });
    };
    const unwrapEmptySpan = (dom, node) => {
      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
        dom.remove(node, true);
      }
    };
    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));
    const applyStyle = (dom, name, value) => node => {
      dom.setStyle(node, name, value);
      if (node.getAttribute('style') === '') {
        node.removeAttribute('style');
      }
      unwrapEmptySpan(dom, node);
    };

    const removeResult = Adt.generate([
      { keep: [] },
      { rename: ['name'] },
      { removed: [] }
    ]);
    const MCE_ATTR_RE = /^(src|href|style)$/;
    const each$7 = Tools.each;
    const isEq$2 = isEq$5;
    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);
    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
    const getContainer = (ed, rng, start) => {
      let container = rng[start ? 'startContainer' : 'endContainer'];
      let offset = rng[start ? 'startOffset' : 'endOffset'];
      if (isElement$6(container)) {
        const lastIdx = container.childNodes.length - 1;
        if (!start && offset) {
          offset--;
        }
        container = container.childNodes[offset > lastIdx ? lastIdx : offset];
      }
      if (isText$a(container) && start && offset >= container.data.length) {
        container = new DomTreeWalker(container, ed.getBody()).next() || container;
      }
      if (isText$a(container) && !start && offset === 0) {
        container = new DomTreeWalker(container, ed.getBody()).prev() || container;
      }
      return container;
    };
    const normalizeTableSelection = (node, start) => {
      const prop = start ? 'firstChild' : 'lastChild';
      const childNode = node[prop];
      if (isTableCellOrRow(node) && childNode) {
        if (node.nodeName === 'TR') {
          return childNode[prop] || childNode;
        } else {
          return childNode;
        }
      }
      return node;
    };
    const wrap$1 = (dom, node, name, attrs) => {
      var _a;
      const wrapper = dom.create(name, attrs);
      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
      wrapper.appendChild(node);
      return wrapper;
    };
    const wrapWithSiblings = (dom, node, next, name, attrs) => {
      const start = SugarElement.fromDom(node);
      const wrapper = SugarElement.fromDom(dom.create(name, attrs));
      const siblings = next ? nextSiblings(start) : prevSiblings(start);
      append(wrapper, siblings);
      if (next) {
        before$3(start, wrapper);
        prepend(wrapper, start);
      } else {
        after$4(start, wrapper);
        append$1(wrapper, start);
      }
      return wrapper.dom;
    };
    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';
    const removeNode = (ed, node, format) => {
      const parentNode = node.parentNode;
      let rootBlockElm;
      const dom = ed.dom;
      const forcedRootBlock = getForcedRootBlock(ed);
      if (isBlockFormat(format)) {
        if (parentNode === dom.getRoot()) {
          if (!format.list_block || !isEq$2(node, format.list_block)) {
            each$e(from(node.childNodes), node => {
              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
                if (!rootBlockElm) {
                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);
                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                } else {
                  rootBlockElm.appendChild(node);
                }
              } else {
                rootBlockElm = null;
              }
            });
          }
        }
      }
      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
        return;
      }
      dom.remove(node, true);
    };
    const processFormatAttrOrStyle = (name, value, vars) => {
      if (isNumber(name)) {
        return {
          name: value,
          value: null
        };
      } else {
        return {
          name,
          value: replaceVars(value, vars)
        };
      }
    };
    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {
      if (dom.getAttrib(elm, 'style') === '') {
        elm.removeAttribute('style');
        elm.removeAttribute('data-mce-style');
      }
    };
    const removeStyles = (dom, elm, format, vars, compareNode) => {
      let stylesModified = false;
      each$7(format.styles, (value, name) => {
        const {
          name: styleName,
          value: styleValue
        } = processFormatAttrOrStyle(name, value, vars);
        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {
          dom.setStyle(elm, styleName, '');
        }
        stylesModified = true;
      });
      if (stylesModified) {
        removeEmptyStyleAttributeIfNeeded(dom, elm);
      }
    };
    const removeListStyleFormats = (editor, name, vars) => {
      if (name === 'removeformat') {
        each$e(getPartiallySelectedListItems(editor.selection), li => {
          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));
          removeEmptyStyleAttributeIfNeeded(editor.dom, li);
        });
      } else {
        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {
          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));
        });
      }
    };
    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
      const dom = ed.dom;
      const elementUtils = ElementUtils(ed);
      const schema = ed.schema;
      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
        removeNode(ed, node, format);
        return removeResult.removed();
      }
      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {
        return removeResult.keep();
      }
      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
        return removeResult.keep();
      }
      const elm = node;
      const preserveAttributes = format.preserve_attributes;
      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {
        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));
        dom.removeAllAttribs(elm);
        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));
        if (attrsToPreserve.length > 0) {
          return removeResult.rename('span');
        }
      }
      if (format.remove !== 'all') {
        removeStyles(dom, elm, format, vars, compareNode);
        each$7(format.attributes, (value, name) => {
          const {
            name: attrName,
            value: attrValue
          } = processFormatAttrOrStyle(name, value, vars);
          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {
            if (attrName === 'class') {
              const currentValue = dom.getAttrib(elm, attrName);
              if (currentValue) {
                let valueOut = '';
                each$e(currentValue.split(/\s+/), cls => {
                  if (/mce\-\w+/.test(cls)) {
                    valueOut += (valueOut ? ' ' : '') + cls;
                  }
                });
                if (valueOut) {
                  dom.setAttrib(elm, attrName, valueOut);
                  return;
                }
              }
            }
            if (MCE_ATTR_RE.test(attrName)) {
              elm.removeAttribute('data-mce-' + attrName);
            }
            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {
              elm.removeAttribute(attrName);
              dom.setStyle(elm, 'list-style-type', 'none');
              return;
            }
            if (attrName === 'class') {
              elm.removeAttribute('className');
            }
            elm.removeAttribute(attrName);
          }
        });
        each$7(format.classes, value => {
          value = replaceVars(value, vars);
          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {
            dom.removeClass(elm, value);
          }
        });
        const attrs = dom.getAttribs(elm);
        for (let i = 0; i < attrs.length; i++) {
          const attrName = attrs[i].nodeName;
          if (!elementUtils.isAttributeInternal(attrName)) {
            return removeResult.keep();
          }
        }
      }
      if (format.remove !== 'none') {
        removeNode(ed, elm, format);
        return removeResult.removed();
      }
      return removeResult.keep();
    };
    const findFormatRoot = (editor, container, name, vars, similar) => {
      let formatRoot;
      if (container.parentNode) {
        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {
          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {
            const format = matchNode(editor, parent, name, vars, similar);
            if (format && format.split !== false) {
              formatRoot = parent;
            }
          }
        });
      }
      return formatRoot;
    };
    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {
      const fragment = editor.dom.createFragment();
      fragment.appendChild(clone);
      return editor.dom.rename(clone, newName);
    }, constant(null));
    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {
      var _a, _b;
      let lastClone;
      let firstClone;
      const dom = editor.dom;
      if (formatRoot) {
        const formatRootParent = formatRoot.parentNode;
        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {
          let clone = dom.clone(parent, false);
          for (let i = 0; i < formatList.length; i++) {
            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);
            if (clone === null) {
              break;
            }
          }
          if (clone) {
            if (lastClone) {
              clone.appendChild(lastClone);
            }
            if (!firstClone) {
              firstClone = clone;
            }
            lastClone = clone;
          }
        }
        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
        }
        if (lastClone && firstClone) {
          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
          firstClone.appendChild(target);
          if (isInlineFormat(format)) {
            mergeSiblings(editor, format, vars, lastClone);
          }
        }
      }
      return container;
    };
    const removeFormatInternal = (ed, name, vars, node, similar) => {
      const formatList = ed.formatter.get(name);
      const format = formatList[0];
      const dom = ed.dom;
      const selection = ed.selection;
      const splitToFormatRoot = container => {
        const formatRoot = findFormatRoot(ed, container, name, vars, similar);
        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
      };
      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');
      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));
      const process = node => {
        const children = from(node.childNodes);
        const removed = removeFormatOnNode(node);
        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));
        const parentNode = node.parentNode;
        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
          removeFormatOnNode(parentNode);
        }
        if (format.deep) {
          if (children.length) {
            for (let i = 0; i < children.length; i++) {
              process(children[i]);
            }
          }
        }
        const textDecorations = [
          'underline',
          'line-through',
          'overline'
        ];
        each$e(textDecorations, decoration => {
          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {
            removeNodeFormat(ed, {
              deep: false,
              exact: true,
              inline: 'span',
              styles: { textDecoration: decoration }
            }, undefined, node);
          }
        });
      };
      const unwrap = start => {
        const node = dom.get(start ? '_start' : '_end');
        if (node) {
          let out = node[start ? 'firstChild' : 'lastChild'];
          if (isRemoveBookmarkNode(out)) {
            out = out[start ? 'firstChild' : 'lastChild'];
          }
          if (isText$a(out) && out.data.length === 0) {
            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
          }
          dom.remove(node, true);
          return out;
        } else {
          return null;
        }
      };
      const removeRngStyle = rng => {
        let startContainer;
        let endContainer;
        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);
        if (format.split) {
          expandedRng = split(expandedRng);
          startContainer = getContainer(ed, expandedRng, true);
          endContainer = getContainer(ed, expandedRng);
          if (startContainer !== endContainer) {
            startContainer = normalizeTableSelection(startContainer, true);
            endContainer = normalizeTableSelection(endContainer, false);
            if (isChildOfInlineParent(dom, startContainer, endContainer)) {
              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {
                'id': '_start',
                'data-mce-type': 'bookmark'
              }));
              unwrap(true);
              return;
            }
            if (isChildOfInlineParent(dom, endContainer, startContainer)) {
              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {
                'id': '_end',
                'data-mce-type': 'bookmark'
              }));
              unwrap(false);
              return;
            }
            startContainer = wrap$1(dom, startContainer, 'span', {
              'id': '_start',
              'data-mce-type': 'bookmark'
            });
            endContainer = wrap$1(dom, endContainer, 'span', {
              'id': '_end',
              'data-mce-type': 'bookmark'
            });
            const newRng = dom.createRng();
            newRng.setStartAfter(startContainer);
            newRng.setEndBefore(endContainer);
            walk$3(dom, newRng, nodes => {
              each$e(nodes, n => {
                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                  splitToFormatRoot(n);
                }
              });
            });
            splitToFormatRoot(startContainer);
            splitToFormatRoot(endContainer);
            startContainer = unwrap(true);
            endContainer = unwrap();
          } else {
            startContainer = endContainer = splitToFormatRoot(startContainer);
          }
          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
          expandedRng.startOffset = dom.nodeIndex(startContainer);
          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
        }
        walk$3(dom, expandedRng, nodes => {
          each$e(nodes, process);
        });
      };
      if (node) {
        if (isNode(node)) {
          const rng = dom.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          removeRngStyle(rng);
        } else {
          removeRngStyle(node);
        }
        fireFormatRemove(ed, name, node, vars);
        return;
      }
      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));
        ed.nodeChanged();
      } else {
        removeCaretFormat(ed, name, vars, similar);
      }
      removeListStyleFormats(ed, name, vars);
      fireFormatRemove(ed, name, node, vars);
    };
    const removeFormat$1 = (ed, name, vars, node, similar) => {
      if (node || ed.selection.isEditable()) {
        removeFormatInternal(ed, name, vars, node, similar);
      }
    };
    const removeNodeFormat = (editor, format, vars, node, compareNode) => {
      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {
        editor.dom.rename(node, newName);
        return true;
      }, always);
    };

    const each$6 = Tools.each;
    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {
      const processTextDecorationsAndColor = n => {
        if (isElement$6(n) && isElement$6(n.parentNode) && isEditable$2(n)) {
          const parentTextDecoration = getTextDecoration(dom, n.parentNode);
          if (dom.getStyle(n, 'color') && parentTextDecoration) {
            dom.setStyle(n, 'text-decoration', parentTextDecoration);
          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {
            dom.setStyle(n, 'text-decoration', null);
          }
        }
      };
      if (format.styles && (format.styles.color || format.styles.textDecoration)) {
        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');
        processTextDecorationsAndColor(node);
      }
    };
    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {
      if (format.styles && format.styles.backgroundColor) {
        const hasFontSize = hasStyle(dom, 'fontSize');
        processChildElements(node, elm => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
      }
    };
    const mergeSubSup = (dom, format, vars, node) => {
      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {
        const hasFontSize = hasStyle(dom, 'fontSize');
        processChildElements(node, elm => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom, 'fontSize', ''));
        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), isEditable$2);
        dom.remove(inverseTagDescendants, true);
      }
    };
    const mergeWithChildren = (editor, formatList, vars, node) => {
      each$6(formatList, format => {
        if (isInlineFormat(format)) {
          each$6(editor.dom.select(format.inline, node), child => {
            if (isElementNode(child)) {
              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);
            }
          });
        }
        clearChildStyles(editor.dom, format, node);
      });
    };
    const mergeWithParents = (editor, format, name, vars, node) => {
      const parentNode = node.parentNode;
      if (matchNode(editor, parentNode, name, vars)) {
        if (removeNodeFormat(editor, format, vars, node)) {
          return;
        }
      }
      if (format.merge_with_parents && parentNode) {
        editor.dom.getParent(parentNode, parent => {
          if (matchNode(editor, parent, name, vars)) {
            removeNodeFormat(editor, format, vars, node);
            return true;
          } else {
            return false;
          }
        });
      }
    };

    const each$5 = Tools.each;
    const canFormatBR = (editor, format, node, parentName) => {
      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
        const validBRParentElements = getTextRootBlockElements(editor.schema);
        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));
        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
      } else {
        return false;
      }
    };
    const applyStyles = (dom, elm, format, vars) => {
      each$5(format.styles, (value, name) => {
        dom.setStyle(elm, name, replaceVars(value, vars));
      });
      if (format.styles) {
        const styleVal = dom.getAttrib(elm, 'style');
        if (styleVal) {
          dom.setAttrib(elm, 'data-mce-style', styleVal);
        }
      }
    };
    const applyFormatAction = (ed, name, vars, node) => {
      const formatList = ed.formatter.get(name);
      const format = formatList[0];
      const isCollapsed = !node && ed.selection.isCollapsed();
      const dom = ed.dom;
      const selection = ed.selection;
      const setElementFormat = (elm, fmt = format) => {
        if (isFunction(fmt.onformat)) {
          fmt.onformat(elm, fmt, vars, node);
        }
        applyStyles(dom, elm, fmt, vars);
        each$5(fmt.attributes, (value, name) => {
          dom.setAttrib(elm, name, replaceVars(value, vars));
        });
        each$5(fmt.classes, value => {
          const newValue = replaceVars(value, vars);
          if (!dom.hasClass(elm, newValue)) {
            dom.addClass(elm, newValue);
          }
        });
      };
      const applyNodeStyle = (formatList, node) => {
        let found = false;
        each$5(formatList, format => {
          if (!isSelectorFormat(format)) {
            return false;
          }
          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {
            return true;
          }
          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {
            return true;
          }
          if (dom.is(node, format.selector) && !isCaretNode(node)) {
            setElementFormat(node, format);
            found = true;
            return false;
          }
          return true;
        });
        return found;
      };
      const createWrapElement = wrapName => {
        if (isString(wrapName)) {
          const wrapElm = dom.create(wrapName);
          setElementFormat(wrapElm);
          return wrapElm;
        } else {
          return null;
        }
      };
      const applyRngStyle = (dom, rng, nodeSpecific) => {
        const newWrappers = [];
        let contentEditable = true;
        const wrapName = format.inline || format.block;
        const wrapElm = createWrapElement(wrapName);
        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);
        const canRenameBlock = (node, parentName, isEditableDescendant) => {
          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);
          return isEditableDescendant && isValidBlockFormatForNode;
        };
        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
          const nodeName = node.nodeName.toLowerCase();
          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);
          const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);
          const isCaret = isCaretNode(node);
          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);
          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;
        };
        walk$3(dom, rng, nodes => {
          let currentWrapElm;
          const process = node => {
            let hasContentEditableState = false;
            let lastContentEditable = contentEditable;
            let isWrappableNoneditableElm = false;
            const parentNode = node.parentNode;
            const parentName = parentNode.nodeName.toLowerCase();
            const contentEditableValue = dom.getContentEditable(node);
            if (isNonNullable(contentEditableValue)) {
              lastContentEditable = contentEditable;
              contentEditable = contentEditableValue === 'true';
              hasContentEditableState = true;
              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);
            }
            const isEditableDescendant = contentEditable && !hasContentEditableState;
            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {
              currentWrapElm = null;
              if (isBlockFormat(format)) {
                dom.remove(node);
              }
              return;
            }
            if (isMatchingWrappingBlock(node)) {
              currentWrapElm = null;
              return;
            }
            if (canRenameBlock(node, parentName, isEditableDescendant)) {
              const elm = dom.rename(node, wrapName);
              setElementFormat(elm);
              newWrappers.push(elm);
              currentWrapElm = null;
              return;
            }
            if (isSelectorFormat(format)) {
              let found = applyNodeStyle(formatList, node);
              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                found = applyNodeStyle(formatList, parentNode);
              }
              if (!isInlineFormat(format) || found) {
                currentWrapElm = null;
                return;
              }
            }
            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
              if (!currentWrapElm) {
                currentWrapElm = dom.clone(wrapElm, false);
                parentNode.insertBefore(currentWrapElm, node);
                newWrappers.push(currentWrapElm);
              }
              if (isWrappableNoneditableElm && hasContentEditableState) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm.appendChild(node);
            } else {
              currentWrapElm = null;
              each$e(from(node.childNodes), process);
              if (hasContentEditableState) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm = null;
            }
          };
          each$e(nodes, process);
        });
        if (format.links === true) {
          each$e(newWrappers, node => {
            const process = node => {
              if (node.nodeName === 'A') {
                setElementFormat(node, format);
              }
              each$e(from(node.childNodes), process);
            };
            process(node);
          });
        }
        each$e(newWrappers, node => {
          const getChildCount = node => {
            let count = 0;
            each$e(node.childNodes, node => {
              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {
                count++;
              }
            });
            return count;
          };
          const mergeStyles = node => {
            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));
            return childElement.map(child => {
              const clone = dom.clone(child, false);
              setElementFormat(clone);
              dom.replace(clone, node, true);
              dom.remove(child, true);
              return clone;
            }).getOr(node);
          };
          const childCount = getChildCount(node);
          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
            dom.remove(node, true);
            return;
          }
          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
            if (!format.exact && childCount === 1) {
              node = mergeStyles(node);
            }
            mergeWithChildren(ed, formatList, vars, node);
            mergeWithParents(ed, format, name, vars, node);
            mergeBackgroundColorAndFontSize(dom, format, vars, node);
            mergeTextDecorationsAndColor(dom, format, vars, node);
            mergeSubSup(dom, format, vars, node);
            mergeSiblings(ed, format, vars, node);
          }
        });
      };
      const targetNode = isNode(node) ? node : selection.getNode();
      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {
        node = targetNode;
        applyNodeStyle(formatList, node);
        fireFormatApply(ed, name, node, vars);
        return;
      }
      if (format) {
        if (node) {
          if (isNode(node)) {
            if (!applyNodeStyle(formatList, node)) {
              const rng = dom.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              applyRngStyle(dom, expandRng(dom, rng, formatList), true);
            }
          } else {
            applyRngStyle(dom, node, true);
          }
        } else {
          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            selection.setRng(normalize(selection.getRng()));
            preserveSelection(ed, () => {
              runOnRanges(ed, (selectionRng, fake) => {
                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);
                applyRngStyle(dom, expandedRng, false);
              });
            }, always);
            ed.nodeChanged();
          } else {
            applyCaretFormat(ed, name, vars);
          }
          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {
            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));
          });
        }
        postProcess$1(name, ed);
      }
      fireFormatApply(ed, name, node, vars);
    };
    const applyFormat$1 = (editor, name, vars, node) => {
      if (node || editor.selection.isEditable()) {
        applyFormatAction(editor, name, vars, node);
      }
    };

    const hasVars = value => has$2(value, 'vars');
    const setup$t = (registeredFormatListeners, editor) => {
      registeredFormatListeners.set({});
      editor.on('NodeChange', e => {
        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
      });
      editor.on('FormatApply FormatRemove', e => {
        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));
        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
      });
    };
    const fallbackElement = editor => editor.selection.getStart();
    const matchingNode = (editor, parents, format, similar, vars) => {
      const isMatchingNode = node => {
        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
        return !isUndefined(matchingFormat);
      };
      const isUnableToMatch = node => {
        if (matchesUnInheritedFormatSelector(editor, node, format)) {
          return true;
        } else {
          if (!similar) {
            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
          } else {
            return false;
          }
        }
      };
      return findUntil$1(parents, isMatchingNode, isUnableToMatch);
    };
    const getParents = (editor, elm) => {
      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));
    };
    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
      const parents = getParents(editor, elm);
      each$d(registeredCallbacks, (data, format) => {
        const runIfChanged = spec => {
          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);
          const isSet = match.isSome();
          if (spec.state.get() !== isSet) {
            spec.state.set(isSet);
            const node = match.getOr(elm);
            if (hasVars(spec)) {
              spec.callback(isSet, {
                node,
                format,
                parents
              });
            } else {
              each$e(spec.callbacks, callback => callback(isSet, {
                node,
                format,
                parents
              }));
            }
          }
        };
        each$e([
          data.withSimilar,
          data.withoutSimilar
        ], runIfChanged);
        each$e(data.withVars, runIfChanged);
      });
    };
    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(','), format => {
        const group = get$a(formatChangeItems, format).getOrThunk(() => {
          const base = {
            withSimilar: {
              state: Cell(false),
              similar: true,
              callbacks: []
            },
            withoutSimilar: {
              state: Cell(false),
              similar: false,
              callbacks: []
            },
            withVars: []
          };
          formatChangeItems[format] = base;
          return base;
        });
        const getCurrent = () => {
          const parents = getParents(editor);
          return matchingNode(editor, parents, format, similar, vars).isSome();
        };
        if (isUndefined(vars)) {
          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
          toAppendTo.callbacks.push(callback);
          if (toAppendTo.callbacks.length === 1) {
            toAppendTo.state.set(getCurrent());
          }
        } else {
          group.withVars.push({
            state: Cell(getCurrent()),
            similar,
            vars,
            callback
          });
        }
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    const removeListeners = (registeredFormatListeners, formats, callback) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {
        formatChangeItems[format] = {
          withSimilar: {
            ...group.withSimilar,
            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)
          },
          withoutSimilar: {
            ...group.withoutSimilar,
            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)
          },
          withVars: filter$5(group.withVars, item => item.callback !== callback)
        };
      }));
      registeredFormatListeners.set(formatChangeItems);
    };
    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };
    };

    const toggle = (editor, name, vars, node) => {
      const fmt = editor.formatter.get(name);
      if (fmt) {
        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
          removeFormat$1(editor, name, vars, node);
        } else {
          applyFormat$1(editor, name, vars, node);
        }
      }
    };

    const explode$1 = Tools.explode;
    const create$8 = () => {
      const filters = {};
      const addFilter = (name, callback) => {
        each$e(explode$1(name), name => {
          if (!has$2(filters, name)) {
            filters[name] = {
              name,
              callbacks: []
            };
          }
          filters[name].callbacks.push(callback);
        });
      };
      const getFilters = () => values(filters);
      const removeFilter = (name, callback) => {
        each$e(explode$1(name), name => {
          if (has$2(filters, name)) {
            if (isNonNullable(callback)) {
              const filter = filters[name];
              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);
              if (newCallbacks.length > 0) {
                filter.callbacks = newCallbacks;
              } else {
                delete filters[name];
              }
            } else {
              delete filters[name];
            }
          }
        });
      };
      return {
        addFilter,
        getFilters,
        removeFilter
      };
    };

    const removeAttrs = (node, names) => {
      each$e(names, name => {
        node.attr(name, null);
      });
    };
    const addFontToSpansFilter = (domParser, styles, fontSizes) => {
      domParser.addNodeFilter('font', nodes => {
        each$e(nodes, node => {
          const props = styles.parse(node.attr('style'));
          const color = node.attr('color');
          const face = node.attr('face');
          const size = node.attr('size');
          if (color) {
            props.color = color;
          }
          if (face) {
            props['font-family'] = face;
          }
          if (size) {
            toInt(size).each(num => {
              props['font-size'] = fontSizes[num - 1];
            });
          }
          node.name = 'span';
          node.attr('style', styles.serialize(props));
          removeAttrs(node, [
            'color',
            'face',
            'size'
          ]);
        });
      });
    };
    const addStrikeFilter = (domParser, schema, styles) => {
      domParser.addNodeFilter('strike', nodes => {
        const convertToSTag = schema.type !== 'html4';
        each$e(nodes, node => {
          if (convertToSTag) {
            node.name = 's';
          } else {
            const props = styles.parse(node.attr('style'));
            props['text-decoration'] = 'line-through';
            node.name = 'span';
            node.attr('style', styles.serialize(props));
          }
        });
      });
    };
    const addFilters = (domParser, settings, schema) => {
      var _a;
      const styles = Styles();
      if (settings.convert_fonts_to_spans) {
        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));
      }
      addStrikeFilter(domParser, schema, styles);
    };
    const register$5 = (domParser, settings, schema) => {
      if (settings.inline_styles) {
        addFilters(domParser, settings, schema);
      }
    };

    const addNodeFilter = (settings, htmlParser, schema) => {
      htmlParser.addNodeFilter('br', (nodes, _, args) => {
        const blockElements = Tools.extend({}, schema.getBlockElements());
        const nonEmptyElements = schema.getNonEmptyElements();
        const whitespaceElements = schema.getWhitespaceElements();
        blockElements.body = 1;
        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);
        for (let i = 0, l = nodes.length; i < l; i++) {
          let node = nodes[i];
          let parent = node.parent;
          if (parent && isBlock(parent) && node === parent.lastChild) {
            let prev = node.prev;
            while (prev) {
              const prevName = prev.name;
              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
                if (prevName === 'br') {
                  node = null;
                }
                break;
              }
              prev = prev.prev;
            }
            if (node) {
              node.remove();
              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {
                const elementRule = schema.getElementRule(parent.name);
                if (elementRule) {
                  if (elementRule.removeEmpty) {
                    parent.remove();
                  } else if (elementRule.paddEmpty) {
                    paddEmptyNode(settings, args, isBlock, parent);
                  }
                }
              }
            }
          } else {
            let lastParent = node;
            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
              lastParent = parent;
              if (blockElements[parent.name]) {
                break;
              }
              parent = parent.parent;
            }
            if (lastParent === parent) {
              const textNode = new AstNode('#text', 3);
              textNode.value = nbsp;
              node.replace(textNode);
            }
          }
        }
      });
    };

    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,
      uriType: 'blob'
    }));
    const extractBase64Data = data => {
      const matches = /([a-z0-9+\/=\s]+)/i.exec(data);
      return matches ? matches[1] : '';
    };
    const parseDataUri = uri => {
      const [type, ...rest] = uri.split(',');
      const data = rest.join(',');
      const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type);
      if (matches) {
        const base64Encoded = matches[2] === ';base64';
        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);
        return Optional.some({
          type: matches[1],
          data: extractedData,
          base64Encoded
        });
      } else {
        return Optional.none();
      }
    };
    const buildBlob = (type, data, base64Encoded = true) => {
      let str = data;
      if (base64Encoded) {
        try {
          str = atob(data);
        } catch (e) {
          return Optional.none();
        }
      }
      const arr = new Uint8Array(str.length);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }
      return Optional.some(new Blob([arr], { type }));
    };
    const dataUriToBlob = uri => {
      return new Promise((resolve, reject) => {
        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);
      });
    };
    const uriToBlob = url => {
      if (startsWith(url, 'blob:')) {
        return blobUriToBlob(url);
      } else if (startsWith(url, 'data:')) {
        return dataUriToBlob(url);
      } else {
        return Promise.reject('Unknown URI format');
      }
    };
    const blobToDataUri = blob => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result);
        };
        reader.onerror = () => {
          var _a;
          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
        };
        reader.readAsDataURL(blob);
      });
    };

    let count$1 = 0;
    const uniqueId$1 = prefix => {
      return (prefix || 'blobid') + count$1++;
    };
    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {
        if (base64Only && !base64Encoded) {
          return Optional.none();
        } else {
          const base64 = base64Encoded ? data : btoa(data);
          return generateBlobInfo(base64, type);
        }
      });
    };
    const createBlobInfo$1 = (blobCache, blob, base64) => {
      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));
    };
    const imageToBlobInfo = (blobCache, imageSrc) => {
      const invalidDataUri = () => Promise.reject('Invalid data URI');
      if (startsWith(imageSrc, 'blob:')) {
        const blobInfo = blobCache.getByUri(imageSrc);
        if (isNonNullable(blobInfo)) {
          return Promise.resolve(blobInfo);
        } else {
          return uriToBlob(imageSrc).then(blob => {
            return blobToDataUri(blob).then(dataUri => {
              return processDataUri(dataUri, false, base64 => {
                return Optional.some(createBlobInfo$1(blobCache, blob, base64));
              }).getOrThunk(invalidDataUri);
            });
          });
        }
      } else if (startsWith(imageSrc, 'data:')) {
        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));
      } else {
        return Promise.reject('Unknown image data format');
      }
    };

    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));
    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
    const registerBase64ImageFilter = (parser, settings) => {
      const {blob_cache: blobCache} = settings;
      if (blobCache) {
        const processImage = img => {
          const inputSrc = img.attr('src');
          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
            return;
          }
          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {
            img.attr('src', blobInfo.blobUri());
          });
        };
        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));
      }
    };
    const register$4 = (parser, settings) => {
      const schema = parser.schema;
      if (settings.remove_trailing_brs) {
        addNodeFilter(settings, parser, schema);
      }
      parser.addAttributeFilter('href', nodes => {
        let i = nodes.length;
        const appendRel = rel => {
          const parts = rel.split(' ').filter(p => p.length > 0);
          return parts.concat(['noopener']).sort().join(' ');
        };
        const addNoOpener = rel => {
          const newRel = rel ? Tools.trim(rel) : '';
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };
        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            const node = nodes[i];
            if (node.name === 'a' && node.attr('target') === '_blank') {
              node.attr('rel', addNoOpener(node.attr('rel')));
            }
          }
        }
      });
      if (!settings.allow_html_in_named_anchor) {
        parser.addAttributeFilter('id,name', nodes => {
          let i = nodes.length, sibling, prevSibling, parent, node;
          while (i--) {
            node = nodes[i];
            if (node.name === 'a' && node.firstChild && !node.attr('href')) {
              parent = node.parent;
              sibling = node.lastChild;
              while (sibling && parent) {
                prevSibling = sibling.prev;
                parent.insert(sibling, node);
                sibling = prevSibling;
              }
            }
          }
        });
      }
      if (settings.fix_list_elements) {
        parser.addNodeFilter('ul,ol', nodes => {
          let i = nodes.length, node, parentNode;
          while (i--) {
            node = nodes[i];
            parentNode = node.parent;
            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {
              if (node.prev && node.prev.name === 'li') {
                node.prev.append(node);
              } else {
                const li = new AstNode('li', 1);
                li.attr('style', 'list-style-type: none');
                node.wrap(li);
              }
            }
          }
        });
      }
      const validClasses = schema.getValidClasses();
      if (settings.validate && validClasses) {
        parser.addAttributeFilter('class', nodes => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';
            const classList = Tools.explode(clazz, ' ');
            let classValue = '';
            for (let ci = 0; ci < classList.length; ci++) {
              const className = classList[ci];
              let valid = false;
              let validClassesMap = validClasses['*'];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              if (valid) {
                if (classValue) {
                  classValue += ' ';
                }
                classValue += className;
              }
            }
            if (!classValue.length) {
              classValue = null;
            }
            node.attr('class', classValue);
          }
        });
      }
      registerBase64ImageFilter(parser, settings);
    };

    function _typeof(obj) {
      '@babel/helpers - typeof';
      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
      }, _typeof(obj);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === 'undefined' || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === 'function')
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class)
            _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null || iter['@@iterator'] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === 'string')
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === 'Object' && o.constructor)
        n = o.constructor.name;
      if (n === 'Map' || n === 'Set')
        return Array.from(o);
      if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
    }
    var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;
    var _ref = typeof Reflect !== 'undefined' && Reflect, apply = _ref.apply, construct = _ref.construct;
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return _construct(Func, _toConsumableArray(args));
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function (thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    function addToSet(set, array) {
      if (setPrototypeOf) {
        setPrototypeOf(set, null);
      }
      var l = array.length;
      while (l--) {
        var element = array[l];
        if (typeof element === 'string') {
          var lcElement = stringToLowerCase(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    function clone(object) {
      var newObject = create$7(null);
      var property;
      for (property in object) {
        if (apply(hasOwnProperty, object, [property])) {
          newObject[property] = object[property];
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        var desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue(element) {
        console.warn('fallback value for', element);
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze([
      'a',
      'abbr',
      'acronym',
      'address',
      'area',
      'article',
      'aside',
      'audio',
      'b',
      'bdi',
      'bdo',
      'big',
      'blink',
      'blockquote',
      'body',
      'br',
      'button',
      'canvas',
      'caption',
      'center',
      'cite',
      'code',
      'col',
      'colgroup',
      'content',
      'data',
      'datalist',
      'dd',
      'decorator',
      'del',
      'details',
      'dfn',
      'dialog',
      'dir',
      'div',
      'dl',
      'dt',
      'element',
      'em',
      'fieldset',
      'figcaption',
      'figure',
      'font',
      'footer',
      'form',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'head',
      'header',
      'hgroup',
      'hr',
      'html',
      'i',
      'img',
      'input',
      'ins',
      'kbd',
      'label',
      'legend',
      'li',
      'main',
      'map',
      'mark',
      'marquee',
      'menu',
      'menuitem',
      'meter',
      'nav',
      'nobr',
      'ol',
      'optgroup',
      'option',
      'output',
      'p',
      'picture',
      'pre',
      'progress',
      'q',
      'rp',
      'rt',
      'ruby',
      's',
      'samp',
      'section',
      'select',
      'shadow',
      'small',
      'source',
      'spacer',
      'span',
      'strike',
      'strong',
      'style',
      'sub',
      'summary',
      'sup',
      'table',
      'tbody',
      'td',
      'template',
      'textarea',
      'tfoot',
      'th',
      'thead',
      'time',
      'tr',
      'track',
      'tt',
      'u',
      'ul',
      'var',
      'video',
      'wbr'
    ]);
    var svg$1 = freeze([
      'svg',
      'a',
      'altglyph',
      'altglyphdef',
      'altglyphitem',
      'animatecolor',
      'animatemotion',
      'animatetransform',
      'circle',
      'clippath',
      'defs',
      'desc',
      'ellipse',
      'filter',
      'font',
      'g',
      'glyph',
      'glyphref',
      'hkern',
      'image',
      'line',
      'lineargradient',
      'marker',
      'mask',
      'metadata',
      'mpath',
      'path',
      'pattern',
      'polygon',
      'polyline',
      'radialgradient',
      'rect',
      'stop',
      'style',
      'switch',
      'symbol',
      'text',
      'textpath',
      'title',
      'tref',
      'tspan',
      'view',
      'vkern'
    ]);
    var svgFilters = freeze([
      'feBlend',
      'feColorMatrix',
      'feComponentTransfer',
      'feComposite',
      'feConvolveMatrix',
      'feDiffuseLighting',
      'feDisplacementMap',
      'feDistantLight',
      'feFlood',
      'feFuncA',
      'feFuncB',
      'feFuncG',
      'feFuncR',
      'feGaussianBlur',
      'feImage',
      'feMerge',
      'feMergeNode',
      'feMorphology',
      'feOffset',
      'fePointLight',
      'feSpecularLighting',
      'feSpotLight',
      'feTile',
      'feTurbulence'
    ]);
    var svgDisallowed = freeze([
      'animate',
      'color-profile',
      'cursor',
      'discard',
      'fedropshadow',
      'font-face',
      'font-face-format',
      'font-face-name',
      'font-face-src',
      'font-face-uri',
      'foreignobject',
      'hatch',
      'hatchpath',
      'mesh',
      'meshgradient',
      'meshpatch',
      'meshrow',
      'missing-glyph',
      'script',
      'set',
      'solidcolor',
      'unknown',
      'use'
    ]);
    var mathMl$1 = freeze([
      'math',
      'menclose',
      'merror',
      'mfenced',
      'mfrac',
      'mglyph',
      'mi',
      'mlabeledtr',
      'mmultiscripts',
      'mn',
      'mo',
      'mover',
      'mpadded',
      'mphantom',
      'mroot',
      'mrow',
      'ms',
      'mspace',
      'msqrt',
      'mstyle',
      'msub',
      'msup',
      'msubsup',
      'mtable',
      'mtd',
      'mtext',
      'mtr',
      'munder',
      'munderover'
    ]);
    var mathMlDisallowed = freeze([
      'maction',
      'maligngroup',
      'malignmark',
      'mlongdiv',
      'mscarries',
      'mscarry',
      'msgroup',
      'mstack',
      'msline',
      'msrow',
      'semantics',
      'annotation',
      'annotation-xml',
      'mprescripts',
      'none'
    ]);
    var text = freeze(['#text']);
    var html = freeze([
      'accept',
      'action',
      'align',
      'alt',
      'autocapitalize',
      'autocomplete',
      'autopictureinpicture',
      'autoplay',
      'background',
      'bgcolor',
      'border',
      'capture',
      'cellpadding',
      'cellspacing',
      'checked',
      'cite',
      'class',
      'clear',
      'color',
      'cols',
      'colspan',
      'controls',
      'controlslist',
      'coords',
      'crossorigin',
      'datetime',
      'decoding',
      'default',
      'dir',
      'disabled',
      'disablepictureinpicture',
      'disableremoteplayback',
      'download',
      'draggable',
      'enctype',
      'enterkeyhint',
      'face',
      'for',
      'headers',
      'height',
      'hidden',
      'high',
      'href',
      'hreflang',
      'id',
      'inputmode',
      'integrity',
      'ismap',
      'kind',
      'label',
      'lang',
      'list',
      'loading',
      'loop',
      'low',
      'max',
      'maxlength',
      'media',
      'method',
      'min',
      'minlength',
      'multiple',
      'muted',
      'name',
      'nonce',
      'noshade',
      'novalidate',
      'nowrap',
      'open',
      'optimum',
      'pattern',
      'placeholder',
      'playsinline',
      'poster',
      'preload',
      'pubdate',
      'radiogroup',
      'readonly',
      'rel',
      'required',
      'rev',
      'reversed',
      'role',
      'rows',
      'rowspan',
      'spellcheck',
      'scope',
      'selected',
      'shape',
      'size',
      'sizes',
      'span',
      'srclang',
      'start',
      'src',
      'srcset',
      'step',
      'style',
      'summary',
      'tabindex',
      'title',
      'translate',
      'type',
      'usemap',
      'valign',
      'value',
      'width',
      'xmlns',
      'slot'
    ]);
    var svg = freeze([
      'accent-height',
      'accumulate',
      'additive',
      'alignment-baseline',
      'ascent',
      'attributename',
      'attributetype',
      'azimuth',
      'basefrequency',
      'baseline-shift',
      'begin',
      'bias',
      'by',
      'class',
      'clip',
      'clippathunits',
      'clip-path',
      'clip-rule',
      'color',
      'color-interpolation',
      'color-interpolation-filters',
      'color-profile',
      'color-rendering',
      'cx',
      'cy',
      'd',
      'dx',
      'dy',
      'diffuseconstant',
      'direction',
      'display',
      'divisor',
      'dur',
      'edgemode',
      'elevation',
      'end',
      'fill',
      'fill-opacity',
      'fill-rule',
      'filter',
      'filterunits',
      'flood-color',
      'flood-opacity',
      'font-family',
      'font-size',
      'font-size-adjust',
      'font-stretch',
      'font-style',
      'font-variant',
      'font-weight',
      'fx',
      'fy',
      'g1',
      'g2',
      'glyph-name',
      'glyphref',
      'gradientunits',
      'gradienttransform',
      'height',
      'href',
      'id',
      'image-rendering',
      'in',
      'in2',
      'k',
      'k1',
      'k2',
      'k3',
      'k4',
      'kerning',
      'keypoints',
      'keysplines',
      'keytimes',
      'lang',
      'lengthadjust',
      'letter-spacing',
      'kernelmatrix',
      'kernelunitlength',
      'lighting-color',
      'local',
      'marker-end',
      'marker-mid',
      'marker-start',
      'markerheight',
      'markerunits',
      'markerwidth',
      'maskcontentunits',
      'maskunits',
      'max',
      'mask',
      'media',
      'method',
      'mode',
      'min',
      'name',
      'numoctaves',
      'offset',
      'operator',
      'opacity',
      'order',
      'orient',
      'orientation',
      'origin',
      'overflow',
      'paint-order',
      'path',
      'pathlength',
      'patterncontentunits',
      'patterntransform',
      'patternunits',
      'points',
      'preservealpha',
      'preserveaspectratio',
      'primitiveunits',
      'r',
      'rx',
      'ry',
      'radius',
      'refx',
      'refy',
      'repeatcount',
      'repeatdur',
      'restart',
      'result',
      'rotate',
      'scale',
      'seed',
      'shape-rendering',
      'specularconstant',
      'specularexponent',
      'spreadmethod',
      'startoffset',
      'stddeviation',
      'stitchtiles',
      'stop-color',
      'stop-opacity',
      'stroke-dasharray',
      'stroke-dashoffset',
      'stroke-linecap',
      'stroke-linejoin',
      'stroke-miterlimit',
      'stroke-opacity',
      'stroke',
      'stroke-width',
      'style',
      'surfacescale',
      'systemlanguage',
      'tabindex',
      'targetx',
      'targety',
      'transform',
      'transform-origin',
      'text-anchor',
      'text-decoration',
      'text-rendering',
      'textlength',
      'type',
      'u1',
      'u2',
      'unicode',
      'values',
      'viewbox',
      'visibility',
      'version',
      'vert-adv-y',
      'vert-origin-x',
      'vert-origin-y',
      'width',
      'word-spacing',
      'wrap',
      'writing-mode',
      'xchannelselector',
      'ychannelselector',
      'x',
      'x1',
      'x2',
      'xmlns',
      'y',
      'y1',
      'y2',
      'z',
      'zoomandpan'
    ]);
    var mathMl = freeze([
      'accent',
      'accentunder',
      'align',
      'bevelled',
      'close',
      'columnsalign',
      'columnlines',
      'columnspan',
      'denomalign',
      'depth',
      'dir',
      'display',
      'displaystyle',
      'encoding',
      'fence',
      'frame',
      'height',
      'href',
      'id',
      'largeop',
      'length',
      'linethickness',
      'lspace',
      'lquote',
      'mathbackground',
      'mathcolor',
      'mathsize',
      'mathvariant',
      'maxsize',
      'minsize',
      'movablelimits',
      'notation',
      'numalign',
      'open',
      'rowalign',
      'rowlines',
      'rowspacing',
      'rowspan',
      'rspace',
      'rquote',
      'scriptlevel',
      'scriptminsize',
      'scriptsizemultiplier',
      'selection',
      'separator',
      'separators',
      'stretchy',
      'subscriptshift',
      'supscriptshift',
      'symmetric',
      'voffset',
      'width',
      'xmlns'
    ]);
    var xml = freeze([
      'xlink:href',
      'xml:id',
      'xlink:title',
      'xml:space',
      'xmlns:xlink'
    ]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
    var DOCTYPE_NAME = seal(/^html$/i);
    var getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
      if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      var suffix = null;
      var ATTR_NAME = 'data-tt-policy-suffix';
      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document.currentScript.getAttribute(ATTR_NAME);
      }
      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html) {
            return html;
          }
        });
      } catch (_) {
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    function createDOMPurify() {
      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      DOMPurify.version = '2.3.8';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== 9) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      var originalDocument = window.document;
      var document = window.document;
      var DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, Element = window.Element, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window.HTMLFormElement, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;
      var ElementPrototype = Element.prototype;
      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      var getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
      var _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
      var importNode = originalDocument.importNode;
      var documentMode = {};
      try {
        documentMode = clone(document).documentMode ? document.documentMode : {};
      } catch (_) {
      }
      var hooks = {};
      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      var FORBID_TAGS = null;
      var FORBID_ATTR = null;
      var ALLOW_ARIA_ATTR = true;
      var ALLOW_DATA_ATTR = true;
      var ALLOW_UNKNOWN_PROTOCOLS = false;
      var SAFE_FOR_TEMPLATES = false;
      var WHOLE_DOCUMENT = false;
      var SET_CONFIG = false;
      var FORCE_BODY = false;
      var RETURN_DOM = false;
      var RETURN_DOM_FRAGMENT = false;
      var RETURN_TRUSTED_TYPE = false;
      var SANITIZE_DOM = true;
      var KEEP_CONTENT = true;
      var IN_PLACE = false;
      var USE_PROFILES = {};
      var FORBID_CONTENTS = null;
      var DEFAULT_FORBID_CONTENTS = addToSet({}, [
        'annotation-xml',
        'audio',
        'colgroup',
        'desc',
        'foreignobject',
        'head',
        'iframe',
        'math',
        'mi',
        'mn',
        'mo',
        'ms',
        'mtext',
        'noembed',
        'noframes',
        'noscript',
        'plaintext',
        'script',
        'style',
        'svg',
        'template',
        'thead',
        'title',
        'video',
        'xmp'
      ]);
      var DATA_URI_TAGS = null;
      var DEFAULT_DATA_URI_TAGS = addToSet({}, [
        'audio',
        'video',
        'img',
        'source',
        'image',
        'track'
      ]);
      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
        'alt',
        'class',
        'for',
        'id',
        'label',
        'name',
        'pattern',
        'placeholder',
        'role',
        'summary',
        'title',
        'value',
        'style',
        'xmlns'
      ]);
      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      var NAMESPACE = HTML_NAMESPACE;
      var IS_EMPTY_INPUT = false;
      var PARSER_MEDIA_TYPE;
      var SUPPORTED_PARSER_MEDIA_TYPES = [
        'application/xhtml+xml',
        'text/html'
      ];
      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      var transformCaseFunc;
      var CONFIG = null;
      var formElement = document.createElement('form');
      var isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || _typeof(cfg) !== 'object') {
          cfg = {};
        }
        cfg = clone(cfg);
        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
          return x;
        } : stringToLowerCase;
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, [
            'html',
            'head',
            'body'
          ]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
        'mi',
        'mo',
        'mn',
        'ms',
        'mtext'
      ]);
      var HTML_INTEGRATION_POINTS = addToSet({}, [
        'foreignobject',
        'desc',
        'title',
        'annotation-xml'
      ]);
      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
        'title',
        'style',
        'font',
        'a',
        'script'
      ]);
      var ALL_SVG_TAGS = addToSet({}, svg$1);
      addToSet(ALL_SVG_TAGS, svgFilters);
      addToSet(ALL_SVG_TAGS, svgDisallowed);
      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
      var _checkValidNamespace = function _checkValidNamespace(element) {
        var parent = getParentNode(element);
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: HTML_NAMESPACE,
            tagName: 'template'
          };
        }
        var tagName = stringToLowerCase(element.tagName);
        var parentTagName = stringToLowerCase(parent.tagName);
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        return false;
      };
      var _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, { element: node });
        try {
          node.parentNode.removeChild(node);
        } catch (_) {
          try {
            node.outerHTML = emptyHTML;
          } catch (_) {
            node.remove();
          }
        }
      };
      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: node
          });
        }
        node.removeAttribute(name);
        if (name === 'is' && !ALLOWED_ATTR[name]) {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(node);
            } catch (_) {
            }
          } else {
            try {
              node.setAttribute(name, '');
            } catch (_) {
            }
          }
        }
      };
      var _initDocument = function _initDocument(dirty) {
        var doc;
        var leadingWhitespace;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          var matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {
          }
        }
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
          } catch (_) {
          }
        }
        var body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
      };
      var _isClobbered = function _isClobbered(elm) {
        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
      };
      var _isNode = function _isNode(object) {
        return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
      };
      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }
        arrayForEach(hooks[entryPoint], function (hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content;
        _executeHook('beforeSanitizeElements', currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
          _forceRemove(currentNode);
          return true;
        }
        var tagName = transformCaseFunc(currentNode.nodeName);
        _executeHook('uponSanitizeElement', currentNode, {
          tagName: tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
              return false;
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
              return false;
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            var parentNode = getParentNode(currentNode) || currentNode.parentNode;
            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              var childCount = childNodes.length;
              for (var i = childCount - 1; i >= 0; --i) {
                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          content = currentNode.textContent;
          content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
          content = stringReplace(content, ERB_EXPR$1, ' ');
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
            currentNode.textContent = content;
          }
        }
        _executeHook('afterSanitizeElements', currentNode, null);
        return false;
      };
      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName));
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName));
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName]);
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, '')));
        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, '')));
        else if (!value);
        else {
          return false;
        }
        return true;
      };
      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
        return tagName.indexOf('-') > 0;
      };
      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr;
        var value;
        var lcName;
        var l;
        _executeHook('beforeSanitizeAttributes', currentNode, null);
        var attributes = currentNode.attributes;
        if (!attributes) {
          return;
        }
        var hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        while (l--) {
          attr = attributes[l];
          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
          value = name === 'value' ? attr.value : stringTrim(attr.value);
          lcName = transformCaseFunc(name);
          var initValue = value;
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined;
          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
          value = hookEvent.attrValue;
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          if (!hookEvent.keepAttr) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
            value = stringReplace(value, ERB_EXPR$1, ' ');
          }
          var lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          if (value !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
            } catch (_) {
              _removeAttribute(name, currentNode);
            }
          }
        }
        _executeHook('afterSanitizeAttributes', currentNode, null);
      };
      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);
        _executeHook('beforeSanitizeShadowDOM', fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHook('uponSanitizeShadowNode', shadowNode, null);
          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
          _sanitizeAttributes(shadowNode);
        }
        _executeHook('afterSanitizeShadowDOM', fragment, null);
      };
      DOMPurify.sanitize = function (dirty, cfg) {
        var body;
        var importedNode;
        var currentNode;
        var oldNode;
        var returnNode;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString !== 'function') {
            throw typeErrorCreate('toString is not a function');
          } else {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          }
        }
        if (!DOMPurify.isSupported) {
          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
            if (typeof dirty === 'string') {
              return window.toStaticHTML(dirty);
            }
            if (_isNode(dirty)) {
              return window.toStaticHTML(dirty.outerHTML);
            }
          }
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            var tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          if (_sanitizeElements(currentNode)) {
            continue;
          }
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          _sanitizeAttributes(currentNode);
          oldNode = currentNode;
        }
        oldNode = null;
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot) {
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function (cfg) {
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        if (!CONFIG) {
          _parseConfig({});
        }
        var lcTag = transformCaseFunc(tag);
        var lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint) {
        if (hooks[entryPoint]) {
          return arrayPop(hooks[entryPoint]);
        }
      };
      DOMPurify.removeHooks = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      DOMPurify.removeAllHooks = function () {
        hooks = {};
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    const each$4 = Tools.each, trim = Tools.trim;
    const queryParts = [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor'
    ];
    const DEFAULT_PORTS = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    };
    const safeSvgDataUrlElements = [
      'img',
      'video'
    ];
    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
      if (isNonNullable(allowSvgDataUrls)) {
        return !allowSvgDataUrls;
      } else {
        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
      }
    };
    const decodeUri = encodedUri => {
      try {
        return decodeURIComponent(encodedUri);
      } catch (ex) {
        return unescape(encodedUri);
      }
    };
    const isInvalidUri = (settings, uri, tagName) => {
      const decodedUri = decodeUri(uri).replace(/\s/g, '');
      if (settings.allow_script_urls) {
        return false;
      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
        return true;
      } else if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(decodedUri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
      } else {
        return /^data:/i.test(decodedUri);
      }
    };
    class URI {
      static parseDataUri(uri) {
        let type;
        const uriComponents = decodeURIComponent(uri).split(',');
        const matches = /data:([^;]+)/.exec(uriComponents[0]);
        if (matches) {
          type = matches[1];
        }
        return {
          type,
          data: uriComponents[1]
        };
      }
      static isDomSafe(uri, context, options = {}) {
        if (options.allow_script_urls) {
          return true;
        } else {
          const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');
          return !isInvalidUri(options, decodedUri, context);
        }
      }
      static getDocumentBaseUrl(loc) {
        var _a;
        let baseUrl;
        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';
        } else {
          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
        }
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
          baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(baseUrl)) {
            baseUrl += '/';
          }
        }
        return baseUrl;
      }
      constructor(url, settings = {}) {
        this.path = '';
        this.directory = '';
        url = trim(url);
        this.settings = settings;
        const baseUri = settings.base_uri;
        const self = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self.source = url;
          return;
        }
        const isProtocolRelative = url.indexOf('//') === 0;
        if (url.indexOf('/') === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
        }
        if (!/^[\w\-]*:?\/\//.test(url)) {
          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {
            url = '//mce_host' + self.toAbsPath(baseUrl, url);
          } else {
            const match = /([^#?]*)([#?]?.*)/.exec(url);
            if (match) {
              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
            }
          }
        }
        url = url.replace(/@@/g, '(mce_at)');
        const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
        if (urlMatch) {
          each$4(queryParts, (v, i) => {
            let part = urlMatch[i];
            if (part) {
              part = part.replace(/\(mce_at\)/g, '@@');
            }
            self[v] = part;
          });
        }
        if (baseUri) {
          if (!self.protocol) {
            self.protocol = baseUri.protocol;
          }
          if (!self.userInfo) {
            self.userInfo = baseUri.userInfo;
          }
          if (!self.port && self.host === 'mce_host') {
            self.port = baseUri.port;
          }
          if (!self.host || self.host === 'mce_host') {
            self.host = baseUri.host;
          }
          self.source = '';
        }
        if (isProtocolRelative) {
          self.protocol = '';
        }
      }
      setPath(path) {
        const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
        if (pathMatch) {
          this.path = pathMatch[0];
          this.directory = pathMatch[1];
          this.file = pathMatch[2];
        }
        this.source = '';
        this.getURI();
      }
      toRelative(uri) {
        if (uri === './') {
          return uri;
        }
        const relativeUri = new URI(uri, { base_uri: this });
        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {
          return relativeUri.getURI();
        }
        const tu = this.getURI(), uu = relativeUri.getURI();
        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {
          return tu;
        }
        let output = this.toRelPath(this.path, relativeUri.path);
        if (relativeUri.query) {
          output += '?' + relativeUri.query;
        }
        if (relativeUri.anchor) {
          output += '#' + relativeUri.anchor;
        }
        return output;
      }
      toAbsolute(uri, noHost) {
        const absoluteUri = new URI(uri, { base_uri: this });
        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
      }
      isSameOrigin(uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }
          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
            return true;
          }
        }
        return false;
      }
      toRelPath(base, path) {
        let breakPoint = 0, out = '', i, l;
        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
        const items = path.split('/');
        if (normalizedBase.length >= items.length) {
          for (i = 0, l = normalizedBase.length; i < l; i++) {
            if (i >= items.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (normalizedBase.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (breakPoint === 1) {
          return path;
        }
        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
          out += '../';
        }
        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i !== breakPoint - 1) {
            out += '/' + items[i];
          } else {
            out += items[i];
          }
        }
        return out;
      }
      toAbsPath(base, path) {
        let nb = 0;
        const tr = /\/$/.test(path) ? '/' : '';
        const normalizedBase = base.split('/');
        const normalizedPath = path.split('/');
        const baseParts = [];
        each$4(normalizedBase, k => {
          if (k) {
            baseParts.push(k);
          }
        });
        const pathParts = [];
        for (let i = normalizedPath.length - 1; i >= 0; i--) {
          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
            continue;
          }
          if (normalizedPath[i] === '..') {
            nb++;
            continue;
          }
          if (nb > 0) {
            nb--;
            continue;
          }
          pathParts.push(normalizedPath[i]);
        }
        const i = baseParts.length - nb;
        let outPath;
        if (i <= 0) {
          outPath = reverse(pathParts).join('/');
        } else {
          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');
        }
        if (outPath.indexOf('/') !== 0) {
          outPath = '/' + outPath;
        }
        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
          outPath += tr;
        }
        return outPath;
      }
      getURI(noProtoHost = false) {
        let s;
        if (!this.source || noProtoHost) {
          s = '';
          if (!noProtoHost) {
            if (this.protocol) {
              s += this.protocol + '://';
            } else {
              s += '//';
            }
            if (this.userInfo) {
              s += this.userInfo + '@';
            }
            if (this.host) {
              s += this.host;
            }
            if (this.port) {
              s += ':' + this.port;
            }
          }
          if (this.path) {
            s += this.path;
          }
          if (this.query) {
            s += '?' + this.query;
          }
          if (this.anchor) {
            s += '#' + this.anchor;
          }
          this.source = s;
        }
        return this.source;
      }
    }

    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
    const internalElementAttr = 'data-mce-type';
    let uid = 0;
    const processNode = (node, settings, schema, evt) => {
      var _a, _b, _c, _d;
      const validate = settings.validate;
      const specialElements = schema.getSpecialElements();
      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {
        node.nodeValue = ' ' + node.nodeValue;
      }
      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
      if (node.nodeType !== ELEMENT || lcTagName === 'body') {
        return;
      }
      const element = SugarElement.fromDom(node);
      const isInternalElement = has$1(element, internalElementAttr);
      const bogus = get$9(element, 'data-mce-bogus');
      if (!isInternalElement && isString(bogus)) {
        if (bogus === 'all') {
          remove$5(element);
        } else {
          unwrap(element);
        }
        return;
      }
      const rule = schema.getElementRule(lcTagName);
      if (validate && !rule) {
        if (has$2(specialElements, lcTagName)) {
          remove$5(element);
        } else {
          unwrap(element);
        }
        return;
      } else {
        if (isNonNullable(evt)) {
          evt.allowedTags[lcTagName] = true;
        }
      }
      if (validate && rule && !isInternalElement) {
        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {
          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);
        });
        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {
          if (!has$1(element, attr.name)) {
            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);
          }
        });
        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {
          unwrap(element);
          return;
        }
        if (rule.removeEmptyAttrs && hasNone(element)) {
          unwrap(element);
          return;
        }
        if (rule.outputName && rule.outputName !== lcTagName) {
          mutate(element, rule.outputName);
        }
      }
    };
    const shouldKeepAttribute = (settings, schema, tagName, attrName, attrValue) => !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));
    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');
    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
    const filterAttributes = (ele, settings, schema) => {
      const {attributes} = ele;
      for (let i = attributes.length - 1; i >= 0; i--) {
        const attr = attributes[i];
        const attrName = attr.name;
        const attrValue = attr.value;
        if (!shouldKeepAttribute(settings, schema, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
          ele.removeAttribute(attrName);
        } else if (isBooleanAttribute(attrName, schema)) {
          ele.setAttribute(attrName, attrName);
        }
      }
    };
    const setupPurify = (settings, schema) => {
      const purify$1 = purify();
      purify$1.addHook('uponSanitizeElement', (ele, evt) => {
        processNode(ele, settings, schema, evt);
      });
      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {
        const tagName = ele.tagName.toLowerCase();
        const {attrName, attrValue} = evt;
        evt.keepAttr = shouldKeepAttribute(settings, schema, tagName, attrName, attrValue);
        if (evt.keepAttr) {
          evt.allowedAttributes[attrName] = true;
          if (isBooleanAttribute(attrName, schema)) {
            evt.attrValue = attrName;
          }
          if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {
            evt.forceKeepAttr = true;
          }
        } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
          evt.forceKeepAttr = true;
        }
      });
      return purify$1;
    };
    const getPurifyConfig = (settings, mimeType) => {
      const basePurifyConfig = {
        IN_PLACE: true,
        ALLOW_UNKNOWN_PROTOCOLS: true,
        ALLOWED_TAGS: [
          '#comment',
          '#cdata-section',
          'body'
        ],
        ALLOWED_ATTR: []
      };
      const config = { ...basePurifyConfig };
      config.PARSER_MEDIA_TYPE = mimeType;
      if (settings.allow_script_urls) {
        config.ALLOWED_URI_REGEXP = /.*/;
      } else if (settings.allow_html_data_urls) {
        config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
      }
      return config;
    };
    const getSanitizer = (settings, schema) => {
      if (settings.sanitize) {
        const purify = setupPurify(settings, schema);
        return (body, mimeType) => {
          purify.sanitize(body, getPurifyConfig(settings, mimeType));
          purify.removed = [];
        };
      } else {
        return (body, _) => {
          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
          let node;
          while (node = nodeIterator.nextNode()) {
            processNode(node, settings, schema);
            if (isElement$6(node)) {
              filterAttributes(node, settings, schema);
            }
          }
        };
      }
    };

    const makeMap = Tools.makeMap, extend$1 = Tools.extend;
    const transferChildren = (parent, nativeParent, specialElements) => {
      const parentName = parent.name;
      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';
      const childNodes = nativeParent.childNodes;
      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
        const nativeChild = childNodes[ni];
        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
        if (isElement$6(nativeChild)) {
          const attributes = nativeChild.attributes;
          for (let ai = 0, al = attributes.length; ai < al; ai++) {
            const attr = attributes[ai];
            child.attr(attr.name, attr.value);
          }
        } else if (isText$a(nativeChild)) {
          child.value = nativeChild.data;
          if (isSpecial) {
            child.raw = true;
          }
        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {
          child.value = nativeChild.data;
        }
        transferChildren(child, nativeChild, specialElements);
        parent.append(child);
      }
    };
    const walkTree = (root, preprocessors, postprocessors) => {
      const traverseOrder = [];
      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
        const tempNode = node;
        each$e(preprocessors, preprocess => preprocess(tempNode));
        if (isNullable(tempNode.parent) && tempNode !== root) {
          node = lastNode;
        } else {
          traverseOrder.push(tempNode);
        }
      }
      for (let i = traverseOrder.length - 1; i >= 0; i--) {
        const node = traverseOrder[i];
        each$e(postprocessors, postprocess => postprocess(node));
      }
    };
    const whitespaceCleaner = (root, schema, settings, args) => {
      const validate = settings.validate;
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
      const textRootBlockElements = getTextRootBlockElements(schema);
      const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
      const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
      const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
      const hasWhitespaceParent = node => {
        let tempNode = node.parent;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in whitespaceElements) {
            return true;
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isTextRootBlockEmpty = node => {
        let tempNode = node;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in textRootBlockElements) {
            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);
      const isAtEdgeOfBlock = (node, start) => {
        const neighbour = start ? node.prev : node.next;
        if (isNonNullable(neighbour) || isNullable(node.parent)) {
          return false;
        }
        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);
      };
      const preprocess = node => {
        var _a;
        if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
            text = text.replace(allWhiteSpaceRegExp, ' ');
            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {
              text = text.replace(startWhiteSpaceRegExp, '');
            }
            if (text.length === 0) {
              node.remove();
            } else {
              node.value = text;
            }
          }
        }
      };
      const postprocess = node => {
        var _a;
        if (node.type === 1) {
          const elementRule = schema.getElementRule(node.name);
          if (validate && elementRule) {
            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);
            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
              paddEmptyNode(settings, args, isBlock, node);
            } else if (elementRule.removeEmpty && isNodeEmpty) {
              if (isBlock(node)) {
                node.remove();
              } else {
                node.unwrap();
              }
            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
              paddEmptyNode(settings, args, isBlock, node);
            }
          }
        } else if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';
            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {
              text = text.replace(endWhiteSpaceRegExp, '');
            }
            if (text.length === 0) {
              node.remove();
            } else {
              node.value = text;
            }
          }
        }
      };
      return [
        preprocess,
        postprocess
      ];
    };
    const getRootBlockName = (settings, args) => {
      var _a;
      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
      if (name === false) {
        return '';
      } else if (name === true) {
        return 'p';
      } else {
        return name;
      }
    };
    const DomParser = (settings = {}, schema = Schema()) => {
      const nodeFilterRegistry = create$8();
      const attributeFilterRegistry = create$8();
      const defaultedSettings = {
        validate: true,
        root_name: 'body',
        sanitize: true,
        ...settings
      };
      const parser = new DOMParser();
      const sanitize = getSanitizer(defaultedSettings, schema);
      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {
        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';
        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;
        const wrappedHtml = format === 'xhtml' ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;
        const body = parser.parseFromString(wrappedHtml, mimeType).body;
        sanitize(body, mimeType);
        return isSpecialRoot ? body.firstChild : body;
      };
      const addNodeFilter = nodeFilterRegistry.addFilter;
      const getNodeFilters = nodeFilterRegistry.getFilters;
      const removeNodeFilter = nodeFilterRegistry.removeFilter;
      const addAttributeFilter = attributeFilterRegistry.addFilter;
      const getAttributeFilters = attributeFilterRegistry.getFilters;
      const removeAttributeFilter = attributeFilterRegistry.removeFilter;
      const findInvalidChildren = (node, invalidChildren) => {
        if (isInvalid(schema, node)) {
          invalidChildren.push(node);
        }
      };
      const isWrappableNode = (blockElements, node) => {
        const isInternalElement = isString(node.attr(internalElementAttr));
        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node));
        return node.type === 3 || isInlineElement && !isInternalElement;
      };
      const addRootBlocks = (rootNode, rootBlockName) => {
        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
        const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        let node = rootNode.firstChild, rootBlockNode = null;
        const trim = rootBlock => {
          var _a, _b;
          if (rootBlock) {
            node = rootBlock.firstChild;
            if (node && node.type === 3) {
              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');
            }
            node = rootBlock.lastChild;
            if (node && node.type === 3) {
              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');
            }
          }
        };
        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
          return;
        }
        while (node) {
          const next = node.next;
          if (isWrappableNode(blockElements, node)) {
            if (!rootBlockNode) {
              rootBlockNode = new AstNode(rootBlockName, 1);
              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
              rootNode.insert(rootBlockNode, node);
              rootBlockNode.append(node);
            } else {
              rootBlockNode.append(node);
            }
          } else {
            trim(rootBlockNode);
            rootBlockNode = null;
          }
          node = next;
        }
        trim(rootBlockNode);
      };
      const parse = (html, args = {}) => {
        var _a;
        const validate = defaultedSettings.validate;
        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
        const element = parseAndSanitizeWithContext(html, rootName, args.format);
        updateChildren(schema, element);
        const rootNode = new AstNode(rootName, 11);
        transferChildren(rootNode, element, schema.getSpecialElements());
        element.innerHTML = '';
        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
        const invalidChildren = [];
        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;
        const matches = {
          nodes: {},
          attributes: {}
        };
        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
        walkTree(rootNode, [
          whitespacePre,
          matchFinder
        ], [
          whitespacePost,
          invalidFinder
        ]);
        invalidChildren.reverse();
        if (validate && invalidChildren.length > 0) {
          if (args.context) {
            const {
              pass: topLevelChildren,
              fail: otherChildren
            } = partition$2(invalidChildren, child => child.parent === rootNode);
            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
            args.invalid = topLevelChildren.length > 0;
          } else {
            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
          }
        }
        const rootBlockName = getRootBlockName(defaultedSettings, args);
        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
          addRootBlocks(rootNode, rootBlockName);
        }
        if (!args.invalid) {
          runFilters(matches, args);
        }
        return rootNode;
      };
      const exports = {
        schema,
        addAttributeFilter,
        getAttributeFilters,
        removeAttributeFilter,
        addNodeFilter,
        getNodeFilters,
        removeNodeFilter,
        parse
      };
      register$4(exports, defaultedSettings);
      register$5(exports, defaultedSettings, schema);
      return exports;
    };

    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
    const withSerializedContent = (content, fireEvent, sanitize) => {
      const serializedContent = serializeContent(content);
      const eventArgs = fireEvent(serializedContent);
      if (eventArgs.isDefaultPrevented()) {
        return eventArgs;
      } else if (isTreeNode(content)) {
        if (eventArgs.content !== serializedContent) {
          const rootNode = DomParser({
            validate: false,
            forced_root_block: false,
            sanitize
          }).parse(eventArgs.content, { context: content.name });
          return {
            ...eventArgs,
            content: rootNode
          };
        } else {
          return {
            ...eventArgs,
            content
          };
        }
      } else {
        return eventArgs;
      }
    };
    const preProcessGetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const eventArgs = fireBeforeGetContent(editor, args);
        if (eventArgs.isDefaultPrevented()) {
          return Result.error(fireGetContent(editor, {
            content: '',
            ...eventArgs
          }).content);
        } else {
          return Result.value(eventArgs);
        }
      }
    };
    const postProcessGetContent = (editor, content, args) => {
      if (args.no_events) {
        return content;
      } else {
        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {
          ...args,
          content
        }), shouldSanitizeXss(editor));
        return processedEventArgs.content;
      }
    };
    const preProcessSetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {
          ...args,
          content
        }), shouldSanitizeXss(editor));
        if (processedEventArgs.isDefaultPrevented()) {
          fireSetContent(editor, processedEventArgs);
          return Result.error(undefined);
        } else {
          return Result.value(processedEventArgs);
        }
      }
    };
    const postProcessSetContent = (editor, content, args) => {
      if (!args.no_events) {
        fireSetContent(editor, {
          ...args,
          content
        });
      }
    };

    const tableModel = (element, width, rows) => ({
      element,
      width,
      rows
    });
    const tableRow = (element, cells) => ({
      element,
      cells
    });
    const cellPosition = (x, y) => ({
      x,
      y
    });
    const getSpan = (td, key) => {
      return getOpt(td, key).bind(toInt).getOr(1);
    };
    const fillout = (table, x, y, tr, td) => {
      const rowspan = getSpan(td, 'rowspan');
      const colspan = getSpan(td, 'colspan');
      const rows = table.rows;
      for (let y2 = y; y2 < y + rowspan; y2++) {
        if (!rows[y2]) {
          rows[y2] = tableRow(deep$1(tr), []);
        }
        for (let x2 = x; x2 < x + colspan; x2++) {
          const cells = rows[y2].cells;
          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);
        }
      }
    };
    const cellExists = (table, x, y) => {
      const rows = table.rows;
      const cells = rows[y] ? rows[y].cells : [];
      return !!cells[x];
    };
    const skipCellsX = (table, x, y) => {
      while (cellExists(table, x, y)) {
        x++;
      }
      return x;
    };
    const getWidth = rows => {
      return foldl(rows, (acc, row) => {
        return row.cells.length > acc ? row.cells.length : acc;
      }, 0);
    };
    const findElementPos = (table, element) => {
      const rows = table.rows;
      for (let y = 0; y < rows.length; y++) {
        const cells = rows[y].cells;
        for (let x = 0; x < cells.length; x++) {
          if (eq(cells[x], element)) {
            return Optional.some(cellPosition(x, y));
          }
        }
      }
      return Optional.none();
    };
    const extractRows = (table, sx, sy, ex, ey) => {
      const newRows = [];
      const rows = table.rows;
      for (let y = sy; y <= ey; y++) {
        const cells = rows[y].cells;
        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
        newRows.push(tableRow(rows[y].element, slice));
      }
      return newRows;
    };
    const subTable = (table, startPos, endPos) => {
      const sx = startPos.x, sy = startPos.y;
      const ex = endPos.x, ey = endPos.y;
      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
      return tableModel(table.element, getWidth(newRows), newRows);
    };
    const createDomTable = (table, rows) => {
      const tableElement = shallow$1(table.element);
      const tableBody = SugarElement.fromTag('tbody');
      append(tableBody, rows);
      append$1(tableElement, tableBody);
      return tableElement;
    };
    const modelRowsToDomRows = table => {
      return map$3(table.rows, row => {
        const cells = map$3(row.cells, cell => {
          const td = deep$1(cell);
          remove$a(td, 'colspan');
          remove$a(td, 'rowspan');
          return td;
        });
        const tr = shallow$1(row.element);
        append(tr, cells);
        return tr;
      });
    };
    const fromDom = tableElm => {
      const table = tableModel(shallow$1(tableElm), 0, []);
      each$e(descendants(tableElm, 'tr'), (tr, y) => {
        each$e(descendants(tr, 'td,th'), (td, x) => {
          fillout(table, skipCellsX(table, x, y), y, tr, td);
        });
      });
      return tableModel(table.element, getWidth(table.rows), table.rows);
    };
    const toDom = table => {
      return createDomTable(table, modelRowsToDomRows(table));
    };
    const subsection = (table, startElement, endElement) => {
      return findElementPos(table, startElement).bind(startPos => {
        return findElementPos(table, endElement).map(endPos => {
          return subTable(table, startPos, endPos);
        });
      });
    };

    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');
    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {
      const listElm = SugarElement.fromTag(name(listCont));
      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));
      setAll(listElm, listStyles);
      return [
        SugarElement.fromTag('li'),
        listElm
      ];
    }).getOr([]));
    const wrap = (innerElm, elms) => {
      const wrapped = foldl(elms, (acc, elm) => {
        append$1(elm, acc);
        return elm;
      }, innerElm);
      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    const directListWrappers = commonAnchorContainer => {
      if (isListItem$1(commonAnchorContainer)) {
        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [
          commonAnchorContainer,
          listElm
        ]);
      } else {
        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
      }
    };
    const getWrapElements = (rootNode, rng) => {
      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
      const parents = parentsAndSelf(commonAnchorContainer, rootNode);
      const wrapElements = filter$5(parents, isWrapElement);
      const listWrappers = getFullySelectedListWrappers(parents, rng);
      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
      return map$3(allWrappers, shallow$1);
    };
    const emptyFragment = () => fromElements([]);
    const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));
    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {
      const firstCell = selectedTableCells[0];
      const lastCell = selectedTableCells[selectedTableCells.length - 1];
      const fullTableModel = fromDom(tableElm);
      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));
    }).getOrThunk(emptyFragment);
    const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
    const read$3 = (rootNode, ranges) => {
      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
    };

    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));
    const getInnerText = bin => {
      return trim$1(bin.innerText);
    };
    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();
    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {
      var _a;
      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
      const body = editor.getBody();
      const contextNodeName = getContextNodeName(parentBlockOpt);
      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
      cleanupBogusElements(rangeContentClone);
      cleanupInputNames(rangeContentClone);
      const bin = editor.dom.add(body, contextNodeName, {
        'data-mce-bogus': 'all',
        'style': 'overflow: hidden; opacity: 0;'
      }, rangeContentClone.dom);
      const text = getInnerText(bin);
      const nonRenderedText = trim$1((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');
      editor.dom.remove(bin);
      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
        const parentBlock = parentBlockOpt.getOr(body);
        const parentBlockText = getInnerText(parentBlock);
        const textIndex = parentBlockText.indexOf(text);
        if (textIndex === -1) {
          return text;
        } else {
          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);
          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');
        }
      } else {
        return text;
      }
    }).getOr('');
    const getSerializedContent = (editor, args) => {
      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
      const sel = editor.selection.getSel();
      const ranges = processRanges(editor, getRanges$1(sel));
      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
      if (fragment) {
        tmpElm.appendChild(fragment);
      }
      return editor.selection.serializer.serialize(tmpElm, args);
    };
    const extractSelectedContent = (editor, args) => {
      if (args.format === 'text') {
        return getTextContent(editor);
      } else {
        const content = getSerializedContent(editor, args);
        if (args.format === 'tree') {
          return content;
        } else {
          return editor.selection.isCollapsed() ? '' : content;
        }
      }
    };
    const setupArgs$3 = (args, format) => ({
      ...args,
      format,
      get: true,
      selection: true,
      getInner: true
    });
    const getSelectedContentInternal = (editor, format, args = {}) => {
      const defaultedArgs = setupArgs$3(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {
        const content = extractSelectedContent(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };

    const KEEP = 0, INSERT = 1, DELETE = 2;
    const diff = (left, right) => {
      const size = left.length + right.length + 2;
      const vDown = new Array(size);
      const vUp = new Array(size);
      const snake = (start, end, diag) => {
        return {
          start,
          end,
          diag
        };
      };
      const buildScript = (start1, end1, start2, end2, script) => {
        const middle = getMiddleSnake(start1, end1, start2, end2);
        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
          let i = start1;
          let j = start2;
          while (i < end1 || j < end2) {
            if (i < end1 && j < end2 && left[i] === right[j]) {
              script.push([
                KEEP,
                left[i]
              ]);
              ++i;
              ++j;
            } else {
              if (end1 - start1 > end2 - start2) {
                script.push([
                  DELETE,
                  left[i]
                ]);
                ++i;
              } else {
                script.push([
                  INSERT,
                  right[j]
                ]);
                ++j;
              }
            }
          }
        } else {
          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
          for (let i2 = middle.start; i2 < middle.end; ++i2) {
            script.push([
              KEEP,
              left[i2]
            ]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
        }
      };
      const buildSnake = (start, diag, end1, end2) => {
        let end = start;
        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
          ++end;
        }
        return snake(start, end, diag);
      };
      const getMiddleSnake = (start1, end1, start2, end2) => {
        const m = end1 - start1;
        const n = end2 - start2;
        if (m === 0 || n === 0) {
          return null;
        }
        const delta = m - n;
        const sum = n + m;
        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
        vDown[1 + offset] = start1;
        vUp[1 + offset] = end1 + 1;
        let d, k, i, x, y;
        for (d = 0; d <= offset; ++d) {
          for (k = -d; k <= d; k += 2) {
            i = k + offset;
            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
              vDown[i] = vDown[i + 1];
            } else {
              vDown[i] = vDown[i - 1] + 1;
            }
            x = vDown[i];
            y = x - start1 + start2 - k;
            while (x < end1 && y < end2 && left[x] === right[y]) {
              vDown[i] = ++x;
              ++y;
            }
            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
              if (vUp[i - delta] <= vDown[i]) {
                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
              }
            }
          }
          for (k = delta - d; k <= delta + d; k += 2) {
            i = k + offset - delta;
            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
              vUp[i] = vUp[i + 1] - 1;
            } else {
              vUp[i] = vUp[i - 1];
            }
            x = vUp[i] - 1;
            y = x - start1 + start2 - k;
            while (x >= start1 && y >= start2 && left[x] === right[y]) {
              vUp[i] = x--;
              y--;
            }
            if (delta % 2 === 0 && -d <= k && k <= d) {
              if (vUp[i] <= vDown[i + delta]) {
                return buildSnake(vUp[i], k + start1 - start2, end1, end2);
              }
            }
          }
        }
        return null;
      };
      const script = [];
      buildScript(0, left.length, 0, right.length, script);
      return script;
    };

    const getOuterHtml = elm => {
      if (isElement$6(elm)) {
        return elm.outerHTML;
      } else if (isText$a(elm)) {
        return Entities.encodeRaw(elm.data, false);
      } else if (isComment(elm)) {
        return '<!--' + elm.data + '-->';
      }
      return '';
    };
    const createFragment = html => {
      let node;
      const container = document.createElement('div');
      const frag = document.createDocumentFragment();
      if (html) {
        container.innerHTML = html;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    const insertAt = (elm, html, index) => {
      const fragment = createFragment(html);
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.insertBefore(fragment, target);
      } else {
        elm.appendChild(fragment);
      }
    };
    const removeAt = (elm, index) => {
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.removeChild(target);
      }
    };
    const applyDiff = (diff, elm) => {
      let index = 0;
      each$e(diff, action => {
        if (action[0] === KEEP) {
          index++;
        } else if (action[0] === INSERT) {
          insertAt(elm, action[1], index);
          index++;
        } else if (action[0] === DELETE) {
          removeAt(elm, index);
        }
      });
    };
    const read$2 = elm => {
      return filter$5(map$3(from(elm.childNodes), getOuterHtml), item => {
        return item.length > 0;
      });
    };
    const write = (fragments, elm) => {
      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
      applyDiff(diff(currentFragments, fragments), elm);
      return elm;
    };

    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));
    const hasIframes = html => {
      return html.indexOf('</iframe>') !== -1;
    };
    const createFragmentedLevel = fragments => {
      return {
        type: 'fragmented',
        fragments,
        content: '',
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createCompleteLevel = content => {
      return {
        type: 'complete',
        fragments: null,
        content,
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createFromEditor = editor => {
      const fragments = read$2(editor.getBody());
      const trimmedFragments = bind$3(fragments, html => {
        const trimmed = trimInternal(editor.serializer, html);
        return trimmed.length > 0 ? [trimmed] : [];
      });
      const content = trimmedFragments.join('');
      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };
    const applyToEditor = (editor, level, before) => {
      const bookmark = before ? level.beforeBookmark : level.bookmark;
      if (level.type === 'fragmented') {
        write(level.fragments, editor.getBody());
      } else {
        editor.setContent(level.content, {
          format: 'raw',
          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
        });
      }
      if (bookmark) {
        editor.selection.moveToBookmark(bookmark);
        editor.selection.scrollIntoView();
      }
    };
    const getLevelContent = level => {
      return level.type === 'fragmented' ? level.fragments.join('') : level.content;
    };
    const getCleanLevelContent = level => {
      const elm = SugarElement.fromTag('body', lazyTempDocument());
      set$1(elm, getLevelContent(level));
      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);
      return get$6(elm);
    };
    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
    const isEq$1 = (level1, level2) => {
      if (!level1 || !level2) {
        return false;
      } else if (hasEqualContent(level1, level2)) {
        return true;
      } else {
        return hasEqualCleanedContent(level1, level2);
      }
    };

    const isUnlocked = locks => locks.get() === 0;

    const setTyping = (undoManager, typing, locks) => {
      if (isUnlocked(locks)) {
        undoManager.typing = typing;
      }
    };
    const endTyping = (undoManager, locks) => {
      if (undoManager.typing) {
        setTyping(undoManager, false, locks);
        undoManager.add();
      }
    };
    const endTypingLevelIgnoreLocks = undoManager => {
      if (undoManager.typing) {
        undoManager.typing = false;
        undoManager.add();
      }
    };

    const beforeChange$1 = (editor, locks, beforeBookmark) => {
      if (isUnlocked(locks)) {
        beforeBookmark.set(getUndoBookmark(editor.selection));
      }
    };
    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
      const currentLevel = createFromEditor(editor);
      const newLevel = Tools.extend(level || {}, currentLevel);
      if (!isUnlocked(locks) || editor.removed) {
        return null;
      }
      const lastLevel = undoManager.data[index.get()];
      if (editor.dispatch('BeforeAddUndo', {
          level: newLevel,
          lastLevel,
          originalEvent: event
        }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel && isEq$1(lastLevel, newLevel)) {
        return null;
      }
      if (undoManager.data[index.get()]) {
        beforeBookmark.get().each(bm => {
          undoManager.data[index.get()].beforeBookmark = bm;
        });
      }
      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
      if (customUndoRedoLevels) {
        if (undoManager.data.length > customUndoRedoLevels) {
          for (let i = 0; i < undoManager.data.length - 1; i++) {
            undoManager.data[i] = undoManager.data[i + 1];
          }
          undoManager.data.length--;
          index.set(undoManager.data.length);
        }
      }
      newLevel.bookmark = getUndoBookmark(editor.selection);
      if (index.get() < undoManager.data.length - 1) {
        undoManager.data.length = index.get() + 1;
      }
      undoManager.data.push(newLevel);
      index.set(undoManager.data.length - 1);
      const args = {
        level: newLevel,
        lastLevel,
        originalEvent: event
      };
      if (index.get() > 0) {
        editor.setDirty(true);
        editor.dispatch('AddUndo', args);
        editor.dispatch('change', args);
      } else {
        editor.dispatch('AddUndo', args);
      }
      return newLevel;
    };
    const clear$1 = (editor, undoManager, index) => {
      undoManager.data = [];
      index.set(0);
      undoManager.typing = false;
      editor.dispatch('ClearUndos');
    };
    const extra$1 = (editor, undoManager, index, callback1, callback2) => {
      if (undoManager.transact(callback1)) {
        const bookmark = undoManager.data[index.get()].bookmark;
        const lastLevel = undoManager.data[index.get() - 1];
        applyToEditor(editor, lastLevel, true);
        if (undoManager.transact(callback2)) {
          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
        }
      }
    };
    const redo$1 = (editor, index, data) => {
      let level;
      if (index.get() < data.length - 1) {
        index.set(index.get() + 1);
        level = data[index.get()];
        applyToEditor(editor, level, false);
        editor.setDirty(true);
        editor.dispatch('Redo', { level });
      }
      return level;
    };
    const undo$1 = (editor, undoManager, locks, index) => {
      let level;
      if (undoManager.typing) {
        undoManager.add();
        undoManager.typing = false;
        setTyping(undoManager, false, locks);
      }
      if (index.get() > 0) {
        index.set(index.get() - 1);
        level = undoManager.data[index.get()];
        applyToEditor(editor, level, true);
        editor.setDirty(true);
        editor.dispatch('Undo', { level });
      }
      return level;
    };
    const reset$1 = undoManager => {
      undoManager.clear();
      undoManager.add();
    };
    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
    const transact$1 = (undoManager, locks, callback) => {
      endTyping(undoManager, locks);
      undoManager.beforeChange();
      undoManager.ignore(callback);
      return undoManager.add();
    };
    const ignore$1 = (locks, callback) => {
      try {
        locks.set(locks.get() + 1);
        callback();
      } finally {
        locks.set(locks.get() - 1);
      }
    };

    const addVisualInternal = (editor, elm) => {
      const dom = editor.dom;
      const scope = isNonNullable(elm) ? elm : editor.getBody();
      each$e(dom.select('table,a', scope), matchedElm => {
        switch (matchedElm.nodeName) {
        case 'TABLE':
          const cls = getVisualAidsTableClass(editor);
          const value = dom.getAttrib(matchedElm, 'border');
          if ((!value || value === '0') && editor.hasVisual) {
            dom.addClass(matchedElm, cls);
          } else {
            dom.removeClass(matchedElm, cls);
          }
          break;
        case 'A':
          if (!dom.getAttrib(matchedElm, 'href')) {
            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;
            const cls = getVisualAidsAnchorClass(editor);
            if (value && editor.hasVisual) {
              dom.addClass(matchedElm, cls);
            } else {
              dom.removeClass(matchedElm, cls);
            }
          }
          break;
        }
      });
      editor.dispatch('VisualAid', {
        element: elm,
        hasVisual: editor.hasVisual
      });
    };

    const makePlainAdaptor = editor => ({
      init: { bindEvents: noop },
      undoManager: {
        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
        redo: (index, data) => redo$1(editor, index, data),
        clear: (undoManager, index) => clear$1(editor, undoManager, index),
        reset: undoManager => reset$1(undoManager),
        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
        ignore: (locks, callback) => ignore$1(locks, callback),
        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
      },
      formatter: {
        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),
        matchAll: (names, vars) => matchAll(editor, names, vars),
        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),
        canApply: name => canApply(editor, name),
        closest: names => closest(editor, names),
        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),
        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),
        toggle: (name, vars, node) => toggle(editor, name, vars, node),
        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
      },
      editor: {
        getContent: args => getContentInternal(editor, args),
        setContent: (content, args) => setContentInternal(editor, content, args),
        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),
        addVisual: elm => addVisualInternal(editor, elm)
      },
      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },
      autocompleter: {
        addDecoration: range => create$9(editor, range),
        removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))
      },
      raw: { getModel: () => Optional.none() }
    });
    const makeRtcAdaptor = rtcEditor => {
      const defaultVars = vars => isObject(vars) ? vars : {};
      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;
      return {
        init: { bindEvents: init.bindEvents },
        undoManager: {
          beforeChange: undoManager.beforeChange,
          add: undoManager.add,
          undo: undoManager.undo,
          redo: undoManager.redo,
          clear: undoManager.clear,
          reset: undoManager.reset,
          hasUndo: undoManager.hasUndo,
          hasRedo: undoManager.hasRedo,
          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),
          ignore: (_locks, callback) => undoManager.ignore(callback),
          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
        },
        formatter: {
          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),
          matchAll: formatter.matchAll,
          matchNode: formatter.matchNode,
          canApply: name => formatter.canApply(name),
          closest: names => formatter.closest(names),
          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),
          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),
          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),
          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
        },
        editor: {
          getContent: args => editor.getContent(args),
          setContent: (content, args) => {
            return {
              content: editor.setContent(content, args),
              html: ''
            };
          },
          insertContent: (content, _details) => {
            editor.insertContent(content);
            return '';
          },
          addVisual: editor.addVisual
        },
        selection: { getContent: (_format, args) => selection.getContent(args) },
        autocompleter: {
          addDecoration: autocompleter.addDecoration,
          removeDecoration: autocompleter.removeDecoration
        },
        raw: { getModel: () => Optional.some(raw.getRawModel()) }
      };
    };
    const makeNoopAdaptor = () => {
      const nul = constant(null);
      const empty = constant('');
      return {
        init: { bindEvents: noop },
        undoManager: {
          beforeChange: noop,
          add: nul,
          undo: nul,
          redo: nul,
          clear: noop,
          reset: noop,
          hasUndo: never,
          hasRedo: never,
          transact: nul,
          ignore: noop,
          extra: noop
        },
        formatter: {
          match: never,
          matchAll: constant([]),
          matchNode: constant(undefined),
          canApply: never,
          closest: empty,
          apply: noop,
          remove: noop,
          toggle: noop,
          formatChanged: constant({ unbind: noop })
        },
        editor: {
          getContent: empty,
          setContent: constant({
            content: '',
            html: ''
          }),
          insertContent: constant(''),
          addVisual: noop
        },
        selection: { getContent: empty },
        autocompleter: {
          addDecoration: noop,
          removeDecoration: noop
        },
        raw: { getModel: constant(Optional.none()) }
      };
    };
    const isRtc = editor => has$2(editor.plugins, 'rtc');
    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));
    const setup$s = editor => {
      const editorCast = editor;
      return getRtcSetup(editor).fold(() => {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      }, setup => {
        editorCast.rtcInstance = makeNoopAdaptor();
        return Optional.some(() => setup().then(rtcEditor => {
          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
          return rtcEditor.rtc.isRemote;
        }));
      });
    };
    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    const getRtcInstanceWithError = editor => {
      const rtcInstance = editor.rtcInstance;
      if (!rtcInstance) {
        throw new Error('Failed to get RTC instance not yet initialized.');
      } else {
        return rtcInstance;
      }
    };
    const beforeChange = (editor, locks, beforeBookmark) => {
      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);
    const clear = (editor, undoManager, index) => {
      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    const reset = (editor, undoManager) => {
      getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    const ignore = (editor, locks, callback) => {
      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    const extra = (editor, undoManager, index, callback1, callback2) => {
      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);
    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);
    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);
    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
    const applyFormat = (editor, name, vars, node) => {
      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);
    };
    const removeFormat = (editor, name, vars, node, similar) => {
      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);
    };
    const toggleFormat = (editor, name, vars, node) => {
      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);
    };
    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);
    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();
    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);
    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();

    const getContent$1 = (editor, args = {}) => {
      const format = args.format ? args.format : 'html';
      return getSelectedContent(editor, format, args);
    };

    const removeEmpty = text => {
      if (text.dom.length === 0) {
        remove$5(text);
        return Optional.none();
      } else {
        return Optional.some(text);
      }
    };
    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);
    const merge$1 = (outer, inner, rng, start) => {
      const outerElm = outer.dom;
      const innerElm = inner.dom;
      const oldLength = start ? outerElm.length : innerElm.length;
      if (start) {
        mergeTextNodes(outerElm, innerElm, false, !start);
        rng.setStart(innerElm, oldLength);
      } else {
        mergeTextNodes(innerElm, outerElm, false, !start);
        rng.setEnd(innerElm, oldLength);
      }
    };
    const normalizeTextIfRequired = (inner, start) => {
      parent(inner).each(root => {
        const text = inner.dom;
        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {
          normalizeWhitespaceAfter(text, 0);
        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {
          normalizeWhitespaceBefore(text, text.length);
        }
      });
    };
    const mergeAndNormalizeText = (outerNode, innerNode, rng, start) => {
      outerNode.bind(outer => {
        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
        normalizer(outer.dom, start ? outer.dom.length : 0);
        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start));
      }).orThunk(() => {
        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);
        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start));
      });
    };
    const rngSetContent = (rng, fragment) => {
      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
      rng.deleteContents();
      rng.insertNode(fragment);
      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);
      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);
      mergeAndNormalizeText(prevText, firstChild, rng, true);
      mergeAndNormalizeText(nextText, lastChild, rng, false);
      rng.collapse(false);
    };
    const setupArgs$2 = (args, content) => ({
      format: 'html',
      ...args,
      set: true,
      selection: true,
      content
    });
    const cleanContent = (editor, args) => {
      if (args.format !== 'raw') {
        const rng = editor.selection.getRng();
        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
        const node = editor.parser.parse(args.content, {
          forced_root_block: false,
          ...contextArgs,
          ...args
        });
        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
      } else {
        return args.content;
      }
    };
    const setContent$1 = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs$2(args, content);
      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {
        const cleanedContent = cleanContent(editor, updatedArgs);
        const rng = editor.selection.getRng();
        rngSetContent(rng, rng.createContextualFragment(cleanedContent));
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
        postProcessSetContent(editor, cleanedContent, updatedArgs);
      });
    };

    const deleteFromCallbackMap = (callbackMap, selector, callback) => {
      if (has$2(callbackMap, selector)) {
        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);
        if (newCallbacks.length === 0) {
          delete callbackMap[selector];
        } else {
          callbackMap[selector] = newCallbacks;
        }
      }
    };
    var SelectorChanged = (dom, editor) => {
      let selectorChangedData;
      let currentSelectors;
      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));
      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());
      const setup = () => {
        selectorChangedData = {};
        currentSelectors = {};
        editor.on('NodeChange', e => {
          const node = e.element;
          const parents = getParents(node);
          const matchedSelectors = {};
          each$d(selectorChangedData, (callbacks, selector) => {
            findMatchingNode(selector, parents).each(node => {
              if (!currentSelectors[selector]) {
                each$e(callbacks, callback => {
                  callback(true, {
                    node,
                    selector,
                    parents
                  });
                });
                currentSelectors[selector] = callbacks;
              }
              matchedSelectors[selector] = callbacks;
            });
          });
          each$d(currentSelectors, (callbacks, selector) => {
            if (!matchedSelectors[selector]) {
              delete currentSelectors[selector];
              each$e(callbacks, callback => {
                callback(false, {
                  node,
                  selector,
                  parents
                });
              });
            }
          });
        });
      };
      return {
        selectorChangedWithUnbind: (selector, callback) => {
          if (!selectorChangedData) {
            setup();
          }
          if (!selectorChangedData[selector]) {
            selectorChangedData[selector] = [];
          }
          selectorChangedData[selector].push(callback);
          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {
            currentSelectors[selector] = selectorChangedData[selector];
          });
          return {
            unbind: () => {
              deleteFromCallbackMap(selectorChangedData, selector, callback);
              deleteFromCallbackMap(currentSelectors, selector, callback);
            }
          };
        }
      };
    };

    const isAttachedToDom = node => {
      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    const isValidRange = rng => {
      if (!rng) {
        return false;
      } else {
        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
      }
    };
    const EditorSelection = (dom, win, serializer, editor) => {
      let selectedRange;
      let explicitRange;
      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);
      const setCursorLocation = (node, offset) => {
        const rng = dom.createRng();
        if (isNonNullable(node) && isNonNullable(offset)) {
          rng.setStart(node, offset);
          rng.setEnd(node, offset);
          setRng(rng);
          collapse(false);
        } else {
          moveEndPoint(dom, rng, editor.getBody(), true);
          setRng(rng);
        }
      };
      const getContent = args => getContent$1(editor, args);
      const setContent = (content, args) => setContent$1(editor, content, args);
      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);
      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);
      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);
      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);
      const select$1 = (node, content) => {
        select(dom, node, content).each(setRng);
        return node;
      };
      const isCollapsed = () => {
        const rng = getRng$1(), sel = getSel();
        if (!rng || rng.item) {
          return false;
        }
        if (rng.compareEndPoints) {
          return rng.compareEndPoints('StartToEnd', rng) === 0;
        }
        return !sel || rng.collapsed;
      };
      const isEditable = () => {
        const rng = getRng$1();
        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
        if (fakeSelectedElements.length > 0) {
          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));
        } else if (rng.startContainer === rng.endContainer) {
          return dom.isEditable(rng.startContainer);
        } else {
          return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);
        }
      };
      const collapse = toStart => {
        const rng = getRng$1();
        rng.collapse(!!toStart);
        setRng(rng);
      };
      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
      const getRng$1 = () => {
        let rng;
        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            return -1;
          }
        };
        const doc = win.document;
        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
          const bookmark = getRng(editor);
          if (bookmark.isSome()) {
            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());
          }
        }
        try {
          const selection = getSel();
          if (selection && !isRestrictedNode(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = doc.createRange();
            }
            rng = processRanges(editor, [rng])[0];
          }
        } catch (ex) {
        }
        if (!rng) {
          rng = doc.createRange();
        }
        if (isDocument$1(rng.startContainer) && rng.collapsed) {
          const elm = dom.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }
        if (selectedRange && explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
            rng = explicitRange;
          } else {
            selectedRange = null;
            explicitRange = null;
          }
        }
        return rng;
      };
      const setRng = (rng, forward) => {
        if (!isValidRange(rng)) {
          return;
        }
        const sel = getSel();
        const evt = editor.dispatch('SetSelectionRange', {
          range: rng,
          forward
        });
        rng = evt.range;
        if (sel) {
          explicitRange = rng;
          try {
            sel.removeAllRanges();
            sel.addRange(rng);
          } catch (ex) {
          }
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }
          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }
        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              const node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.nodeName === 'IMG') {
                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }
        editor.dispatch('AfterSetSelectionRange', {
          range: rng,
          forward
        });
      };
      const setNode = elm => {
        setContent(dom.getOuterHTML(elm));
        return elm;
      };
      const getNode$1 = () => getNode(editor.getBody(), getRng$1());
      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);
      const isForward = () => {
        const sel = getSel();
        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
          return true;
        }
        const anchorRange = dom.createRng();
        const focusRange = dom.createRng();
        try {
          anchorRange.setStart(anchorNode, sel.anchorOffset);
          anchorRange.collapse(true);
          focusRange.setStart(focusNode, sel.focusOffset);
          focusRange.collapse(true);
        } catch (e) {
          return true;
        }
        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      };
      const normalize = () => {
        const rng = getRng$1();
        const sel = getSel();
        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
          const normRng = normalize$2(dom, rng);
          normRng.each(normRng => {
            setRng(normRng, isForward());
          });
          return normRng.getOr(rng);
        }
        return rng;
      };
      const selectorChanged = (selector, callback) => {
        selectorChangedWithUnbind(selector, callback);
        return exports;
      };
      const getScrollContainer = () => {
        let scrollContainer;
        let node = dom.getRoot();
        while (node && node.nodeName !== 'BODY') {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
          node = node.parentNode;
        }
        return scrollContainer;
      };
      const scrollIntoView = (elm, alignToTop) => {
        if (isNonNullable(elm)) {
          scrollElementIntoView(editor, elm, alignToTop);
        } else {
          scrollRangeIntoView(editor, getRng$1(), alignToTop);
        }
      };
      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
      const getBoundingClientRect = () => {
        const rng = getRng$1();
        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
      };
      const destroy = () => {
        win = selectedRange = explicitRange = null;
        controlSelection.destroy();
      };
      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));
      const exports = {
        dom,
        win,
        serializer,
        editor,
        expand,
        collapse,
        setCursorLocation,
        getContent,
        setContent,
        getBookmark,
        moveToBookmark,
        select: select$1,
        isCollapsed,
        isEditable,
        isForward,
        setNode,
        getNode: getNode$1,
        getSel,
        setRng,
        getRng: getRng$1,
        getStart: getStart$1,
        getEnd,
        getSelectedBlocks: getSelectedBlocks$1,
        normalize,
        selectorChanged,
        selectorChangedWithUnbind,
        getScrollContainer,
        scrollIntoView,
        placeCaretAt,
        getBoundingClientRect,
        destroy
      };
      const bookmarkManager = BookmarkManager(exports);
      const controlSelection = ControlSelection(exports, editor);
      exports.bookmarkManager = bookmarkManager;
      exports.controlSelection = controlSelection;
      return exports;
    };

    const register$3 = (htmlParser, settings, dom) => {
      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          node.attr('tabindex', node.attr('data-mce-tabindex'));
          node.attr(name, null);
        }
      });
      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {
        const internalName = 'data-mce-' + name;
        const urlConverter = settings.url_converter;
        const urlConverterScope = settings.url_converter_scope;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr(internalName);
          if (value !== undefined) {
            node.attr(name, value.length > 0 ? value : null);
            node.attr(internalName, null);
          } else {
            value = node.attr(name);
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
            } else if (urlConverter) {
              value = urlConverter.call(urlConverterScope, value, name, node.name);
            }
            node.attr(name, value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('class', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr('class');
          if (value) {
            value = value.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
            node.attr('class', value.length > 0 ? value : null);
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {
              var _a;
              return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');
            });
            if (hasChildren) {
              node.unwrap();
            } else {
              node.remove();
            }
          }
        }
      });
      htmlParser.addNodeFilter('noscript', nodes => {
        var _a;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i].firstChild;
          if (node) {
            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');
          }
        }
      });
      htmlParser.addNodeFilter('script,style', (nodes, name) => {
        var _a;
        const trim = value => {
          return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n').replace(/^[\r\n]*|[\r\n]*$/g, '').replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '').replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
        };
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const firstChild = node.firstChild;
          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';
          if (name === 'script') {
            const type = node.attr('type');
            if (type) {
              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
            }
            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
              firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
            }
          } else {
            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {
              firstChild.value = '<!--\n' + trim(value) + '\n-->';
            }
          }
        }
      });
      htmlParser.addNodeFilter('#comment', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const value = node.value;
          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {
            node.name = '#cdata';
            node.type = 4;
            node.value = dom.decode(value.replace(/^\[CDATA\[|\]\]$/g, ''));
          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {
            node.name = '#text';
            node.type = 3;
            node.raw = true;
            node.value = unescape(value).substr(14);
          }
        }
      });
      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name === 'input' && !node.attr('type')) {
              node.attr('type', 'text');
            }
          }
        }
      });
      htmlParser.addAttributeFilter('data-mce-type', nodes => {
        each$e(nodes, node => {
          if (node.attr('data-mce-type') === 'format-caret') {
            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
              node.remove();
            } else {
              node.unwrap();
            }
          }
        });
      });
      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {
        let i = nodes.length;
        while (i--) {
          nodes[i].attr(name, null);
        }
      });
      if (settings.remove_trailing_brs) {
        addNodeFilter(settings, htmlParser, htmlParser.schema);
      }
    };
    const trimTrailingBr = rootNode => {
      const isBr = node => {
        return (node === null || node === void 0 ? void 0 : node.name) === 'br';
      };
      const brNode1 = rootNode.lastChild;
      if (isBr(brNode1)) {
        const brNode2 = brNode1.prev;
        if (isBr(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    };

    const preProcess$1 = (editor, node, args) => {
      let oldDoc;
      const dom = editor.dom;
      let clonedNode = node.cloneNode(true);
      const impl = document.implementation;
      if (impl.createHTMLDocument) {
        const doc = impl.createHTMLDocument('');
        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {
          doc.body.appendChild(doc.importNode(node, true));
        });
        if (clonedNode.nodeName !== 'BODY') {
          clonedNode = doc.body.firstChild;
        } else {
          clonedNode = doc.body;
        }
        oldDoc = dom.doc;
        dom.doc = doc;
      }
      firePreProcess(editor, {
        ...args,
        node: clonedNode
      });
      if (oldDoc) {
        dom.doc = oldDoc;
      }
      return clonedNode;
    };
    const shouldFireEvent = (editor, args) => {
      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;
    };
    const process$1 = (editor, node, args) => {
      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
    };

    const addTempAttr = (htmlParser, tempAttrs, name) => {
      if (Tools.inArray(tempAttrs, name) === -1) {
        htmlParser.addAttributeFilter(name, (nodes, name) => {
          let i = nodes.length;
          while (i--) {
            nodes[i].attr(name, null);
          }
        });
        tempAttrs.push(name);
      }
    };
    const postProcess = (editor, args, content) => {
      if (!args.no_events && editor) {
        const outArgs = firePostProcess(editor, {
          ...args,
          content
        });
        return outArgs.content;
      } else {
        return content;
      }
    };
    const getHtmlFromNode = (dom, node, args) => {
      const html = trim$1(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);
    };
    const parseHtml = (htmlParser, html, args) => {
      const parserArgs = args.selection ? {
        forced_root_block: false,
        ...args
      } : args;
      const rootNode = htmlParser.parse(html, parserArgs);
      trimTrailingBr(rootNode);
      return rootNode;
    };
    const serializeNode = (settings, schema, node) => {
      const htmlSerializer = HtmlSerializer(settings, schema);
      return htmlSerializer.serialize(node);
    };
    const toHtml = (editor, settings, schema, rootNode, args) => {
      const content = serializeNode(settings, schema, rootNode);
      return postProcess(editor, args, content);
    };
    const DomSerializerImpl = (settings, editor) => {
      const tempAttrs = ['data-mce-selected'];
      const defaultedSettings = {
        entity_encoding: 'named',
        remove_trailing_brs: true,
        pad_empty_with_br: false,
        ...settings
      };
      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;
      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);
      const htmlParser = DomParser(defaultedSettings, schema);
      register$3(htmlParser, defaultedSettings, dom);
      const serialize = (node, parserArgs = {}) => {
        const args = {
          format: 'html',
          ...parserArgs
        };
        const targetNode = process$1(editor, node, args);
        const html = getHtmlFromNode(dom, targetNode, args);
        const rootNode = parseHtml(htmlParser, html, args);
        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);
      };
      return {
        schema,
        addNodeFilter: htmlParser.addNodeFilter,
        addAttributeFilter: htmlParser.addAttributeFilter,
        serialize: serialize,
        addRules: schema.addValidElements,
        setRules: schema.setValidElements,
        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
        getTempAttrs: constant(tempAttrs),
        getNodeFilters: htmlParser.getNodeFilters,
        getAttributeFilters: htmlParser.getAttributeFilters,
        removeNodeFilter: htmlParser.removeNodeFilter,
        removeAttributeFilter: htmlParser.removeAttributeFilter
      };
    };

    const DomSerializer = (settings, editor) => {
      const domSerializer = DomSerializerImpl(settings, editor);
      return {
        schema: domSerializer.schema,
        addNodeFilter: domSerializer.addNodeFilter,
        addAttributeFilter: domSerializer.addAttributeFilter,
        serialize: domSerializer.serialize,
        addRules: domSerializer.addRules,
        setRules: domSerializer.setRules,
        addTempAttr: domSerializer.addTempAttr,
        getTempAttrs: domSerializer.getTempAttrs,
        getNodeFilters: domSerializer.getNodeFilters,
        getAttributeFilters: domSerializer.getAttributeFilters,
        removeNodeFilter: domSerializer.removeNodeFilter,
        removeAttributeFilter: domSerializer.removeAttributeFilter
      };
    };

    const defaultFormat$1 = 'html';
    const setupArgs$1 = (args, format) => ({
      ...args,
      format,
      get: true,
      getInner: true
    });
    const getContent = (editor, args = {}) => {
      const format = args.format ? args.format : defaultFormat$1;
      const defaultedArgs = setupArgs$1(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {
        const content = getContent$2(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };

    const defaultFormat = 'html';
    const setupArgs = (args, content) => ({
      format: defaultFormat,
      ...args,
      set: true,
      content
    });
    const setContent = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs(args, content);
      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {
        const result = setContent$2(editor, updatedArgs.content, updatedArgs);
        postProcessSetContent(editor, result.html, updatedArgs);
        return result.content;
      }).getOr(content);
    };

    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');
    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');
    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');
    const deprecatedPlugins = [
      {
        name: 'template',
        replacedWith: 'Advanced Template'
      },
      { name: 'rtc' }
    ];
    const getMatchingOptions = (options, searchingFor) => {
      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));
      return sort(settingNames);
    };
    const getRemovedOptions = options => {
      const settingNames = getMatchingOptions(options, removedOptions);
      const forcedRootBlock = options.forced_root_block;
      if (forcedRootBlock === false || forcedRootBlock === '') {
        settingNames.push('forced_root_block (false only)');
      }
      return sort(settingNames);
    };
    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);
    const getMatchingPlugins = (options, searchingFor) => {
      const plugins = Tools.makeMap(options.plugins, ' ');
      const hasPlugin = plugin => has$2(plugins, plugin);
      const pluginNames = filter$5(searchingFor, hasPlugin);
      return sort(pluginNames);
    };
    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);
    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));
    const logRemovedWarnings = (rawOptions, normalizedOptions) => {
      const removedOptions = getRemovedOptions(rawOptions);
      const removedPlugins = getRemovedPlugins(normalizedOptions);
      const hasRemovedPlugins = removedPlugins.length > 0;
      const hasRemovedOptions = removedOptions.length > 0;
      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';
      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
        const listJoiner = '\n- ';
        const themesMessage = isLegacyMobileTheme ? `\n\nThemes:${ listJoiner }mobile` : '';
        const pluginsMessage = hasRemovedPlugins ? `\n\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';
        const optionsMessage = hasRemovedOptions ? `\n\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';
        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);
      }
    };
    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {
      if (entry.replacedWith) {
        return `${ name }, replaced by ${ entry.replacedWith }`;
      } else {
        return name;
      }
    });
    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
      const deprecatedOptions = getDeprecatedOptions(rawOptions);
      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);
      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;
      const hasDeprecatedOptions = deprecatedOptions.length > 0;
      if (hasDeprecatedPlugins || hasDeprecatedOptions) {
        const listJoiner = '\n- ';
        const pluginsMessage = hasDeprecatedPlugins ? `\n\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';
        const optionsMessage = hasDeprecatedOptions ? `\n\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';
        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);
      }
    };
    const logWarnings = (rawOptions, normalizedOptions) => {
      logRemovedWarnings(rawOptions, normalizedOptions);
      logDeprecatedWarnings(rawOptions, normalizedOptions);
    };

    const DOM$8 = DOMUtils.DOM;
    const restoreOriginalStyles = editor => {
      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);
    };
    const safeDestroy = x => Optional.from(x).each(x => x.destroy());
    const clearDomReferences = editor => {
      const ed = editor;
      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
      ed.iframeElement = ed.targetElm = null;
      const selection = editor.selection;
      if (selection) {
        const dom = selection.dom;
        ed.selection = selection.win = selection.dom = dom.doc = null;
      }
    };
    const restoreForm = editor => {
      const form = editor.formElement;
      if (form) {
        if (form._mceOldSubmit) {
          form.submit = form._mceOldSubmit;
          delete form._mceOldSubmit;
        }
        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);
      }
    };
    const remove$1 = editor => {
      if (!editor.removed) {
        const {_selectionOverrides, editorUpload} = editor;
        const body = editor.getBody();
        const element = editor.getElement();
        if (body) {
          editor.save({ is_removing: true });
        }
        editor.removed = true;
        editor.unbindAllNativeEvents();
        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
          DOM$8.remove(element.nextSibling);
        }
        fireRemove(editor);
        editor.editorManager.remove(editor);
        if (!editor.inline && body) {
          restoreOriginalStyles(editor);
        }
        fireDetach(editor);
        DOM$8.remove(editor.getContainer());
        safeDestroy(_selectionOverrides);
        safeDestroy(editorUpload);
        editor.destroy();
      }
    };
    const destroy = (editor, automatic) => {
      const {selection, dom} = editor;
      if (editor.destroyed) {
        return;
      }
      if (!automatic && !editor.removed) {
        editor.remove();
        return;
      }
      if (!automatic) {
        editor.editorManager.off('beforeunload', editor._beforeUnload);
        if (editor.theme && editor.theme.destroy) {
          editor.theme.destroy();
        }
        safeDestroy(selection);
        safeDestroy(dom);
      }
      restoreForm(editor);
      clearDomReferences(editor);
      editor.destroyed = true;
    };

    const CreateIconManager = () => {
      const lookup = {};
      const add = (id, iconPack) => {
        lookup[id] = iconPack;
      };
      const get = id => {
        if (lookup[id]) {
          return lookup[id];
        } else {
          return { icons: {} };
        }
      };
      const has = id => has$2(lookup, id);
      return {
        add,
        get,
        has
      };
    };
    const IconManager = CreateIconManager();

    const ModelManager = AddOnManager.ModelManager;

    const getProp = (propName, elm) => {
      const rawElm = elm.dom;
      return rawElm[propName];
    };
    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
    const getClientWidth = curry(getProp, 'clientWidth');
    const getClientHeight = curry(getProp, 'clientHeight');
    const getMarginTop = curry(getComputedSizeProp, 'margin-top');
    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');
    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();
    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
      const clientWidth = getClientWidth(bodyElm);
      const clientHeight = getClientHeight(bodyElm);
      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    const transpose = (inline, elm, clientX, clientY) => {
      const clientRect = getBoundingClientRect(elm);
      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
      const x = clientX - deltaX;
      const y = clientY - deltaY;
      return {
        x,
        y
      };
    };
    const isXYInContentArea = (editor, clientX, clientY) => {
      const bodyElm = SugarElement.fromDom(editor.getBody());
      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);
    const isEditorAttachedToDom = editor => {
      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
      return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };

    var NotificationManagerImpl = () => {
      const unimplemented = () => {
        throw new Error('Theme did not provide a NotificationManager implementation.');
      };
      return {
        open: unimplemented,
        close: unimplemented,
        getArgs: unimplemented
      };
    };

    const NotificationManager = editor => {
      const notifications = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
      };
      const getTopNotification = () => {
        return Optional.from(notifications[0]);
      };
      const isEqual = (a, b) => {
        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
      };
      const reposition = () => {
        each$e(notifications, notification => {
          notification.reposition();
        });
      };
      const addNotification = notification => {
        notifications.push(notification);
      };
      const closeNotification = notification => {
        findIndex$2(notifications, otherNotification => {
          return otherNotification === notification;
        }).each(index => {
          notifications.splice(index, 1);
        });
      };
      const open = (spec, fireEvent = true) => {
        if (editor.removed || !isEditorAttachedToDom(editor)) {
          return {};
        }
        if (fireEvent) {
          editor.dispatch('BeforeOpenNotification', { notification: spec });
        }
        return find$2(notifications, notification => {
          return isEqual(getImplementation().getArgs(notification), spec);
        }).getOrThunk(() => {
          editor.editorManager.setActive(editor);
          const notification = getImplementation().open(spec, () => {
            closeNotification(notification);
            reposition();
            getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));
          });
          addNotification(notification);
          reposition();
          editor.dispatch('OpenNotification', { notification: { ...notification } });
          return notification;
        });
      };
      const close = () => {
        getTopNotification().each(notification => {
          getImplementation().close(notification);
          closeNotification(notification);
          reposition();
        });
      };
      const getNotifications = constant(notifications);
      const registerEvents = editor => {
        editor.on('SkinLoaded', () => {
          const serviceMessage = getServiceMessage(editor);
          if (serviceMessage) {
            open({
              text: serviceMessage,
              type: 'warning',
              timeout: 0
            }, false);
          }
          reposition();
        });
        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {
          requestAnimationFrame(reposition);
        });
        editor.on('remove', () => {
          each$e(notifications.slice(), notification => {
            getImplementation().close(notification);
          });
        });
      };
      registerEvents(editor);
      return {
        open,
        close,
        getNotifications
      };
    };

    const PluginManager = AddOnManager.PluginManager;

    const ThemeManager = AddOnManager.ThemeManager;

    var WindowManagerImpl = () => {
      const unimplemented = () => {
        throw new Error('Theme did not provide a WindowManager implementation.');
      };
      return {
        open: unimplemented,
        openUrl: unimplemented,
        alert: unimplemented,
        confirm: unimplemented,
        close: unimplemented
      };
    };

    const WindowManager = editor => {
      let dialogs = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
      };
      const funcBind = (scope, f) => {
        return (...args) => {
          return f ? f.apply(scope, args) : undefined;
        };
      };
      const fireOpenEvent = dialog => {
        editor.dispatch('OpenWindow', { dialog });
      };
      const fireCloseEvent = dialog => {
        editor.dispatch('CloseWindow', { dialog });
      };
      const addDialog = dialog => {
        dialogs.push(dialog);
        fireOpenEvent(dialog);
      };
      const closeDialog = dialog => {
        fireCloseEvent(dialog);
        dialogs = filter$5(dialogs, otherDialog => {
          return otherDialog !== dialog;
        });
        if (dialogs.length === 0) {
          editor.focus();
        }
      };
      const getTopDialog = () => {
        return Optional.from(dialogs[dialogs.length - 1]);
      };
      const storeSelectionAndOpenDialog = openDialog => {
        editor.editorManager.setActive(editor);
        store(editor);
        editor.ui.show();
        const dialog = openDialog();
        addDialog(dialog);
        return dialog;
      };
      const open = (args, params) => {
        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
      };
      const openUrl = args => {
        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
      };
      const alert = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const confirm = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const close = () => {
        getTopDialog().each(dialog => {
          getImplementation().close(dialog);
          closeDialog(dialog);
        });
      };
      editor.on('remove', () => {
        each$e(dialogs, dialog => {
          getImplementation().close(dialog);
        });
      });
      return {
        open,
        openUrl,
        alert,
        confirm,
        close
      };
    };

    const displayNotification = (editor, message) => {
      editor.notificationManager.open({
        type: 'error',
        text: message
      });
    };
    const displayError = (editor, message) => {
      if (editor._skinLoaded) {
        displayNotification(editor, message);
      } else {
        editor.on('SkinLoaded', () => {
          displayNotification(editor, message);
        });
      }
    };
    const uploadError = (editor, message) => {
      displayError(editor, I18n.translate([
        'Failed to upload image: {0}',
        message
      ]));
    };
    const logError = (editor, errorType, msg) => {
      fireError(editor, errorType, { message: msg });
      console.error(msg);
    };
    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;
    const pluginLoadError = (editor, url, name) => {
      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
    };
    const iconsLoadError = (editor, url, name) => {
      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
    };
    const languageLoadError = (editor, url, name) => {
      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
    };
    const themeLoadError = (editor, url, name) => {
      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));
    };
    const modelLoadError = (editor, url, name) => {
      logError(editor, 'ModelLoadError', createLoadError('model', url, name));
    };
    const pluginInitError = (editor, name, err) => {
      const message = I18n.translate([
        'Failed to initialize plugin: {0}',
        name
      ]);
      fireError(editor, 'PluginLoadError', { message });
      initError(message, err);
      displayError(editor, message);
    };
    const initError = (message, ...x) => {
      const console = window.console;
      if (console) {
        if (console.error) {
          console.error(message, ...x);
        } else {
          console.log(message, ...x);
        }
      }
    };

    const isContentCssSkinName = url => /^[a-z0-9\-]+$/i.test(url);
    const getContentCssUrls = editor => {
      return transformToUrls(editor, getContentCss(editor));
    };
    const getFontCssUrls = editor => {
      return transformToUrls(editor, getFontCss(editor));
    };
    const transformToUrls = (editor, cssLinks) => {
      const skinUrl = editor.editorManager.baseURL + '/skins/content';
      const suffix = editor.editorManager.suffix;
      const contentCssFile = `content${ suffix }.css`;
      return map$3(cssLinks, url => {
        if (isContentCssSkinName(url) && !editor.inline) {
          return `${ skinUrl }/${ url }/${ contentCssFile }`;
        } else {
          return editor.documentBaseURI.toAbsolute(url);
        }
      });
    };
    const appendContentCssFromSettings = editor => {
      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };

    const getAllImages = elm => {
      return elm ? from(elm.getElementsByTagName('img')) : [];
    };
    const ImageScanner = (uploadStatus, blobCache) => {
      const cachedPromises = {};
      const findAll = (elm, predicate = always) => {
        const images = filter$5(getAllImages(elm), img => {
          const src = img.src;
          if (img.hasAttribute('data-mce-bogus')) {
            return false;
          }
          if (img.hasAttribute('data-mce-placeholder')) {
            return false;
          }
          if (!src || src === Env.transparentSrc) {
            return false;
          }
          if (startsWith(src, 'blob:')) {
            return !uploadStatus.isUploaded(src) && predicate(img);
          }
          if (startsWith(src, 'data:')) {
            return predicate(img);
          }
          return false;
        });
        const promises = map$3(images, img => {
          const imageSrc = img.src;
          if (has$2(cachedPromises, imageSrc)) {
            return cachedPromises[imageSrc].then(imageInfo => {
              if (isString(imageInfo)) {
                return imageInfo;
              } else {
                return {
                  image: img,
                  blobInfo: imageInfo.blobInfo
                };
              }
            });
          } else {
            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {
              delete cachedPromises[imageSrc];
              return {
                image: img,
                blobInfo
              };
            }).catch(error => {
              delete cachedPromises[imageSrc];
              return error;
            });
            cachedPromises[imageSrc] = newPromise;
            return newPromise;
          }
        });
        return Promise.all(promises);
      };
      return { findAll };
    };

    const UploadStatus = () => {
      const PENDING = 1, UPLOADED = 2;
      let blobUriStatuses = {};
      const createStatus = (status, resultUri) => {
        return {
          status,
          resultUri
        };
      };
      const hasBlobUri = blobUri => {
        return blobUri in blobUriStatuses;
      };
      const getResultUri = blobUri => {
        const result = blobUriStatuses[blobUri];
        return result ? result.resultUri : null;
      };
      const isPending = blobUri => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
      };
      const isUploaded = blobUri => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
      };
      const markPending = blobUri => {
        blobUriStatuses[blobUri] = createStatus(PENDING, null);
      };
      const markUploaded = (blobUri, resultUri) => {
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      };
      const removeFailed = blobUri => {
        delete blobUriStatuses[blobUri];
      };
      const destroy = () => {
        blobUriStatuses = {};
      };
      return {
        hasBlobUri,
        getResultUri,
        isPending,
        isUploaded,
        markPending,
        markUploaded,
        removeFailed,
        destroy
      };
    };

    let count = 0;
    const seed = () => {
      const rnd = () => {
        return Math.round(Math.random() * 4294967295).toString(36);
      };
      const now = new Date().getTime();
      return 's' + now.toString(36) + rnd() + rnd() + rnd();
    };
    const uuid = prefix => {
      return prefix + count++ + seed();
    };

    const BlobCache = () => {
      let cache = [];
      const mimeToExt = mime => {
        const mimes = {
          'image/jpeg': 'jpg',
          'image/jpg': 'jpg',
          'image/gif': 'gif',
          'image/png': 'png',
          'image/apng': 'apng',
          'image/avif': 'avif',
          'image/svg+xml': 'svg',
          'image/webp': 'webp',
          'image/bmp': 'bmp',
          'image/tiff': 'tiff'
        };
        return mimes[mime.toLowerCase()] || 'dat';
      };
      const create = (o, blob, base64, name, filename) => {
        if (isString(o)) {
          const id = o;
          return toBlobInfo({
            id,
            name,
            filename,
            blob: blob,
            base64: base64
          });
        } else if (isObject(o)) {
          return toBlobInfo(o);
        } else {
          throw new Error('Unknown input type');
        }
      };
      const toBlobInfo = o => {
        if (!o.blob || !o.base64) {
          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
        }
        const id = o.id || uuid('blobid');
        const name = o.name || id;
        const blob = o.blob;
        return {
          id: constant(id),
          name: constant(name),
          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),
          blob: constant(blob),
          base64: constant(o.base64),
          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),
          uri: constant(o.uri)
        };
      };
      const add = blobInfo => {
        if (!get(blobInfo.id())) {
          cache.push(blobInfo);
        }
      };
      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();
      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);
      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);
      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);
      const removeByUri = blobUri => {
        cache = filter$5(cache, blobInfo => {
          if (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            return false;
          }
          return true;
        });
      };
      const destroy = () => {
        each$e(cache, cachedBlobInfo => {
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });
        cache = [];
      };
      return {
        create,
        add,
        get,
        getByUri,
        getByData,
        findFirst,
        removeByUri,
        destroy
      };
    };

    const Uploader = (uploadStatus, settings) => {
      const pendingPromises = {};
      const pathJoin = (path1, path2) => {
        if (path1) {
          return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
        }
        return path2;
      };
      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = e => {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = () => {
          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
        };
        xhr.onload = () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure('HTTP Error: ' + xhr.status);
            return;
          }
          const json = JSON.parse(xhr.responseText);
          if (!json || !isString(json.location)) {
            failure('Invalid JSON: ' + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        const formData = new FormData();
        formData.append('file', blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      });
      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
      const noUpload = () => new Promise(resolve => {
        resolve([]);
      });
      const handlerSuccess = (blobInfo, url) => ({
        url,
        blobInfo,
        status: true
      });
      const handlerFailure = (blobInfo, error) => ({
        url: '',
        blobInfo,
        status: false,
        error
      });
      const resolvePending = (blobUri, result) => {
        Tools.each(pendingPromises[blobUri], resolve => {
          resolve(result);
        });
        delete pendingPromises[blobUri];
      };
      const uploadBlobInfo = (blobInfo, handler, openNotification) => {
        uploadStatus.markPending(blobInfo.blobUri());
        return new Promise(resolve => {
          let notification;
          let progress;
          try {
            const closeNotification = () => {
              if (notification) {
                notification.close();
                progress = noop;
              }
            };
            const success = url => {
              closeNotification();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve(handlerSuccess(blobInfo, url));
            };
            const failure = error => {
              closeNotification();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
              resolve(handlerFailure(blobInfo, error));
            };
            progress = percent => {
              if (percent < 0 || percent > 100) {
                return;
              }
              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {
                notification = n;
                n.progressBar.value(percent);
              });
            };
            handler(blobInfo, progress).then(success, err => {
              failure(isString(err) ? { message: err } : err);
            });
          } catch (ex) {
            resolve(handlerFailure(blobInfo, ex));
          }
        });
      };
      const isDefaultHandler = handler => handler === defaultHandler;
      const pendingUploadBlobInfo = blobInfo => {
        const blobUri = blobInfo.blobUri();
        return new Promise(resolve => {
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve);
        });
      };
      const uploadBlobs = (blobInfos, openNotification) => {
        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));
        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));
      };
      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
      return { upload };
    };

    const openNotification = editor => () => editor.notificationManager.open({
      text: editor.translate('Image uploading...'),
      type: 'info',
      timeout: -1,
      progressBar: true
    });
    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
      url: getImageUploadUrl(editor),
      basePath: getImageUploadBasePath(editor),
      credentials: getImagesUploadCredentials(editor),
      handler: getImagesUploadHandler(editor)
    });
    const ImageUploader = editor => {
      const uploadStatus = UploadStatus();
      const uploader = createUploader(editor, uploadStatus);
      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };
    };

    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
    const addPaddingToEmpty = editor => element => {
      if (isEmptyForPadding(editor, element)) {
        append$1(element, SugarElement.fromHtml('<br data-mce-bogus="1" />'));
      }
    };
    const EditorUpload = editor => {
      const blobCache = BlobCache();
      let uploader, imageScanner;
      const uploadStatus = UploadStatus();
      const urlFilters = [];
      const aliveGuard = callback => {
        return result => {
          if (editor.selection) {
            return callback(result);
          }
          return [];
        };
      };
      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();
      const replaceString = (content, search, replace) => {
        let index = 0;
        do {
          index = content.indexOf(search, index);
          if (index !== -1) {
            content = content.substring(0, index) + replace + content.substr(index + search.length);
            index += replace.length - search.length + 1;
          }
        } while (index !== -1);
        return content;
      };
      const replaceImageUrl = (content, targetUrl, replacementUrl) => {
        const replacementString = `src="${ replacementUrl }"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : '' }`;
        content = replaceString(content, `src="${ targetUrl }"`, replacementString);
        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
        return content;
      };
      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
        each$e(editor.undoManager.data, level => {
          if (level.type === 'fragmented') {
            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));
          } else {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      };
      const replaceImageUriInView = (image, resultUri) => {
        const src = editor.convertURL(resultUri, 'src');
        replaceUrlInUndoStack(image.src, resultUri);
        setAll$1(SugarElement.fromDom(image), {
          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
          'data-mce-src': src
        });
      };
      const uploadImages = () => {
        if (!uploader) {
          uploader = createUploader(editor, uploadStatus);
        }
        return scanForImages().then(aliveGuard(imageInfos => {
          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);
          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {
            const imagesToRemove = [];
            let shouldDispatchChange = false;
            const filteredResult = map$3(result, (uploadInfo, index) => {
              const {blobInfo, image} = imageInfos[index];
              let removed = false;
              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                  shouldDispatchChange = true;
                }
                blobCache.removeByUri(image.src);
                if (isRtc(editor)) ; else {
                  replaceImageUriInView(image, uploadInfo.url);
                }
              } else if (uploadInfo.error) {
                if (uploadInfo.error.remove) {
                  replaceUrlInUndoStack(image.src, Env.transparentSrc);
                  imagesToRemove.push(image);
                  removed = true;
                }
                uploadError(editor, uploadInfo.error.message);
              }
              return {
                element: image,
                status: uploadInfo.status,
                uploadUri: uploadInfo.url,
                blobInfo,
                removed
              };
            });
            if (imagesToRemove.length > 0 && !isRtc(editor)) {
              editor.undoManager.transact(() => {
                each$e(fromDom$1(imagesToRemove), sugarElement => {
                  const parentOpt = parent(sugarElement);
                  remove$5(sugarElement);
                  parentOpt.each(addPaddingToEmpty(editor));
                  blobCache.removeByUri(sugarElement.dom.src);
                });
              });
            } else if (shouldDispatchChange) {
              editor.undoManager.dispatchChange();
            }
            return filteredResult;
          }));
        }));
      };
      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));
      const addFilter = filter => {
        urlFilters.push(filter);
      };
      const scanForImages = () => {
        if (!imageScanner) {
          imageScanner = ImageScanner(uploadStatus, blobCache);
        }
        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {
          const filteredResult = filter$5(result, resultItem => {
            if (isString(resultItem)) {
              displayError(editor, resultItem);
              return false;
            } else if (resultItem.uriType === 'blob') {
              return false;
            } else {
              return true;
            }
          });
          if (isRtc(editor)) ; else {
            each$e(filteredResult, resultItem => {
              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
              resultItem.image.src = resultItem.blobInfo.blobUri();
              resultItem.image.removeAttribute('data-mce-src');
            });
          }
          return filteredResult;
        }));
      };
      const destroy = () => {
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = null;
      };
      const replaceBlobUris = content => {
        return content.replace(/src="(blob:[^"]+)"/g, (match, blobUri) => {
          const resultUri = uploadStatus.getResultUri(blobUri);
          if (resultUri) {
            return 'src="' + resultUri + '"';
          }
          let blobInfo = blobCache.getByUri(blobUri);
          if (!blobInfo) {
            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {
              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
            }, undefined);
          }
          if (blobInfo) {
            const blob = blobInfo.blob();
            return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
          }
          return match;
        });
      };
      editor.on('SetContent', () => {
        if (isAutomaticUploadsEnabled(editor)) {
          uploadImagesAuto();
        } else {
          scanForImages();
        }
      });
      editor.on('RawSaveContent', e => {
        e.content = replaceBlobUris(e.content);
      });
      editor.on('GetContent', e => {
        if (e.source_view || e.format === 'raw' || e.format === 'tree') {
          return;
        }
        e.content = replaceBlobUris(e.content);
      });
      editor.on('PostRender', () => {
        editor.parser.addNodeFilter('img', images => {
          each$e(images, img => {
            const src = img.attr('src');
            if (!src || blobCache.getByUri(src)) {
              return;
            }
            const resultUri = uploadStatus.getResultUri(src);
            if (resultUri) {
              img.attr('src', resultUri);
            }
          });
        });
      });
      return {
        blobCache,
        addFilter,
        uploadImages,
        uploadImagesAuto,
        scanForImages,
        destroy
      };
    };

    const get$1 = editor => {
      const dom = editor.dom;
      const schemaType = editor.schema.type;
      const formats = {
        valigntop: [{
            selector: 'td,th',
            styles: { verticalAlign: 'top' }
          }],
        valignmiddle: [{
            selector: 'td,th',
            styles: { verticalAlign: 'middle' }
          }],
        valignbottom: [{
            selector: 'td,th',
            styles: { verticalAlign: 'bottom' }
          }],
        alignleft: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-left',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'left' },
            inherit: false,
            preview: false
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: { float: 'left' },
            preview: 'font-family font-size'
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginLeft: '0px',
              marginRight: 'auto'
            },
            onformat: table => {
              dom.setStyle(table, 'float', null);
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object,[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: { float: 'left' }
          }
        ],
        aligncenter: [
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'center' },
            inherit: false,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-center',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: {
              display: 'block',
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object',
            ceFalseOverride: true,
            styles: {
              display: 'table',
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          },
          {
            selector: '[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: {
              marginLeft: 'auto',
              marginRight: 'auto'
            },
            preview: false
          }
        ],
        alignright: [
          {
            selector: 'figure.image',
            collapsed: false,
            classes: 'align-right',
            ceFalseOverride: true,
            preview: 'font-family font-size'
          },
          {
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'right' },
            inherit: false,
            preview: 'font-family font-size'
          },
          {
            selector: 'img,audio,video',
            collapsed: false,
            styles: { float: 'right' },
            preview: 'font-family font-size'
          },
          {
            selector: 'table',
            collapsed: false,
            styles: {
              marginRight: '0px',
              marginLeft: 'auto'
            },
            onformat: table => {
              dom.setStyle(table, 'float', null);
            },
            preview: 'font-family font-size'
          },
          {
            selector: '.mce-preview-object,[data-ephox-embed-iri]',
            ceFalseOverride: true,
            styles: { float: 'right' },
            preview: false
          }
        ],
        alignjustify: [{
            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',
            styles: { textAlign: 'justify' },
            inherit: false,
            preview: 'font-family font-size'
          }],
        bold: [
          {
            inline: 'strong',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontWeight: 'bold' }
          },
          {
            inline: 'b',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        italic: [
          {
            inline: 'em',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          },
          {
            inline: 'span',
            styles: { fontStyle: 'italic' }
          },
          {
            inline: 'i',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        underline: [
          {
            inline: 'span',
            styles: { textDecoration: 'underline' },
            exact: true
          },
          {
            inline: 'u',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          }
        ],
        strikethrough: (() => {
          const span = {
            inline: 'span',
            styles: { textDecoration: 'line-through' },
            exact: true
          };
          const strike = {
            inline: 'strike',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          };
          const s = {
            inline: 's',
            remove: 'all',
            preserve_attributes: [
              'class',
              'style'
            ]
          };
          return schemaType !== 'html4' ? [
            s,
            span,
            strike
          ] : [
            span,
            s,
            strike
          ];
        })(),
        forecolor: {
          inline: 'span',
          styles: { color: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        hilitecolor: {
          inline: 'span',
          styles: { backgroundColor: '%value' },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        fontname: {
          inline: 'span',
          toggle: false,
          styles: { fontFamily: '%value' },
          clear_child_styles: true
        },
        fontsize: {
          inline: 'span',
          toggle: false,
          styles: { fontSize: '%value' },
          clear_child_styles: true
        },
        lineheight: {
          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',
          styles: { lineHeight: '%value' }
        },
        fontsize_class: {
          inline: 'span',
          attributes: { class: '%value' }
        },
        blockquote: {
          block: 'blockquote',
          wrapper: true,
          remove: 'all'
        },
        subscript: { inline: 'sub' },
        superscript: { inline: 'sup' },
        code: { inline: 'code' },
        link: {
          inline: 'a',
          selector: 'a',
          remove: 'all',
          split: true,
          deep: true,
          onmatch: (node, _fmt, _itemName) => {
            return isElement$6(node) && node.hasAttribute('href');
          },
          onformat: (elm, _fmt, vars) => {
            Tools.each(vars, (value, key) => {
              dom.setAttrib(elm, key, value);
            });
          }
        },
        lang: {
          inline: 'span',
          clear_child_styles: true,
          remove_similar: true,
          attributes: {
            'lang': '%value',
            'data-mce-lang': vars => {
              var _a;
              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        },
        removeformat: [
          {
            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',
            remove: 'all',
            split: true,
            expand: false,
            block_expand: true,
            deep: true
          },
          {
            selector: 'span',
            attributes: [
              'style',
              'class'
            ],
            remove: 'empty',
            split: true,
            expand: false,
            deep: true
          },
          {
            selector: '*',
            attributes: [
              'style',
              'class'
            ],
            split: false,
            expand: false,
            deep: true
          }
        ]
      };
      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\s/), name => {
        formats[name] = {
          block: name,
          remove: 'all'
        };
      });
      return formats;
    };

    const genericBase = {
      remove_similar: true,
      inherit: false
    };
    const cellBase = {
      selector: 'td,th',
      ...genericBase
    };
    const cellFormats = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: '%value' },
        ...cellBase
      },
      tablecellverticalalign: {
        styles: { 'vertical-align': '%value' },
        ...cellBase
      },
      tablecellbordercolor: {
        styles: { borderColor: '%value' },
        ...cellBase
      },
      tablecellclass: {
        classes: ['%value'],
        ...cellBase
      },
      tableclass: {
        selector: 'table',
        classes: ['%value'],
        ...genericBase
      },
      tablecellborderstyle: {
        styles: { borderStyle: '%value' },
        ...cellBase
      },
      tablecellborderwidth: {
        styles: { borderWidth: '%value' },
        ...cellBase
      }
    };
    const get = constant(cellFormats);

    const FormatRegistry = editor => {
      const formats = {};
      const get$2 = name => isNonNullable(name) ? formats[name] : formats;
      const has = name => has$2(formats, name);
      const register = (name, format) => {
        if (name) {
          if (!isString(name)) {
            each$d(name, (format, name) => {
              register(name, format);
            });
          } else {
            if (!isArray$1(format)) {
              format = [format];
            }
            each$e(format, format => {
              if (isUndefined(format.deep)) {
                format.deep = !isSelectorFormat(format);
              }
              if (isUndefined(format.split)) {
                format.split = !isSelectorFormat(format) || isInlineFormat(format);
              }
              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {
                format.remove = 'none';
              }
              if (isSelectorFormat(format) && isInlineFormat(format)) {
                format.mixed = true;
                format.block_expand = true;
              }
              if (isString(format.classes)) {
                format.classes = format.classes.split(/\s+/);
              }
            });
            formats[name] = format;
          }
        }
      };
      const unregister = name => {
        if (name && formats[name]) {
          delete formats[name];
        }
        return formats;
      };
      register(get$1(editor));
      register(get());
      register(getFormats(editor));
      return {
        get: get$2,
        has,
        register,
        unregister
      };
    };

    const each$3 = Tools.each;
    const dom = DOMUtils.DOM;
    const isPreviewItem = item => isNonNullable(item) && isObject(item);
    const parsedSelectorToHtml = (ancestry, editor) => {
      const schema = editor && editor.schema || Schema({});
      const decorate = (elm, item) => {
        if (item.classes.length > 0) {
          dom.addClass(elm, item.classes.join(' '));
        }
        dom.setAttribs(elm, item.attrs);
      };
      const createElement = sItem => {
        const item = isString(sItem) ? {
          name: sItem,
          classes: [],
          attrs: {}
        } : sItem;
        const elm = dom.create(item.name);
        decorate(elm, item);
        return elm;
      };
      const getRequiredParent = (elm, candidate) => {
        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
        if (parentsRequired && parentsRequired.length) {
          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
        } else {
          return false;
        }
      };
      const wrapInHtml = (elm, ancestors, siblings) => {
        let parentCandidate;
        const ancestor = ancestors[0];
        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;
        const parentRequired = getRequiredParent(elm, ancestorName);
        if (parentRequired) {
          if (ancestorName === parentRequired) {
            parentCandidate = ancestor;
            ancestors = ancestors.slice(1);
          } else {
            parentCandidate = parentRequired;
          }
        } else if (ancestor) {
          parentCandidate = ancestor;
          ancestors = ancestors.slice(1);
        } else if (!siblings) {
          return elm;
        }
        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');
        parent.appendChild(elm);
        if (siblings) {
          Tools.each(siblings, sibling => {
            const siblingElm = createElement(sibling);
            parent.insertBefore(siblingElm, elm);
          });
        }
        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;
        return wrapInHtml(parent, ancestors, parentSiblings);
      };
      const fragment = dom.create('div');
      if (ancestry.length > 0) {
        const item = ancestry[0];
        const elm = createElement(item);
        const siblings = isPreviewItem(item) ? item.siblings : undefined;
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));
      }
      return fragment;
    };
    const parseSelectorItem = item => {
      item = Tools.trim(item);
      let tagName = 'div';
      const obj = {
        name: tagName,
        classes: [],
        attrs: {},
        selector: item
      };
      if (item !== '*') {
        tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
          switch ($1) {
          case '#':
            obj.attrs.id = $2;
            break;
          case '.':
            obj.classes.push($2);
            break;
          case ':':
            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
              obj.attrs[$2] = $2;
            }
            break;
          }
          if ($3 === '[') {
            const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return '';
        });
      }
      obj.name = tagName || 'div';
      return obj;
    };
    const parseSelector = selector => {
      if (!isString(selector)) {
        return [];
      }
      selector = selector.split(/\s*,\s*/)[0];
      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), item => {
        const siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
        const obj = siblings.pop();
        if (siblings.length) {
          obj.siblings = siblings;
        }
        return obj;
      }).reverse();
    };
    const getCssText = (editor, format) => {
      let previewCss = '';
      let previewStyles = getPreviewStyles(editor);
      if (previewStyles === '') {
        return '';
      }
      const removeVars = val => {
        return isString(val) ? val.replace(/%(\w+)/g, '') : '';
      };
      const getComputedStyle = (name, elm) => {
        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);
      };
      if (isString(format)) {
        const formats = editor.formatter.get(format);
        if (!formats) {
          return '';
        }
        format = formats[0];
      }
      if ('preview' in format) {
        const preview = format.preview;
        if (preview === false) {
          return '';
        } else {
          previewStyles = preview || previewStyles;
        }
      }
      let name = format.block || format.inline || 'span';
      let previewFrag;
      const items = parseSelector(format.selector);
      if (items.length > 0) {
        if (!items[0].name) {
          items[0].name = name;
        }
        name = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } else {
        previewFrag = parsedSelectorToHtml([name], editor);
      }
      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
      each$3(format.styles, (value, name) => {
        const newValue = removeVars(value);
        if (newValue) {
          dom.setStyle(previewElm, name, newValue);
        }
      });
      each$3(format.attributes, (value, name) => {
        const newValue = removeVars(value);
        if (newValue) {
          dom.setAttrib(previewElm, name, newValue);
        }
      });
      each$3(format.classes, value => {
        const newValue = removeVars(value);
        if (!dom.hasClass(previewElm, newValue)) {
          dom.addClass(previewElm, newValue);
        }
      });
      editor.dispatch('PreviewFormats');
      dom.setStyles(previewFrag, {
        position: 'absolute',
        left: -65535
      });
      editor.getBody().appendChild(previewFrag);
      const rawParentFontSize = getComputedStyle('fontSize');
      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
      each$3(previewStyles.split(' '), name => {
        let value = getComputedStyle(name, previewElm);
        if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
          value = getComputedStyle(name);
          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {
            return;
          }
        }
        if (name === 'color') {
          if (rgbaToHexString(value).toLowerCase() === '#000000') {
            return;
          }
        }
        if (name === 'font-size') {
          if (/em|%$/.test(value)) {
            if (parentFontSize === 0) {
              return;
            }
            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
            value = numValue * parentFontSize + 'px';
          }
        }
        if (name === 'border' && value) {
          previewCss += 'padding:0 2px;';
        }
        previewCss += name + ':' + value + ';';
      });
      editor.dispatch('AfterPreviewFormats');
      dom.remove(previewFrag);
      return previewCss;
    };

    const setup$r = editor => {
      editor.addShortcut('meta+b', '', 'Bold');
      editor.addShortcut('meta+i', '', 'Italic');
      editor.addShortcut('meta+u', '', 'Underline');
      for (let i = 1; i <= 6; i++) {
        editor.addShortcut('access+' + i, '', [
          'FormatBlock',
          false,
          'h' + i
        ]);
      }
      editor.addShortcut('access+7', '', [
        'FormatBlock',
        false,
        'p'
      ]);
      editor.addShortcut('access+8', '', [
        'FormatBlock',
        false,
        'div'
      ]);
      editor.addShortcut('access+9', '', [
        'FormatBlock',
        false,
        'address'
      ]);
    };

    const Formatter = editor => {
      const formats = FormatRegistry(editor);
      const formatChangeState = Cell({});
      setup$r(editor);
      setup$u(editor);
      if (!isRtc(editor)) {
        setup$t(formatChangeState, editor);
      }
      return {
        get: formats.get,
        has: formats.has,
        register: formats.register,
        unregister: formats.unregister,
        apply: (name, vars, node) => {
          applyFormat(editor, name, vars, node);
        },
        remove: (name, vars, node, similar) => {
          removeFormat(editor, name, vars, node, similar);
        },
        toggle: (name, vars, node) => {
          toggleFormat(editor, name, vars, node);
        },
        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),
        closest: names => closestFormat(editor, names),
        matchAll: (names, vars) => matchAllFormats(editor, names, vars),
        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),
        canApply: name => canApplyFormat(editor, name),
        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),
        getCssText: curry(getCssText, editor)
      };
    };

    const shouldIgnoreCommand = cmd => {
      switch (cmd.toLowerCase()) {
      case 'undo':
      case 'redo':
      case 'mcefocus':
        return true;
      default:
        return false;
      }
    };
    const registerEvents = (editor, undoManager, locks) => {
      const isFirstTypedCharacter = Cell(false);
      const addNonTypingUndoLevel = e => {
        setTyping(undoManager, false, locks);
        undoManager.add({}, e);
      };
      editor.on('init', () => {
        undoManager.add();
      });
      editor.on('BeforeExecCommand', e => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
        }
      });
      editor.on('ExecCommand', e => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('ObjectResizeStart cut', () => {
        undoManager.beforeChange();
      });
      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
      editor.on('dragend', addNonTypingUndoLevel);
      editor.on('keyup', e => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        const isMeta = Env.os.isMacOS() && e.key === 'Meta';
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }
        if (keyCode === 46 || keyCode === 8) {
          editor.nodeChanged();
        }
        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
          if (!editor.isDirty()) {
            editor.setDirty(true);
          }
          editor.dispatch('TypingUndo');
          isFirstTypedCharacter.set(false);
          editor.nodeChanged();
        }
      });
      editor.on('keydown', e => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
          if (undoManager.typing) {
            addNonTypingUndoLevel(e);
          }
          return;
        }
        const modKey = e.ctrlKey && !e.altKey || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
          undoManager.beforeChange();
          setTyping(undoManager, true, locks);
          undoManager.add({}, e);
          isFirstTypedCharacter.set(true);
          return;
        }
        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;
        if (hasOnlyMetaOrCtrlModifier) {
          undoManager.beforeChange();
        }
      });
      editor.on('mousedown', e => {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
      });
      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';
      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;
      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';
      editor.on('input', e => {
        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on('AddUndo Undo Redo ClearUndos', e => {
        if (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });
    };
    const addKeyboardShortcuts = editor => {
      editor.addShortcut('meta+z', '', 'Undo');
      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
    };

    const UndoManager = editor => {
      const beforeBookmark = value$2();
      const locks = Cell(0);
      const index = Cell(0);
      const undoManager = {
        data: [],
        typing: false,
        beforeChange: () => {
          beforeChange(editor, locks, beforeBookmark);
        },
        add: (level, event) => {
          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        dispatchChange: () => {
          editor.setDirty(true);
          const level = createFromEditor(editor);
          level.bookmark = getUndoBookmark(editor.selection);
          editor.dispatch('change', {
            level,
            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
          });
        },
        undo: () => {
          return undo(editor, undoManager, locks, index);
        },
        redo: () => {
          return redo(editor, index, undoManager.data);
        },
        clear: () => {
          clear(editor, undoManager, index);
        },
        reset: () => {
          reset(editor, undoManager);
        },
        hasUndo: () => {
          return hasUndo(editor, undoManager, index);
        },
        hasRedo: () => {
          return hasRedo(editor, undoManager, index);
        },
        transact: callback => {
          return transact(editor, undoManager, locks, callback);
        },
        ignore: callback => {
          ignore(editor, locks, callback);
        },
        extra: (callback1, callback2) => {
          extra(editor, undoManager, index, callback1, callback2);
        }
      };
      if (!isRtc(editor)) {
        registerEvents(editor, undoManager, locks);
      }
      addKeyboardShortcuts(editor);
      return undoManager;
    };

    const nonTypingKeycodes = [
      9,
      27,
      VK.HOME,
      VK.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      VK.DOWN,
      VK.UP,
      VK.LEFT,
      VK.RIGHT
    ].concat(Env.browser.isFirefox() ? [224] : []);
    const placeholderAttr = 'data-mce-placeholder';
    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';
    const isDeleteEvent = e => {
      const keyCode = e.keyCode;
      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    const isNonTypingKeyboardEvent = e => {
      if (isKeyboardEvent(e)) {
        const keyCode = e.keyCode;
        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
      } else {
        return false;
      }
    };
    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {
      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
        const firstElement = rootElm.firstElementChild;
        if (!firstElement) {
          return true;
        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
          return false;
        } else {
          return forcedRootBlock === firstElement.nodeName.toLowerCase();
        }
      } else {
        return false;
      }
    };
    const setup$q = editor => {
      var _a;
      const dom = editor.dom;
      const rootBlock = getForcedRootBlock(editor);
      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';
      const updatePlaceholder = (e, initial) => {
        if (isNonTypingKeyboardEvent(e)) {
          return;
        }
        const body = editor.getBody();
        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
        if (isPlaceholderShown !== showPlaceholder || initial) {
          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);
          firePlaceholderToggle(editor, showPlaceholder);
          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
        }
      };
      if (isNotEmpty(placeholder)) {
        editor.on('init', e => {
          updatePlaceholder(e, true);
          editor.on('change SetContent ExecCommand', updatePlaceholder);
          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));
        });
      }
    };

    const blockPosition = (block, position) => ({
      block,
      position
    });
    const blockBoundary = (from, to) => ({
      from,
      to
    });
    const getBlockPosition = (rootNode, pos) => {
      const rootElm = SugarElement.fromDom(rootNode);
      const containerElm = SugarElement.fromDom(pos.container());
      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));
    };
    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);
    const getClosestHost = (root, scope) => {
      const isRoot = node => eq(node, root);
      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);
    };
    const hasSameHost = (rootNode, blockBoundary) => {
      const root = SugarElement.fromDom(rootNode);
      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));
    };
    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;
    const hasValidBlocks = blockBoundary => {
      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);
      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);
    };
    const skipLastBr = (rootNode, forward, blockPosition) => {
      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {
        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {
          if (lastPositionInBlock.isEqual(blockPosition.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));
          } else {
            return Optional.some(blockPosition);
          }
        }).getOr(blockPosition);
      } else {
        return blockPosition;
      }
    };
    const readFromRange = (rootNode, forward, rng) => {
      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));
      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));
    };
    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();

    const getChildrenUntilBlockBoundary = block => {
      const children = children$1(block);
      return findIndex$2(children, isBlock$2).fold(constant(children), index => children.slice(0, index));
    };
    const extractChildren = block => {
      const children = getChildrenUntilBlockBoundary(block);
      each$e(children, remove$5);
      return children;
    };
    const removeEmptyRoot = (rootNode, block) => {
      const parents = parentsAndSelf(block, rootNode);
      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);
    };
    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;
    const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {
      if (isEmpty$2(toBlock)) {
        fillWithPaddingBr(toBlock);
        return firstPositionIn(toBlock.dom);
      }
      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {
        before$3(insertionPoint, SugarElement.fromTag('br'));
      }
      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
      each$e(extractChildren(fromBlock), child => {
        before$3(insertionPoint, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {
      if (isEmpty$2(toBlock)) {
        if (isEmpty$2(fromBlock)) {
          const getInlineToBlockDescendants = el => {
            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline$1(child) ? helper(child, elements.concat(shallow$1(child))) : elements);
            return helper(el, []);
          };
          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {
            wrap$2(element, descendant);
            return descendant;
          }, createPaddingBr());
          empty(fromBlock);
          append$1(fromBlock, newFromBlockDescendants);
        }
        remove$5(toBlock);
        return firstPositionIn(fromBlock.dom);
      }
      const position = lastPositionIn(toBlock.dom);
      each$e(extractChildren(fromBlock), child => {
        append$1(toBlock, child);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const findInsertionPoint = (toBlock, block) => {
      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    const trimBr = (first, block) => {
      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);
    };
    const mergeBlockInto = (rootNode, fromBlock, toBlock) => {
      trimBr(true, fromBlock);
      trimBr(false, toBlock);
      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
    };
    const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);

    const backspaceDelete$9 = (editor, forward) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {
        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block).each(pos => {
          editor.selection.setRng(pos.toRange());
        });
      });
      return position;
    };

    const deleteRangeMergeBlocks = (rootNode, selection) => {
      const rng = selection.getRng();
      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
        if (!eq(block1, block2)) {
          return Optional.some(() => {
            rng.deleteContents();
            mergeBlocks(rootNode, true, block1, block2).each(pos => {
              selection.setRng(pos.toRange());
            });
          });
        } else {
          return Optional.none();
        }
      }).getOr(Optional.none());
    };
    const isRawNodeInTable = (root, rawNode) => {
      const node = SugarElement.fromDom(rawNode);
      const isRoot = curry(eq, root);
      return ancestor$4(node, isTableCell$2, isRoot).isSome();
    };
    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
    const isEverythingSelected = (root, rng) => {
      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
      return !isSelectionInTable(root, rng) && noPrevious && noNext;
    };
    const emptyEditor = editor => {
      return Optional.some(() => {
        editor.setContent('');
        editor.selection.setCursorLocation();
      });
    };
    const deleteRange$2 = editor => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
    };
    const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);

    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));
    const getNodeRange = node => {
      const rng = node.ownerDocument.createRange();
      rng.selectNode(node);
      return rng;
    };
    const selectNode = (editor, node) => {
      const e = editor.dispatch('BeforeObjectSelected', { target: node });
      if (e.isDefaultPrevented()) {
        return Optional.none();
      }
      return Optional.some(getNodeRange(node));
    };
    const renderCaretAtRange = (editor, range, scrollIntoView) => {
      const normalizedRange = normalizeRange(1, editor.getBody(), range);
      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
      const caretPositionNode = caretPosition.getNode();
      if (isInlineFakeCaretTarget(caretPositionNode)) {
        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
      }
      const caretPositionBeforeNode = caretPosition.getNode(true);
      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
        return showCaret(1, editor, caretPositionBeforeNode, false, false);
      }
      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
      if (isInlineFakeCaretTarget(ceRoot)) {
        return showCaret(1, editor, ceRoot, false, scrollIntoView);
      }
      return Optional.none();
    };
    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;

    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    const trimEmptyTextNode = (dom, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom.remove(node);
      }
    };
    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {
      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {
        if (range.collapsed) {
          const deleteRange = range.cloneRange();
          if (forward) {
            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
          } else {
            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
          }
          deleteRange.deleteContents();
        } else {
          range.deleteContents();
        }
        editor.selection.setRng(caretRange);
      });
      trimEmptyTextNode(editor.dom, node);
    };
    const deleteBoundaryText = (editor, forward) => {
      const range = editor.selection.getRng();
      if (!isText$a(range.commonAncestorContainer)) {
        return Optional.none();
      }
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      const nextCaretPosition = getNextPosFn(caretPosition);
      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
        return Optional.none();
      } else if (isBeforeFn(normalizedNextCaretPosition)) {
        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
      }
      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));
        }
      }
      return Optional.none();
    };
    const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);

    const getEdgeCefPosition = (editor, atStart) => {
      const root = editor.getBody();
      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);
    };
    const isCefAtEdgeSelected = editor => {
      const rng = editor.selection.getRng();
      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
    };

    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
    const DeleteAction = Adt.generate([
      { remove: ['element'] },
      { moveToElement: ['element'] },
      { moveToPosition: ['position'] }
    ]);
    const isAtContentEditableBlockCaret = (forward, from) => {
      const elm = from.getNode(!forward);
      const caretLocation = forward ? 'after' : 'before';
      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
    };
    const isDeleteFromCefDifferentBlocks = (root, forward, from, to) => {
      const inSameBlock = elm => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);
      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);
    };
    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {
      const toCefElm = to.getNode(!forward);
      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
    };
    const findCefPosition = (root, forward, from) => fromPosition(forward, root, from).bind(to => {
      if (isCompoundElement(to.getNode())) {
        return Optional.none();
      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(to.getNode())) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {
        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
      } else if (forward && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else if (!forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.moveToPosition(to));
      } else {
        return Optional.none();
      }
    });
    const getContentEditableBlockAction = (forward, elm) => {
      if (isNullable(elm)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
      } else {
        return Optional.none();
      }
    };
    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {
      if (isInSameBlock(from, to, root)) {
        return Optional.none();
      } else {
        return Optional.some(DeleteAction.moveToPosition(to));
      }
    });
    const getContentEditableAction = (root, forward, from) => {
      if (isAtContentEditableBlockCaret(forward, from)) {
        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from));
      } else {
        return findCefPosition(root, forward, from).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));
      }
    };
    const read = (root, forward, rng) => {
      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
      const from = CaretPosition.fromRangeStart(normalizedRange);
      const rootElement = SugarElement.fromDom(root);
      if (!forward && isAfterContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode(true)));
      } else if (forward && isBeforeContentEditableFalse(from)) {
        return Optional.some(DeleteAction.remove(from.getNode()));
      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {
        return findPreviousBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));
      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {
        return findNextBr(rootElement, from).map(br => DeleteAction.remove(br.getNode()));
      } else {
        return getContentEditableAction(root, forward, from);
      }
    };

    const deleteElement$1 = (editor, forward) => element => {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement$2(editor, forward, SugarElement.fromDom(element));
      return true;
    };
    const moveToElement = (editor, forward) => element => {
      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const moveToPosition = editor => pos => {
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    const backspaceDeleteCaret = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng()).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));
    };
    const deleteOffscreenSelection = rootElement => {
      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);
    };
    const backspaceDeleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {
        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);
        return hasCefAncestor.fold(() => Optional.some(() => {
          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
          paddEmptyBody(editor);
        }), () => Optional.some(noop));
      }
      if (isCefAtEdgeSelected(editor)) {
        return Optional.some(() => {
          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
        });
      }
      return Optional.none();
    };
    const paddEmptyElement = editor => {
      const dom = editor.dom, selection = editor.selection;
      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {
        const br = dom.create('br', { 'data-mce-bogus': '1' });
        dom.setHTML(ceRoot, '');
        ceRoot.appendChild(br);
        selection.setRng(CaretPosition.before(br).toRange());
      }
      return true;
    };
    const backspaceDelete$6 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return backspaceDeleteCaret(editor, forward);
      } else {
        return backspaceDeleteRange(editor, forward);
      }
    };

    const deleteCaret$2 = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));
    };
    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();

    const isText$2 = isText$a;
    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
    const createZwsp = node => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return doc.createTextNode(ZWSP$1);
    };
    const insertBefore$1 = node => {
      var _a;
      if (isText$2(node.previousSibling)) {
        if (endsWithCaretContainer(node.previousSibling)) {
          return node.previousSibling;
        } else {
          node.previousSibling.appendData(ZWSP$1);
          return node.previousSibling;
        }
      } else if (isText$2(node)) {
        if (startsWithCaretContainer(node)) {
          return node;
        } else {
          node.insertData(0, ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
        return newNode;
      }
    };
    const insertAfter$1 = node => {
      var _a, _b;
      if (isText$2(node.nextSibling)) {
        if (startsWithCaretContainer(node.nextSibling)) {
          return node.nextSibling;
        } else {
          node.nextSibling.insertData(0, ZWSP$1);
          return node.nextSibling;
        }
      } else if (isText$2(node)) {
        if (endsWithCaretContainer(node)) {
          return node;
        } else {
          node.appendData(ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        if (node.nextSibling) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
        } else {
          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
        }
        return newNode;
      }
    };
    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);
    const insertInlineBefore = curry(insertInline, true);
    const insertInlineAfter = curry(insertInline, false);

    const insertInlinePos = (pos, before) => {
      if (isText$a(pos.container())) {
        return insertInline(before, pos.container());
      } else {
        return insertInline(before, pos.getNode());
      }
    };
    const isPosCaretContainer = (pos, caret) => {
      const caretNode = caret.get();
      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    const renderCaret = (caret, location) => location.fold(element => {
      remove$3(caret.get());
      const text = insertInlineBefore(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, text.length - 1));
    }, element => firstPositionIn(element).map(pos => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$3(caret.get());
        const text = insertInlinePos(pos, true);
        caret.set(text);
        return CaretPosition(text, 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, 1);
      }
    }), element => lastPositionIn(element).map(pos => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$3(caret.get());
        const text = insertInlinePos(pos, false);
        caret.set(text);
        return CaretPosition(text, text.length - 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, node.length - 1);
      }
    }), element => {
      remove$3(caret.get());
      const text = insertInlineAfter(element);
      caret.set(text);
      return Optional.some(CaretPosition(text, 1));
    });

    const evaluateUntil = (fns, args) => {
      for (let i = 0; i < fns.length; i++) {
        const result = fns[i].apply(null, args);
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    };

    const Location = Adt.generate([
      { before: ['element'] },
      { start: ['element'] },
      { end: ['element'] },
      { after: ['element'] }
    ]);
    const rescope$1 = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const before = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);
    };
    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    const start$1 = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {
        const prevPos = prevPosition(inline, nPos);
        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
      });
    };
    const end = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {
        const nextPos = nextPosition(inline, nPos);
        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
      });
    };
    const after = (isInlineTarget, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);
    };
    const isValidLocation = location => !isRtl(getElement(location));
    const readLocation = (isInlineTarget, rootNode, pos) => {
      const location = evaluateUntil([
        before,
        start$1,
        end,
        after
      ], [
        isInlineTarget,
        rootNode,
        pos
      ]);
      return location.filter(isValidLocation);
    };
    const getElement = location => location.fold(identity, identity, identity, identity);
    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));
    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);
    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);
    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {
      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
        return Location.after(forward ? fromInline : toInline);
      } else {
        return location;
      }
    }).getOr(location);
    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));
    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {
      const from = normalizePosition(forward, pos);
      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));
      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));
      return location.filter(isValidLocation);
    };
    const findLocationSimple = (forward, location) => {
      if (forward) {
        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
      } else {
        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
      }
    };
    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {
      const from = normalizePosition(forward, pos);
      const fromLocation = readLocation(isInlineTarget, rootNode, from);
      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));
    };

    const hasSelectionModifyApi = editor => {
      return isFunction(editor.selection.getSel().modify);
    };
    const moveRel = (forward, selection, pos) => {
      const delta = forward ? 1 : -1;
      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
      return true;
    };
    const moveByWord = (forward, editor) => {
      const rng = editor.selection.getRng();
      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      if (!hasSelectionModifyApi(editor)) {
        return false;
      } else if (forward && isBeforeInline(pos)) {
        return moveRel(true, editor.selection, pos);
      } else if (!forward && isAfterInline(pos)) {
        return moveRel(false, editor.selection, pos);
      } else {
        return false;
      }
    };

    var BreakType;
    (function (BreakType) {
      BreakType[BreakType['Br'] = 0] = 'Br';
      BreakType[BreakType['Block'] = 1] = 'Block';
      BreakType[BreakType['Wrap'] = 2] = 'Wrap';
      BreakType[BreakType['Eol'] = 3] = 'Eol';
    }(BreakType || (BreakType = {})));
    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;
    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
    const getBreakType = (scope, direction, currentPos, nextPos) => {
      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {
        return BreakType.Br;
      } else if (isInSameBlock(currentPos, nextPos) === false) {
        return BreakType.Block;
      } else {
        return BreakType.Wrap;
      }
    };
    const getPositionsUntil = (predicate, direction, scope, start) => {
      const caretWalker = CaretWalker(scope);
      let currentPos = start;
      const positions = [];
      while (currentPos) {
        const nextPos = walk$1(direction, caretWalker, currentPos);
        if (!nextPos) {
          break;
        }
        if (isBr$6(nextPos.getNode(false))) {
          if (direction === HDirection.Forwards) {
            return {
              positions: flip(direction, positions).concat([nextPos]),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          } else {
            return {
              positions: flip(direction, positions),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          }
        }
        if (!nextPos.isVisible()) {
          currentPos = nextPos;
          continue;
        }
        if (predicate(currentPos, nextPos)) {
          const breakType = getBreakType(scope, direction, currentPos, nextPos);
          return {
            positions: flip(direction, positions),
            breakType,
            breakAt: Optional.some(nextPos)
          };
        }
        positions.push(nextPos);
        currentPos = nextPos;
      }
      return {
        positions: flip(direction, positions),
        breakType: BreakType.Eol,
        breakAt: Optional.none()
      };
    };
    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {
      const positions = getPositionsUntilBreak(scope, pos).positions;
      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
      const lastDist = Math.abs(x - lastRect.left);
      const newDist = Math.abs(x - newRect.left);
      return newDist <= lastDist ? newPos : lastPos;
    }).or(acc)), Optional.none());
    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);

    const isContentEditableFalse$4 = isContentEditableFalse$b;
    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');
    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
        return clientRect;
      }
      if (newDistance < oldDistance) {
        return clientRect;
      }
      return oldClientRect;
    });

    const getNodeClientRects = node => {
      const toArrayWithNode = clientRects => {
        return map$3(clientRects, rect => {
          const clientRect = clone$1(rect);
          clientRect.node = node;
          return clientRect;
        });
      };
      if (isElement$6(node)) {
        return toArrayWithNode(node.getClientRects());
      } else if (isText$a(node)) {
        const rng = node.ownerDocument.createRange();
        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);
        return toArrayWithNode(rng.getClientRects());
      } else {
        return [];
      }
    };
    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);

    var VDirection;
    (function (VDirection) {
      VDirection[VDirection['Up'] = -1] = 'Up';
      VDirection[VDirection['Down'] = 1] = 'Down';
    }(VDirection || (VDirection = {})));
    const findUntil = (direction, root, predicateFn, node) => {
      let currentNode = node;
      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {
        if (predicateFn(currentNode)) {
          return;
        }
      }
    };
    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
      let line = 0;
      const result = [];
      const add = node => {
        let clientRects = getClientRects([node]);
        if (direction === -1) {
          clientRects = clientRects.reverse();
        }
        for (let i = 0; i < clientRects.length; i++) {
          const clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }
          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {
            line++;
          }
          clientRect.line = line;
          if (predicateFn(clientRect)) {
            return true;
          }
          result.push(clientRect);
        }
        return false;
      };
      const targetClientRect = last$2(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }
      const node = caretPosition.getNode();
      if (node) {
        add(node);
        findUntil(direction, root, add, node);
      }
      return result;
    };
    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
    const getLastClientRect = caretPosition => {
      return last$2(caretPosition.getClientRects());
    };
    const positionsUntil = (direction, root, predicateFn, node) => {
      const caretWalker = CaretWalker(root);
      let walkFn;
      let isBelowFn;
      let isAboveFn;
      let caretPosition;
      const result = [];
      let line = 0;
      if (direction === 1) {
        walkFn = caretWalker.next;
        isBelowFn = isBelow$1;
        isAboveFn = isAbove$1;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = isAbove$1;
        isAboveFn = isBelow$1;
        caretPosition = CaretPosition.before(node);
      }
      const targetClientRect = getLastClientRect(caretPosition);
      do {
        if (!caretPosition.isVisible()) {
          continue;
        }
        const rect = getLastClientRect(caretPosition);
        if (isAboveFn(rect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isBelowFn(rect, last$2(result))) {
          line++;
        }
        const clientRect = clone$1(rect);
        clientRect.position = caretPosition;
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return result;
        }
        result.push(clientRect);
      } while (caretPosition = walkFn(caretPosition));
      return result;
    };
    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);
    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);

    const moveToRange = (editor, rng) => {
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, editor.selection.getRng());
    };
    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));
    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {
      const forwards = direction === HDirection.Forwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forwards ? isBefore : isAfter;
      if (!range.collapsed) {
        const node = getSelectedNode(range);
        if (isElement(node)) {
          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
        } else if (isCefAtEdgeSelected(editor)) {
          const newRange = range.cloneRange();
          newRange.collapse(direction === HDirection.Backwards);
          return Optional.from(newRange);
        }
      }
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      if (isBeforeFn(caretPosition)) {
        return selectNode(editor, caretPosition.getNode(!forwards));
      }
      let nextCaretPosition = getNextPosFn(caretPosition);
      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
      if (!nextCaretPosition) {
        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();
      } else {
        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
      }
      if (isBeforeFn(nextCaretPosition)) {
        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
      }
      const peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
        }
      }
      if (rangeIsInContainerBlock) {
        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
      }
      return Optional.none();
    };
    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
      const caretClientRect = last$2(caretPosition.getClientRects());
      const forwards = direction === VDirection.Down;
      const root = editor.getBody();
      if (!caretClientRect) {
        return Optional.none();
      }
      if (isCefAtEdgeSelected(editor)) {
        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);
        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());
      }
      const walkerFn = forwards ? downUntil : upUntil;
      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
      const nextLinePositions = filter$5(linePositions, isLine(1));
      const clientX = caretClientRect.left;
      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
      if (nextLineRect && isElement(nextLineRect.node)) {
        const dist1 = Math.abs(clientX - nextLineRect.left);
        const dist2 = Math.abs(clientX - nextLineRect.right);
        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
      }
      let currentNode;
      if (isBefore(caretPosition)) {
        currentNode = caretPosition.getNode();
      } else if (isAfter(caretPosition)) {
        currentNode = caretPosition.getNode(true);
      } else {
        currentNode = getSelectedNode(range);
      }
      if (currentNode) {
        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
      }
      if (nextLinePositions.length === 0) {
        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));
      }
      return Optional.none();
    };
    const getLineEndPoint = (editor, forward) => {
      const rng = editor.selection.getRng();
      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      const host = getEditingHost(from.container(), editor.getBody());
      if (forward) {
        const lineInfo = getPositionsUntilNextLine(host, from);
        return last$3(lineInfo.positions);
      } else {
        const lineInfo = getPositionsUntilPreviousLine(host, from);
        return head(lineInfo.positions);
      }
    };
    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {
      editor.selection.setRng(pos.toRange());
      return true;
    });

    const setCaretPosition = (editor, pos) => {
      const rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };
    const setSelected = (state, elm) => {
      if (state) {
        elm.setAttribute('data-mce-selected', 'inline-boundary');
      } else {
        elm.removeAttribute('data-mce-selected');
      }
    };
    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {
      setCaretPosition(editor, pos);
      return location;
    });
    const getPositionFromRange = (range, root, forward) => {
      const start = CaretPosition.fromRangeStart(range);
      if (range.collapsed) {
        return start;
      } else {
        const end = CaretPosition.fromRangeEnd(range);
        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);
      }
    };
    const findLocation = (editor, caret, forward) => {
      const rootNode = editor.getBody();
      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);
      return location.bind(location => renderCaretLocation(editor, caret, location));
    };
    const toggleInlines = (isInlineTarget, dom, elms) => {
      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected="inline-boundary"]'), e => e.dom);
      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);
      const targetInlines = filter$5(elms, isInlineTarget);
      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    const safeRemoveCaretContainer = (editor, caret) => {
      const caretValue = caret.get();
      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
          setCaretPosition(editor, removeAndReposition(caretValue, pos));
          caret.set(null);
        }
      }
    };
    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {
      if (editor.selection.isCollapsed()) {
        const inlines = filter$5(elms, isInlineTarget);
        each$e(inlines, _inline => {
          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));
        });
      }
    };
    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    const setupSelectedState = editor => {
      const caret = Cell(null);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.on('NodeChange', e => {
        if (isInlineBoundariesEnabled(editor)) {
          toggleInlines(isInlineTarget$1, editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
        }
      });
      return caret;
    };
    const moveNextWord = curry(moveWord, true);
    const movePrevWord = curry(moveWord, false);
    const moveToLineEndPoint$2 = (editor, forward, caret) => {
      if (isInlineBoundariesEnabled(editor)) {
        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
          const rng = editor.selection.getRng();
          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        });
        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {
          const outsideLoc = outside(loc);
          return renderCaret(caret, outsideLoc).exists(pos => {
            setCaretPosition(editor, pos);
            return true;
          });
        });
      } else {
        return false;
      }
    };

    const rangeFromPositions = (from, to) => {
      const range = document.createRange();
      range.setStart(from.container(), from.offset());
      range.setEnd(to.container(), to.offset());
      return range;
    };
    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));
    }).getOr(true);
    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));
    const deleteFromTo = (editor, caret, from, to) => {
      const rootNode = editor.getBody();
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.undoManager.ignore(() => {
        editor.selection.setRng(rangeFromPositions(from, to));
        execNativeDeleteCommand(editor);
        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);
      });
      editor.nodeChanged();
    };
    const rescope = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {
      const rootNode = rescope(editor.getBody(), from.container());
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);
      const location = fromLocation.bind(location => {
        if (forward) {
          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);
        } else {
          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));
        }
      });
      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {
        const toPosition = navigate(forward, rootNode, from);
        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));
        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {
          if (hasOnlyTwoOrLessPositionsLeft(elm)) {
            return Optional.some(() => {
              deleteElement$2(editor, forward, SugarElement.fromDom(elm));
            });
          } else {
            return Optional.none();
          }
        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {
          return () => {
            if (forward) {
              deleteFromTo(editor, caret, from, to);
            } else {
              deleteFromTo(editor, caret, to, from);
            }
          };
        })));
      });
    };
    const backspaceDelete$4 = (editor, caret, forward) => {
      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
        const from = CaretPosition.fromRangeStart(editor.selection.getRng());
        return backspaceDeleteCollapsed(editor, caret, forward, from);
      }
      return Optional.none();
    };

    const hasMultipleChildren = elm => childNodesCount(elm) > 1;
    const getParentsUntil = (editor, pred) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      const startElm = SugarElement.fromDom(editor.selection.getStart());
      const parents = parentsAndSelf(startElm, rootElm);
      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));
    };
    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;
    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => isBlock$2(elm) || hasMultipleChildren(elm));
    const getParentInlines = editor => getParentsUntil(editor, isBlock$2);
    const getFormatNodes = (editor, parentInlines) => {
      const isFormatElement$1 = curry(isFormatElement, editor);
      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);
    };
    const getFormatNodesAtStart = editor => {
      const parentInlines = getParentInlines(editor);
      return getFormatNodes(editor, parentInlines);
    };
    const deleteLastPosition = (forward, editor, target, parentInlines) => {
      const formatNodes = getFormatNodes(editor, parentInlines);
      if (formatNodes.length === 0) {
        deleteElement$2(editor, forward, target);
      } else {
        const pos = replaceWithCaretFormat(target.dom, formatNodes);
        editor.selection.setRng(pos.toRange());
      }
    };
    const deleteCaret$1 = (editor, forward) => {
      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);
      return last$3(parentInlines).bind(target => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
        } else {
          return Optional.none();
        }
      });
    };
    const isBrInEmptyElement = (editor, elm) => {
      const parentElm = elm.parentElement;
      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
    };
    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
    const createCaretFormatAtStart = (editor, formatNodes) => {
      const startElm = editor.selection.getStart();
      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
      editor.selection.setRng(pos.toRange());
    };
    const updateCaretFormat = (editor, updateFormats) => {
      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
      if (missingFormats.length > 0) {
        createCaretFormatAtStart(editor, missingFormats);
      }
    };
    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);
    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
    const rangeStartParentIsFormatElement = (editor, rng) => {
      const startParent = rng.startContainer.parentElement;
      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
    };
    const rangeStartAndEndHaveSameParent = rng => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
    };
    const rangeEndsAtEndOfEndContainer = rng => {
      const endContainer = rng.endContainer;
      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);
    };
    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
    const requiresDeleteRangeOverride = editor => {
      const rng = editor.selection.getRng();
      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
    };
    const deleteRange$1 = editor => {
      if (requiresDeleteRangeOverride(editor)) {
        const formatNodes = getFormatNodesAtStart(editor);
        return Optional.some(() => {
          execNativeDeleteCommand(editor);
          updateCaretFormat(editor, formatNodes);
        });
      } else {
        return Optional.none();
      }
    };
    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
    const hasAncestorInlineCaret = elm => ancestor$1(elm, node => isCaretNode(node.dom), isBlock$2);
    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()));
    const requiresRefreshCaretOverride = editor => {
      const rng = editor.selection.getRng();
      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
    };
    const refreshCaret = editor => {
      if (requiresRefreshCaretOverride(editor)) {
        createCaretFormatAtStart(editor, []);
      }
      return true;
    };

    const deleteElement = (editor, forward, element) => {
      if (isNonNullable(element)) {
        return Optional.some(() => {
          editor._selectionOverrides.hideFakeCaret();
          deleteElement$2(editor, forward, SugarElement.fromDom(element));
        });
      } else {
        return Optional.none();
      }
    };
    const deleteCaret = (editor, forward) => {
      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
      if (isNearMedia(fromPos)) {
        return deleteElement(editor, forward, fromPos.getNode(!forward));
      } else {
        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));
      }
    };
    const deleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
    };
    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);

    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));
    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);
    const getIndentStyleName = (useMargin, element) => {
      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';
      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';
      return indentStyleName + suffix;
    };
    const indentElement = (dom, command, useMargin, value, unit, element) => {
      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));
      if (command === 'outdent') {
        const styleValue = Math.max(0, parsedValue - value);
        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
      } else {
        const styleValue = parsedValue + value + unit;
        dom.setStyle(element, indentStyleName, styleValue);
      }
    };
    const validateBlocks = (editor, blocks) => forall(blocks, block => {
      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
      const contentEditable = editor.dom.getContentEditable(block.dom);
      return contentEditable !== 'false' && intentValue > 0;
    });
    const canOutdent = editor => {
      const blocks = getBlocksToIndent(editor);
      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
    };
    const isListComponent = el => isList(el) || isListItem$1(el);
    const parentIsListComponent = el => parent(el).exists(isListComponent);
    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
    const handle = (editor, command) => {
      var _a, _b;
      const {dom} = editor;
      const indentation = getIndentation(editor);
      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';
      const indentValue = parseIndentValue(indentation);
      const useMargin = shouldIndentUseMargin(editor);
      each$e(getBlocksToIndent(editor), block => {
        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);
      });
    };
    const indent = editor => handle(editor, 'indent');
    const outdent = editor => handle(editor, 'outdent');

    const backspaceDelete$1 = editor => {
      if (editor.selection.isCollapsed() && canOutdent(editor)) {
        const dom = editor.dom;
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const block = dom.getParent(rng.startContainer, dom.isBlock);
        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
          return Optional.some(() => outdent(editor));
        }
      }
      return Optional.none();
    };

    const findAction = (editor, caret, forward) => findMap([
      backspaceDelete$1,
      backspaceDelete$6,
      backspaceDelete$7,
      (editor, forward) => backspaceDelete$4(editor, caret, forward),
      backspaceDelete$9,
      backspaceDelete$a,
      backspaceDelete$5,
      backspaceDelete$2,
      backspaceDelete$8,
      backspaceDelete$3
    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());
    const deleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, false);
      result.fold(() => {
        execNativeDeleteCommand(editor);
        paddEmptyBody(editor);
      }, call);
    };
    const forwardDeleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, true);
      result.fold(() => execNativeForwardDeleteCommand(editor), call);
    };
    const setup$p = (editor, caret) => {
      editor.addCommand('delete', () => {
        deleteCommand(editor, caret);
      });
      editor.addCommand('forwardDelete', () => {
        forwardDeleteCommand(editor, caret);
      });
    };

    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = event => {
      if (event.touches === undefined || event.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(event.touches[0]);
    };
    const isFarEnough = (touch, data) => {
      const distX = Math.abs(touch.clientX - data.x);
      const distY = Math.abs(touch.clientY - data.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const setup$o = editor => {
      const startData = value$2();
      const longpressFired = Cell(false);
      const debounceLongpress = last$1(e => {
        editor.dispatch('longpress', {
          ...e,
          type: 'longpress'
        });
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      editor.on('touchstart', e => {
        getTouch(e).each(touch => {
          debounceLongpress.cancel();
          const data = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(data);
        });
      }, true);
      editor.on('touchmove', e => {
        debounceLongpress.cancel();
        getTouch(e).each(touch => {
          startData.on(data => {
            if (isFarEnough(touch, data)) {
              startData.clear();
              longpressFired.set(false);
              editor.dispatch('longpresscancel');
            }
          });
        });
      }, true);
      editor.on('touchend touchcancel', e => {
        debounceLongpress.cancel();
        if (e.type === 'touchcancel') {
          return;
        }
        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {
          if (longpressFired.get()) {
            e.preventDefault();
          } else {
            editor.dispatch('tap', {
              ...e,
              type: 'tap'
            });
          }
        });
      }, true);
    };

    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
    const isValidTarget = (schema, node) => {
      if (isText$a(node)) {
        return true;
      } else if (isElement$6(node)) {
        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node);
      } else {
        return false;
      }
    };
    const hasBlockParent = (blockElements, root, node) => {
      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {
        return isBlockElement(blockElements, elm.dom);
      });
    };
    const shouldRemoveTextNode = (blockElements, node) => {
      if (isText$a(node)) {
        if (node.data.length === 0) {
          return true;
        } else if (/^\s+$/.test(node.data) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
          return true;
        }
      }
      return false;
    };
    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
    const addRootBlocks = editor => {
      const dom = editor.dom, selection = editor.selection;
      const schema = editor.schema;
      const blockElements = schema.getBlockElements();
      const startNode = selection.getStart();
      const rootNode = editor.getBody();
      let rootBlockNode;
      let tempNode;
      let wrapped = false;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!startNode || !isElement$6(startNode)) {
        return;
      }
      const rootNodeName = rootNode.nodeName.toLowerCase();
      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
        return;
      }
      const rng = selection.getRng();
      const {startContainer, startOffset, endContainer, endOffset} = rng;
      const restoreSelection = hasFocus(editor);
      let node = rootNode.firstChild;
      while (node) {
        if (isElement$6(node)) {
          updateElement(schema, node);
        }
        if (isValidTarget(schema, node)) {
          if (shouldRemoveTextNode(blockElements, node)) {
            tempNode = node;
            node = node.nextSibling;
            dom.remove(tempNode);
            continue;
          }
          if (!rootBlockNode) {
            rootBlockNode = createRootBlock(editor);
            rootNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }
          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }
      if (wrapped && restoreSelection) {
        rng.setStart(startContainer, startOffset);
        rng.setEnd(endContainer, endOffset);
        selection.setRng(rng);
        editor.nodeChanged();
      }
    };
    const insertEmptyLine = (editor, root, insertBlock) => {
      const block = SugarElement.fromDom(createRootBlock(editor));
      const br = createPaddingBr();
      append$1(block, br);
      insertBlock(root, block);
      const rng = document.createRange();
      rng.setStartBefore(br.dom);
      rng.setEndBefore(br.dom);
      return rng;
    };
    const setup$n = editor => {
      editor.on('NodeChange', curry(addRootBlocks, editor));
    };

    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;
    const replaceMatchWithSpan = (editor, content, cls) => {
      return function (match) {
        const args = arguments, index = args[args.length - 2];
        const prevChar = index > 0 ? content.charAt(index - 1) : '';
        if (prevChar === '"') {
          return match;
        }
        if (prevChar === '>') {
          const findStartTagIndex = content.lastIndexOf('<', index);
          if (findStartTagIndex !== -1) {
            const tagHtml = content.substring(findStartTagIndex, index);
            if (tagHtml.indexOf('contenteditable="false"') !== -1) {
              return match;
            }
          }
        }
        return '<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';
      };
    };
    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
      let i = nonEditableRegExps.length, content = e.content;
      if (e.format === 'raw') {
        return;
      }
      while (i--) {
        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
      }
      e.content = content;
    };
    const setup$m = editor => {
      const contentEditableAttrName = 'contenteditable';
      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';
      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';
      const hasEditClass = hasClass(editClass);
      const hasNonEditClass = hasClass(nonEditClass);
      const nonEditableRegExps = getNonEditableRegExps(editor);
      if (nonEditableRegExps.length > 0) {
        editor.on('BeforeSetContent', e => {
          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
        });
      }
      editor.parser.addAttributeFilter('class', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (hasEditClass(node)) {
            node.attr(contentEditableAttrName, 'true');
          } else if (hasNonEditClass(node)) {
            node.attr(contentEditableAttrName, 'false');
          }
        }
      });
      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (!hasEditClass(node) && !hasNonEditClass(node)) {
            continue;
          }
          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {
            node.name = '#text';
            node.type = 3;
            node.raw = true;
            node.value = node.attr('data-mce-content');
          } else {
            node.attr(contentEditableAttrName, null);
          }
        }
      });
    };

    const findBlockCaretContainer = editor => descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();
    const showBlockCaretContainer = (editor, blockCaretContainer) => {
      if (blockCaretContainer.hasAttribute('data-mce-caret')) {
        showCaretContainerBlock(blockCaretContainer);
        editor.selection.setRng(editor.selection.getRng());
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };
    const handleBlockContainer = (editor, e) => {
      const blockCaretContainer = findBlockCaretContainer(editor);
      if (!blockCaretContainer) {
        return;
      }
      if (e.type === 'compositionstart') {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(editor, blockCaretContainer);
        return;
      }
      if (hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
        editor.undoManager.add();
      }
    };
    const setup$l = editor => {
      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
    };

    const isContentEditableFalse$3 = isContentEditableFalse$b;
    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
    const moveToCeFalseVertically = (direction, editor, range) => {
      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);
    };
    const createTextBlock = editor => {
      const textBlock = editor.dom.create(getForcedRootBlock(editor));
      textBlock.innerHTML = '<br data-mce-bogus="1">';
      return textBlock;
    };
    const exitPreBlock = (editor, direction, range) => {
      const caretWalker = CaretWalker(editor.getBody());
      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
      if (range.collapsed) {
        const pre = editor.dom.getParent(range.startContainer, 'PRE');
        if (!pre) {
          return;
        }
        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));
        if (!caretPos) {
          const newBlock = SugarElement.fromDom(createTextBlock(editor));
          if (direction === 1) {
            after$4(SugarElement.fromDom(pre), newBlock);
          } else {
            before$3(SugarElement.fromDom(pre), newBlock);
          }
          editor.selection.select(newBlock.dom, true);
          editor.selection.collapse();
        }
      }
    };
    const getHorizontalRange = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range = editor.selection.getRng();
      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    const getVerticalRange = (editor, down) => {
      const direction = down ? 1 : -1;
      const range = editor.selection.getRng();
      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {
        exitPreBlock(editor, direction, range);
        return Optional.none();
      });
    };
    const flipDirection = (selection, forward) => {
      const elm = forward ? selection.getEnd(true) : selection.getStart(true);
      return isRtl(elm) ? !forward : forward;
    };
    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveToLineEndPoint$1 = (editor, forward) => {
      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
      return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };
    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {
      const rng = pos.toRange();
      const curRng = editor.selection.getRng();
      if (forward) {
        rng.setStart(curRng.startContainer, curRng.startOffset);
      } else {
        rng.setEnd(curRng.endContainer, curRng.endOffset);
      }
      return rng;
    }).exists(rng => {
      moveToRange(editor, rng);
      return true;
    });

    const isTarget = node => contains$2(['figcaption'], name(node));
    const getClosestTargetBlock = (pos, root) => {
      const isRoot = curry(eq, root);
      return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);
    };
    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
    const moveCaretToNewEmptyLine = (editor, forward) => {
      const root = SugarElement.fromDom(editor.getBody());
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getClosestTargetBlock(pos, root).exists(() => {
        if (isAtFirstOrLastLine(root, forward, pos)) {
          const insertFn = forward ? append$1 : prepend;
          const rng = insertEmptyLine(editor, root, insertFn);
          editor.selection.setRng(rng);
          return true;
        } else {
          return false;
        }
      });
    };
    const moveV$3 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return moveCaretToNewEmptyLine(editor, forward);
      } else {
        return false;
      }
    };

    const moveUp = (editor, details, summary) => {
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const root = editor.getBody();
      if (root.firstChild === details && isAtFirstLine(summary, pos)) {
        editor.execCommand('InsertNewBlockBefore');
        return true;
      } else {
        return false;
      }
    };
    const moveDown = (editor, details) => {
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const root = editor.getBody();
      if (root.lastChild === details && isAtLastLine(details, pos)) {
        editor.execCommand('InsertNewBlockAfter');
        return true;
      } else {
        return false;
      }
    };
    const move$2 = (editor, forward) => {
      if (forward) {
        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);
      } else {
        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);
      }
    };
    const moveV$2 = (editor, forward) => move$2(editor, forward);

    const baseKeyPattern = {
      shiftKey: false,
      altKey: false,
      ctrlKey: false,
      metaKey: false,
      keyCode: 0
    };
    const defaultPatterns = patterns => map$3(patterns, pattern => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);
    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);
    const action = (f, ...x) => () => f.apply(null, x);
    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());
    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());

    const moveH$1 = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range = editor.selection.getRng();
      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveV$1 = (editor, down) => {
      const direction = down ? 1 : -1;
      const range = editor.selection.getRng();
      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveToLineEndPoint = (editor, forward) => {
      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
      return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };

    const adt = Adt.generate([
      { none: ['current'] },
      { first: ['current'] },
      {
        middle: [
          'current',
          'target'
        ]
      },
      { last: ['current'] }
    ]);
    const none = current => adt.none(current);
    const CellLocation = {
      ...adt,
      none
    };

    const firstLayer = (scope, selector) => {
      return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate) => {
      return bind$3(children$1(scope), x => {
        if (is$1(x, selector)) {
          return predicate(x) ? [x] : [];
        } else {
          return filterFirstLayer(x, selector, predicate);
        }
      });
    };

    const lookup$1 = (tags, element, isRoot = never) => {
      if (isRoot(element)) {
        return Optional.none();
      }
      if (contains$2(tags, name(element))) {
        return Optional.some(element);
      }
      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);
      return ancestor$3(element, tags.join(','), isRootOrUpperTable);
    };
    const cell = (element, isRoot) => lookup$1([
      'td',
      'th'
    ], element, isRoot);
    const cells = ancestor => firstLayer(ancestor, 'th,td');
    const table = (element, isRoot) => closest$3(element, 'table', isRoot);

    const walk = (all, current, index, direction, isEligible = always) => {
      const forwards = direction === 1;
      if (!forwards && index <= 0) {
        return CellLocation.first(all[0]);
      } else if (forwards && index >= all.length - 1) {
        return CellLocation.last(all[all.length - 1]);
      } else {
        const newIndex = index + direction;
        const elem = all[newIndex];
        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);
      }
    };
    const detect = (current, isRoot) => {
      return table(current, isRoot).bind(table => {
        const all = cells(table);
        const index = findIndex$2(all, x => eq(current, x));
        return index.map(index => ({
          index,
          all
        }));
      });
    };
    const next = (current, isEligible, isRoot) => {
      const detection = detect(current, isRoot);
      return detection.fold(() => {
        return CellLocation.none(current);
      }, info => {
        return walk(info.all, current, info.index, 1, isEligible);
      });
    };
    const prev = (current, isEligible, isRoot) => {
      const detection = detect(current, isRoot);
      return detection.fold(() => {
        return CellLocation.none();
      }, info => {
        return walk(info.all, current, info.index, -1, isEligible);
      });
    };

    const deflate = (rect, delta) => ({
      left: rect.left - delta,
      top: rect.top - delta,
      right: rect.right + delta * 2,
      bottom: rect.bottom + delta * 2,
      width: rect.width + delta,
      height: rect.height + delta
    });
    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {
      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
      return [
        {
          x: rect.left,
          y: getYAxisValue(rect),
          cell: td
        },
        {
          x: rect.right,
          y: getYAxisValue(rect),
          cell: td
        }
      ];
    });
    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {
      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
      return Optional.some(newDist < oldDist ? newCorner : oldCorner);
    }), Optional.none());
    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {
      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);
      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));
      return findClosestCorner(corners, x, y).map(corner => corner.cell);
    };
    const getBottomValue = rect => rect.bottom;
    const getTopValue = rect => rect.top;
    const isAbove = (corner, y) => corner.y < y;
    const isBelow = (corner, y) => corner.y > y;
    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));
    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));

    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());
    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {
      const lineInfo = getPositionsUntil(scope, pos);
      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {
        return !hasNextBreak(getPositionsUntil, scope, lineInfo);
      } else {
        return lineInfo.breakAt.isNone();
      }
    };
    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {
      const caretPos = CaretPosition.fromRangeStart(rng);
      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));
    };
    const navigateHorizontally = (editor, forward, table, _td) => {
      const rng = editor.selection.getRng();
      const direction = forward ? 1 : -1;
      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
        showCaret(direction, editor, table, !forward, false).each(newRng => {
          moveToRange(editor, newRng);
        });
        return true;
      }
      return false;
    };
    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));
    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));
    const getTable = (previous, pos) => {
      const node = pos.getNode(previous);
      return isTable$2(node) ? Optional.some(node) : Optional.none();
    };
    const renderBlock = (down, editor, table) => {
      editor.undoManager.transact(() => {
        const insertFn = down ? after$4 : before$3;
        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);
        moveToRange(editor, rng);
      });
    };
    const moveCaret = (editor, down, pos) => {
      const table = down ? getTable(true, pos) : getTable(false, pos);
      const last = down === false;
      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));
    };
    const navigateVertically = (editor, down, table, td) => {
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const root = editor.getBody();
      if (!down && isAtFirstTableCellLine(td, pos)) {
        const newPos = getClosestAbovePosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else if (down && isAtLastTableCellLine(td, pos)) {
        const newPos = getClosestBelowPosition(root, table, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else {
        return false;
      }
    };
    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);
    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
    const getCellFirstCursorPosition = cell => {
      const selection = SimSelection.exact(cell, 0, cell, 0);
      return toNative(selection);
    };
    const tabGo = (editor, isRoot, cell) => {
      return cell.fold(Optional.none, Optional.none, (_current, next) => {
        return first(next).map(cell => {
          return getCellFirstCursorPosition(cell);
        });
      }, current => {
        editor.execCommand('mceTableInsertRowAfter');
        return tabForward(editor, isRoot, current);
      });
    };
    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$3));
    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$3));
    const handleTab = (editor, forward) => {
      const rootElements = [
        'table',
        'li',
        'dl'
      ];
      const body = SugarElement.fromDom(editor.getBody());
      const isRoot = element => {
        const name$1 = name(element);
        return eq(element, body) || contains$2(rootElements, name$1);
      };
      const rng = editor.selection.getRng();
      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
      return cell(container, isRoot).map(cell => {
        table(cell, isRoot).each(table => {
          editor.model.table.clearSelectedCells(table.dom);
        });
        editor.selection.collapse(!forward);
        const navigation = !forward ? tabBackward : tabForward;
        const rng = navigation(editor, isRoot, cell);
        rng.each(range => {
          editor.selection.setRng(range);
        });
        return true;
      }).getOr(false);
    };

    const executeKeydownOverride$4 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute([
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$4, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$4, editor, true)
        },
        ...isMac ? [
          {
            keyCode: VK.UP,
            action: action(selectToEndPoint, editor, false),
            metaKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.DOWN,
            action: action(selectToEndPoint, editor, true),
            metaKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(move$3, editor, caret, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(move$3, editor, caret, false)
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(moveNextWord, editor, caret)
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(movePrevWord, editor, caret)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true)
        }
      ], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$k = (editor, caret) => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$4(editor, caret, evt);
        }
      });
    };

    const point = (container, offset) => ({
      container,
      offset
    });

    const DOM$7 = DOMUtils.DOM;
    const alwaysNext = startNode => node => startNode === node ? -1 : 0;
    const isBoundary = dom => node => dom.isBlock(node) || contains$2([
      'BR',
      'IMG',
      'HR',
      'INPUT'
    ], node.nodeName) || dom.getContentEditable(node) === 'false';
    const textBefore = (node, offset, rootNode) => {
      if (isText$a(node) && offset >= 0) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));
      }
    };
    const textAfter = (node, offset, rootNode) => {
      if (isText$a(node) && offset >= node.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));
      }
    };
    const scanLeft = (node, offset, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text = node.data;
      if (offset >= 0 && offset <= text.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {
          const prevText = prev.container.data;
          return scanLeft(prev.container, offset + prevText.length, rootNode);
        });
      }
    };
    const scanRight = (node, offset, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text = node.data;
      if (offset <= text.length) {
        return Optional.some(point(node, offset));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));
      }
    };
    const repeatLeft = (dom, node, offset, process, rootNode) => {
      const search = TextSeeker(dom, isBoundary(dom));
      return Optional.from(search.backwards(node, offset, process, rootNode));
    };

    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);
    const getText = rng => trim$1(rng.toString().replace(/\u00A0/g, ' '));
    const isWhitespace = chr => chr !== '' && ' \xA0\f\n\r\t\x0B'.indexOf(chr) !== -1;

    const stripTrigger = (text, trigger) => text.substring(trigger.length);
    const findTrigger = (text, index, trigger) => {
      let i;
      const firstChar = trigger.charAt(0);
      for (i = index - 1; i >= 0; i--) {
        const char = text.charAt(i);
        if (isWhitespace(char)) {
          return Optional.none();
        }
        if (firstChar === char && contains$1(text, trigger, i, index)) {
          break;
        }
      }
      return Optional.some(i);
    };
    const findStart = (dom, initRange, trigger, minChars = 0) => {
      if (!isValidTextRange(initRange)) {
        return Optional.none();
      }
      const buffer = {
        text: '',
        offset: 0
      };
      const findTriggerIndex = (element, offset, text) => {
        buffer.text = text + buffer.text;
        buffer.offset += offset;
        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);
      };
      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {
        const range = initRange.cloneRange();
        range.setStart(spot.container, spot.offset);
        range.setEnd(initRange.endContainer, initRange.endOffset);
        if (range.collapsed) {
          return Optional.none();
        }
        const text = getText(range);
        const triggerIndex = text.lastIndexOf(trigger);
        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {
          return Optional.none();
        } else {
          return Optional.some({
            text: stripTrigger(text, trigger),
            range,
            trigger
          });
        }
      });
    };
    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {
      const range = dom.createRng();
      range.selectNode(elm.dom);
      const text = getText(range);
      return Optional.some({
        range,
        text: stripTrigger(text, trigger),
        trigger
      });
    });

    const isText$1 = node => node.nodeType === TEXT;
    const isElement = node => node.nodeType === ELEMENT;
    const toLast = node => {
      if (isText$1(node)) {
        return point(node, node.data.length);
      } else {
        const children = node.childNodes;
        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);
      }
    };
    const toLeaf = (node, offset) => {
      const children = node.childNodes;
      if (children.length > 0 && offset < children.length) {
        return toLeaf(children[offset], 0);
      } else if (children.length > 0 && isElement(node) && children.length === offset) {
        return toLast(children[children.length - 1]);
      } else {
        return point(node, offset);
      }
    };

    const isPreviousCharContent = (dom, leaf) => {
      var _a;
      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();
      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {
        const char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      }).isSome();
    };
    const isStartOfWord = dom => rng => {
      const leaf = toLeaf(rng.startContainer, rng.startOffset);
      return !isPreviousCharContent(dom, leaf);
    };
    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));
    const lookup = (editor, getDatabase) => {
      const database = getDatabase();
      const rng = editor.selection.getRng();
      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));
    };
    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {
      var _a;
      const database = getDatabase();
      const rng = editor.selection.getRng();
      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';
      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));
      if (autocompleters.length === 0) {
        return Optional.none();
      }
      const lookupData = Promise.all(map$3(autocompleters, ac => {
        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
        return fetchResult.then(results => ({
          matchText: context.text,
          items: results,
          columns: ac.columns,
          onAction: ac.onAction,
          highlightOn: ac.highlightOn
        }));
      }));
      return Optional.some({
        lookupData,
        context
      });
    };

    var SimpleResultType;
    (function (SimpleResultType) {
      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';
      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';
    }(SimpleResultType || (SimpleResultType = {})));
    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    const partition = results => {
      const values = [];
      const errors = [];
      each$e(results, obj => {
        fold$1(obj, err => errors.push(err), val => values.push(val));
      });
      return {
        values,
        errors
      };
    };
    const mapError = (res, f) => {
      if (res.stype === SimpleResultType.Error) {
        return {
          stype: SimpleResultType.Error,
          serror: f(res.serror)
        };
      } else {
        return res;
      }
    };
    const map = (res, f) => {
      if (res.stype === SimpleResultType.Value) {
        return {
          stype: SimpleResultType.Value,
          svalue: f(res.svalue)
        };
      } else {
        return res;
      }
    };
    const bind$1 = (res, f) => {
      if (res.stype === SimpleResultType.Value) {
        return f(res.svalue);
      } else {
        return res;
      }
    };
    const bindError = (res, f) => {
      if (res.stype === SimpleResultType.Error) {
        return f(res.serror);
      } else {
        return res;
      }
    };
    const svalue = v => ({
      stype: SimpleResultType.Value,
      svalue: v
    });
    const serror = e => ({
      stype: SimpleResultType.Error,
      serror: e
    });
    const toResult = res => fold$1(res, Result.error, Result.value);
    const fromResult = res => res.fold(serror, svalue);
    const SimpleResult = {
      fromResult,
      toResult,
      svalue,
      partition,
      serror,
      bind: bind$1,
      bindError,
      map,
      mapError,
      fold: fold$1
    };

    const formatObj = input => {
      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);
    };
    const formatErrors = errors => {
      const es = errors.length > 10 ? errors.slice(0, 10).concat([{
          path: [],
          getErrorInfo: constant('... (only showing first ten failures)')
        }]) : errors;
      return map$3(es, e => {
        return 'Failed path: (' + e.path.join(' > ') + ')\n' + e.getErrorInfo();
      });
    };

    const nu = (path, getErrorInfo) => {
      return SimpleResult.serror([{
          path,
          getErrorInfo
        }]);
    };
    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: "' + key + '"');
    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
    const custom = (path, err) => nu(path, constant(err));

    const chooseFrom = (path, input, branches, ch) => {
      const fields = get$a(branches, ch);
      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));
    };
    const choose$1 = (key, branches) => {
      const extract = (path, input) => {
        const choice = get$a(input, key);
        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));
      };
      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);
      return {
        extract,
        toString
      };
    };

    const shallow = (old, nu) => {
      return nu;
    };
    const deep = (old, nu) => {
      const bothObjects = isPlainObject(old) && isPlainObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    const baseMerge = merger => {
      return (...objects) => {
        if (objects.length === 0) {
          throw new Error(`Can't merge zero objects`);
        }
        const ret = {};
        for (let j = 0; j < objects.length; j++) {
          const curObject = objects[j];
          for (const key in curObject) {
            if (has$2(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    const deepMerge = baseMerge(deep);
    const merge = baseMerge(shallow);

    const required = () => ({
      tag: 'required',
      process: {}
    });
    const defaultedThunk = fallbackThunk => ({
      tag: 'defaultedThunk',
      process: fallbackThunk
    });
    const defaulted$1 = fallback => defaultedThunk(constant(fallback));
    const asOption = () => ({
      tag: 'option',
      process: {}
    });

    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);
    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
      const partition = SimpleResult.partition(objects);
      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);
    };
    const consolidateArr = objects => {
      const partitions = SimpleResult.partition(objects);
      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
      consolidateObj,
      consolidateArr
    };

    const field$1 = (key, newKey, presence, prop) => ({
      tag: 'field',
      key,
      newKey,
      presence,
      prop
    });
    const customField$1 = (newKey, instantiator) => ({
      tag: 'custom',
      newKey,
      instantiator
    });
    const fold = (value, ifField, ifCustom) => {
      switch (value.tag) {
      case 'field':
        return ifField(value.key, value.newKey, value.presence, value.prop);
      case 'custom':
        return ifCustom(value.newKey, value.instantiator);
      }
    };

    const value = validator => {
      const extract = (path, val) => {
        return SimpleResult.bindError(validator(val), err => custom(path, err));
      };
      const toString = constant('val');
      return {
        extract,
        toString
      };
    };
    const anyValue$1 = value(SimpleResult.svalue);

    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback, bundle) => {
      const v = get$a(obj, key).getOrThunk(() => fallback(obj));
      return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
    const optionDefaultedAccess = (obj, key, fallback, bundle) => {
      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);
      return bundle(opt);
    };
    const extractField = (field, path, obj, key, prop) => {
      const bundle = av => prop.extract(path.concat([key]), av);
      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {
        const result = prop.extract(path.concat([key]), ov);
        return SimpleResult.map(result, Optional.some);
      });
      switch (field.tag) {
      case 'required':
        return requiredAccess(path, obj, key, bundle);
      case 'defaultedThunk':
        return fallbackAccess(obj, key, field.process, bundle);
      case 'option':
        return optionAccess(obj, key, bundleAsOption);
      case 'defaultedOptionThunk':
        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);
      case 'mergeWithThunk': {
          return fallbackAccess(obj, key, constant({}), v => {
            const result = deepMerge(field.process(obj), v);
            return bundle(result);
          });
        }
      }
    };
    const extractFields = (path, obj, fields) => {
      const success = {};
      const errors = [];
      for (const field of fields) {
        fold(field, (key, newKey, presence, prop) => {
          const result = extractField(presence, path, obj, key, prop);
          SimpleResult.fold(result, err => {
            errors.push(...err);
          }, res => {
            success[newKey] = res;
          });
        }, (newKey, instantiator) => {
          success[newKey] = instantiator(obj);
        });
      }
      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const objOf = values => {
      const extract = (path, o) => extractFields(path, o, values);
      const toString = () => {
        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));
        return 'obj{\n' + fieldStrings.join('\n') + '}';
      };
      return {
        extract,
        toString
      };
    };
    const arrOf = prop => {
      const extract = (path, array) => {
        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));
        return ResultCombine.consolidateArr(results);
      };
      const toString = () => 'array(' + prop.toString() + ')';
      return {
        extract,
        toString
      };
    };

    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));
    const extractValue = (label, prop, obj) => {
      const res = prop.extract([label], obj);
      return SimpleResult.mapError(res, errs => ({
        input: obj,
        errors: errs
      }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const formatError = errInfo => {
      return 'Errors: \n' + formatErrors(errInfo.errors).join('\n') + '\n\nInput object: ' + formatObj(errInfo.input);
    };
    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));

    const anyValue = constant(anyValue$1);
    const typedValue = (validator, expectedType) => value(a => {
      const actualType = typeof a;
      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);
    });
    const number = typedValue(isNumber, 'number');
    const string = typedValue(isString, 'string');
    const boolean = typedValue(isBoolean, 'boolean');
    const functionProcessor = typedValue(isFunction, 'function');

    const field = field$1;
    const customField = customField$1;
    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: "${ value }", choose one of "${ values.join(', ') }".`));
    const requiredOf = (key, schema) => field(key, key, required(), schema);
    const requiredString = key => requiredOf(key, string);
    const requiredFunction = key => requiredOf(key, functionProcessor);
    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));
    const optionOf = (key, schema) => field(key, key, asOption(), schema);
    const optionString = key => optionOf(key, string);
    const optionFunction = key => optionOf(key, functionProcessor);
    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());
    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);
    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);
    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);
    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));
    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);
    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);
    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));

    const type = requiredString('type');
    const fetch$1 = requiredFunction('fetch');
    const onAction = requiredFunction('onAction');
    const onSetup = defaultedFunction('onSetup', () => noop);
    const optionalText = optionString('text');
    const optionalIcon = optionString('icon');
    const optionalTooltip = optionString('tooltip');
    const optionalLabel = optionString('label');
    const active = defaultedBoolean('active', false);
    const enabled = defaultedBoolean('enabled', true);
    const primary = defaultedBoolean('primary', false);
    const defaultedColumns = num => defaulted('columns', num);
    const defaultedType = type => defaultedString('type', type);

    const autocompleterSchema = objOf([
      type,
      requiredString('trigger'),
      defaultedNumber('minChars', 1),
      defaultedColumns(1),
      defaultedNumber('maxResults', 10),
      optionFunction('matches'),
      fetch$1,
      onAction,
      defaultedArrayOf('highlightOn', [], string)
    ]);
    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {
      trigger: spec.ch,
      ...spec
    });

    const baseToolbarButtonFields = [
      enabled,
      optionalTooltip,
      optionalIcon,
      optionalText,
      onSetup
    ];

    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);

    const contextBarFields = [
      defaultedFunction('predicate', never),
      defaultedStringEnum('scope', 'node', [
        'node',
        'editor'
      ]),
      defaultedStringEnum('position', 'selection', [
        'node',
        'selection',
        'line'
      ])
    ];

    const contextButtonFields = baseToolbarButtonFields.concat([
      defaultedType('contextformbutton'),
      primary,
      onAction,
      customField('original', identity)
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
      defaultedType('contextformbutton'),
      primary,
      onAction,
      customField('original', identity)
    ]);
    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);
    const toggleOrNormal = choose('type', {
      contextformbutton: contextButtonFields,
      contextformtogglebutton: contextToggleButtonFields
    });
    objOf([
      defaultedType('contextform'),
      defaultedFunction('initValue', constant('')),
      optionalLabel,
      requiredArrayOf('commands', toggleOrNormal),
      optionOf('launch', choose('type', {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields
      }))
    ].concat(contextBarFields));

    const register$2 = editor => {
      const popups = editor.ui.registry.getAll().popups;
      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {
        throw new Error(formatError(err));
      }, identity));
      const triggers = stringArray(mapToArray(dataset, v => v.trigger));
      const datasetValues = values(dataset);
      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);
      return {
        dataset,
        triggers,
        lookupByTrigger
      };
    };

    const setupEditorInput = (editor, api) => {
      const update = last$1(api.load, 50);
      editor.on('keypress compositionend', e => {
        if (e.which === 27) {
          return;
        }
        update.throttle();
      });
      editor.on('keydown', e => {
        const keyCode = e.which;
        if (keyCode === 8) {
          update.throttle();
        } else if (keyCode === 27) {
          api.cancelIfNecessary();
        }
      });
      editor.on('remove', update.cancel);
    };
    const setup$j = editor => {
      const activeAutocompleter = value$2();
      const uiActive = Cell(false);
      const isActive = activeAutocompleter.isSet;
      const cancelIfNecessary = () => {
        if (isActive()) {
          removeAutocompleterDecoration(editor);
          fireAutocompleterEnd(editor);
          uiActive.set(false);
          activeAutocompleter.clear();
        }
      };
      const commenceIfNecessary = context => {
        if (!isActive()) {
          addAutocompleterDecoration(editor, context.range);
          activeAutocompleter.set({
            trigger: context.trigger,
            matchLength: context.text.length
          });
        }
      };
      const getAutocompleters = cached(() => register$2(editor));
      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
      const load = fetchOptions => {
        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {
          commenceIfNecessary(lookupInfo.context);
          lookupInfo.lookupData.then(lookupData => {
            activeAutocompleter.get().map(ac => {
              const context = lookupInfo.context;
              if (ac.trigger === context.trigger) {
                if (context.text.length - ac.matchLength >= 10) {
                  cancelIfNecessary();
                } else {
                  activeAutocompleter.set({
                    ...ac,
                    matchLength: context.text.length
                  });
                  if (uiActive.get()) {
                    fireAutocompleterUpdate(editor, { lookupData });
                  } else {
                    uiActive.set(true);
                    fireAutocompleterStart(editor, { lookupData });
                  }
                }
              }
            });
          });
        });
      };
      editor.addCommand('mceAutocompleterReload', (_ui, value) => {
        const fetchOptions = isObject(value) ? value.fetchOptions : {};
        load(fetchOptions);
      });
      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);
      setupEditorInput(editor, {
        cancelIfNecessary,
        load
      });
    };

    const browser$1 = detect$2().browser;
    const isSafari = browser$1.isSafari();
    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));
    const isEntireNodeSelected = (rng, node) => {
      var _a;
      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);
    };
    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));
    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();
    const getDetailsElements = (dom, rng) => {
      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));
      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));
      if (startDetails.isSome() || endDetails.isSome()) {
        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));
        return Optional.some({
          startSummary,
          startDetails,
          endDetails
        });
      } else {
        return Optional.none();
      }
    };
    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));
    const isCaretInTheEndOf = (caretPos, element) => {
      return lastPositionIn(element).exists(pos => {
        if (isBr$6(pos.getNode())) {
          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);
        } else {
          return pos.isEqual(caretPos);
        }
      });
    };
    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));
    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));
    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));
    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));
    const setCaretToPosition = (editor, position) => {
      const node = position.getNode();
      if (!isUndefined(node)) {
        editor.selection.setCursorLocation(node, position.offset());
      }
    };
    const moveCaretToDetailsPos = (editor, pos, forward) => {
      const details = editor.dom.getParent(pos.container(), 'details');
      if (details && !details.open) {
        const summary = editor.dom.select('summary', details)[0];
        if (summary) {
          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);
          newPos.each(pos => setCaretToPosition(editor, pos));
        }
      } else {
        setCaretToPosition(editor, pos);
      }
    };
    const isPartialDelete = (rng, detailsElements) => {
      const containsStart = element => element.contains(rng.startContainer);
      const containsEnd = element => element.contains(rng.endContainer);
      const startInSummary = detailsElements.startSummary.exists(containsStart);
      const endInSummary = detailsElements.startSummary.exists(containsEnd);
      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));
      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);
      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;
    };
    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {
      const {dom, selection} = editor;
      const root = editor.getBody();
      if (granularity === 'character') {
        const caretPos = CaretPosition.fromRangeStart(selection.getRng());
        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);
        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);
        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);
        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);
        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);
        if (inEmptyParentBlock) {
          const firstOrLast = forward ? isLastBlock : isFirstBlock;
          if (firstOrLast) {
            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {
              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));
            });
            if (isBeforeAfterDetails) {
              return true;
            }
          }
        }
        return navigate(forward, root, caretPos).fold(never, pos => {
          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);
          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {
            if (!forward) {
              moveCaretToDetailsPos(editor, pos, false);
            }
            if (parentBlock && inEmptyParentBlock) {
              if (forward && isFirstBlock) {
                return true;
              } else if (!forward && isLastBlock) {
                return true;
              }
              moveCaretToDetailsPos(editor, pos, forward);
              editor.dom.remove(parentBlock);
            }
            return true;
          } else {
            return false;
          }
        });
      } else {
        return false;
      }
    };
    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {
      const selection = editor.selection;
      const rng = selection.getRng();
      const caretPos = CaretPosition.fromRangeStart(rng);
      const root = editor.getBody();
      if (granularity === 'selection') {
        return isPartialDelete(rng, detailElements);
      } else if (forward) {
        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);
      } else {
        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);
      }
    };
    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));
    const handleDeleteActionSafari = (editor, forward, granularity) => {
      const selection = editor.selection;
      const node = selection.getNode();
      const rng = selection.getRng();
      const caretPos = CaretPosition.fromRangeStart(rng);
      if (isSummary(node)) {
        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {
          emptyNodeContents(node);
        } else {
          editor.undoManager.transact(() => {
            const sel = selection.getSel();
            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};
            const applySelection = () => {
              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {
                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
              }
            };
            const updateSelection = () => {
              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;
            };
            const appendAllChildNodes = (from, to) => {
              each$e(from.childNodes, child => {
                if (isNode(child)) {
                  to.appendChild(child);
                }
              });
            };
            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });
            appendAllChildNodes(node, container);
            node.appendChild(container);
            applySelection();
            if (granularity === 'word' || granularity === 'line') {
              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);
            }
            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {
              emptyNodeContents(node);
            } else {
              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');
              updateSelection();
              appendAllChildNodes(container, node);
              applySelection();
            }
            editor.dom.remove(container);
          });
        }
        return true;
      } else {
        return false;
      }
    };
    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();

    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {
      const target = editor.getBody();
      const overrides = {
        bubbles: true,
        composed: true,
        data: null,
        isComposing: false,
        detail: 0,
        view: null,
        target,
        currentTarget: target,
        eventPhase: Event.AT_TARGET,
        originalTarget: target,
        explicitOriginalTarget: target,
        isTrusted: false,
        srcElement: target,
        cancelable: false,
        preventDefault: noop,
        inputType
      };
      const input = clone$3(new InputEvent(eventType));
      return editor.dispatch(eventType, {
        ...input,
        ...overrides,
        ...specifics
      });
    };
    const fireInputEvent = createAndFireInputEvent('input');
    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');

    const platform$2 = detect$2();
    const os = platform$2.os;
    const isMacOSOriOS = os.isMacOS() || os.isiOS();
    const browser = platform$2.browser;
    const isFirefox = browser.isFirefox();
    const executeKeydownOverride$3 = (editor, caret, evt) => {
      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';
      const isCollapsed = editor.selection.isCollapsed();
      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';
      const getModifiedGranularity = isWord => {
        if (isCollapsed) {
          return isWord ? 'word' : 'line';
        } else {
          return 'selection';
        }
      };
      executeWithDelayedAction([
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, caret, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, caret, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$a, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$a, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor, false, unmodifiedGranularity)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete, editor, true, unmodifiedGranularity)
        },
        ...isMacOSOriOS ? [
          {
            keyCode: VK.BACKSPACE,
            altKey: true,
            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))
          },
          {
            keyCode: VK.DELETE,
            altKey: true,
            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))
          },
          {
            keyCode: VK.BACKSPACE,
            metaKey: true,
            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))
          }
        ] : [
          {
            keyCode: VK.BACKSPACE,
            ctrlKey: true,
            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))
          },
          {
            keyCode: VK.DELETE,
            ctrlKey: true,
            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))
          }
        ],
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$9, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, true)
        }
      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {
        evt.preventDefault();
        const beforeInput = fireBeforeInputEvent(editor, inputType);
        if (!beforeInput.isDefaultPrevented()) {
          applyAction();
          fireInputEvent(editor, inputType);
        }
      });
    };
    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([
      {
        keyCode: VK.BACKSPACE,
        action: action(paddEmptyElement, editor)
      },
      {
        keyCode: VK.DELETE,
        action: action(paddEmptyElement, editor)
      },
      ...isMacOSOriOS ? [
        {
          keyCode: VK.BACKSPACE,
          altKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          altKey: true,
          action: action(refreshCaret, editor)
        },
        ...isBackspaceKeydown ? [{
            keyCode: isFirefox ? 224 : 91,
            action: action(refreshCaret, editor)
          }] : []
      ] : [
        {
          keyCode: VK.BACKSPACE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        }
      ]
    ], evt);
    const setup$i = (editor, caret) => {
      let isBackspaceKeydown = false;
      editor.on('keydown', evt => {
        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$3(editor, caret, evt);
        }
      });
      editor.on('keyup', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupOverride(editor, evt, isBackspaceKeydown);
        }
        isBackspaceKeydown = false;
      });
    };

    const firstNonWhiteSpaceNodeSibling = node => {
      while (node) {
        if (isElement$6(node) || isText$a(node) && node.data && /[\r\n\s]/.test(node.data)) {
          return node;
        }
        node = node.nextSibling;
      }
      return null;
    };
    const moveToCaretPosition = (editor, root) => {
      const dom = editor.dom;
      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
      if (!root) {
        return;
      }
      if (/^(LI|DT|DD)$/.test(root.nodeName)) {
        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
        }
      }
      const rng = dom.createRng();
      root.normalize();
      if (root.hasChildNodes()) {
        const walker = new DomTreeWalker(root, root);
        let lastNode = root;
        let node;
        while (node = walker.current()) {
          if (isText$a(node)) {
            rng.setStart(node, 0);
            rng.setEnd(node, 0);
            break;
          }
          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
            rng.setStartBefore(node);
            rng.setEndBefore(node);
            break;
          }
          lastNode = node;
          node = walker.next();
        }
        if (!node) {
          rng.setStart(lastNode, 0);
          rng.setEnd(lastNode, 0);
        }
      } else {
        if (isBr$6(root)) {
          if (root.nextSibling && dom.isBlock(root.nextSibling)) {
            rng.setStartBefore(root);
            rng.setEndBefore(root);
          } else {
            rng.setStartAfter(root);
            rng.setEndAfter(root);
          }
        } else {
          rng.setStart(root, 0);
          rng.setEnd(root, 0);
        }
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const getEditableRoot = (dom, node) => {
      const root = dom.getRoot();
      let editableRoot;
      let parent = node;
      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {
        if (dom.getContentEditable(parent) === 'true') {
          editableRoot = parent;
          break;
        }
        parent = parent.parentNode;
      }
      return parent !== root ? editableRoot : root;
    };
    const getParentBlock$1 = editor => {
      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    const getParentBlockName = editor => {
      return getParentBlock$1(editor).fold(constant(''), parentBlock => {
        return parentBlock.nodeName.toUpperCase();
      });
    };
    const isListItemParentBlock = editor => {
      return getParentBlock$1(editor).filter(elm => {
        return isListItem$1(SugarElement.fromDom(elm));
      }).isSome();
    };
    const emptyBlock = elm => {
      elm.innerHTML = '<br data-mce-bogus="1">';
    };
    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
      const dom = editor.dom;
      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {
        const currentStyles = getAllRaw(SugarElement.fromDom(node));
        const newStyles = {
          ...currentStyles,
          ...attrStyles
        };
        dom.setStyles(node, newStyles);
      });
      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\s+/));
      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\s+/), clazz => clazz !== ''));
      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));
        const newClasses = [
          ...attrClasses,
          ...filteredClasses
        ];
        dom.setAttrib(node, 'class', newClasses.join(' '));
      });
      const appliedAttrs = [
        'style',
        'class'
      ];
      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));
      dom.setAttribs(node, remainingAttrs);
    };
    const setForcedBlockAttrs = (editor, node) => {
      const forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
        applyAttributes(editor, node, forcedRootBlockAttrs);
      }
    };
    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name) => {
      const dom = editor.dom;
      const schema = editor.schema;
      const newBlockName = getForcedRootBlock(editor);
      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';
      let node = container;
      const textInlineElements = schema.getTextInlineElements();
      let block;
      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
        block = dom.create(name || newBlockName);
      } else {
        block = parentBlock.cloneNode(false);
      }
      let caretNode = block;
      if (!keepStyles) {
        dom.setAttrib(block, 'style', null);
        dom.setAttrib(block, 'class', null);
      } else {
        do {
          if (textInlineElements[node.nodeName]) {
            if (isCaretNode(node) || isBookmarkNode$1(node)) {
              continue;
            }
            const clonedNode = node.cloneNode(false);
            dom.setAttrib(clonedNode, 'id', '');
            if (block.hasChildNodes()) {
              clonedNode.appendChild(block.firstChild);
              block.appendChild(clonedNode);
            } else {
              caretNode = clonedNode;
              block.appendChild(clonedNode);
            }
          }
        } while ((node = node.parentNode) && node !== editableRoot);
      }
      setForcedBlockAttrs(editor, block);
      emptyBlock(caretNode);
      return block;
    };

    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);
    const isAtDetailsEdge = (root, element, isTextBlock) => {
      let node = element;
      while (node && node !== root && isNull(node.nextSibling)) {
        const parent = node.parentElement;
        if (!parent || !isTextBlock(parent)) {
          return isDetails(parent);
        }
        node = parent;
      }
      return false;
    };
    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));
    const insertNewLine = (editor, createNewBlock, parentBlock) => {
      var _a, _b, _c;
      const newBlock = createNewBlock(getForcedRootBlock(editor));
      const root = getDetailsRoot(editor, parentBlock);
      if (!root) {
        return;
      }
      editor.dom.insertAfter(newBlock, root);
      moveToCaretPosition(editor, newBlock);
      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {
        editor.dom.remove(parentBlock);
      }
    };

    const hasFirstChild = (elm, name) => {
      return elm.firstChild && elm.firstChild.nodeName === name;
    };
    const isFirstChild = elm => {
      var _a;
      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    const hasParent = (elm, parentName) => {
      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
      return isNonNullable(parentNode) && parentNode.nodeName === parentName;
    };
    const isListBlock = elm => {
      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    const isListItem = elm => {
      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
    };
    const isNestedList = elm => {
      return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    const getContainerBlock = containerBlock => {
      const containerBlockParent = containerBlock.parentNode;
      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
    };
    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {
      let node = containerBlock[first ? 'firstChild' : 'lastChild'];
      while (node) {
        if (isElement$6(node)) {
          break;
        }
        node = node[first ? 'nextSibling' : 'previousSibling'];
      }
      return node === parentBlock;
    };
    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
      const dom = editor.dom;
      const rng = editor.selection.getRng();
      const containerParent = containerBlock.parentNode;
      if (containerBlock === editor.getBody() || !containerParent) {
        return;
      }
      if (isNestedList(containerBlock)) {
        newBlockName = 'LI';
      }
      let newBlock = createNewBlock(newBlockName);
      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
        if (hasParent(containerBlock, 'LI')) {
          const containerBlockParent = getContainerBlock(containerBlock);
          dom.insertAfter(newBlock, containerBlockParent);
          if (isFirstChild(containerBlock)) {
            dom.remove(containerBlockParent);
          } else {
            dom.remove(containerBlock);
          }
        } else {
          dom.replace(newBlock, containerBlock);
        }
      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
        if (hasParent(containerBlock, 'LI')) {
          dom.insertAfter(newBlock, getContainerBlock(containerBlock));
          newBlock.appendChild(dom.doc.createTextNode(' '));
          newBlock.appendChild(containerBlock);
        } else {
          containerParent.insertBefore(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
        dom.insertAfter(newBlock, getContainerBlock(containerBlock));
        dom.remove(parentBlock);
      } else {
        containerBlock = getContainerBlock(containerBlock);
        const tmpRng = rng.cloneRange();
        tmpRng.setStartAfter(parentBlock);
        tmpRng.setEndAfter(containerBlock);
        const fragment = tmpRng.extractContents();
        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
          newBlock = fragment.firstChild;
          dom.insertAfter(fragment, containerBlock);
        } else {
          dom.insertAfter(fragment, containerBlock);
          dom.insertAfter(newBlock, containerBlock);
        }
        dom.remove(parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };

    const trimZwsp = fragment => {
      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {
        const rawNode = text.dom;
        rawNode.nodeValue = trim$1(rawNode.data);
      });
    };
    const isWithinNonEditableList = (editor, node) => {
      const parentList = editor.dom.getParent(node, 'ol,ul,dl');
      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';
    };
    const isEmptyAnchor = (dom, elm) => {
      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
    };
    const containerAndSiblingName = (container, nodeName) => {
      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
    };
    const canSplitBlock = (dom, node) => {
      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';
    };
    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {
      var _a;
      const firstChilds = [];
      if (!block) {
        return;
      }
      let currentNode = block;
      while (currentNode = currentNode.firstChild) {
        if (dom.isBlock(currentNode)) {
          return;
        }
        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
          firstChilds.push(currentNode);
        }
      }
      let i = firstChilds.length;
      while (i--) {
        currentNode = firstChilds[i];
        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {
          dom.remove(currentNode);
        } else {
          if (isEmptyAnchor(dom, currentNode)) {
            dom.remove(currentNode);
          }
        }
      }
    };
    const normalizeZwspOffset = (start, container, offset) => {
      if (!isText$a(container)) {
        return offset;
      } else if (start) {
        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;
      } else {
        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;
      }
    };
    const includeZwspInRange = rng => {
      const newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
      return newRng;
    };
    const trimLeadingLineBreaks = node => {
      let currentNode = node;
      do {
        if (isText$a(currentNode)) {
          currentNode.data = currentNode.data.replace(/^[\r\n]+/, '');
        }
        currentNode = currentNode.firstChild;
      } while (currentNode);
    };
    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {
      var _a, _b;
      const dom = editor.dom;
      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();
      let parentBlock = dom.getParent(container, dom.isBlock);
      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
        parentBlock = parentBlock || editableRoot;
        if (!parentBlock.hasChildNodes()) {
          const newBlock = dom.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          parentBlock.appendChild(newBlock);
          rng.setStart(newBlock, 0);
          rng.setEnd(newBlock, 0);
          return newBlock;
        }
        let node = container;
        while (node && node.parentNode !== parentBlock) {
          node = node.parentNode;
        }
        let startNode;
        while (node && !dom.isBlock(node)) {
          startNode = node;
          node = node.previousSibling;
        }
        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
          const startNodeParent = startNode.parentNode;
          const newBlock = dom.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          startNodeParent.insertBefore(newBlock, startNode);
          node = startNode;
          while (node && !dom.isBlock(node)) {
            const next = node.nextSibling;
            newBlock.appendChild(node);
            node = next;
          }
          rng.setStart(container, offset);
          rng.setEnd(container, offset);
        }
      }
      return container;
    };
    const addBrToBlockIfNeeded = (dom, block) => {
      block.normalize();
      const lastChild = block.lastChild;
      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {
        dom.add(block, 'br');
      }
    };
    const shouldEndContainer = (editor, container) => {
      const optionValue = shouldEndContainerOnEmptyBlock(editor);
      if (isNullable(container)) {
        return false;
      } else if (isString(optionValue)) {
        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
      } else {
        return optionValue;
      }
    };
    const insert$3 = (editor, evt) => {
      let container;
      let offset;
      let parentBlockName;
      let containerBlock;
      let isAfterLastNodeInContainer = false;
      const dom = editor.dom;
      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
      const rng = editor.selection.getRng();
      const newBlockName = getForcedRootBlock(editor);
      const start = SugarElement.fromDom(rng.startContainer);
      const child = child$1(start, rng.startOffset);
      const isCef = child.exists(element => isHTMLElement(element) && !isEditable$3(element));
      const collapsedAndCef = rng.collapsed && isCef;
      const createNewBlock$1 = name => {
        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name);
      };
      const isCaretAtStartOrEndOfBlock = start => {
        const normalizedOffset = normalizeZwspOffset(start, container, offset);
        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
          return false;
        }
        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {
          return true;
        }
        if (start && isElement$6(container) && container === parentBlock.firstChild) {
          return true;
        }
        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {
          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;
        }
        const walker = new DomTreeWalker(container, parentBlock);
        if (isText$a(container)) {
          if (start && normalizedOffset === 0) {
            walker.prev();
          } else if (!start && normalizedOffset === container.data.length) {
            walker.next();
          }
        }
        let node;
        while (node = walker.current()) {
          if (isElement$6(node)) {
            if (!node.getAttribute('data-mce-bogus')) {
              const name = node.nodeName.toLowerCase();
              if (nonEmptyElementsMap[name] && name !== 'br') {
                return false;
              }
            }
          } else if (isText$a(node) && !isWhitespaceText(node.data)) {
            return false;
          }
          if (start) {
            walker.prev();
          } else {
            walker.next();
          }
        }
        return true;
      };
      const insertNewBlockAfter = () => {
        let block;
        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
          block = createNewBlock$1(newBlockName);
        } else {
          block = createNewBlock$1();
        }
        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {
          block = dom.split(containerBlock, parentBlock);
        } else {
          dom.insertAfter(block, parentBlock);
        }
        moveToCaretPosition(editor, block);
        return block;
      };
      normalize$2(dom, rng).each(normRng => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      container = rng.startContainer;
      offset = rng.startOffset;
      const shiftKey = !!(evt && evt.shiftKey);
      const ctrlKey = !!(evt && evt.ctrlKey);
      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {
        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset = container.data.length;
        } else {
          offset = 0;
        }
      }
      const editableRoot = getEditableRoot(dom, container);
      if (!editableRoot || isWithinNonEditableList(editor, container)) {
        return;
      }
      if (!shiftKey) {
        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
      }
      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();
      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      if (containerBlockName === 'LI' && !ctrlKey) {
        const liBlock = containerBlock;
        parentBlock = liBlock;
        containerBlock = liBlock.parentNode;
        parentBlockName = containerBlockName;
      }
      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {
        return insertNewLine(editor, createNewBlock$1, parentBlock);
      }
      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
        if (dom.isEmpty(parentBlock)) {
          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);
          return;
        }
      }
      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {
        return;
      }
      const parentBlockParent = parentBlock.parentNode;
      let newBlock;
      if (collapsedAndCef) {
        newBlock = createNewBlock$1(newBlockName);
        child.fold(() => {
          append$1(start, SugarElement.fromDom(newBlock));
        }, child => {
          before$3(child, SugarElement.fromDom(newBlock));
        });
        editor.selection.setCursorLocation(newBlock, 0);
      } else if (isCaretContainerBlock$1(parentBlock)) {
        newBlock = showCaretContainerBlock(parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      } else if (isCaretAtStartOrEndOfBlock(false)) {
        newBlock = insertNewBlockAfter();
      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);
        const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;
        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);
      } else {
        const tmpRng = includeZwspInRange(rng).cloneRange();
        tmpRng.setEndAfter(parentBlock);
        const fragment = tmpRng.extractContents();
        trimZwsp(fragment);
        trimLeadingLineBreaks(fragment);
        newBlock = fragment.firstChild;
        dom.insertAfter(fragment, parentBlock);
        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
        addBrToBlockIfNeeded(dom, parentBlock);
        if (dom.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        newBlock.normalize();
        if (dom.isEmpty(newBlock)) {
          dom.remove(newBlock);
          insertNewBlockAfter();
        } else {
          setForcedBlockAttrs(editor, newBlock);
          moveToCaretPosition(editor, newBlock);
        }
      }
      dom.setAttrib(newBlock, 'id', '');
      editor.dispatch('NewBlock', { newBlock });
    };
    const fakeEventName$1 = 'insertParagraph';
    const blockbreak = {
      insert: insert$3,
      fakeEventName: fakeEventName$1
    };

    const hasRightSideContent = (schema, container, parentBlock) => {
      const walker = new DomTreeWalker(container, parentBlock);
      let node;
      const nonEmptyElementsMap = schema.getNonEmptyElements();
      while (node = walker.next()) {
        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {
          return true;
        }
      }
      return false;
    };
    const moveSelectionToBr = (editor, brElm, extraBr) => {
      const rng = editor.dom.createRng();
      if (!extraBr) {
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
      } else {
        rng.setStartBefore(brElm);
        rng.setEndBefore(brElm);
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const insertBrAtCaret = (editor, evt) => {
      const selection = editor.selection;
      const dom = editor.dom;
      const rng = selection.getRng();
      let brElm;
      let extraBr = false;
      normalize$2(dom, rng).each(normRng => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      let offset = rng.startOffset;
      let container = rng.startContainer;
      if (isElement$6(container) && container.hasChildNodes()) {
        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset = container.data.length;
        } else {
          offset = 0;
        }
      }
      let parentBlock = dom.getParent(container, dom.isBlock);
      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
      const isControlKey = !!(evt && evt.ctrlKey);
      if (containerBlockName === 'LI' && !isControlKey) {
        parentBlock = containerBlock;
      }
      if (isText$a(container) && offset >= container.data.length) {
        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {
          brElm = dom.create('br');
          rng.insertNode(brElm);
          rng.setStartAfter(brElm);
          rng.setEndAfter(brElm);
          extraBr = true;
        }
      }
      brElm = dom.create('br');
      rangeInsertNode(dom, rng, brElm);
      moveSelectionToBr(editor, brElm, extraBr);
      editor.undoManager.add();
    };
    const insertBrBefore = (editor, inline) => {
      const br = SugarElement.fromTag('br');
      before$3(SugarElement.fromDom(inline), br);
      editor.undoManager.add();
    };
    const insertBrAfter = (editor, inline) => {
      if (!hasBrAfter(editor.getBody(), inline)) {
        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));
      }
      const br = SugarElement.fromTag('br');
      after$4(SugarElement.fromDom(inline), br);
      moveSelectionToBr(editor, br.dom, false);
      editor.undoManager.add();
    };
    const isBeforeBr = pos => {
      return isBr$6(pos.getNode());
    };
    const hasBrAfter = (rootNode, startNode) => {
      if (isBeforeBr(CaretPosition.after(startNode))) {
        return true;
      } else {
        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {
          return isBr$6(pos.getNode());
        }).getOr(false);
      }
    };
    const isAnchorLink = elm => {
      return elm && elm.nodeName === 'A' && 'href' in elm;
    };
    const isInsideAnchor = location => {
      return location.fold(never, isAnchorLink, isAnchorLink, never);
    };
    const readInlineAnchorLocation = editor => {
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const position = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    const insertBrOutsideAnchor = (editor, location) => {
      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
    };
    const insert$2 = (editor, evt) => {
      const anchorLocation = readInlineAnchorLocation(editor);
      if (anchorLocation.isSome()) {
        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
      } else {
        insertBrAtCaret(editor, evt);
      }
    };
    const fakeEventName = 'insertLineBreak';
    const linebreak = {
      insert: insert$2,
      fakeEventName
    };

    const matchesSelector = (editor, selector) => {
      return getParentBlock$1(editor).filter(parentBlock => {
        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
      }).isSome();
    };
    const shouldInsertBr = editor => {
      return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    const shouldBlockNewLine$1 = editor => {
      return matchesSelector(editor, getNoNewLineSelector(editor));
    };

    const newLineAction = Adt.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]);
    const shouldBlockNewLine = (editor, _shiftKey) => {
      return shouldBlockNewLine$1(editor);
    };
    const inListBlock = requiredState => {
      return (editor, _shiftKey) => {
        return isListItemParentBlock(editor) === requiredState;
      };
    };
    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
      const state = getParentBlockName(editor) === blockName.toUpperCase();
      return state === requiredState;
    };
    const inCefBlock = editor => {
      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNullable(editableRoot);
    };
    const inPreBlock = requiredState => inBlock('pre', requiredState);
    const inSummaryBlock = () => inBlock('summary', true);
    const shouldPutBrInPre = requiredState => {
      return (editor, _shiftKey) => {
        return shouldPutBrInPre$1(editor) === requiredState;
      };
    };
    const inBrContext = (editor, _shiftKey) => {
      return shouldInsertBr(editor);
    };
    const hasShiftKey = (_editor, shiftKey) => {
      return shiftKey;
    };
    const canInsertIntoEditableRoot = editor => {
      const forcedRootBlock = getForcedRootBlock(editor);
      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
    };
    const isInRootWithEmptyOrCEF = editor => {
      const rng = editor.selection.getRng();
      const start = SugarElement.fromDom(rng.startContainer);
      const child = child$1(start, rng.startOffset);
      const isCefOpt = child.map(element => isHTMLElement(element) && !isEditable$3(element));
      return rng.collapsed && isCefOpt.getOr(true);
    };
    const match = (predicates, action) => {
      return (editor, shiftKey) => {
        const isMatch = foldl(predicates, (res, p) => {
          return res && p(editor, shiftKey);
        }, true);
        return isMatch ? Optional.some(action) : Optional.none();
      };
    };
    const getAction = (editor, evt) => {
      return evaluateUntil([
        match([shouldBlockNewLine], newLineAction.none()),
        match([
          inPreBlock(true),
          inCefBlock
        ], newLineAction.none()),
        match([inSummaryBlock()], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false),
          hasShiftKey
        ], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false)
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true),
          hasShiftKey
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true)
        ], newLineAction.br()),
        match([
          inListBlock(true),
          hasShiftKey
        ], newLineAction.br()),
        match([inListBlock(true)], newLineAction.block()),
        match([inBrContext], newLineAction.br()),
        match([hasShiftKey], newLineAction.br()),
        match([canInsertIntoEditableRoot], newLineAction.block()),
        match([isInRootWithEmptyOrCEF], newLineAction.block())
      ], [
        editor,
        !!(evt && evt.shiftKey)
      ]).getOr(newLineAction.none());
    };

    const insertBreak = (breakType, editor, evt) => {
      if (!editor.selection.isCollapsed()) {
        execEditorDeleteCommand(editor);
      }
      if (isNonNullable(evt)) {
        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);
        if (event.isDefaultPrevented()) {
          return;
        }
      }
      breakType.insert(editor, evt);
      if (isNonNullable(evt)) {
        fireInputEvent(editor, breakType.fakeEventName);
      }
    };
    const insert$1 = (editor, evt) => {
      const br = () => insertBreak(linebreak, editor, evt);
      const block = () => insertBreak(blockbreak, editor, evt);
      const logicalAction = getAction(editor, evt);
      switch (getNewlineBehavior(editor)) {
      case 'linebreak':
        logicalAction.fold(br, br, noop);
        break;
      case 'block':
        logicalAction.fold(block, block, noop);
        break;
      case 'invert':
        logicalAction.fold(block, br, noop);
        break;
      default:
        logicalAction.fold(br, block, noop);
        break;
      }
    };

    const platform$1 = detect$2();
    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();
    const handleEnterKeyEvent = (editor, event) => {
      if (event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      endTypingLevelIgnoreLocks(editor.undoManager);
      editor.undoManager.transact(() => {
        insert$1(editor, event);
      });
    };
    const isCaretAfterKoreanCharacter = rng => {
      if (!rng.collapsed) {
        return false;
      }
      const startContainer = rng.startContainer;
      if (isText$a(startContainer)) {
        const koreanCharRegex = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
        const char = startContainer.data.charAt(rng.startOffset - 1);
        return koreanCharRegex.test(char);
      } else {
        return false;
      }
    };
    const setup$h = editor => {
      let iOSSafariKeydownBookmark = Optional.none();
      const iOSSafariKeydownOverride = editor => {
        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());
        editor.undoManager.add();
      };
      const iOSSafariKeyupOverride = (editor, event) => {
        editor.undoManager.undo();
        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));
        handleEnterKeyEvent(editor, event);
        iOSSafariKeydownBookmark = Optional.none();
      };
      editor.on('keydown', event => {
        if (event.keyCode === VK.ENTER) {
          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {
            iOSSafariKeydownOverride(editor);
          } else {
            handleEnterKeyEvent(editor, event);
          }
        }
      });
      editor.on('keyup', event => {
        if (event.keyCode === VK.ENTER) {
          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));
        }
      });
    };

    const executeKeydownOverride$2 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute([
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false)
        },
        ...!isMac ? [
          {
            keyCode: VK.HOME,
            action: action(selectToEndPoint, editor, false),
            ctrlKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.END,
            action: action(selectToEndPoint, editor, true),
            ctrlKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        }
      ], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$g = (editor, caret) => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$2(editor, caret, evt);
        }
      });
    };

    const setup$f = editor => {
      editor.on('input', e => {
        if (!e.isComposing) {
          normalizeNbspsInEditor(editor);
        }
      });
    };

    const platform = detect$2();
    const executeKeyupAction = (editor, caret, evt) => {
      execute([
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        }
      ], evt);
    };
    const stopImmediatePropagation = e => e.stopImmediatePropagation();
    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    const setNodeChangeBlocker = (blocked, editor, block) => {
      if (block && !blocked.get()) {
        editor.on('NodeChange', stopImmediatePropagation, true);
      } else if (!block && blocked.get()) {
        editor.off('NodeChange', stopImmediatePropagation);
      }
      blocked.set(block);
    };
    const setup$e = (editor, caret) => {
      if (platform.os.isMacOS()) {
        return;
      }
      const blocked = Cell(false);
      editor.on('keydown', evt => {
        if (isPageUpDown(evt)) {
          setNodeChangeBlocker(blocked, editor, true);
        }
      });
      editor.on('keyup', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupAction(editor, caret, evt);
        }
        if (isPageUpDown(evt) && blocked.get()) {
          setNodeChangeBlocker(blocked, editor, false);
          editor.nodeChanged();
        }
      });
    };

    const insertTextAtPosition = (text, pos) => {
      const container = pos.container();
      const offset = pos.offset();
      if (isText$a(container)) {
        container.insertData(offset, text);
        return Optional.some(CaretPosition(container, offset + text.length));
      } else {
        return getElementFromPosition(pos).map(elm => {
          const textNode = SugarElement.fromText(text);
          if (pos.isAtEnd()) {
            after$4(elm, textNode);
          } else {
            before$3(elm, textNode);
          }
          return CaretPosition(textNode.dom, text.length);
        });
      }
    };
    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');

    const insertSpaceOrNbspAtPosition = (root, pos) => needsToHaveNbsp(root, pos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));
    const insertInlineBoundarySpaceOrNbsp = (root, pos) => checkPos => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const setSelection = editor => pos => {
      editor.selection.setRng(pos.toRange());
      editor.nodeChanged();
    };
    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));
    const insertSpaceOrNbspAtSelection = editor => {
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      const root = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));
      } else {
        return Optional.none();
      }
    };
    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {
      const insertSpaceThunk = () => {
        const root = SugarElement.fromDom(editor.getBody());
        if (!editor.selection.isCollapsed()) {
          editor.getDoc().execCommand('Delete');
        }
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        insertSpaceOrNbspAtPosition(root, pos).each(setSelection(editor));
      };
      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);
    };

    const executeKeydownOverride$1 = (editor, evt) => {
      executeWithDelayedAction([
        {
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceOrNbspAtSelection, editor)
        },
        {
          keyCode: VK.SPACEBAR,
          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)
        }
      ], evt).each(applyAction => {
        evt.preventDefault();
        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });
        if (!event.isDefaultPrevented()) {
          applyAction();
          fireInputEvent(editor, 'insertText', { data: ' ' });
        }
      });
    };
    const setup$d = editor => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$1(editor, evt);
        }
      });
    };

    const tableTabNavigation = editor => {
      if (hasTableTabNavigation(editor)) {
        return [
          {
            keyCode: VK.TAB,
            action: action(handleTab, editor, true)
          },
          {
            keyCode: VK.TAB,
            shiftKey: true,
            action: action(handleTab, editor, false)
          }
        ];
      } else {
        return [];
      }
    };
    const executeKeydownOverride = (editor, evt) => {
      execute([...tableTabNavigation(editor)], evt).each(_ => {
        evt.preventDefault();
      });
    };
    const setup$c = editor => {
      editor.on('keydown', evt => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride(editor, evt);
        }
      });
    };

    const setup$b = editor => {
      editor.addShortcut('Meta+P', '', 'mcePrint');
      setup$j(editor);
      if (isRtc(editor)) {
        return Cell(null);
      } else {
        const caret = setupSelectedState(editor);
        setup$l(editor);
        setup$k(editor, caret);
        setup$i(editor, caret);
        setup$h(editor);
        setup$d(editor);
        setup$f(editor);
        setup$c(editor);
        setup$g(editor, caret);
        setup$e(editor, caret);
        return caret;
      }
    };

    class NodeChange {
      constructor(editor) {
        this.lastPath = [];
        this.editor = editor;
        let lastRng;
        const self = this;
        if (!('onselectionchange' in editor.getDoc())) {
          editor.on('NodeChange click mouseup keyup focus', e => {
            const nativeRng = editor.selection.getRng();
            const fakeRng = {
              startContainer: nativeRng.startContainer,
              startOffset: nativeRng.startOffset,
              endContainer: nativeRng.endContainer,
              endOffset: nativeRng.endOffset
            };
            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {
              editor.dispatch('SelectionChange');
            }
            lastRng = fakeRng;
          });
        }
        editor.on('contextmenu', () => {
          editor.dispatch('SelectionChange');
        });
        editor.on('SelectionChange', () => {
          const startElm = editor.selection.getStart(true);
          if (!startElm) {
            return;
          }
          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
            editor.nodeChanged({ selectionChange: true });
          }
        });
        editor.on('mouseup', e => {
          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
            if (editor.selection.getNode().nodeName === 'IMG') {
              Delay.setEditorTimeout(editor, () => {
                editor.nodeChanged();
              });
            } else {
              editor.nodeChanged();
            }
          }
        });
      }
      nodeChanged(args = {}) {
        const selection = this.editor.selection;
        let node;
        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
          const root = this.editor.getBody();
          node = selection.getStart(true) || root;
          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
            node = root;
          }
          const parents = [];
          this.editor.dom.getParent(node, node => {
            if (node === root) {
              return true;
            } else {
              parents.push(node);
              return false;
            }
          });
          this.editor.dispatch('NodeChange', {
            ...args,
            element: node,
            parents
          });
        }
      }
      isSameElementPath(startElm) {
        let i;
        const editor = this.editor;
        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
        if (currentPath.length === this.lastPath.length) {
          for (i = currentPath.length; i >= 0; i--) {
            if (currentPath[i] !== this.lastPath[i]) {
              break;
            }
          }
          if (i === -1) {
            this.lastPath = currentPath;
            return true;
          }
        }
        this.lastPath = currentPath;
        return false;
      }
    }

    const imageId = generate$1('image');
    const getDragImage = transfer => {
      const dt = transfer;
      return Optional.from(dt[imageId]);
    };
    const setDragImage = (transfer, imageData) => {
      const dt = transfer;
      dt[imageId] = imageData;
    };

    const eventId = generate$1('event');
    const getEvent = transfer => {
      const dt = transfer;
      return Optional.from(dt[eventId]);
    };
    const mkSetEventFn = type => transfer => {
      const dt = transfer;
      dt[eventId] = type;
    };
    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);
    const setDragstartEvent = mkSetEventFn(0);
    const setDropEvent = mkSetEventFn(2);
    const setDragendEvent = mkSetEventFn(1);
    const checkEvent = expectedType => transfer => {
      const dt = transfer;
      return Optional.from(dt[eventId]).exists(type => type === expectedType);
    };
    const isInDragStartEvent = checkEvent(0);

    const createEmptyFileList = () => Object.freeze({
      length: 0,
      item: _ => null
    });

    const modeId = generate$1('mode');
    const getMode = transfer => {
      const dt = transfer;
      return Optional.from(dt[modeId]);
    };
    const mkSetModeFn = mode => transfer => {
      const dt = transfer;
      dt[modeId] = mode;
    };
    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
    const setReadWriteMode = mkSetModeFn(0);
    const setReadOnlyMode = mkSetModeFn(2);
    const setProtectedMode = mkSetModeFn(1);
    const checkMode = expectedMode => transfer => {
      const dt = transfer;
      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);
    };
    const isInReadWriteMode = checkMode(0);
    const isInProtectedMode = checkMode(1);

    const normalizeItems = (dataTransfer, itemsImpl) => ({
      ...itemsImpl,
      get length() {
        return itemsImpl.length;
      },
      add: (data, type) => {
        if (isInReadWriteMode(dataTransfer)) {
          if (isString(data)) {
            if (!isUndefined(type)) {
              return itemsImpl.add(data, type);
            }
          } else {
            return itemsImpl.add(data);
          }
        }
        return null;
      },
      remove: idx => {
        if (isInReadWriteMode(dataTransfer)) {
          itemsImpl.remove(idx);
        }
      },
      clear: () => {
        if (isInReadWriteMode(dataTransfer)) {
          itemsImpl.clear();
        }
      }
    });

    const validDropEffects = [
      'none',
      'copy',
      'link',
      'move'
    ];
    const validEffectAlloweds = [
      'none',
      'copy',
      'copyLink',
      'copyMove',
      'link',
      'linkMove',
      'move',
      'all',
      'uninitialized'
    ];
    const createDataTransfer = () => {
      const dataTransferImpl = new window.DataTransfer();
      let dropEffect = 'move';
      let effectAllowed = 'all';
      const dataTransfer = {
        get dropEffect() {
          return dropEffect;
        },
        set dropEffect(effect) {
          if (contains$2(validDropEffects, effect)) {
            dropEffect = effect;
          }
        },
        get effectAllowed() {
          return effectAllowed;
        },
        set effectAllowed(allowed) {
          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {
            effectAllowed = allowed;
          }
        },
        get items() {
          return normalizeItems(dataTransfer, dataTransferImpl.items);
        },
        get files() {
          if (isInProtectedMode(dataTransfer)) {
            return createEmptyFileList();
          } else {
            return dataTransferImpl.files;
          }
        },
        get types() {
          return dataTransferImpl.types;
        },
        setDragImage: (image, x, y) => {
          if (isInReadWriteMode(dataTransfer)) {
            setDragImage(dataTransfer, {
              image,
              x,
              y
            });
            dataTransferImpl.setDragImage(image, x, y);
          }
        },
        getData: format => {
          if (isInProtectedMode(dataTransfer)) {
            return '';
          } else {
            return dataTransferImpl.getData(format);
          }
        },
        setData: (format, data) => {
          if (isInReadWriteMode(dataTransfer)) {
            dataTransferImpl.setData(format, data);
          }
        },
        clearData: format => {
          if (isInReadWriteMode(dataTransfer)) {
            dataTransferImpl.clearData(format);
          }
        }
      };
      setReadWriteMode(dataTransfer);
      return dataTransfer;
    };
    const cloneDataTransfer = original => {
      const clone = createDataTransfer();
      const originalMode = getMode(original);
      setReadOnlyMode(original);
      setDragstartEvent(clone);
      clone.dropEffect = original.dropEffect;
      clone.effectAllowed = original.effectAllowed;
      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));
      each$e(original.types, type => {
        if (type !== 'Files') {
          clone.setData(type, original.getData(type));
        }
      });
      each$e(original.files, file => clone.items.add(file));
      getEvent(original).each(type => {
        setEvent(clone, type);
      });
      originalMode.each(mode => {
        setMode$1(original, mode);
        setMode$1(clone, mode);
      });
      return clone;
    };

    const getHtmlData = dataTransfer => {
      const html = dataTransfer.getData('text/html');
      return html === '' ? Optional.none() : Optional.some(html);
    };
    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);

    const internalMimeType = 'x-tinymce/html';
    const internalHtmlMime = constant(internalMimeType);
    const internalMark = '<!-- ' + internalMimeType + ' -->';
    const mark = html => internalMark + html;
    const unmark = html => html.replace(internalMark, '');
    const isMarked = html => html.indexOf(internalMark) !== -1;

    const isPlainText = text => {
      return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text);
    };
    const openContainer = (rootTag, rootAttrs) => {
      let tag = '<' + rootTag;
      const attrs = mapToArray(rootAttrs, (value, key) => key + '="' + Entities.encodeAllRaw(value) + '"');
      if (attrs.length) {
        tag += ' ' + attrs.join(' ');
      }
      return tag + '>';
    };
    const toBlockElements = (text, rootTag, rootAttrs) => {
      const blocks = text.split(/\n\n/);
      const tagOpen = openContainer(rootTag, rootAttrs);
      const tagClose = '</' + rootTag + '>';
      const paragraphs = map$3(blocks, p => {
        return p.split(/\n/).join('<br />');
      });
      const stitch = p => {
        return tagOpen + p + tagClose;
      };
      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');
    };

    const pasteBinDefaultContent = '%MCEPASTEBIN%';
    const create$6 = (editor, lastRngCell) => {
      const {dom, selection} = editor;
      const body = editor.getBody();
      lastRngCell.set(selection.getRng());
      const pasteBinElm = dom.add(editor.getBody(), 'div', {
        'id': 'mcepastebin',
        'class': 'mce-pastebin',
        'contentEditable': true,
        'data-mce-bogus': 'all',
        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'
      }, pasteBinDefaultContent);
      if (Env.browser.isFirefox()) {
        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);
      }
      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {
        e.stopPropagation();
      });
      pasteBinElm.focus();
      selection.select(pasteBinElm, true);
    };
    const remove = (editor, lastRngCell) => {
      const dom = editor.dom;
      if (getEl(editor)) {
        let pasteBinClone;
        const lastRng = lastRngCell.get();
        while (pasteBinClone = getEl(editor)) {
          dom.remove(pasteBinClone);
          dom.unbind(pasteBinClone);
        }
        if (lastRng) {
          editor.selection.setRng(lastRng);
        }
      }
      lastRngCell.set(null);
    };
    const getEl = editor => editor.dom.get('mcepastebin');
    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';
    const getHtml = editor => {
      const dom = editor.dom;
      const copyAndRemove = (toElm, fromElm) => {
        toElm.appendChild(fromElm);
        dom.remove(fromElm, true);
      };
      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
      each$e(pasteBinClones, pasteBinClone => {
        copyAndRemove(pasteBinElm, pasteBinClone);
      });
      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);
      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
        const cleanWrapper = dom.create('div');
        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
        copyAndRemove(cleanWrapper, dirtyWrappers[i]);
      }
      return pasteBinElm ? pasteBinElm.innerHTML : '';
    };
    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;
    const PasteBin = editor => {
      const lastRng = Cell(null);
      return {
        create: () => create$6(editor, lastRng),
        remove: () => remove(editor, lastRng),
        getEl: () => getEl(editor),
        getHtml: () => getHtml(editor),
        getLastRng: lastRng.get
      };
    };

    const filter$1 = (content, items) => {
      Tools.each(items, v => {
        if (is$4(v, RegExp)) {
          content = content.replace(v, '');
        } else {
          content = content.replace(v[0], v[1]);
        }
      });
      return content;
    };
    const innerText = html => {
      const schema = Schema();
      const domParser = DomParser({}, schema);
      let text = '';
      const voidElements = schema.getVoidElements();
      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');
      const blockElements = schema.getBlockElements();
      const walk = node => {
        const name = node.name, currentNode = node;
        if (name === 'br') {
          text += '\n';
          return;
        }
        if (name === 'wbr') {
          return;
        }
        if (voidElements[name]) {
          text += ' ';
        }
        if (ignoreElements[name]) {
          text += ' ';
          return;
        }
        if (node.type === 3) {
          text += node.value;
        }
        if (!(node.name in schema.getVoidElements())) {
          let currentNode = node.firstChild;
          if (currentNode) {
            do {
              walk(currentNode);
            } while (currentNode = currentNode.next);
          }
        }
        if (blockElements[name] && currentNode.next) {
          text += '\n';
          if (name === 'p') {
            text += '\n';
          }
        }
      };
      html = filter$1(html, [/<!\[[^\]]+\]>/g]);
      walk(domParser.parse(html));
      return text;
    };
    const trimHtml = html => {
      const trimSpaces = (all, s1, s2) => {
        if (!s1 && !s2) {
          return ' ';
        }
        return nbsp;
      };
      html = filter$1(html, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        /<!--StartFragment-->|<!--EndFragment-->/g,
        [
          /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
          trimSpaces
        ],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
      ]);
      return html;
    };
    const createIdGenerator = prefix => {
      let count = 0;
      return () => {
        return prefix + count++;
      };
    };
    const getImageMimeType = ext => {
      const lowerExt = ext.toLowerCase();
      const mimeOverrides = {
        jpg: 'jpeg',
        jpe: 'jpeg',
        jfi: 'jpeg',
        jif: 'jpeg',
        jfif: 'jpeg',
        pjpeg: 'jpeg',
        pjp: 'jpeg',
        svg: 'svg+xml'
      };
      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;
    };

    const preProcess = (editor, html) => {
      const parser = DomParser({ sanitize: shouldSanitizeXss(editor) }, editor.schema);
      parser.addNodeFilter('meta', nodes => {
        Tools.each(nodes, node => {
          node.remove();
        });
      });
      const fragment = parser.parse(html, {
        forced_root_block: false,
        isRootContent: true
      });
      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
    };
    const processResult = (content, cancelled) => ({
      content,
      cancelled
    });
    const postProcessFilter = (editor, html, internal) => {
      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);
      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    const filterContent = (editor, content, internal) => {
      const preProcessArgs = firePastePreProcess(editor, content, internal);
      const filteredContent = preProcess(editor, preProcessArgs.content);
      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {
        return postProcessFilter(editor, filteredContent, internal);
      } else {
        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
      }
    };
    const process = (editor, html, internal) => {
      return filterContent(editor, html, internal);
    };

    const pasteHtml$1 = (editor, html) => {
      editor.insertContent(html, {
        merge: shouldPasteMergeFormats(editor),
        paste: true
      });
      return true;
    };
    const isAbsoluteUrl = url => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
    const isImageUrl = (editor, url) => {
      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));
    };
    const createImage = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.insertContent('<img src="' + url + '">');
      });
      return true;
    };
    const createLink = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.execCommand('mceInsertLink', false, url);
      });
      return true;
    };
    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;
    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;
    const smartInsertContent = (editor, html) => {
      Tools.each([
        linkSelection,
        insertImage,
        pasteHtml$1
      ], action => {
        return !action(editor, html, pasteHtml$1);
      });
    };
    const insertContent = (editor, html, pasteAsText) => {
      if (pasteAsText || !isSmartPasteEnabled(editor)) {
        pasteHtml$1(editor, html);
      } else {
        smartInsertContent(editor, html);
      }
    };

    const uniqueId = createIdGenerator('mceclip');
    const createPasteDataTransfer = html => {
      const dataTransfer = createDataTransfer();
      setHtmlData(dataTransfer, html);
      setReadOnlyMode(dataTransfer);
      return dataTransfer;
    };
    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {
      const res = process(editor, content, internal);
      if (!res.cancelled) {
        const content = res.content;
        const doPasteAction = () => insertContent(editor, content, pasteAsText);
        if (shouldSimulateInputEvent) {
          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });
          if (!args.isDefaultPrevented()) {
            doPasteAction();
            fireInputEvent(editor, 'insertFromPaste');
          }
        } else {
          doPasteAction();
        }
      }
    };
    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {
      const internal = internalFlag ? internalFlag : isMarked(html);
      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);
    };
    const pasteText = (editor, text, shouldSimulateInputEvent) => {
      const encodedText = editor.dom.encode(text).replace(/\r\n/g, '\n');
      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
      doPaste(editor, html, false, true, shouldSimulateInputEvent);
    };
    const getDataTransferItems = dataTransfer => {
      const items = {};
      if (dataTransfer && dataTransfer.types) {
        for (let i = 0; i < dataTransfer.types.length; i++) {
          const contentType = dataTransfer.types[i];
          try {
            items[contentType] = dataTransfer.getData(contentType);
          } catch (ex) {
            items[contentType] = '';
          }
        }
      }
      return items;
    };
    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');
    const extractFilename = (editor, str) => {
      const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;
    };
    const createBlobInfo = (editor, blobCache, file, base64) => {
      const id = uniqueId();
      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
      const name = useFileName ? extractFilename(editor, file.name) : id;
      const filename = useFileName ? file.name : undefined;
      const blobInfo = blobCache.create(id, file, base64, name, filename);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const pasteImage = (editor, imageItem) => {
      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {
        const base64 = base64Encoded ? data : btoa(data);
        const file = imageItem.file;
        const blobCache = editor.editorUpload.blobCache;
        const existingBlobInfo = blobCache.getByData(base64, type);
        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);
        pasteHtml(editor, `<img src="${ blobInfo.blobUri() }">`, false, true);
      });
    };
    const isClipboardEvent = event => event.type === 'paste';
    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {
      return blobToDataUri(file).then(uri => ({
        file,
        uri
      }));
    }));
    const isImage = editor => {
      const allowedExtensions = getAllowedImageFileTypes(editor);
      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {
        return getImageMimeType(extension) === file.type;
      });
    };
    const getImagesFromDataTransfer = (editor, dataTransfer) => {
      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {
        return item.kind === 'file' ? [item.getAsFile()] : [];
      }) : [];
      const files = dataTransfer.files ? from(dataTransfer.files) : [];
      return filter$5(items.length > 0 ? items : files, isImage(editor));
    };
    const pasteImageData = (editor, e, rng) => {
      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
      if (shouldPasteDataImages(editor) && dataTransfer) {
        const images = getImagesFromDataTransfer(editor, dataTransfer);
        if (images.length > 0) {
          e.preventDefault();
          readFilesAsDataUris(images).then(fileResults => {
            if (rng) {
              editor.selection.setRng(rng);
            }
            each$e(fileResults, result => {
              pasteImage(editor, result);
            });
          });
          return true;
        }
      }
      return false;
    };
    const isBrokenAndroidClipboardEvent = e => {
      var _a, _b;
      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;
    };
    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;
    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {
      let content = trimHtml(html);
      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);
      const isPlainTextHtml = !isInternal && isPlainText(content);
      const isAbsoluteUrl$1 = isAbsoluteUrl(content);
      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {
        plainTextMode = true;
      }
      if (plainTextMode || isAbsoluteUrl$1) {
        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
          content = clipboardContent['text/plain'];
        } else {
          content = innerText(content);
        }
      }
      if (isDefaultPasteBinContent(content)) {
        return;
      }
      if (plainTextMode) {
        pasteText(editor, content, shouldSimulateInputEvent);
      } else {
        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
      }
    };
    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
      let keyboardPastePlainTextState;
      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
      editor.on('keydown', e => {
        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
        }
      });
      editor.on('paste', e => {
        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
          return;
        }
        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;
        keyboardPastePlainTextState = false;
        const clipboardContent = getDataTransferItems(e.clipboardData);
        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
          return;
        }
        if (hasContentType(clipboardContent, 'text/html')) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);
        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);
        } else {
          pasteBin.create();
          Delay.setEditorTimeout(editor, () => {
            const html = pasteBin.getHtml();
            pasteBin.remove();
            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);
          }, 0);
        }
      });
    };
    const registerDataImageFilter = editor => {
      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');
      const isDataUri = src => startsWith(src, 'data:');
      const isPasteInsert = args => {
        var _a;
        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;
      };
      editor.parser.addNodeFilter('img', (nodes, name, args) => {
        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
          for (const node of nodes) {
            const src = node.attr('src');
            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {
              if (isWebKitFakeUrl(src)) {
                node.remove();
              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                node.remove();
              }
            }
          }
        }
      });
    };
    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
      registerEventHandlers(editor, pasteBin, pasteFormat);
      registerDataImageFilter(editor);
    };

    const togglePlainTextPaste = (editor, pasteFormat) => {
      if (pasteFormat.get() === 'text') {
        pasteFormat.set('html');
        firePastePlainTextToggle(editor, false);
      } else {
        pasteFormat.set('text');
        firePastePlainTextToggle(editor, true);
      }
      editor.focus();
    };
    const register$1 = (editor, pasteFormat) => {
      editor.addCommand('mceTogglePlainTextPaste', () => {
        togglePlainTextPaste(editor, pasteFormat);
      });
      editor.addCommand('mceInsertClipboardContent', (ui, value) => {
        if (value.html) {
          pasteHtml(editor, value.html, value.internal, false);
        }
        if (value.text) {
          pasteText(editor, value.text, false);
        }
      });
    };

    const setHtml5Clipboard = (clipboardData, html, text) => {
      if (clipboardData) {
        try {
          clipboardData.clearData();
          clipboardData.setData('text/html', html);
          clipboardData.setData('text/plain', text);
          clipboardData.setData(internalHtmlMime(), html);
          return true;
        } catch (e) {
          return false;
        }
      } else {
        return false;
      }
    };
    const setClipboardData = (evt, data, fallback, done) => {
      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
        evt.preventDefault();
        done();
      } else {
        fallback(data.html, done);
      }
    };
    const fallback = editor => (html, done) => {
      const {dom, selection} = editor;
      const outer = dom.create('div', {
        'contenteditable': 'false',
        'data-mce-bogus': 'all'
      });
      const inner = dom.create('div', { contenteditable: 'true' }, html);
      dom.setStyles(outer, {
        position: 'fixed',
        top: '0',
        left: '-3000px',
        width: '1000px',
        overflow: 'hidden'
      });
      outer.appendChild(inner);
      dom.add(editor.getBody(), outer);
      const range = selection.getRng();
      inner.focus();
      const offscreenRange = dom.createRng();
      offscreenRange.selectNodeContents(inner);
      selection.setRng(offscreenRange);
      Delay.setEditorTimeout(editor, () => {
        selection.setRng(range);
        dom.remove(outer);
        done();
      }, 0);
    };
    const getData = editor => ({
      html: mark(editor.selection.getContent({ contextual: true })),
      text: editor.selection.getContent({ format: 'text' })
    });
    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());
    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);
    const cut = editor => evt => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback(editor), () => {
          if (Env.browser.isChromium() || Env.browser.isFirefox()) {
            const rng = editor.selection.getRng();
            Delay.setEditorTimeout(editor, () => {
              editor.selection.setRng(rng);
              editor.execCommand('Delete');
            }, 0);
          } else {
            editor.execCommand('Delete');
          }
        });
      }
    };
    const copy = editor => evt => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback(editor), noop);
      }
    };
    const register = editor => {
      editor.on('cut', cut(editor));
      editor.on('copy', copy(editor));
    };

    const getCaretRangeFromEvent = (editor, e) => {
      var _a, _b;
      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());
    };
    const isPlainTextFileUrl = content => {
      const plainTextContent = content['text/plain'];
      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
    };
    const setFocusedRange = (editor, rng) => {
      editor.focus();
      if (rng) {
        editor.selection.setRng(rng);
      }
    };
    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\//.test(file.type));
    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {
      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));
      const inSummary = !isNull(dom.getParent(target, 'summary'));
      if (inSummary) {
        return true;
      } else if (parentTransparent && has$2(dropContent, 'text/html')) {
        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;
        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
      } else {
        return false;
      }
    };
    const setupSummaryDeleteByDragFix = editor => {
      editor.on('input', e => {
        const hasNoSummary = el => isNull(el.querySelector('summary'));
        if (e.inputType === 'deleteByDrag') {
          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);
          each$e(brokenDetailElements, details => {
            if (isBr$6(details.firstChild)) {
              details.firstChild.remove();
            }
            const summary = editor.dom.create('summary');
            summary.appendChild(createPaddingBr().dom);
            details.prepend(summary);
          });
        }
      });
    };
    const setup$a = (editor, draggingInternallyState) => {
      if (shouldPasteBlockDrop(editor)) {
        editor.on('dragend dragover draggesture dragdrop drop drag', e => {
          e.preventDefault();
          e.stopPropagation();
        });
      }
      if (!shouldPasteDataImages(editor)) {
        editor.on('drop', e => {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && hasImage(dataTransfer)) {
            e.preventDefault();
          }
        });
      }
      editor.on('drop', e => {
        if (e.isDefaultPrevented()) {
          return;
        }
        const rng = getCaretRangeFromEvent(editor, e);
        if (isNullable(rng)) {
          return;
        }
        const dropContent = getDataTransferItems(e.dataTransfer);
        const internal = hasContentType(dropContent, internalHtmlMime());
        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {
          return;
        }
        const internalContent = dropContent[internalHtmlMime()];
        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];
        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
        const isInternalDrop = draggingInternallyState.get();
        if (isInternalDrop && !needsInternalDrop) {
          return;
        }
        if (content) {
          e.preventDefault();
          Delay.setEditorTimeout(editor, () => {
            editor.undoManager.transact(() => {
              if (internalContent || isInternalDrop && needsInternalDrop) {
                editor.execCommand('Delete');
              }
              setFocusedRange(editor, rng);
              const trimmedContent = trimHtml(content);
              if (dropContent['text/html']) {
                pasteHtml(editor, trimmedContent, internal, true);
              } else {
                pasteText(editor, trimmedContent, true);
              }
            });
          });
        }
      });
      editor.on('dragstart', _e => {
        draggingInternallyState.set(true);
      });
      editor.on('dragover dragend', e => {
        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
          e.preventDefault();
          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
        }
        if (e.type === 'dragend') {
          draggingInternallyState.set(false);
        }
      });
      setupSummaryDeleteByDragFix(editor);
    };

    const setup$9 = editor => {
      const processEvent = f => e => {
        f(editor, e);
      };
      const preProcess = getPastePreProcess(editor);
      if (isFunction(preProcess)) {
        editor.on('PastePreProcess', processEvent(preProcess));
      }
      const postProcess = getPastePostProcess(editor);
      if (isFunction(postProcess)) {
        editor.on('PastePostProcess', processEvent(postProcess));
      }
    };

    const addPreProcessFilter = (editor, filterFunc) => {
      editor.on('PastePreProcess', e => {
        e.content = filterFunc(editor, e.content, e.internal);
      });
    };
    const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();
    const removeWebKitStyles = (editor, content, internal) => {
      const webKitStylesOption = getPasteWebkitStyles(editor);
      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {
        return content;
      }
      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
      if (webKitStyles && webKitStylesOption !== 'none') {
        const dom = editor.dom, node = editor.selection.getNode();
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all, before, value, after) => {
          const inputStyles = dom.parseStyle(dom.decode(value));
          const outputStyles = {};
          for (let i = 0; i < webKitStyles.length; i++) {
            const inputValue = inputStyles[webKitStyles[i]];
            let compareInput = inputValue;
            let currentValue = dom.getStyle(node, webKitStyles[i], true);
            if (/color/.test(webKitStyles[i])) {
              compareInput = rgbToHex(compareInput);
              currentValue = rgbToHex(currentValue);
            }
            if (currentValue !== compareInput) {
              outputStyles[webKitStyles[i]] = inputValue;
            }
          }
          const outputStyle = dom.serializeStyle(outputStyles, 'span');
          if (outputStyle) {
            return before + ' style="' + outputStyle + '"' + after;
          }
          return before + after;
        });
      } else {
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
      }
      content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all, before, value, after) => {
        return before + ' style="' + value + '"' + after;
      });
      return content;
    };
    const setup$8 = editor => {
      if (Env.browser.isChromium() || Env.browser.isSafari()) {
        addPreProcessFilter(editor, removeWebKitStyles);
      }
    };

    const setup$7 = editor => {
      const draggingInternallyState = Cell(false);
      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');
      const pasteBin = PasteBin(editor);
      setup$8(editor);
      register$1(editor, pasteFormat);
      setup$9(editor);
      editor.on('PreInit', () => {
        register(editor);
        setup$a(editor, draggingInternallyState);
        registerEventsAndFilters(editor, pasteBin, pasteFormat);
      });
    };

    const preventSummaryToggle = editor => {
      editor.on('click', e => {
        if (editor.dom.getParent(e.target, 'details')) {
          e.preventDefault();
        }
      });
    };
    const filterDetails = editor => {
      editor.parser.addNodeFilter('details', elms => {
        const initialStateOption = getDetailsInitialState(editor);
        each$e(elms, details => {
          if (initialStateOption === 'expanded') {
            details.attr('open', 'open');
          } else if (initialStateOption === 'collapsed') {
            details.attr('open', null);
          }
        });
      });
      editor.serializer.addNodeFilter('details', elms => {
        const serializedStateOption = getDetailsSerializedState(editor);
        each$e(elms, details => {
          if (serializedStateOption === 'expanded') {
            details.attr('open', 'open');
          } else if (serializedStateOption === 'collapsed') {
            details.attr('open', null);
          }
        });
      });
    };
    const setup$6 = editor => {
      preventSummaryToggle(editor);
      filterDetails(editor);
    };

    const isBr = isBr$6;
    const isText = isText$a;
    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);
    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);
    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);
    const getClosestScope = (node, rootNode) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || isBlock$2(elm), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;
    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
    const findEdgeCaretCandidate = (startNode, scope, forward) => {
      const walker = new DomTreeWalker(startNode, scope);
      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
      let result = startNode;
      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {
        if (isCaretCandidate$3(current)) {
          result = current;
        }
      }
      return result;
    };
    const findClosestBlockRange = (startRng, rootNode) => {
      const startPos = CaretPosition.fromRangeStart(startRng);
      const clickNode = startPos.getNode();
      const scope = getClosestScope(clickNode, rootNode);
      const startNode = findEdgeCaretCandidate(clickNode, scope, false);
      const endNode = findEdgeCaretCandidate(clickNode, scope, true);
      const rng = document.createRange();
      getClosestCef(startNode, scope).fold(() => {
        if (isText(startNode)) {
          rng.setStart(startNode, 0);
        } else {
          rng.setStartBefore(startNode);
        }
      }, cef => rng.setStartBefore(cef.dom));
      getClosestCef(endNode, scope).fold(() => {
        if (isText(endNode)) {
          rng.setEnd(endNode, endNode.data.length);
        } else {
          rng.setEndAfter(endNode);
        }
      }, cef => rng.setEndAfter(cef.dom));
      return rng;
    };
    const onTripleClickSelect = editor => {
      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody());
      editor.selection.setRng(normalize(rng));
    };
    const setup$5 = editor => {
      editor.on('mousedown', e => {
        if (e.detail >= 3) {
          e.preventDefault();
          onTripleClickSelect(editor);
        }
      });
    };

    var FakeCaretPosition;
    (function (FakeCaretPosition) {
      FakeCaretPosition['Before'] = 'before';
      FakeCaretPosition['After'] = 'after';
    }(FakeCaretPosition || (FakeCaretPosition = {})));
    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
    const isOverlapping = (r1, r2) => {
      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
      return collidesY(r1, r2) && overlap > 0.5;
    };
    const splitRectsPerAxis = (rects, y) => {
      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));
      return boundingClientRectFromRects(intersectingRects).fold(() => [
        [],
        rects
      ], boundingRect => {
        const {
          pass: horizontal,
          fail: vertical
        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));
        return [
          horizontal,
          vertical
        ];
      });
    };
    const clientInfo = (rect, clientX) => {
      return {
        node: rect.node,
        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
      };
    };
    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
    const closestChildCaretCandidateNodeRect = (children, clientX, clientY) => {
      const caretCandidateRect = rect => {
        if (isCaretCandidate$3(rect.node)) {
          return Optional.some(rect);
        } else if (isElement$6(rect.node)) {
          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);
        } else {
          return Optional.none();
        }
      };
      const getClosestTextNode = (rects, distance) => {
        if (rects.length >= 2) {
          const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);
          const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);
          const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
          if (deltaDistance < 2) {
            if (isText$a(r1.node)) {
              return Optional.some(r1);
            } else if (isText$a(r2.node)) {
              return Optional.some(r2);
            }
          }
        }
        return Optional.none();
      };
      const findClosestCaretCandidateNodeRect = (rects, distance) => {
        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
        return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));
      };
      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);
      const {
        pass: above,
        fail: below
      } = partition$2(verticalRects, rect => rect.top < clientY);
      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
    };
    const traverseUp = (rootElm, scope, clientX, clientY) => {
      const helper = (scope, prevScope) => {
        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');
        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));
        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY), prevScope => {
          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);
          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);
        }).orThunk(() => {
          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);
          return parent.bind(newScope => helper(newScope, Optional.some(scope)));
        });
      };
      return helper(scope, Optional.none());
    };
    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
      const rootElm = SugarElement.fromDom(root);
      const ownerDoc = documentOrOwner(rootElm);
      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));
      const element = elementAtPoint.getOr(rootElm);
      return traverseUp(rootElm, element, clientX, clientY);
    };
    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));

    const getAbsolutePosition = elm => {
      var _a, _b;
      const clientRect = elm.getBoundingClientRect();
      const doc = elm.ownerDocument;
      const docElem = doc.documentElement;
      const win = doc.defaultView;
      return {
        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
      };
    };
    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {
      left: 0,
      top: 0
    };
    const getScrollPosition = editor => {
      const body = editor.getBody();
      return editor.inline ? {
        left: body.scrollLeft,
        top: body.scrollTop
      } : {
        left: 0,
        top: 0
      };
    };
    const getBodyScroll = editor => {
      const body = editor.getBody(), docElm = editor.getDoc().documentElement;
      const inlineScroll = {
        left: body.scrollLeft,
        top: body.scrollTop
      };
      const iframeScroll = {
        left: body.scrollLeft || docElm.scrollLeft,
        top: body.scrollTop || docElm.scrollTop
      };
      return editor.inline ? inlineScroll : iframeScroll;
    };
    const getMousePosition = (editor, event) => {
      if (event.target.ownerDocument !== editor.getDoc()) {
        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        const scrollPosition = getBodyScroll(editor);
        return {
          left: event.pageX - iframePosition.left + scrollPosition.left,
          top: event.pageY - iframePosition.top + scrollPosition.top
        };
      }
      return {
        left: event.pageX,
        top: event.pageY
      };
    };
    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
    });
    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));

    const getTargetProps = target => ({
      target,
      srcElement: target
    });
    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({
      ...mouseEvent,
      dataTransfer,
      type,
      ...getTargetProps(target)
    });
    const makeDndEvent = (type, target, dataTransfer) => {
      const fail = die('Function not supported on simulated event.');
      const event = {
        bubbles: true,
        cancelBubble: false,
        cancelable: true,
        composed: false,
        currentTarget: null,
        defaultPrevented: false,
        eventPhase: 0,
        isTrusted: true,
        returnValue: false,
        timeStamp: 0,
        type,
        composedPath: fail,
        initEvent: fail,
        preventDefault: noop,
        stopImmediatePropagation: noop,
        stopPropagation: noop,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: false,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        metaKey: false,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: false,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: fail,
        initMouseEvent: fail,
        getModifierState: fail,
        dataTransfer,
        ...getTargetProps(target)
      };
      return event;
    };
    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
      const copy = cloneDataTransfer(dataTransfer);
      if (eventType === 'dragstart') {
        setDragstartEvent(copy);
        setReadWriteMode(copy);
      } else if (eventType === 'drop') {
        setDropEvent(copy);
        setReadOnlyMode(copy);
      } else {
        setDragendEvent(copy);
        setProtectedMode(copy);
      }
      return copy;
    };
    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {
      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);
      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);
    };

    const scrollPixelsPerInterval = 32;
    const scrollIntervalValue = 100;
    const mouseRangeToTriggerScrollInsideEditor = 8;
    const mouseRangeToTriggerScrollOutsideEditor = 16;
    const isContentEditableFalse$1 = isContentEditableFalse$b;
    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);
    const isValidDropTarget = (editor, targetElement, dragElement) => {
      if (isNullable(targetElement)) {
        return false;
      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      } else {
        return editor.dom.isEditable(targetElement);
      }
    };
    const createGhost = (editor, elm, width, height) => {
      const dom = editor.dom;
      const clonedElm = elm.cloneNode(true);
      dom.setStyles(clonedElm, {
        width,
        height
      });
      dom.setAttrib(clonedElm, 'data-mce-selected', null);
      const ghostElm = dom.create('div', {
        'class': 'mce-drag-container',
        'data-mce-bogus': 'all',
        'unselectable': 'on',
        'contenteditable': 'false'
      });
      dom.setStyles(ghostElm, {
        position: 'absolute',
        opacity: 0.5,
        overflow: 'hidden',
        border: 0,
        padding: 0,
        margin: 0,
        width,
        height
      });
      dom.setStyles(clonedElm, {
        margin: 0,
        boxSizing: 'border-box'
      });
      ghostElm.appendChild(clonedElm);
      return ghostElm;
    };
    const appendGhostToBody = (ghostElm, bodyElm) => {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };
    const scrollEditor = (direction, amount) => win => () => {
      const current = direction === 'left' ? win.scrollX : win.scrollY;
      win.scroll({
        [direction]: current + amount,
        behavior: 'smooth'
      });
    };
    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);
    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);
    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);
    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);
    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
      let overflowX = 0, overflowY = 0;
      ghostElm.style.left = position.pageX + 'px';
      ghostElm.style.top = position.pageY + 'px';
      if (position.pageX + width > maxX) {
        overflowX = position.pageX + width - maxX;
      }
      if (position.pageY + height > maxY) {
        overflowY = position.pageY + height - maxY;
      }
      ghostElm.style.width = width - overflowX + 'px';
      ghostElm.style.height = height - overflowY + 'px';
      const clientHeight = contentAreaContainer.clientHeight;
      const clientWidth = contentAreaContainer.clientWidth;
      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
      state.on(state => {
        state.intervalId.clear();
        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {
          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
            state.intervalId.set(scrollDown(win));
          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state.intervalId.set(scrollUp(win));
          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
            state.intervalId.set(scrollRight(win));
          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state.intervalId.set(scrollLeft(win));
          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
            state.intervalId.set(scrollDown(window));
          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state.intervalId.set(scrollUp(window));
          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
            state.intervalId.set(scrollRight(window));
          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state.intervalId.set(scrollLeft(window));
          }
        }
      });
    };
    const removeElement = elm => {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };
    const removeElementWithPadding = (dom, elm) => {
      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);
      removeElement(elm);
      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {
        fillWithPaddingBr(SugarElement.fromDom(parentBlock));
      }
    };
    const isLeftMouseButtonPressed = e => e.button === 0;
    const applyRelPos = (state, position) => ({
      pageX: position.pageX - state.relX,
      pageY: position.pageY + 5
    });
    const start = (state, editor) => e => {
      if (isLeftMouseButtonPressed(e)) {
        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
          const elmPos = editor.dom.getPos(ceElm);
          const bodyElm = editor.getBody();
          const docElm = editor.getDoc().documentElement;
          state.set({
            element: ceElm,
            dataTransfer: createDataTransfer(),
            dragging: false,
            screenX: e.screenX,
            screenY: e.screenY,
            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
            relX: e.pageX - elmPos.x,
            relY: e.pageY - elmPos.y,
            width: ceElm.offsetWidth,
            height: ceElm.offsetHeight,
            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
            intervalId: repeatable(scrollIntervalValue)
          });
        }
      }
    };
    const placeCaretAt = (editor, clientX, clientY) => {
      editor._selectionOverrides.hideFakeCaret();
      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {
        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
        if (range) {
          editor.selection.setRng(range);
        } else {
          editor.selection.placeCaretAt(clientX, clientY);
        }
      });
    };
    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {
      if (type === 'dragstart') {
        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
      }
      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);
      const args = editor.dispatch(type, event);
      return args;
    };
    const move = (state, editor) => {
      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
      editor.on('remove', throttledPlaceCaretAt.cancel);
      const state_ = state;
      return e => state.on(state => {
        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
        if (!state.dragging && movement > 10) {
          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);
          if (isNonNullable(args.dataTransfer)) {
            state.dataTransfer = args.dataTransfer;
          }
          if (args.isDefaultPrevented()) {
            return;
          }
          state.dragging = true;
          editor.focus();
        }
        if (state.dragging) {
          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
          const targetPos = applyRelPos(state, calc(editor, e));
          appendGhostToBody(state.ghost, editor.getBody());
          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
        }
      });
    };
    const getRawTarget = selection => {
      const sel = selection.getSel();
      if (isNonNullable(sel)) {
        const rng = sel.getRangeAt(0);
        const startContainer = rng.startContainer;
        return isText$a(startContainer) ? startContainer.parentNode : startContainer;
      } else {
        return null;
      }
    };
    const drop = (state, editor) => e => {
      state.on(state => {
        var _a;
        state.intervalId.clear();
        if (state.dragging) {
          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);
            if (!args.isDefaultPrevented()) {
              editor.undoManager.transact(() => {
                removeElementWithPadding(editor.dom, state.element);
                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));
                editor._selectionOverrides.hideFakeCaret();
              });
            }
          }
          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);
        }
      });
      removeDragState(state);
    };
    const stopDragging = (state, editor, e) => {
      state.on(state => {
        state.intervalId.clear();
        if (state.dragging) {
          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));
        }
      });
      removeDragState(state);
    };
    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));
    const removeDragState = state => {
      state.on(state => {
        state.intervalId.clear();
        removeElement(state.ghost);
      });
      state.clear();
    };
    const bindFakeDragEvents = editor => {
      const state = value$2();
      const pageDom = DOMUtils.DOM;
      const rootDocument = document;
      const dragStartHandler = start(state, editor);
      const dragHandler = move(state, editor);
      const dropHandler = drop(state, editor);
      const dragEndHandler = stop(state, editor);
      editor.on('mousedown', dragStartHandler);
      editor.on('mousemove', dragHandler);
      editor.on('mouseup', dropHandler);
      pageDom.bind(rootDocument, 'mousemove', dragHandler);
      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
      editor.on('remove', () => {
        pageDom.unbind(rootDocument, 'mousemove', dragHandler);
        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
      });
      editor.on('keydown', e => {
        if (e.keyCode === VK.ESC) {
          stopDragging(state, editor, Optional.none());
        }
      });
    };
    const blockUnsupportedFileDrop = editor => {
      const preventFileDrop = e => {
        if (!e.isDefaultPrevented()) {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {
            e.preventDefault();
            if (e.type === 'drop') {
              displayError(editor, 'Dropped file type is not supported');
            }
          }
        }
      };
      const preventFileDropIfUIElement = e => {
        if (isUIElement(editor, e.target)) {
          preventFileDrop(e);
        }
      };
      const setup = () => {
        const pageDom = DOMUtils.DOM;
        const dom = editor.dom;
        const doc = document;
        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
        const eventNames = [
          'drop',
          'dragover'
        ];
        each$e(eventNames, name => {
          pageDom.bind(doc, name, preventFileDropIfUIElement);
          dom.bind(editorRoot, name, preventFileDrop);
        });
        editor.on('remove', () => {
          each$e(eventNames, name => {
            pageDom.unbind(doc, name, preventFileDropIfUIElement);
            dom.unbind(editorRoot, name, preventFileDrop);
          });
        });
      };
      editor.on('init', () => {
        Delay.setEditorTimeout(editor, setup, 0);
      });
    };
    const init$2 = editor => {
      bindFakeDragEvents(editor);
      if (shouldBlockUnsupportedDrop(editor)) {
        blockUnsupportedFileDrop(editor);
      }
    };

    const setup$4 = editor => {
      const renderFocusCaret = first$1(() => {
        if (!editor.removed && editor.getBody().contains(document.activeElement)) {
          const rng = editor.selection.getRng();
          if (rng.collapsed) {
            const caretRange = renderRangeCaret(editor, rng, false);
            editor.selection.setRng(caretRange);
          }
        }
      }, 0);
      editor.on('focus', () => {
        renderFocusCaret.throttle();
      });
      editor.on('blur', () => {
        renderFocusCaret.cancel();
      });
    };

    const setup$3 = editor => {
      editor.on('init', () => {
        editor.on('focusin', e => {
          const target = e.target;
          if (isMedia$2(target)) {
            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
            if (editor.selection.getNode() !== node) {
              selectNode(editor, node).each(rng => editor.selection.setRng(rng));
            }
          }
        });
      });
    };

    const isContentEditableFalse = isContentEditableFalse$b;
    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
    const SelectionOverrides = editor => {
      const selection = editor.selection, dom = editor.dom;
      const rootNode = editor.getBody();
      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));
      const realSelectionId = 'sel-' + dom.uniqueId();
      const elementSelectionAttr = 'data-mce-selected';
      let selectedElement;
      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');
      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);
      const setRange = range => {
        if (range) {
          selection.setRng(range);
        }
      };
      const showCaret = (direction, node, before, scrollIntoView = true) => {
        const e = editor.dispatch('ShowCaret', {
          target: node,
          direction,
          before
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        if (scrollIntoView) {
          selection.scrollIntoView(node, direction === -1);
        }
        return fakeCaret.show(before, node);
      };
      const showBlockCaretContainer = blockCaretContainer => {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
          showCaretContainerBlock(blockCaretContainer);
          selection.scrollIntoView(blockCaretContainer);
        }
      };
      const registerEvents = () => {
        editor.on('click', e => {
          if (!dom.isEditable(e.target)) {
            e.preventDefault();
            editor.focus();
          }
        });
        editor.on('blur NewBlock', removeElementSelection);
        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);
        editor.on('tap', e => {
          const targetElm = e.target;
          const contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        }, true);
        editor.on('mousedown', e => {
          const targetElm = e.target;
          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {
            return;
          }
          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
            return;
          }
          removeElementSelection();
          hideFakeCaret();
          const closestContentEditable = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(closestContentEditable)) {
            e.preventDefault();
            selectNode(editor, closestContentEditable).each(setElementSelection);
          } else {
            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {
              e.preventDefault();
              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
              setRange(range);
              if (isElement$6(closestContentEditable)) {
                closestContentEditable.focus();
              } else {
                editor.getBody().focus();
              }
            });
          }
        });
        editor.on('keypress', e => {
          if (VK.modifierPressed(e)) {
            return;
          }
          if (isContentEditableFalse(selection.getNode())) {
            e.preventDefault();
          }
        });
        editor.on('GetSelectionRange', e => {
          let rng = e.range;
          if (selectedElement) {
            if (!selectedElement.parentNode) {
              selectedElement = null;
              return;
            }
            rng = rng.cloneRange();
            rng.selectNode(selectedElement);
            e.range = rng;
          }
        });
        editor.on('SetSelectionRange', e => {
          e.range = normalizeVoidElementSelection(e.range);
          const rng = setElementSelection(e.range, e.forward);
          if (rng) {
            e.range = rng;
          }
        });
        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';
        editor.on('AfterSetSelectionRange', e => {
          const rng = e.range;
          const parent = rng.startContainer.parentElement;
          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {
            hideFakeCaret();
          }
          if (!isFakeSelectionElement(parent)) {
            removeElementSelection();
          }
        });
        init$2(editor);
        setup$4(editor);
        setup$3(editor);
      };
      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      const normalizeVoidElementSelection = rng => {
        const voidElements = editor.schema.getVoidElements();
        const newRng = dom.createRng();
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
          if (startOffset === 0) {
            newRng.setStartBefore(startContainer);
          } else {
            newRng.setStartAfter(startContainer);
          }
        } else {
          newRng.setStart(startContainer, startOffset);
        }
        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
          if (endOffset === 0) {
            newRng.setEndBefore(endContainer);
          } else {
            newRng.setEndAfter(endContainer);
          }
        } else {
          newRng.setEnd(endContainer, endOffset);
        }
        return newRng;
      };
      const setupOffscreenSelection = (node, targetClone) => {
        const body = SugarElement.fromDom(editor.getBody());
        const doc = editor.getDoc();
        const realSelectionContainer = descendant(body, '#' + realSelectionId).getOrThunk(() => {
          const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
          set$3(newContainer, 'id', realSelectionId);
          append$1(body, newContainer);
          return newContainer;
        });
        const newRange = dom.createRng();
        empty(realSelectionContainer);
        append(realSelectionContainer, [
          SugarElement.fromText(nbsp, doc),
          SugarElement.fromDom(targetClone),
          SugarElement.fromText(nbsp, doc)
        ]);
        newRange.setStart(realSelectionContainer.dom.firstChild, 1);
        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });
        focus$1(realSelectionContainer);
        const sel = selection.getSel();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(newRange);
        }
        return newRange;
      };
      const selectElement = elm => {
        const targetClone = elm.cloneNode(true);
        const e = editor.dispatch('ObjectSelected', {
          target: elm,
          targetClone
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        const range = setupOffscreenSelection(elm, e.targetClone);
        const nodeElm = SugarElement.fromDom(elm);
        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {
          if (!eq(nodeElm, elm)) {
            remove$a(elm, elementSelectionAttr);
          }
        });
        if (!dom.getAttrib(elm, elementSelectionAttr)) {
          elm.setAttribute(elementSelectionAttr, '1');
        }
        selectedElement = elm;
        hideFakeCaret();
        return range;
      };
      const setElementSelection = (range, forward) => {
        if (!range) {
          return null;
        }
        if (range.collapsed) {
          if (!isRangeInCaretContainer(range)) {
            const dir = forward ? 1 : -1;
            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);
            const beforeNode = caretPosition.getNode(!forward);
            if (isNonNullable(beforeNode)) {
              if (isFakeCaretTarget(beforeNode)) {
                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
              }
              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {
                const rng = dom.createRng();
                rng.setStart(beforeNode, 0);
                rng.setEnd(beforeNode, 0);
                return rng;
              }
            }
            const afterNode = caretPosition.getNode(forward);
            if (isNonNullable(afterNode)) {
              if (isFakeCaretTarget(afterNode)) {
                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
              }
              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {
                const rng = dom.createRng();
                rng.setStart(afterNode, 1);
                rng.setEnd(afterNode, 1);
                return rng;
              }
            }
          }
          return null;
        }
        let startContainer = range.startContainer;
        let startOffset = range.startOffset;
        const endOffset = range.endOffset;
        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }
        if (!isElement$6(startContainer)) {
          return null;
        }
        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
          const node = startContainer.childNodes[startOffset];
          if (isFakeSelectionTargetElement(node)) {
            return selectElement(node);
          }
        }
        return null;
      };
      const removeElementSelection = () => {
        if (selectedElement) {
          selectedElement.removeAttribute(elementSelectionAttr);
        }
        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);
        selectedElement = null;
      };
      const destroy = () => {
        fakeCaret.destroy();
        selectedElement = null;
      };
      const hideFakeCaret = () => {
        fakeCaret.hide();
      };
      if (!isRtc(editor)) {
        registerEvents();
      }
      return {
        showCaret,
        showBlockCaretContainer,
        hideFakeCaret,
        destroy
      };
    };

    const getNormalizedTextOffset = (container, offset) => {
      let normalizedOffset = offset;
      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {
        normalizedOffset += node.data.length;
      }
      return normalizedOffset;
    };
    const generatePath = (dom, root, node, offset, normalized) => {
      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {
        return [];
      }
      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];
      let current = node;
      while (current !== root && current.parentNode) {
        p.push(dom.nodeIndex(current, normalized));
        current = current.parentNode;
      }
      return current === root ? p.reverse() : [];
    };
    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
      const start = generatePath(dom, root, startNode, startOffset, normalized);
      const end = generatePath(dom, root, endNode, endOffset, normalized);
      return {
        start,
        end
      };
    };
    const resolvePath = (root, path) => {
      const nodePath = path.slice();
      const offset = nodePath.pop();
      if (!isNumber(offset)) {
        return Optional.none();
      } else {
        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));
        return resolvedNode.bind(node => {
          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {
            return Optional.none();
          } else {
            return Optional.some({
              node,
              offset
            });
          }
        });
      }
    };
    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({
      node: startNode,
      offset: startOffset
    }) => resolvePath(root, range.end).map(({
      node: endNode,
      offset: endOffset
    }) => {
      const rng = document.createRange();
      rng.setStart(startNode, startOffset);
      rng.setEnd(endNode, endOffset);
      return rng;
    }));
    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);

    const cleanEmptyNodes = (dom, node, isRoot) => {
      if (node && dom.isEmpty(node) && !isRoot(node)) {
        const parent = node.parentNode;
        dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));
        cleanEmptyNodes(dom, parent, isRoot);
      }
    };
    const deleteRng = (dom, rng, isRoot, clean = true) => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      rng.deleteContents();
      if (clean && !isRoot(rng.startContainer)) {
        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {
          dom.remove(rng.startContainer);
        }
        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {
          dom.remove(rng.endContainer);
        }
        cleanEmptyNodes(dom, startParent, isRoot);
        if (startParent !== endParent) {
          cleanEmptyNodes(dom, endParent, isRoot);
        }
      }
    };
    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
      const dynamicPatterns = patternSet.dynamicPatternsLookup({
        text: beforeText,
        block
      });
      return {
        ...patternSet,
        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
      };
    };
    const getBeforeText = (dom, block, node, offset) => {
      const rng = dom.createRng();
      rng.setStart(block, 0);
      rng.setEnd(node, offset);
      return rng.toString();
    };

    const startsWithSingleSpace = s => /^\s[^\s]/.test(s);
    const stripPattern = (dom, block, pattern) => {
      const firstTextNode = textAfter(block, 0, block);
      firstTextNode.each(spot => {
        const node = spot.container;
        scanRight(node, pattern.start.length, block).each(end => {
          const rng = dom.createRng();
          rng.setStart(node, 0);
          rng.setEnd(end.container, end.offset);
          deleteRng(dom, rng, e => e === block);
        });
        const text = SugarElement.fromDom(node);
        const textContent = get$3(text);
        if (startsWithSingleSpace(textContent)) {
          set(text, textContent.slice(1));
        }
      });
    };
    const applyPattern$1 = (editor, match) => {
      const dom = editor.dom;
      const pattern = match.pattern;
      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');
      const isBlockFormatName = (name, formatter) => {
        const formatSet = formatter.get(name);
        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));
      };
      getParentBlock(editor, rng).each(block => {
        if (pattern.type === 'block-format') {
          if (isBlockFormatName(pattern.format, editor.formatter)) {
            editor.undoManager.transact(() => {
              stripPattern(editor.dom, block, pattern);
              editor.formatter.apply(pattern.format);
            });
          }
        } else if (pattern.type === 'block-command') {
          editor.undoManager.transact(() => {
            stripPattern(editor.dom, block, pattern);
            editor.execCommand(pattern.cmd, false, pattern.value);
          });
        }
      });
      return true;
    };
    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);
    const findPattern$1 = (patterns, text) => {
      const sortedPatterns = sortPatterns$1(patterns);
      const nuText = text.replace(nbsp, ' ');
      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
    };
    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {
      var _a;
      const dom = editor.dom;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!dom.is(block, forcedRootBlock)) {
        return [];
      }
      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';
      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {
        if (Tools.trim(blockText).length === pattern.start.length) {
          return [];
        }
        return [{
            pattern,
            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)
          }];
      }).getOr([]);
    };
    const applyMatches$1 = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const bookmark = editor.selection.getBookmark();
      each$e(matches, match => applyPattern$1(editor, match));
      editor.selection.moveToBookmark(bookmark);
    };

    const newMarker = (dom, id) => dom.create('span', {
      'data-mce-type': 'bookmark',
      id
    });
    const rangeFromMarker = (dom, marker) => {
      const rng = dom.createRng();
      rng.setStartAfter(marker.start);
      rng.setEndBefore(marker.end);
      return rng;
    };
    const createMarker = (dom, markerPrefix, pathRange) => {
      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');
      const startNode = rng.startContainer;
      const endNode = rng.endContainer;
      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
      const startParentNode = textStart.parentNode;
      const endParentNode = textEnd.parentNode;
      return {
        prefix: markerPrefix,
        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),
        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)
      };
    };
    const removeMarker = (dom, marker, isRoot) => {
      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);
      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);
    };

    const isReplacementPattern = pattern => pattern.start.length === 0;
    const matchesPattern = patternContent => (element, offset) => {
      const text = element.data;
      const searchText = text.substring(0, offset);
      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
      const startIndex = searchText.lastIndexOf(patternContent);
      if (startIndex !== -1) {
        return startIndex + patternContent.length;
      } else if (startEndIndex !== -1) {
        return startEndIndex + 1;
      } else {
        return -1;
      }
    };
    const findPatternStartFromSpot = (dom, pattern, block, spot) => {
      const startPattern = pattern.start;
      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);
      return startSpot.bind(spot => {
        var _a, _b;
        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;
        if (isCompleteMatch) {
          const rng = dom.createRng();
          rng.setStart(spot.container, spot.offset - startPattern.length);
          rng.setEnd(spot.container, spot.offset);
          return Optional.some(rng);
        } else {
          const offset = spot.offset - startPattern.length;
          return scanLeft(spot.container, offset, block).map(nextSpot => {
            const rng = dom.createRng();
            rng.setStart(nextSpot.container, nextSpot.offset);
            rng.setEnd(spot.container, spot.offset);
            return rng;
          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));
        }
      });
    };
    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {
      if (pattern.start.length === 0 && !requireGap) {
        const rng = dom.createRng();
        rng.setStart(node, offset);
        rng.setEnd(node, offset);
        return Optional.some(rng);
      }
      return textBefore(node, offset, block).bind(spot => {
        const start = findPatternStartFromSpot(dom, pattern, block, spot);
        return start.bind(startRange => {
          var _a;
          if (requireGap) {
            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
              return Optional.none();
            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
              return Optional.none();
            }
          }
          return Optional.some(startRange);
        });
      });
    };
    const findPattern = (editor, block, details, normalizedMatches) => {
      const dom = editor.dom;
      const root = dom.getRoot();
      const pattern = details.pattern;
      const endNode = details.position.container;
      const endOffset = details.position.offset;
      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {
        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
        if (isReplacementPattern(pattern)) {
          return Optional.some({
            matches: [{
                pattern,
                startRng: endPathRng,
                endRng: endPathRng
              }],
            position: spot
          });
        } else {
          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
          const results = resultsOpt.getOr({
            matches: [],
            position: spot
          });
          const pos = results.position;
          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
          return start.map(startRng => {
            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);
            return {
              matches: results.matches.concat([{
                  pattern,
                  startRng: startPathRng,
                  endRng: endPathRng
                }]),
              position: point(startRng.startContainer, startRng.startOffset)
            };
          });
        }
      });
    };
    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {
      const dom = editor.dom;
      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {
        const text = getBeforeText(dom, block, node, offset);
        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          if (!endsWith(text, pattern.end)) {
            continue;
          }
          const patternsWithoutCurrent = patterns.slice();
          patternsWithoutCurrent.splice(i, 1);
          const result = findPattern(editor, block, {
            pattern,
            remainingPatterns: patternsWithoutCurrent,
            position: endSpot
          }, normalizedMatches);
          if (result.isNone() && offset > 0) {
            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);
          }
          if (result.isSome()) {
            return result;
          }
        }
        return Optional.none();
      });
    };
    const applyPattern = (editor, pattern, patternRange) => {
      editor.selection.setRng(patternRange);
      if (pattern.type === 'inline-format') {
        each$e(pattern.format, format => {
          editor.formatter.apply(format);
        });
      } else {
        editor.execCommand(pattern.cmd, false, pattern.value);
      }
    };
    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {
      const markerRange = rangeFromMarker(editor.dom, marker);
      deleteRng(editor.dom, markerRange, isRoot);
      applyPattern(editor, pattern, markerRange);
    };
    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {
      const dom = editor.dom;
      const markerEndRange = rangeFromMarker(dom, endMarker);
      const markerStartRange = rangeFromMarker(dom, startMarker);
      deleteRng(dom, markerStartRange, isRoot);
      deleteRng(dom, markerEndRange, isRoot);
      const patternMarker = {
        prefix: startMarker.prefix,
        start: startMarker.end,
        end: endMarker.start
      };
      const patternRange = rangeFromMarker(dom, patternMarker);
      applyPattern(editor, pattern, patternRange);
    };
    const addMarkers = (dom, matches) => {
      const markerPrefix = generate$1('mce_textpattern');
      const matchesWithEnds = foldr(matches, (acc, match) => {
        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);
        return acc.concat([{
            ...match,
            endMarker
          }]);
      }, []);
      return foldr(matchesWithEnds, (acc, match) => {
        const idx = matchesWithEnds.length - acc.length - 1;
        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);
        return acc.concat([{
            ...match,
            startMarker
          }]);
      }, []);
    };
    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);
    const getBestMatches = (matches, matchesWithSortedPatterns) => {
      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));
      if (matches.length === matchesWithSortedPatterns.length) {
        if (hasSameMatches) {
          return matches;
        } else {
          return matchesWithSortedPatterns;
        }
      }
      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
    };
    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {
      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);
      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);
      return getBestMatches(matches, matchesWithSortedPatterns);
    };
    const applyMatches = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const dom = editor.dom;
      const bookmark = editor.selection.getBookmark();
      const matchesWithMarkers = addMarkers(dom, matches);
      each$e(matchesWithMarkers, match => {
        const block = dom.getParent(match.startMarker.start, dom.isBlock);
        const isRoot = node => node === block;
        if (isReplacementPattern(match.pattern)) {
          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);
        } else {
          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);
        }
        removeMarker(dom, match.endMarker, isRoot);
        removeMarker(dom, match.startMarker, isRoot);
      });
      editor.selection.moveToBookmark(bookmark);
    };

    const handleEnter = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      return getParentBlock(editor, rng).map(block => {
        var _a;
        const offset = Math.max(0, rng.startOffset);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);
        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
        if (blockMatches.length > 0 || inlineMatches.length > 0) {
          editor.undoManager.add();
          editor.undoManager.extra(() => {
            editor.execCommand('mceInsertNewLine');
          }, () => {
            editor.insertContent(zeroWidth);
            applyMatches(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            const range = editor.selection.getRng();
            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());
            editor.execCommand('mceInsertNewLine');
            spot.each(s => {
              const node = s.container;
              if (node.data.charAt(s.offset - 1) === zeroWidth) {
                node.deleteData(s.offset - 1, 1);
                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());
              }
            });
          });
          return true;
        }
        return false;
      }).getOr(false);
    };
    const handleInlineKey = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      getParentBlock(editor, rng).map(block => {
        const offset = Math.max(0, rng.startOffset - 1);
        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);
        if (inlineMatches.length > 0) {
          editor.undoManager.transact(() => {
            applyMatches(editor, inlineMatches);
          });
        }
      });
    };
    const checkKeyEvent = (codes, event, predicate) => {
      for (let i = 0; i < codes.length; i++) {
        if (predicate(codes[i], event)) {
          return true;
        }
      }
      return false;
    };
    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {
      return code === event.keyCode && !VK.modifierPressed(event);
    });
    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {
      return chr.charCodeAt(0) === event.charCode;
    });

    const setup$2 = editor => {
      const charCodes = [
        ',',
        '.',
        ';',
        ':',
        '!',
        '?'
      ];
      const keyCodes = [32];
      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));
      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
      editor.on('keydown', e => {
        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns && handleEnter(editor, patternSet)) {
            e.preventDefault();
          }
        }
      }, true);
      const handleInlineTrigger = () => {
        if (editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns) {
            handleInlineKey(editor, patternSet);
          }
        }
      };
      editor.on('keyup', e => {
        if (checkKeyCode(keyCodes, e)) {
          handleInlineTrigger();
        }
      });
      editor.on('keypress', e => {
        if (checkCharCode(charCodes, e)) {
          Delay.setEditorTimeout(editor, handleInlineTrigger);
        }
      });
    };

    const setup$1 = editor => {
      setup$2(editor);
    };

    const Quirks = editor => {
      const each = Tools.each;
      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;
      const browser = Env.browser;
      const isGecko = browser.isFirefox();
      const isWebKit = browser.isChromium() || browser.isSafari();
      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      const setEditorCommandState = (cmd, state) => {
        try {
          editor.getDoc().execCommand(cmd, false, String(state));
        } catch (ex) {
        }
      };
      const isDefaultPrevented = e => {
        return e.isDefaultPrevented();
      };
      const emptyEditorWhenDeleting = () => {
        const serializeRng = rng => {
          const body = dom.create('body');
          const contents = rng.cloneContents();
          body.appendChild(contents);
          return selection.serializer.serialize(body, { format: 'html' });
        };
        const allContentsSelected = rng => {
          const selection = serializeRng(rng);
          const allRng = dom.createRng();
          allRng.selectNode(editor.getBody());
          const allSelection = serializeRng(allRng);
          return selection === allSelection;
        };
        const hasPreservedEmptyElements = elm => {
          const scope = SugarElement.fromDom(elm);
          const isEditableHost = elm => parentElement(elm).exists(elm => !isEditable$3(elm));
          return exists(descendants(scope, '[contenteditable="true"]'), isEditableHost);
        };
        editor.on('keydown', e => {
          const keyCode = e.keyCode;
          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {
            const isCollapsed = editor.selection.isCollapsed();
            const body = editor.getBody();
            if (isCollapsed && (!dom.isEmpty(body) || hasPreservedEmptyElements(body))) {
              return;
            }
            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
              return;
            }
            e.preventDefault();
            editor.setContent('');
            if (body.firstChild && dom.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
            editor.nodeChanged();
          }
        });
      };
      const selectAll = () => {
        editor.shortcuts.add('meta+a', null, 'SelectAll');
      };
      const documentElementEditingFocus = () => {
        if (!editor.inline) {
          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {
            let rng;
            if (e.target === editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();
              if (e.type === 'mousedown') {
                if (isCaretContainer$2(rng.startContainer)) {
                  return;
                }
                selection.placeCaretAt(e.clientX, e.clientY);
              } else {
                selection.setRng(rng);
              }
            }
          });
        }
      };
      const removeHrOnBackspace = () => {
        editor.on('keydown', e => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (!editor.getBody().getElementsByTagName('hr').length) {
              return;
            }
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const node = selection.getNode();
              const previousSibling = node.previousSibling;
              if (node.nodeName === 'HR') {
                dom.remove(node);
                e.preventDefault();
                return;
              }
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
                dom.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      };
      const focusBody = () => {
        if (!Range.prototype.getClientRects) {
          editor.on('mousedown', e => {
            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
              const body = editor.getBody();
              body.blur();
              Delay.setEditorTimeout(editor, () => {
                body.focus();
              });
            }
          });
        }
      };
      const selectControlElements = () => {
        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
        editor.on('click', e => {
          const target = e.target;
          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target.parentNode)) {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }
          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {
            e.preventDefault();
            selection.select(target);
          }
        });
      };
      const removeStylesWhenDeletingAcrossBlockElements = () => {
        const getAttributeApplyFunction = () => {
          const template = dom.getAttribs(selection.getStart().cloneNode(false));
          return () => {
            const target = selection.getStart();
            if (target !== editor.getBody()) {
              dom.setAttrib(target, 'style', null);
              each(template, attr => {
                target.setAttributeNode(attr.cloneNode(true));
              });
            }
          };
        };
        const isSelectionAcrossElements = () => {
          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
        };
        editor.on('keypress', e => {
          let applyAttributes;
          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
            applyAttributes = getAttributeApplyFunction();
            editor.getDoc().execCommand('delete', false);
            applyAttributes();
            e.preventDefault();
            return false;
          } else {
            return true;
          }
        });
        dom.bind(editor.getDoc(), 'cut', e => {
          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
            const applyAttributes = getAttributeApplyFunction();
            Delay.setEditorTimeout(editor, () => {
              applyAttributes();
            });
          }
        });
      };
      const disableBackspaceIntoATable = () => {
        editor.on('keydown', e => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const previousSibling = selection.getNode().previousSibling;
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
                e.preventDefault();
                return false;
              }
            }
          }
          return true;
        });
      };
      const removeBlockQuoteOnBackSpace = () => {
        editor.on('keydown', e => {
          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
            return;
          }
          let rng = selection.getRng();
          const container = rng.startContainer;
          const offset = rng.startOffset;
          const root = dom.getRoot();
          let parent = container;
          if (!rng.collapsed || offset !== 0) {
            return;
          }
          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
            parent = parent.parentNode;
          }
          if (parent.nodeName === 'BLOCKQUOTE') {
            editor.formatter.toggle('blockquote', undefined, parent);
            rng = dom.createRng();
            rng.setStart(container, 0);
            rng.setEnd(container, 0);
            selection.setRng(rng);
          }
        });
      };
      const setGeckoEditingOptions = () => {
        const setOpts = () => {
          setEditorCommandState('StyleWithCSS', false);
          setEditorCommandState('enableInlineTableEditing', false);
          if (!getObjectResizing(editor)) {
            setEditorCommandState('enableObjectResizing', false);
          }
        };
        if (!isReadOnly$1(editor)) {
          editor.on('BeforeExecCommand mousedown', setOpts);
        }
      };
      const addBrAfterLastLinks = () => {
        const fixLinks = () => {
          each(dom.select('a:not([data-mce-block])'), node => {
            var _a;
            let parentNode = node.parentNode;
            const root = dom.getRoot();
            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
              while (parentNode && !dom.isBlock(parentNode)) {
                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {
                  return;
                }
                parentNode = parentNode.parentNode;
              }
              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
            }
          });
        };
        editor.on('SetContent ExecCommand', e => {
          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
            fixLinks();
          }
        });
      };
      const setDefaultBlockType = () => {
        editor.on('init', () => {
          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));
        });
      };
      const isAllContentSelected = editor => {
        const body = editor.getBody();
        const rng = editor.selection.getRng();
        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
      };
      const normalizeSelection = () => {
        editor.on('keyup focusin mouseup', e => {
          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
            selection.normalize();
          }
        }, true);
      };
      const showBrokenImageIcon = () => {
        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');
      };
      const restoreFocusOnKeyDown = () => {
        if (!editor.inline) {
          editor.on('keydown', () => {
            if (document.activeElement === document.body) {
              editor.getWin().focus();
            }
          });
        }
      };
      const bodyHeight = () => {
        if (!editor.inline) {
          editor.contentStyles.push('body {min-height: 150px}');
          editor.on('click', e => {
            let rng;
            if (e.target.nodeName === 'HTML') {
              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      };
      const blockCmdArrowNavigation = () => {
        if (isMac) {
          editor.on('keydown', e => {
            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
              e.preventDefault();
              const selection = editor.selection.getSel();
              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
            }
          });
        }
      };
      const tapLinksAndImages = () => {
        editor.on('click', e => {
          let elm = e.target;
          do {
            if (elm.tagName === 'A') {
              e.preventDefault();
              return;
            }
          } while (elm = elm.parentNode);
        });
        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
      };
      const blockFormSubmitInsideEditor = () => {
        editor.on('init', () => {
          editor.dom.bind(editor.getBody(), 'submit', e => {
            e.preventDefault();
          });
        });
      };
      const removeAppleInterchangeBrs = () => {
        parser.addNodeFilter('br', nodes => {
          let i = nodes.length;
          while (i--) {
            if (nodes[i].attr('class') === 'Apple-interchange-newline') {
              nodes[i].remove();
            }
          }
        });
      };
      const refreshContentEditable = noop;
      const isHidden = () => {
        if (!isGecko || editor.removed) {
          return false;
        }
        const sel = editor.selection.getSel();
        return !sel || !sel.rangeCount || sel.rangeCount === 0;
      };
      const setupRtc = () => {
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          blockFormSubmitInsideEditor();
          selectAll();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          }
        }
        if (isGecko) {
          focusBody();
          setGeckoEditingOptions();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
        }
      };
      const dropDragEndEvent = () => {
        editor.on('drop', event => {
          var _a;
          const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');
          if (isString(data) && /^<img[^>]*>$/.test(data)) {
            editor.dispatch('dragend', new window.DragEvent('dragend', event));
          }
        });
      };
      const setup = () => {
        removeBlockQuoteOnBackSpace();
        emptyEditorWhenDeleting();
        if (!Env.windowsPhone) {
          normalizeSelection();
        }
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          setDefaultBlockType();
          blockFormSubmitInsideEditor();
          disableBackspaceIntoATable();
          removeAppleInterchangeBrs();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          } else {
            selectAll();
          }
        }
        if (isGecko) {
          removeHrOnBackspace();
          focusBody();
          removeStylesWhenDeletingAcrossBlockElements();
          setGeckoEditingOptions();
          addBrAfterLastLinks();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
          disableBackspaceIntoATable();
          dropDragEndEvent();
        }
      };
      if (isRtc(editor)) {
        setupRtc();
      } else {
        setup();
      }
      return {
        refreshContentEditable,
        isHidden
      };
    };

    const DOM$6 = DOMUtils.DOM;
    const appendStyle = (editor, text) => {
      const body = SugarElement.fromDom(editor.getBody());
      const container = getStyleContainer(getRootNode(body));
      const style = SugarElement.fromTag('style');
      set$3(style, 'type', 'text/css');
      append$1(style, SugarElement.fromText(text));
      append$1(container, style);
      editor.on('remove', () => {
        remove$5(style);
      });
    };
    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;
    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);
    const mkParserSettings = editor => {
      const getOption = editor.options.get;
      const blobCache = editor.editorUpload.blobCache;
      return removeUndefined({
        allow_conditional_comments: getOption('allow_conditional_comments'),
        allow_html_data_urls: getOption('allow_html_data_urls'),
        allow_svg_data_urls: getOption('allow_svg_data_urls'),
        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),
        allow_script_urls: getOption('allow_script_urls'),
        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),
        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),
        fix_list_elements: getOption('fix_list_elements'),
        font_size_legacy_values: getOption('font_size_legacy_values'),
        forced_root_block: getOption('forced_root_block'),
        forced_root_block_attrs: getOption('forced_root_block_attrs'),
        preserve_cdata: getOption('preserve_cdata'),
        inline_styles: getOption('inline_styles'),
        root_name: getRootName(editor),
        sanitize: getOption('xss_sanitization'),
        validate: true,
        blob_cache: blobCache,
        document: editor.getDoc()
      });
    };
    const mkSchemaSettings = editor => {
      const getOption = editor.options.get;
      return removeUndefined({
        custom_elements: getOption('custom_elements'),
        extended_valid_elements: getOption('extended_valid_elements'),
        invalid_elements: getOption('invalid_elements'),
        invalid_styles: getOption('invalid_styles'),
        schema: getOption('schema'),
        valid_children: getOption('valid_children'),
        valid_classes: getOption('valid_classes'),
        valid_elements: getOption('valid_elements'),
        valid_styles: getOption('valid_styles'),
        verify_html: getOption('verify_html'),
        padd_empty_block_inline_children: getOption('format_empty_lines')
      });
    };
    const mkSerializerSettings = editor => {
      const getOption = editor.options.get;
      return {
        ...mkParserSettings(editor),
        ...mkSchemaSettings(editor),
        ...removeUndefined({
          remove_trailing_brs: getOption('remove_trailing_brs'),
          pad_empty_with_br: getOption('pad_empty_with_br'),
          url_converter: getOption('url_converter'),
          url_converter_scope: getOption('url_converter_scope'),
          element_format: getOption('element_format'),
          entities: getOption('entities'),
          entity_encoding: getOption('entity_encoding'),
          indent: getOption('indent'),
          indent_after: getOption('indent_after'),
          indent_before: getOption('indent_before')
        })
      };
    };
    const createParser = editor => {
      const parser = DomParser(mkParserSettings(editor), editor.schema);
      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {
        const dom = editor.dom;
        const internalName = 'data-mce-' + name;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value = node.attr(name);
          if (value && !node.attr(internalName)) {
            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
              continue;
            }
            if (name === 'style') {
              value = dom.serializeStyle(dom.parseStyle(value), node.name);
              if (!value.length) {
                value = null;
              }
              node.attr(internalName, value);
              node.attr(name, value);
            } else if (name === 'tabindex') {
              node.attr(internalName, value);
              node.attr(name, null);
            } else {
              node.attr(internalName, editor.convertURL(value, name, node.name));
            }
          }
        }
      });
      parser.addNodeFilter('script', nodes => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const type = node.attr('type') || 'no/type';
          if (type.indexOf('mce-') !== 0) {
            node.attr('type', 'mce-' + type);
          }
        }
      });
      if (shouldPreserveCData(editor)) {
        parser.addNodeFilter('#cdata', nodes => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.type = 8;
            node.name = '#comment';
            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';
          }
        });
      }
      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {
        let i = nodes.length;
        const nonEmptyElements = editor.schema.getNonEmptyElements();
        while (i--) {
          const node = nodes[i];
          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
            node.append(new AstNode('br', 1));
          }
        }
      });
      return parser;
    };
    const autoFocus = editor => {
      const autoFocus = getAutoFocus(editor);
      if (autoFocus) {
        Delay.setEditorTimeout(editor, () => {
          let focusEditor;
          if (autoFocus === true) {
            focusEditor = editor;
          } else {
            focusEditor = editor.editorManager.get(autoFocus);
          }
          if (focusEditor && !focusEditor.destroyed) {
            focusEditor.focus();
            focusEditor.selection.scrollIntoView();
          }
        }, 100);
      }
    };
    const moveSelectionToFirstCaretPosition = editor => {
      const root = editor.dom.getRoot();
      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
        firstPositionIn(root).each(pos => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const initEditor = editor => {
      editor.bindPendingEventDelegates();
      editor.initialized = true;
      fireInit(editor);
      editor.focus(true);
      moveSelectionToFirstCaretPosition(editor);
      editor.nodeChanged({ initial: true });
      const initInstanceCallback = getInitInstanceCallback(editor);
      if (isFunction(initInstanceCallback)) {
        initInstanceCallback.call(editor, editor);
      }
      autoFocus(editor);
    };
    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
      const promises = [getStyleSheetLoader$1(editor).loadAll(css)];
      if (editor.inline) {
        return promises;
      } else {
        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
      }
    };
    const loadContentCss = editor => {
      const styleSheetLoader = getStyleSheetLoader$1(editor);
      const fontCss = getFontCss(editor);
      const css = editor.contentCSS;
      const removeCss = () => {
        styleSheetLoader.unloadAll(css);
        if (!editor.inline) {
          editor.ui.styleSheetLoader.unloadAll(fontCss);
        }
      };
      const loaded = () => {
        if (editor.removed) {
          removeCss();
        } else {
          editor.on('remove', removeCss);
        }
      };
      if (editor.contentStyles.length > 0) {
        let contentCssText = '';
        Tools.each(editor.contentStyles, style => {
          contentCssText += style + '\r\n';
        });
        editor.dom.addStyle(contentCssText);
      }
      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
      const contentStyle = getContentStyle(editor);
      if (contentStyle) {
        appendStyle(editor, contentStyle);
      }
      return allStylesheets;
    };
    const preInit = editor => {
      const doc = editor.getDoc(), body = editor.getBody();
      firePreInit(editor);
      if (!shouldBrowserSpellcheck(editor)) {
        doc.body.spellcheck = false;
        DOM$6.setAttrib(body, 'spellcheck', 'false');
      }
      editor.quirks = Quirks(editor);
      firePostRender(editor);
      const directionality = getDirectionality(editor);
      if (directionality !== undefined) {
        body.dir = directionality;
      }
      const protect = getProtect(editor);
      if (protect) {
        editor.on('BeforeSetContent', e => {
          Tools.each(protect, pattern => {
            e.content = e.content.replace(pattern, str => {
              return '<!--mce:protected ' + escape(str) + '-->';
            });
          });
        });
      }
      editor.on('SetContent', () => {
        editor.addVisual(editor.getBody());
      });
      editor.on('compositionstart compositionend', e => {
        editor.composing = e.type === 'compositionstart';
      });
    };
    const loadInitialContent = editor => {
      if (!isRtc(editor)) {
        editor.load({
          initial: true,
          format: 'html'
        });
      }
      editor.startContent = editor.getContent({ format: 'raw' });
    };
    const initEditorWithInitialContent = editor => {
      if (editor.removed !== true) {
        loadInitialContent(editor);
        initEditor(editor);
      }
    };
    const startProgress = editor => {
      let canceled = false;
      const progressTimeout = setTimeout(() => {
        if (!canceled) {
          editor.setProgressState(true);
        }
      }, 500);
      return () => {
        clearTimeout(progressTimeout);
        canceled = true;
        editor.setProgressState(false);
      };
    };
    const contentBodyLoaded = editor => {
      const targetElm = editor.getElement();
      let doc = editor.getDoc();
      if (editor.inline) {
        DOM$6.addClass(targetElm, 'mce-content-body');
        editor.contentDocument = doc = document;
        editor.contentWindow = window;
        editor.bodyElement = targetElm;
        editor.contentAreaContainer = targetElm;
      }
      const body = editor.getBody();
      body.disabled = true;
      editor.readonly = isReadOnly$1(editor);
      editor._editableRoot = hasEditableRoot$1(editor);
      if (!editor.readonly && editor.hasEditableRoot()) {
        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {
          body.style.position = 'relative';
        }
        body.contentEditable = 'true';
      }
      body.disabled = false;
      editor.editorUpload = EditorUpload(editor);
      editor.schema = Schema(mkSchemaSettings(editor));
      editor.dom = DOMUtils(doc, {
        keep_values: true,
        url_converter: editor.convertURL,
        url_converter_scope: editor,
        update_styles: true,
        root_element: editor.inline ? editor.getBody() : null,
        collect: editor.inline,
        schema: editor.schema,
        contentCssCors: shouldUseContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor),
        onSetAttrib: e => {
          editor.dispatch('SetAttrib', e);
        }
      });
      editor.parser = createParser(editor);
      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.annotator = Annotator(editor);
      editor.formatter = Formatter(editor);
      editor.undoManager = UndoManager(editor);
      editor._nodeChangeDispatcher = new NodeChange(editor);
      editor._selectionOverrides = SelectionOverrides(editor);
      setup$o(editor);
      setup$6(editor);
      setup$m(editor);
      if (!isRtc(editor)) {
        setup$5(editor);
        setup$1(editor);
      }
      const caret = setup$b(editor);
      setup$p(editor, caret);
      setup$n(editor);
      setup$q(editor);
      setup$7(editor);
      const setupRtcThunk = setup$s(editor);
      preInit(editor);
      setupRtcThunk.fold(() => {
        const cancelProgress = startProgress(editor);
        loadContentCss(editor).then(() => {
          initEditorWithInitialContent(editor);
          cancelProgress();
        });
      }, setupRtc => {
        editor.setProgressState(true);
        loadContentCss(editor).then(() => {
          setupRtc().then(_rtcMode => {
            editor.setProgressState(false);
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          }, err => {
            editor.notificationManager.open({
              type: 'error',
              text: String(err)
            });
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          });
        });
      });
    };

    const filter = always;
    const bind = (element, event, handler) => bind$2(element, event, filter, handler);

    const DOM$5 = DOMUtils.DOM;
    const createIframeElement = (id, title, customAttrs, tabindex) => {
      const iframe = SugarElement.fromTag('iframe');
      tabindex.each(t => set$3(iframe, 'tabindex', t));
      setAll$1(iframe, customAttrs);
      setAll$1(iframe, {
        id: id + '_ifr',
        frameBorder: '0',
        allowTransparency: 'true',
        title
      });
      add$2(iframe, 'tox-edit-area__iframe');
      return iframe;
    };
    const getIframeHtml = editor => {
      let iframeHTML = getDocType(editor) + '<html><head>';
      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
      }
      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const bodyId = getBodyId(editor);
      const bodyClass = getBodyClass(editor);
      const translatedAriaText = editor.translate(getIframeAriaText(editor));
      if (getContentSecurityPolicy(editor)) {
        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
      }
      iframeHTML += '</head>' + `<body id="${ bodyId }" class="mce-content-body ${ bodyClass }" data-id="${ editor.id }" aria-label="${ translatedAriaText }">` + '<br>' + '</body></html>';
      return iframeHTML;
    };
    const createIframe = (editor, boxInfo) => {
      const iframeTitle = editor.translate('Rich Text Area');
      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);
      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;
      ifr.onload = () => {
        ifr.onload = null;
        editor.dispatch('load');
      };
      editor.contentAreaContainer = boxInfo.iframeContainer;
      editor.iframeElement = ifr;
      editor.iframeHTML = getIframeHtml(editor);
      DOM$5.add(boxInfo.iframeContainer, ifr);
    };
    const setupIframeBody = editor => {
      const iframe = editor.iframeElement;
      const ready = () => {
        editor.contentDocument = iframe.contentDocument;
        contentBodyLoaded(editor);
      };
      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
        const doc = editor.getDoc();
        doc.open();
        doc.write(editor.iframeHTML);
        doc.close();
        ready();
      } else {
        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {
          binder.unbind();
          ready();
        });
        iframe.srcdoc = editor.iframeHTML;
      }
    };
    const init$1 = (editor, boxInfo) => {
      createIframe(editor, boxInfo);
      if (boxInfo.editorContainer) {
        boxInfo.editorContainer.style.display = editor.orgDisplay;
        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
      }
      editor.getElement().style.display = 'none';
      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
      editor.getElement().style.visibility = editor.orgVisibility;
      setupIframeBody(editor);
    };

    const DOM$4 = DOMUtils.DOM;
    const initPlugin = (editor, initializedPlugins, plugin) => {
      const Plugin = PluginManager.get(plugin);
      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, '');
      plugin = Tools.trim(plugin);
      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
        if (editor.plugins[plugin]) {
          return;
        }
        try {
          const pluginInstance = Plugin(editor, pluginUrl) || {};
          editor.plugins[plugin] = pluginInstance;
          if (isFunction(pluginInstance.init)) {
            pluginInstance.init(editor, pluginUrl);
            initializedPlugins.push(plugin);
          }
        } catch (e) {
          pluginInitError(editor, plugin, e);
        }
      }
    };
    const trimLegacyPrefix = name => {
      return name.replace(/^\-/, '');
    };
    const initPlugins = editor => {
      const initializedPlugins = [];
      each$e(getPlugins(editor), name => {
        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
      });
    };
    const initIcons = editor => {
      const iconPackName = Tools.trim(getIconPackName(editor));
      const currentIcons = editor.ui.registry.getAll().icons;
      const loadIcons = {
        ...IconManager.get('default').icons,
        ...IconManager.get(iconPackName).icons
      };
      each$d(loadIcons, (svgData, icon) => {
        if (!has$2(currentIcons, icon)) {
          editor.ui.registry.addIcon(icon, svgData);
        }
      });
    };
    const initTheme = editor => {
      const theme = getTheme(editor);
      if (isString(theme)) {
        const Theme = ThemeManager.get(theme);
        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
        if (isFunction(editor.theme.init)) {
          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ''));
        }
      } else {
        editor.theme = {};
      }
    };
    const initModel = editor => {
      const model = getModel(editor);
      const Model = ModelManager.get(model);
      editor.model = Model(editor, ModelManager.urls[model]);
    };
    const renderFromLoadedTheme = editor => {
      const render = editor.theme.renderUI;
      return render ? render() : renderThemeFalse(editor);
    };
    const renderFromThemeFunc = editor => {
      const elm = editor.getElement();
      const theme = getTheme(editor);
      const info = theme(editor, elm);
      if (info.editorContainer.nodeType) {
        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
      }
      if (info.iframeContainer && info.iframeContainer.nodeType) {
        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
      }
      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
      return info;
    };
    const createThemeFalseResult = (element, iframe) => {
      return {
        editorContainer: element,
        iframeContainer: iframe,
        api: {}
      };
    };
    const renderThemeFalseIframe = targetElement => {
      const iframeContainer = DOM$4.create('div');
      DOM$4.insertAfter(iframeContainer, targetElement);
      return createThemeFalseResult(iframeContainer, iframeContainer);
    };
    const renderThemeFalse = editor => {
      const targetElement = editor.getElement();
      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    const renderThemeUi = editor => {
      const elm = editor.getElement();
      editor.orgDisplay = elm.style.display;
      if (isString(getTheme(editor))) {
        return renderFromLoadedTheme(editor);
      } else if (isFunction(getTheme(editor))) {
        return renderFromThemeFunc(editor);
      } else {
        return renderThemeFalse(editor);
      }
    };
    const augmentEditorUiApi = (editor, api) => {
      const uiApiFacade = {
        show: Optional.from(api.show).getOr(noop),
        hide: Optional.from(api.hide).getOr(noop),
        isEnabled: Optional.from(api.isEnabled).getOr(always),
        setEnabled: state => {
          if (!editor.mode.isReadOnly()) {
            Optional.from(api.setEnabled).each(f => f(state));
          }
        }
      };
      editor.ui = {
        ...editor.ui,
        ...uiApiFacade
      };
    };
    const init = async editor => {
      editor.dispatch('ScriptsLoaded');
      initIcons(editor);
      initTheme(editor);
      initModel(editor);
      initPlugins(editor);
      const renderInfo = await renderThemeUi(editor);
      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
      editor.editorContainer = renderInfo.editorContainer;
      appendContentCssFromSettings(editor);
      if (editor.inline) {
        contentBodyLoaded(editor);
      } else {
        init$1(editor, {
          editorContainer: renderInfo.editorContainer,
          iframeContainer: renderInfo.iframeContainer
        });
      }
    };

    const DOM$3 = DOMUtils.DOM;
    const hasSkipLoadPrefix = name => name.charAt(0) === '-';
    const loadLanguage = (scriptLoader, editor) => {
      const languageCode = getLanguageCode(editor);
      const languageUrl = getLanguageUrl(editor);
      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {
        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;
        scriptLoader.add(url).catch(() => {
          languageLoadError(editor, url, languageCode);
        });
      }
    };
    const loadTheme = (editor, suffix) => {
      const theme = getTheme(editor);
      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
        const themeUrl = getThemeUrl(editor);
        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;
        ThemeManager.load(theme, url).catch(() => {
          themeLoadError(editor, url, theme);
        });
      }
    };
    const loadModel = (editor, suffix) => {
      const model = getModel(editor);
      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {
        const modelUrl = getModelUrl(editor);
        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;
        ModelManager.load(model, url).catch(() => {
          modelLoadError(editor, url, model);
        });
      }
    };
    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({
      url,
      name: Optional.none()
    }));
    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({
      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,
      name: Optional.some(name)
    }));
    const loadIcons = (scriptLoader, editor, suffix) => {
      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);
      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));
      each$e(cat([
        defaultIconsUrl,
        customIconsUrl
      ]), urlMeta => {
        scriptLoader.add(urlMeta.url).catch(() => {
          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
        });
      });
    };
    const loadPlugins = (editor, suffix) => {
      const loadPlugin = (name, url) => {
        PluginManager.load(name, url).catch(() => {
          pluginLoadError(editor, url, name);
        });
      };
      each$d(getExternalPlugins$1(editor), (url, name) => {
        loadPlugin(name, url);
        editor.options.set('plugins', getPlugins(editor).concat(name));
      });
      each$e(getPlugins(editor), plugin => {
        plugin = Tools.trim(plugin);
        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);
        }
      });
    };
    const isThemeLoaded = editor => {
      const theme = getTheme(editor);
      return !isString(theme) || isNonNullable(ThemeManager.get(theme));
    };
    const isModelLoaded = editor => {
      const model = getModel(editor);
      return isNonNullable(ModelManager.get(model));
    };
    const loadScripts = (editor, suffix) => {
      const scriptLoader = ScriptLoader.ScriptLoader;
      const initEditor = () => {
        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
          init(editor);
        }
      };
      loadTheme(editor, suffix);
      loadModel(editor, suffix);
      loadLanguage(scriptLoader, editor);
      loadIcons(scriptLoader, editor, suffix);
      loadPlugins(editor, suffix);
      scriptLoader.loadQueue().then(initEditor, initEditor);
    };
    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
      contentCssCors: hasContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor)
    });
    const render = editor => {
      const id = editor.id;
      I18n.setCode(getLanguageCode(editor));
      const readyHandler = () => {
        DOM$3.unbind(window, 'ready', readyHandler);
        editor.render();
      };
      if (!EventUtils.Event.domLoaded) {
        DOM$3.bind(window, 'ready', readyHandler);
        return;
      }
      if (!editor.getElement()) {
        return;
      }
      const element = SugarElement.fromDom(editor.getElement());
      const snapshot = clone$4(element);
      editor.on('remove', () => {
        eachr(element.dom.attributes, attr => remove$a(element, attr.name));
        setAll$1(element, snapshot);
      });
      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
      if (!isInline(editor)) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = 'hidden';
      } else {
        editor.inline = true;
      }
      const form = editor.getElement().form || DOM$3.getParent(id, 'form');
      if (form) {
        editor.formElement = form;
        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
          DOM$3.insertAfter(DOM$3.create('input', {
            type: 'hidden',
            name: id
          }), id);
          editor.hasHiddenInput = true;
        }
        editor.formEventDelegate = e => {
          editor.dispatch(e.type, e);
        };
        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);
        editor.on('reset', () => {
          editor.resetContent();
        });
        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = () => {
            editor.editorManager.triggerSave();
            editor.setDirty(false);
            return form._mceOldSubmit(form);
          };
        }
      }
      editor.windowManager = WindowManager(editor);
      editor.notificationManager = NotificationManager(editor);
      if (isEncodingXml(editor)) {
        editor.on('GetContent', e => {
          if (e.save) {
            e.content = DOM$3.encode(e.content);
          }
        });
      }
      if (shouldAddFormSubmitTrigger(editor)) {
        editor.on('submit', () => {
          if (editor.initialized) {
            editor.save();
          }
        });
      }
      if (shouldAddUnloadTrigger(editor)) {
        editor._beforeUnload = () => {
          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
            editor.save({
              format: 'raw',
              no_events: true,
              set_dirty: false
            });
          }
        };
        editor.editorManager.on('BeforeUnload', editor._beforeUnload);
      }
      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };

    const setEditableRoot = (editor, state) => {
      if (editor._editableRoot !== state) {
        editor._editableRoot = state;
        if (!editor.readonly) {
          editor.getBody().contentEditable = String(editor.hasEditableRoot());
          editor.nodeChanged();
        }
        fireEditableRootStateChange(editor, state);
      }
    };
    const hasEditableRoot = editor => editor._editableRoot;

    const sectionResult = (sections, settings) => ({
      sections: constant(sections),
      options: constant(settings)
    });
    const deviceDetection = detect$2().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const normalizePlugins = plugins => {
      if (isNullable(plugins)) {
        return [];
      } else {
        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
        const trimmedPlugins = map$3(pluginNames, trim$3);
        return filter$5(trimmedPlugins, isNotEmpty);
      }
    };
    const extractSections = (keys, options) => {
      const result = bifilter(options, (value, key) => {
        return contains$2(keys, key);
      });
      return sectionResult(result.t, result.f);
    };
    const getSection = (sectionResult, name, defaults = {}) => {
      const sections = sectionResult.sections();
      const sectionOptions = get$a(sections, name).getOr({});
      return Tools.extend({}, defaults, sectionOptions);
    };
    const hasSection = (sectionResult, name) => {
      return has$2(sectionResult.sections(), name);
    };
    const getSectionConfig = (sectionResult, name) => {
      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
    };
    const getMobileOverrideOptions = (mobileOptions, isPhone) => {
      const defaultMobileOptions = {
        table_grid: false,
        object_resizing: false,
        resize: false,
        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),
        toolbar_sticky: false
      };
      const defaultPhoneOptions = { menubar: false };
      return {
        ...defaultMobileOptions,
        ...isPhone ? defaultPhoneOptions : {}
      };
    };
    const getExternalPlugins = (overrideOptions, options) => {
      var _a;
      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
      if (overrideOptions && overrideOptions.external_plugins) {
        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
      } else {
        return userDefinedExternalPlugins;
      }
    };
    const combinePlugins = (forcedPlugins, plugins) => [
      ...normalizePlugins(forcedPlugins),
      ...normalizePlugins(plugins)
    ];
    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {
      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {
        return mobilePlugins;
      } else {
        return desktopPlugins;
      }
    };
    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {
      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
      const desktopPlugins = normalizePlugins(options.plugins);
      const mobileConfig = getSectionConfig(sectionResult, 'mobile');
      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);
      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
      return Tools.extend(options, {
        forced_plugins: forcedPlugins,
        plugins: combinedPlugins
      });
    };
    const isOnMobile = (isMobileDevice, sectionResult) => {
      return isMobileDevice && hasSection(sectionResult, 'mobile');
    };
    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {
      var _a;
      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};
      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));
      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });
      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);
    };
    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);

    const addVisual = (editor, elm) => addVisual$1(editor, elm);

    const registerExecCommands$3 = editor => {
      const toggleFormat = (name, value) => {
        editor.formatter.toggle(name, value);
        editor.nodeChanged();
      };
      const toggleAlign = align => () => {
        each$e('left,center,right,justify'.split(','), name => {
          if (align !== name) {
            editor.formatter.remove('align' + name);
          }
        });
        if (align !== 'none') {
          toggleFormat('align' + align);
        }
      };
      editor.editorCommands.addCommands({
        JustifyLeft: toggleAlign('left'),
        JustifyCenter: toggleAlign('center'),
        JustifyRight: toggleAlign('right'),
        JustifyFull: toggleAlign('justify'),
        JustifyNone: toggleAlign('none')
      });
    };
    const registerQueryStateCommands$1 = editor => {
      const alignStates = name => () => {
        const selection = editor.selection;
        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));
      };
      editor.editorCommands.addCommands({
        JustifyLeft: alignStates('alignleft'),
        JustifyCenter: alignStates('aligncenter'),
        JustifyRight: alignStates('alignright'),
        JustifyFull: alignStates('alignjustify')
      }, 'state');
    };
    const registerCommands$b = editor => {
      registerExecCommands$3(editor);
      registerQueryStateCommands$1(editor);
    };

    const registerCommands$a = editor => {
      editor.editorCommands.addCommands({
        'Cut,Copy,Paste': command => {
          const doc = editor.getDoc();
          let failed;
          try {
            doc.execCommand(command);
          } catch (ex) {
            failed = true;
          }
          if (command === 'paste' && !doc.queryCommandEnabled(command)) {
            failed = true;
          }
          if (failed || !doc.queryCommandSupported(command)) {
            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
            if (Env.os.isMacOS() || Env.os.isiOS()) {
              msg = msg.replace(/Ctrl\+/g, '\u2318+');
            }
            editor.notificationManager.open({
              text: msg,
              type: 'error'
            });
          }
        }
      });
    };

    const trimOrPadLeftRight = (dom, rng, html) => {
      const root = SugarElement.fromDom(dom.getRoot());
      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
        html = html.replace(/^ /, '&nbsp;');
      } else {
        html = html.replace(/^&nbsp;/, ' ');
      }
      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
        html = html.replace(/(&nbsp;| )(<br( \/)>)?$/, '&nbsp;');
      } else {
        html = html.replace(/&nbsp;(<br( \/)?>)?$/, ' ');
      }
      return html;
    };

    const processValue$1 = value => {
      if (typeof value !== 'string') {
        const details = Tools.extend({
          paste: value.paste,
          data: { paste: value.paste }
        }, value);
        return {
          content: value.content,
          details
        };
      }
      return {
        content: value,
        details: {}
      };
    };
    const trimOrPad = (editor, value) => {
      const selection = editor.selection;
      const dom = editor.dom;
      if (/^ | $/.test(value)) {
        return trimOrPadLeftRight(dom, selection.getRng(), value);
      } else {
        return value;
      }
    };
    const insertAtCaret = (editor, value) => {
      if (editor.selection.isEditable()) {
        const {content, details} = processValue$1(value);
        preProcessSetContent(editor, {
          ...details,
          content: trimOrPad(editor, content),
          format: 'html',
          set: false,
          selection: true
        }).each(args => {
          const insertedContent = insertContent$1(editor, args.content, details);
          postProcessSetContent(editor, insertedContent, args);
          editor.addVisual();
        });
      }
    };

    const registerCommands$9 = editor => {
      editor.editorCommands.addCommands({
        mceCleanup: () => {
          const bm = editor.selection.getBookmark();
          editor.setContent(editor.getContent());
          editor.selection.moveToBookmark(bm);
        },
        insertImage: (_command, _ui, value) => {
          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));
        },
        insertHorizontalRule: () => {
          editor.execCommand('mceInsertContent', false, '<hr>');
        },
        insertText: (_command, _ui, value) => {
          insertAtCaret(editor, editor.dom.encode(value));
        },
        insertHTML: (_command, _ui, value) => {
          insertAtCaret(editor, value);
        },
        mceInsertContent: (_command, _ui, value) => {
          insertAtCaret(editor, value);
        },
        mceSetContent: (_command, _ui, value) => {
          editor.setContent(value);
        },
        mceReplaceContent: (_command, _ui, value) => {
          editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
        },
        mceNewDocument: () => {
          editor.setContent(getNewDocumentContent(editor));
        }
      });
    };

    const legacyPropNames = {
      'font-size': 'size',
      'font-family': 'face'
    };
    const isFont = isTag('font');
    const getSpecifiedFontProp = (propName, rootElm, elm) => {
      const getProperty = elm => getRaw(elm, propName).orThunk(() => {
        if (isFont(elm)) {
          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));
        } else {
          return Optional.none();
        }
      });
      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);
      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);
    };
    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');
    const getFontSize = getFontProp('font-size');
    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));

    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {
      const container = caret.container();
      return Optional.from(isText$a(container) ? container.parentNode : container);
    });
    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {
      const root = editor.getBody();
      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);
    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));

    const fromFontSizeNumber = (editor, value) => {
      if (/^[0-9.]+$/.test(value)) {
        const fontSizeNumber = parseInt(value, 10);
        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
          const fontSizes = getFontStyleValues(editor);
          const fontClasses = getFontSizeClasses(editor);
          if (fontClasses.length > 0) {
            return fontClasses[fontSizeNumber - 1] || value;
          } else {
            return fontSizes[fontSizeNumber - 1] || value;
          }
        } else {
          return value;
        }
      } else {
        return value;
      }
    };
    const normalizeFontNames = font => {
      const fonts = font.split(/\s*,\s*/);
      return map$3(fonts, font => {
        if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, `'`))) {
          return `'${ font }'`;
        } else {
          return font;
        }
      }).join(',');
    };
    const fontNameAction = (editor, value) => {
      const font = fromFontSizeNumber(editor, value);
      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
      editor.nodeChanged();
    };
    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');
    const fontSizeAction = (editor, value) => {
      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
      editor.nodeChanged();
    };
    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');

    const lineHeightQuery = editor => mapRange(editor, elm => {
      const root = SugarElement.fromDom(editor.getBody());
      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));
      const computedStyle = () => {
        const lineHeight = parseFloat(get$7(elm, 'line-height'));
        const fontSize = parseFloat(get$7(elm, 'font-size'));
        return String(lineHeight / fontSize);
      };
      return specifiedStyle.getOrThunk(computedStyle);
    }).getOr('');
    const lineHeightAction = (editor, lineHeight) => {
      editor.formatter.toggle('lineheight', { value: String(lineHeight) });
      editor.nodeChanged();
    };

    const registerExecCommands$2 = editor => {
      const toggleFormat = (name, value) => {
        editor.formatter.toggle(name, value);
        editor.nodeChanged();
      };
      editor.editorCommands.addCommands({
        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {
          toggleFormat(command);
        },
        'ForeColor,HiliteColor': (command, _ui, value) => {
          toggleFormat(command, { value });
        },
        'BackColor': (_command, _ui, value) => {
          toggleFormat('hilitecolor', { value });
        },
        'FontName': (_command, _ui, value) => {
          fontNameAction(editor, value);
        },
        'FontSize': (_command, _ui, value) => {
          fontSizeAction(editor, value);
        },
        'LineHeight': (_command, _ui, value) => {
          lineHeightAction(editor, value);
        },
        'Lang': (command, _ui, lang) => {
          var _a;
          toggleFormat(command, {
            value: lang.code,
            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null
          });
        },
        'RemoveFormat': command => {
          editor.formatter.remove(command);
        },
        'mceBlockQuote': () => {
          toggleFormat('blockquote');
        },
        'FormatBlock': (_command, _ui, value) => {
          toggleFormat(isString(value) ? value : 'p');
        },
        'mceToggleFormat': (_command, _ui, value) => {
          toggleFormat(value);
        }
      });
    };
    const registerQueryValueCommands = editor => {
      const isFormatMatch = name => editor.formatter.match(name);
      editor.editorCommands.addCommands({
        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),
        'mceBlockQuote': () => isFormatMatch('blockquote')
      }, 'state');
      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));
      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));
      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));
    };
    const registerCommands$8 = editor => {
      registerExecCommands$2(editor);
      registerQueryValueCommands(editor);
    };

    const registerCommands$7 = editor => {
      editor.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          editor.undoManager.add();
        },
        mceEndUndoLevel: () => {
          editor.undoManager.add();
        },
        Undo: () => {
          editor.undoManager.undo();
        },
        Redo: () => {
          editor.undoManager.redo();
        }
      });
    };

    const registerCommands$6 = editor => {
      editor.editorCommands.addCommands({
        Indent: () => {
          indent(editor);
        },
        Outdent: () => {
          outdent(editor);
        }
      });
      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');
    };

    const registerCommands$5 = editor => {
      const applyLinkToSelection = (_command, _ui, value) => {
        const linkDetails = isString(value) ? { href: value } : value;
        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
        if (isObject(linkDetails) && isString(linkDetails.href)) {
          linkDetails.href = linkDetails.href.replace(/ /g, '%20');
          if (!anchor || !linkDetails.href) {
            editor.formatter.remove('link');
          }
          if (linkDetails.href) {
            editor.formatter.apply('link', linkDetails, anchor);
          }
        }
      };
      editor.editorCommands.addCommands({
        unlink: () => {
          if (editor.selection.isEditable()) {
            if (editor.selection.isCollapsed()) {
              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');
              if (elm) {
                editor.dom.remove(elm, true);
              }
              return;
            }
            editor.formatter.remove('link');
          }
        },
        mceInsertLink: applyLinkToSelection,
        createLink: applyLinkToSelection
      });
    };

    const registerExecCommands$1 = editor => {
      editor.editorCommands.addCommands({
        'InsertUnorderedList,InsertOrderedList': command => {
          editor.getDoc().execCommand(command);
          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');
          if (listElm) {
            const listParent = listElm.parentNode;
            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
              const bm = editor.selection.getBookmark();
              editor.dom.split(listParent, listElm);
              editor.selection.moveToBookmark(bm);
            }
          }
        }
      });
    };
    const registerQueryStateCommands = editor => {
      editor.editorCommands.addCommands({
        'InsertUnorderedList,InsertOrderedList': command => {
          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');
          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');
        }
      }, 'state');
    };
    const registerCommands$4 = editor => {
      registerExecCommands$1(editor);
      registerQueryStateCommands(editor);
    };

    const getTopParentBlock = (editor, node, root, container) => {
      const dom = editor.dom;
      const selector = node => dom.isBlock(node) && node.parentElement === root;
      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);
      return Optional.from(topParentBlock).map(SugarElement.fromDom);
    };
    const insert = (editor, before) => {
      const dom = editor.dom;
      const rng = editor.selection.getRng();
      const node = before ? editor.selection.getStart() : editor.selection.getEnd();
      const container = before ? rng.startContainer : rng.endContainer;
      const root = getEditableRoot(dom, container);
      if (!root || !root.isContentEditable) {
        return;
      }
      const insertFn = before ? before$3 : after$4;
      const newBlockName = getForcedRootBlock(editor);
      getTopParentBlock(editor, node, root, container).each(parentBlock => {
        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);
        insertFn(parentBlock, SugarElement.fromDom(newBlock));
        editor.selection.setCursorLocation(newBlock, 0);
        editor.dispatch('NewBlock', { newBlock });
        fireInputEvent(editor, 'insertParagraph');
      });
    };
    const insertBefore = editor => insert(editor, true);
    const insertAfter = editor => insert(editor, false);

    const registerCommands$3 = editor => {
      editor.editorCommands.addCommands({
        InsertNewBlockBefore: () => {
          insertBefore(editor);
        },
        InsertNewBlockAfter: () => {
          insertAfter(editor);
        }
      });
    };

    const registerCommands$2 = editor => {
      editor.editorCommands.addCommands({
        insertParagraph: () => {
          insertBreak(blockbreak, editor);
        },
        mceInsertNewLine: (_command, _ui, value) => {
          insert$1(editor, value);
        },
        InsertLineBreak: (_command, _ui, _value) => {
          insertBreak(linebreak, editor);
        }
      });
    };

    const registerCommands$1 = editor => {
      editor.editorCommands.addCommands({
        mceSelectNodeDepth: (_command, _ui, value) => {
          let counter = 0;
          editor.dom.getParent(editor.selection.getNode(), node => {
            if (isElement$6(node) && counter++ === value) {
              editor.selection.select(node);
              return false;
            } else {
              return true;
            }
          }, editor.getBody());
        },
        mceSelectNode: (_command, _ui, value) => {
          editor.selection.select(value);
        },
        selectAll: () => {
          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
          if (editingHost) {
            const rng = editor.dom.createRng();
            rng.selectNodeContents(editingHost);
            editor.selection.setRng(rng);
          }
        }
      });
    };

    const registerExecCommands = editor => {
      editor.editorCommands.addCommands({
        mceRemoveNode: (_command, _ui, value) => {
          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();
          if (node !== editor.getBody()) {
            const bm = editor.selection.getBookmark();
            editor.dom.remove(node, true);
            editor.selection.moveToBookmark(bm);
          }
        },
        mcePrint: () => {
          editor.getWin().print();
        },
        mceFocus: (_command, _ui, value) => {
          focus(editor, value === true);
        },
        mceToggleVisualAid: () => {
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        }
      });
    };
    const registerCommands = editor => {
      registerCommands$b(editor);
      registerCommands$a(editor);
      registerCommands$7(editor);
      registerCommands$1(editor);
      registerCommands$9(editor);
      registerCommands$5(editor);
      registerCommands$6(editor);
      registerCommands$3(editor);
      registerCommands$2(editor);
      registerCommands$4(editor);
      registerCommands$8(editor);
      registerExecCommands(editor);
    };

    const selectionSafeCommands = ['toggleview'];
    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());
    class EditorCommands {
      constructor(editor) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        };
        this.editor = editor;
      }
      execCommand(command, ui = false, value, args) {
        const editor = this.editor;
        const lowerCaseCommand = command.toLowerCase();
        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
        if (editor.removed) {
          return false;
        }
        if (lowerCaseCommand !== 'mcefocus') {
          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
            editor.focus();
          } else {
            restore(editor);
          }
        }
        const eventArgs = editor.dispatch('BeforeExecCommand', {
          command,
          ui,
          value
        });
        if (eventArgs.isDefaultPrevented()) {
          return false;
        }
        const func = this.commands.exec[lowerCaseCommand];
        if (isFunction(func)) {
          func(lowerCaseCommand, ui, value);
          editor.dispatch('ExecCommand', {
            command,
            ui,
            value
          });
          return true;
        }
        return false;
      }
      queryCommandState(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return false;
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.state[lowerCaseCommand];
        if (isFunction(func)) {
          return func(lowerCaseCommand);
        }
        return false;
      }
      queryCommandValue(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return '';
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.value[lowerCaseCommand];
        if (isFunction(func)) {
          return func(lowerCaseCommand);
        }
        return '';
      }
      addCommands(commandList, type = 'exec') {
        const commands = this.commands;
        each$d(commandList, (callback, command) => {
          each$e(command.toLowerCase().split(','), command => {
            commands[type][command] = callback;
          });
        });
      }
      addCommand(command, callback, scope) {
        const lowerCaseCommand = command.toLowerCase();
        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);
      }
      queryCommandSupported(command) {
        const lowerCaseCommand = command.toLowerCase();
        if (this.commands.exec[lowerCaseCommand]) {
          return true;
        } else {
          return false;
        }
      }
      addQueryStateHandler(command, callback, scope) {
        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
      addQueryValueHandler(command, callback, scope) {
        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
    }

    const internalContentEditableAttr = 'data-mce-contenteditable';
    const toggleClass = (elm, cls, state) => {
      if (has(elm, cls) && !state) {
        remove$7(elm, cls);
      } else if (state) {
        add$2(elm, cls);
      }
    };
    const setEditorCommandState = (editor, cmd, state) => {
      try {
        editor.getDoc().execCommand(cmd, false, String(state));
      } catch (ex) {
      }
    };
    const setContentEditable = (elm, state) => {
      elm.dom.contentEditable = state ? 'true' : 'false';
    };
    const switchOffContentEditableTrue = elm => {
      each$e(descendants(elm, '*[contenteditable="true"]'), elm => {
        set$3(elm, internalContentEditableAttr, 'true');
        setContentEditable(elm, false);
      });
    };
    const switchOnContentEditableTrue = elm => {
      each$e(descendants(elm, `*[${ internalContentEditableAttr }="true"]`), elm => {
        remove$a(elm, internalContentEditableAttr);
        setContentEditable(elm, true);
      });
    };
    const removeFakeSelection = editor => {
      Optional.from(editor.selection.getNode()).each(elm => {
        elm.removeAttribute('data-mce-selected');
      });
    };
    const restoreFakeSelection = editor => {
      editor.selection.setRng(editor.selection.getRng());
    };
    const toggleReadOnly = (editor, state) => {
      const body = SugarElement.fromDom(editor.getBody());
      toggleClass(body, 'mce-content-readonly', state);
      if (state) {
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
        editor.readonly = true;
        setContentEditable(body, false);
        switchOffContentEditableTrue(body);
      } else {
        editor.readonly = false;
        if (editor.hasEditableRoot()) {
          setContentEditable(body, true);
        }
        switchOnContentEditableTrue(body);
        setEditorCommandState(editor, 'StyleWithCSS', false);
        setEditorCommandState(editor, 'enableInlineTableEditing', false);
        setEditorCommandState(editor, 'enableObjectResizing', false);
        if (hasEditorOrUiFocus(editor)) {
          editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
      }
    };
    const isReadOnly = editor => editor.readonly;
    const registerFilters = editor => {
      editor.parser.addAttributeFilter('contenteditable', nodes => {
        if (isReadOnly(editor)) {
          each$e(nodes, node => {
            node.attr(internalContentEditableAttr, node.attr('contenteditable'));
            node.attr('contenteditable', 'false');
          });
        }
      });
      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {
        if (isReadOnly(editor)) {
          each$e(nodes, node => {
            node.attr('contenteditable', node.attr(internalContentEditableAttr));
          });
        }
      });
      editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    const registerReadOnlyContentFilters = editor => {
      if (editor.serializer) {
        registerFilters(editor);
      } else {
        editor.on('PreInit', () => {
          registerFilters(editor);
        });
      }
    };
    const isClickEvent = e => e.type === 'click';
    const allowedEvents = ['copy'];
    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);
    const getAnchorHrefOpt = (editor, elm) => {
      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));
      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));
    };
    const processReadonlyEvents = (editor, e) => {
      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
        const elm = SugarElement.fromDom(e.target);
        getAnchorHrefOpt(editor, elm).each(href => {
          e.preventDefault();
          if (/^#/.test(href)) {
            const targetEl = editor.dom.select(`${ href },[name="${ removeLeading(href, '#') }"]`);
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');
          }
        });
      } else if (isReadOnlyAllowedEvent(e)) {
        editor.dispatch(e.type, e);
      }
    };
    const registerReadOnlySelectionBlockers = editor => {
      editor.on('ShowCaret', e => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
      editor.on('ObjectSelected', e => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
    };

    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
    class EventDispatcher {
      static isNative(name) {
        return !!nativeEvents[name.toLowerCase()];
      }
      constructor(settings) {
        this.bindings = {};
        this.settings = settings || {};
        this.scope = this.settings.scope || this;
        this.toggleEvent = this.settings.toggleEvent || never;
      }
      fire(name, args) {
        return this.dispatch(name, args);
      }
      dispatch(name, args) {
        const lcName = name.toLowerCase();
        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
        if (this.settings.beforeFire) {
          this.settings.beforeFire(event);
        }
        const handlers = this.bindings[lcName];
        if (handlers) {
          for (let i = 0, l = handlers.length; i < l; i++) {
            const callback = handlers[i];
            if (callback.removed) {
              continue;
            }
            if (callback.once) {
              this.off(lcName, callback.func);
            }
            if (event.isImmediatePropagationStopped()) {
              return event;
            }
            if (callback.func.call(this.scope, event) === false) {
              event.preventDefault();
              return event;
            }
          }
        }
        return event;
      }
      on(name, callback, prepend, extra) {
        if (callback === false) {
          callback = never;
        }
        if (callback) {
          const wrappedCallback = {
            func: callback,
            removed: false
          };
          if (extra) {
            Tools.extend(wrappedCallback, extra);
          }
          const names = name.toLowerCase().split(' ');
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!handlers) {
              handlers = [];
              this.toggleEvent(currentName, true);
            }
            if (prepend) {
              handlers = [
                wrappedCallback,
                ...handlers
              ];
            } else {
              handlers = [
                ...handlers,
                wrappedCallback
              ];
            }
            this.bindings[currentName] = handlers;
          }
        }
        return this;
      }
      off(name, callback) {
        if (name) {
          const names = name.toLowerCase().split(' ');
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!currentName) {
              each$d(this.bindings, (_value, bindingName) => {
                this.toggleEvent(bindingName, false);
                delete this.bindings[bindingName];
              });
              return this;
            }
            if (handlers) {
              if (!callback) {
                handlers.length = 0;
              } else {
                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);
                handlers = filteredHandlers.fail;
                this.bindings[currentName] = handlers;
                each$e(filteredHandlers.pass, handler => {
                  handler.removed = true;
                });
              }
              if (!handlers.length) {
                this.toggleEvent(name, false);
                delete this.bindings[currentName];
              }
            }
          }
        } else {
          each$d(this.bindings, (_value, name) => {
            this.toggleEvent(name, false);
          });
          this.bindings = {};
        }
        return this;
      }
      once(name, callback, prepend) {
        return this.on(name, callback, prepend, { once: true });
      }
      has(name) {
        name = name.toLowerCase();
        const binding = this.bindings[name];
        return !(!binding || binding.length === 0);
      }
    }

    const getEventDispatcher = obj => {
      if (!obj._eventDispatcher) {
        obj._eventDispatcher = new EventDispatcher({
          scope: obj,
          toggleEvent: (name, state) => {
            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name, state);
            }
          }
        });
      }
      return obj._eventDispatcher;
    };
    const Observable = {
      fire(name, args, bubble) {
        return this.dispatch(name, args, bubble);
      },
      dispatch(name, args, bubble) {
        const self = this;
        if (self.removed && name !== 'remove' && name !== 'detach') {
          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);
        }
        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);
        if (bubble !== false && self.parent) {
          let parent = self.parent();
          while (parent && !dispatcherArgs.isPropagationStopped()) {
            parent.dispatch(name, dispatcherArgs, false);
            parent = parent.parent ? parent.parent() : undefined;
          }
        }
        return dispatcherArgs;
      },
      on(name, callback, prepend) {
        return getEventDispatcher(this).on(name, callback, prepend);
      },
      off(name, callback) {
        return getEventDispatcher(this).off(name, callback);
      },
      once(name, callback) {
        return getEventDispatcher(this).once(name, callback);
      },
      hasEventListeners(name) {
        return getEventDispatcher(this).has(name);
      }
    };

    const DOM$2 = DOMUtils.DOM;
    let customEventRootDelegates;
    const getEventTarget = (editor, eventName) => {
      if (eventName === 'selectionchange') {
        return editor.getDoc();
      }
      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
        return editor.getDoc().documentElement;
      }
      const eventRoot = getEventRoot(editor);
      if (eventRoot) {
        if (!editor.eventRoot) {
          editor.eventRoot = DOM$2.select(eventRoot)[0];
        }
        return editor.eventRoot;
      }
      return editor.getBody();
    };
    const isListening = editor => !editor.hidden && !isReadOnly(editor);
    const fireEvent = (editor, eventName, e) => {
      if (isListening(editor)) {
        editor.dispatch(eventName, e);
      } else if (isReadOnly(editor)) {
        processReadonlyEvents(editor, e);
      }
    };
    const bindEventDelegate = (editor, eventName) => {
      if (!editor.delegates) {
        editor.delegates = {};
      }
      if (editor.delegates[eventName] || editor.removed) {
        return;
      }
      const eventRootElm = getEventTarget(editor, eventName);
      if (getEventRoot(editor)) {
        if (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on('removeEditor', () => {
            if (!editor.editorManager.activeEditor) {
              if (customEventRootDelegates) {
                each$d(customEventRootDelegates, (_value, name) => {
                  editor.dom.unbind(getEventTarget(editor, name));
                });
                customEventRootDelegates = null;
              }
            }
          });
        }
        if (customEventRootDelegates[eventName]) {
          return;
        }
        const delegate = e => {
          const target = e.target;
          const editors = editor.editorManager.get();
          let i = editors.length;
          while (i--) {
            const body = editors[i].getBody();
            if (body === target || DOM$2.isChildOf(target, body)) {
              fireEvent(editors[i], eventName, e);
            }
          }
        };
        customEventRootDelegates[eventName] = delegate;
        DOM$2.bind(eventRootElm, eventName, delegate);
      } else {
        const delegate = e => {
          fireEvent(editor, eventName, e);
        };
        DOM$2.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    };
    const EditorObservable = {
      ...Observable,
      bindPendingEventDelegates() {
        const self = this;
        Tools.each(self._pendingNativeEvents, name => {
          bindEventDelegate(self, name);
        });
      },
      toggleNativeEvent(name, state) {
        const self = this;
        if (name === 'focus' || name === 'blur') {
          return;
        }
        if (self.removed) {
          return;
        }
        if (state) {
          if (self.initialized) {
            bindEventDelegate(self, name);
          } else {
            if (!self._pendingNativeEvents) {
              self._pendingNativeEvents = [name];
            } else {
              self._pendingNativeEvents.push(name);
            }
          }
        } else if (self.initialized && self.delegates) {
          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
          delete self.delegates[name];
        }
      },
      unbindAllNativeEvents() {
        const self = this;
        const body = self.getBody();
        const dom = self.dom;
        if (self.delegates) {
          each$d(self.delegates, (value, name) => {
            self.dom.unbind(getEventTarget(self, name), name, value);
          });
          delete self.delegates;
        }
        if (!self.inline && body && dom) {
          body.onload = null;
          dom.unbind(self.getWin());
          dom.unbind(self.getDoc());
        }
        if (dom) {
          dom.unbind(body);
          dom.unbind(self.getContainer());
        }
      }
    };

    const stringListProcessor = value => {
      if (isString(value)) {
        return {
          value: value.split(/[ ,]/),
          valid: true
        };
      } else if (isArrayOf(value, isString)) {
        return {
          value,
          valid: true
        };
      } else {
        return {
          valid: false,
          message: `The value must be a string[] or a comma/space separated string.`
        };
      }
    };
    const getBuiltInProcessor = type => {
      const validator = (() => {
        switch (type) {
        case 'array':
          return isArray$1;
        case 'boolean':
          return isBoolean;
        case 'function':
          return isFunction;
        case 'number':
          return isNumber;
        case 'object':
          return isObject;
        case 'string':
          return isString;
        case 'string[]':
          return stringListProcessor;
        case 'object[]':
          return val => isArrayOf(val, isObject);
        case 'regexp':
          return val => is$4(val, RegExp);
        default:
          return always;
        }
      })();
      return value => processValue(value, validator, `The value must be a ${ type }.`);
    };
    const isBuiltInSpec = spec => isString(spec.processor);
    const getErrorMessage = (message, result) => {
      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;
      return message + additionalText;
    };
    const isValidResult = result => result.valid;
    const processValue = (value, processor, message = '') => {
      const result = processor(value);
      if (isBoolean(result)) {
        return result ? {
          value: value,
          valid: true
        } : {
          valid: false,
          message
        };
      } else {
        return result;
      }
    };
    const processDefaultValue = (name, defaultValue, processor) => {
      if (!isUndefined(defaultValue)) {
        const result = processValue(defaultValue, processor);
        if (isValidResult(result)) {
          return result.value;
        } else {
          console.error(getErrorMessage(`Invalid default value passed for the "${ name }" option`, result));
        }
      }
      return undefined;
    };
    const create$5 = (editor, initialOptions) => {
      const registry = {};
      const values = {};
      const setValue = (name, value, processor) => {
        const result = processValue(value, processor);
        if (isValidResult(result)) {
          values[name] = result.value;
          return true;
        } else {
          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));
          return false;
        }
      };
      const register = (name, spec) => {
        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
        const defaultValue = processDefaultValue(name, spec.default, processor);
        registry[name] = {
          ...spec,
          default: defaultValue,
          processor
        };
        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));
        initValue.each(value => setValue(name, value, processor));
      };
      const isRegistered = name => has$2(registry, name);
      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();
      const set = (name, value) => {
        if (!isRegistered(name)) {
          console.warn(`"${ name }" is not a registered option. Ensure the option has been registered before setting a value.`);
          return false;
        } else {
          const spec = registry[name];
          if (spec.immutable) {
            console.error(`"${ name }" is an immutable option and cannot be updated`);
            return false;
          } else {
            return setValue(name, value, spec.processor);
          }
        }
      };
      const unset = name => {
        const registered = isRegistered(name);
        if (registered) {
          delete values[name];
        }
        return registered;
      };
      const isSet = name => has$2(values, name);
      return {
        register,
        isRegistered,
        get,
        set,
        unset,
        isSet
      };
    };

    const defaultModes = [
      'design',
      'readonly'
    ];
    const switchToMode = (editor, activeMode, availableModes, mode) => {
      const oldMode = availableModes[activeMode.get()];
      const newMode = availableModes[mode];
      try {
        newMode.activate();
      } catch (e) {
        console.error(`problem while activating editor mode ${ mode }:`, e);
        return;
      }
      oldMode.deactivate();
      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
        toggleReadOnly(editor, newMode.editorReadOnly);
      }
      activeMode.set(mode);
      fireSwitchMode(editor, mode);
    };
    const setMode = (editor, availableModes, activeMode, mode) => {
      if (mode === activeMode.get()) {
        return;
      } else if (!has$2(availableModes, mode)) {
        throw new Error(`Editor mode '${ mode }' is invalid`);
      }
      if (editor.initialized) {
        switchToMode(editor, activeMode, availableModes, mode);
      } else {
        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));
      }
    };
    const registerMode = (availableModes, mode, api) => {
      if (contains$2(defaultModes, mode)) {
        throw new Error(`Cannot override default mode ${ mode }`);
      }
      return {
        ...availableModes,
        [mode]: {
          ...api,
          deactivate: () => {
            try {
              api.deactivate();
            } catch (e) {
              console.error(`problem while deactivating editor mode ${ mode }:`, e);
            }
          }
        }
      };
    };

    const create$4 = editor => {
      const activeMode = Cell('design');
      const availableModes = Cell({
        design: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: false
        },
        readonly: {
          activate: noop,
          deactivate: noop,
          editorReadOnly: true
        }
      });
      registerReadOnlyContentFilters(editor);
      registerReadOnlySelectionBlockers(editor);
      return {
        isReadOnly: () => isReadOnly(editor),
        set: mode => setMode(editor, availableModes.get(), activeMode, mode),
        get: () => activeMode.get(),
        register: (mode, api) => {
          availableModes.set(registerMode(availableModes.get(), mode, api));
        }
      };
    };

    const each$2 = Tools.each, explode = Tools.explode;
    const keyCodeLookup = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    };
    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
    const isModifier = key => key in modifierNames;
    const parseShortcut = pattern => {
      const shortcut = {};
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      each$2(explode(pattern.toLowerCase(), '+'), value => {
        if (isModifier(value)) {
          shortcut[value] = true;
        } else {
          if (/^[0-9]{2,}$/.test(value)) {
            shortcut.keyCode = parseInt(value, 10);
          } else {
            shortcut.charCode = value.charCodeAt(0);
            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
          }
        }
      });
      const id = [shortcut.keyCode];
      let key;
      for (key in modifierNames) {
        if (shortcut[key]) {
          id.push(key);
        } else {
          shortcut[key] = false;
        }
      }
      shortcut.id = id.join(',');
      if (shortcut.access) {
        shortcut.alt = true;
        if (isMac) {
          shortcut.ctrl = true;
        } else {
          shortcut.shift = true;
        }
      }
      if (shortcut.meta) {
        if (isMac) {
          shortcut.meta = true;
        } else {
          shortcut.ctrl = true;
          shortcut.meta = false;
        }
      }
      return shortcut;
    };
    class Shortcuts {
      constructor(editor) {
        this.shortcuts = {};
        this.pendingPatterns = [];
        this.editor = editor;
        const self = this;
        editor.on('keyup keypress keydown', e => {
          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
            each$2(self.shortcuts, shortcut => {
              if (self.matchShortcut(e, shortcut)) {
                self.pendingPatterns = shortcut.subpatterns.slice(0);
                if (e.type === 'keydown') {
                  self.executeShortcutAction(shortcut);
                }
              }
            });
            if (self.matchShortcut(e, self.pendingPatterns[0])) {
              if (self.pendingPatterns.length === 1) {
                if (e.type === 'keydown') {
                  self.executeShortcutAction(self.pendingPatterns[0]);
                }
              }
              self.pendingPatterns.shift();
            }
          }
        });
      }
      add(pattern, desc, cmdFunc, scope) {
        const self = this;
        const func = self.normalizeCommandFunc(cmdFunc);
        each$2(explode(Tools.trim(pattern)), pattern => {
          const shortcut = self.createShortcut(pattern, desc, func, scope);
          self.shortcuts[shortcut.id] = shortcut;
        });
        return true;
      }
      remove(pattern) {
        const shortcut = this.createShortcut(pattern);
        if (this.shortcuts[shortcut.id]) {
          delete this.shortcuts[shortcut.id];
          return true;
        }
        return false;
      }
      normalizeCommandFunc(cmdFunc) {
        const self = this;
        const cmd = cmdFunc;
        if (typeof cmd === 'string') {
          return () => {
            self.editor.execCommand(cmd, false, null);
          };
        } else if (Tools.isArray(cmd)) {
          return () => {
            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        } else {
          return cmd;
        }
      }
      createShortcut(pattern, desc, cmdFunc, scope) {
        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
          func: cmdFunc,
          scope: scope || this.editor
        });
        return Tools.extend(shortcuts[0], {
          desc: this.editor.translate(desc),
          subpatterns: shortcuts.slice(1)
        });
      }
      hasModifier(e) {
        return e.altKey || e.ctrlKey || e.metaKey;
      }
      isFunctionKey(e) {
        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
      }
      matchShortcut(e, shortcut) {
        if (!shortcut) {
          return false;
        }
        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
          return false;
        }
        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
          return false;
        }
        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
          e.preventDefault();
          return true;
        }
        return false;
      }
      executeShortcutAction(shortcut) {
        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
      }
    }

    const create$3 = () => {
      const buttons = {};
      const menuItems = {};
      const popups = {};
      const icons = {};
      const contextMenus = {};
      const contextToolbars = {};
      const sidebars = {};
      const views = {};
      const add = (collection, type) => (name, spec) => {
        collection[name.toLowerCase()] = {
          ...spec,
          type
        };
      };
      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;
      return {
        addButton: add(buttons, 'button'),
        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
        addToggleButton: add(buttons, 'togglebutton'),
        addMenuButton: add(buttons, 'menubutton'),
        addSplitButton: add(buttons, 'splitbutton'),
        addMenuItem: add(menuItems, 'menuitem'),
        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
        addToggleMenuItem: add(menuItems, 'togglemenuitem'),
        addAutocompleter: add(popups, 'autocompleter'),
        addContextMenu: add(contextMenus, 'contextmenu'),
        addContextToolbar: add(contextToolbars, 'contexttoolbar'),
        addContextForm: add(contextToolbars, 'contextform'),
        addSidebar: add(sidebars, 'sidebar'),
        addView: add(views, 'views'),
        addIcon,
        getAll: () => ({
          buttons,
          menuItems,
          icons,
          popups,
          contextMenus,
          contextToolbars,
          sidebars,
          views
        })
      };
    };

    const registry = () => {
      const bridge = create$3();
      return {
        addAutocompleter: bridge.addAutocompleter,
        addButton: bridge.addButton,
        addContextForm: bridge.addContextForm,
        addContextMenu: bridge.addContextMenu,
        addContextToolbar: bridge.addContextToolbar,
        addIcon: bridge.addIcon,
        addMenuButton: bridge.addMenuButton,
        addMenuItem: bridge.addMenuItem,
        addNestedMenuItem: bridge.addNestedMenuItem,
        addSidebar: bridge.addSidebar,
        addSplitButton: bridge.addSplitButton,
        addToggleButton: bridge.addToggleButton,
        addGroupToolbarButton: bridge.addGroupToolbarButton,
        addToggleMenuItem: bridge.addToggleMenuItem,
        addView: bridge.addView,
        getAll: bridge.getAll
      };
    };

    const DOM$1 = DOMUtils.DOM;
    const extend = Tools.extend, each$1 = Tools.each;
    class Editor {
      constructor(id, options, editorManager) {
        this.plugins = {};
        this.contentCSS = [];
        this.contentStyles = [];
        this.loadedCSS = {};
        this.isNotDirty = false;
        this.composing = false;
        this.destroyed = false;
        this.hasHiddenInput = false;
        this.iframeElement = null;
        this.initialized = false;
        this.readonly = false;
        this.removed = false;
        this.startContent = '';
        this._pendingNativeEvents = [];
        this._skinLoaded = false;
        this._editableRoot = true;
        this.editorManager = editorManager;
        this.documentBaseUrl = editorManager.documentBaseURL;
        extend(this, EditorObservable);
        const self = this;
        this.id = id;
        this.hidden = false;
        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
        this.options = create$5(self, normalizedOptions);
        register$7(self);
        const getOption = this.options.get;
        if (getOption('deprecation_warnings')) {
          logWarnings(options, normalizedOptions);
        }
        const suffix = getOption('suffix');
        if (suffix) {
          editorManager.suffix = suffix;
        }
        this.suffix = editorManager.suffix;
        const baseUrl = getOption('base_url');
        if (baseUrl) {
          editorManager._setBaseUrl(baseUrl);
        }
        this.baseUri = editorManager.baseURI;
        const referrerPolicy = getReferrerPolicy(self);
        if (referrerPolicy) {
          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
        }
        const contentCssCors = hasContentCssCors(self);
        if (isNonNullable(contentCssCors)) {
          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
        }
        AddOnManager.languageLoad = getOption('language_load');
        AddOnManager.baseURL = editorManager.baseURL;
        this.setDirty(false);
        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });
        this.baseURI = this.baseUri;
        this.inline = isInline(self);
        this.hasVisual = isVisualAidsEnabled(self);
        this.shortcuts = new Shortcuts(this);
        this.editorCommands = new EditorCommands(this);
        registerCommands(this);
        const cacheSuffix = getOption('cache_suffix');
        if (cacheSuffix) {
          Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, '');
        }
        this.ui = {
          registry: registry(),
          styleSheetLoader: undefined,
          show: noop,
          hide: noop,
          setEnabled: noop,
          isEnabled: always
        };
        this.mode = create$4(self);
        editorManager.dispatch('SetupEditor', { editor: this });
        const setupCallback = getSetupCallback(self);
        if (isFunction(setupCallback)) {
          setupCallback.call(self, self);
        }
      }
      render() {
        render(this);
      }
      focus(skipFocus) {
        this.execCommand('mceFocus', false, skipFocus);
      }
      hasFocus() {
        return hasFocus(this);
      }
      translate(text) {
        return I18n.translate(text);
      }
      getParam(name, defaultVal, type) {
        const options = this.options;
        if (!options.isRegistered(name)) {
          if (isNonNullable(type)) {
            options.register(name, {
              processor: type,
              default: defaultVal
            });
          } else {
            options.register(name, {
              processor: always,
              default: defaultVal
            });
          }
        }
        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);
      }
      hasPlugin(name, loaded) {
        const hasPlugin = contains$2(getPlugins(this), name);
        if (hasPlugin) {
          return loaded ? PluginManager.get(name) !== undefined : true;
        } else {
          return false;
        }
      }
      nodeChanged(args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      }
      addCommand(name, callback, scope) {
        this.editorCommands.addCommand(name, callback, scope);
      }
      addQueryStateHandler(name, callback, scope) {
        this.editorCommands.addQueryStateHandler(name, callback, scope);
      }
      addQueryValueHandler(name, callback, scope) {
        this.editorCommands.addQueryValueHandler(name, callback, scope);
      }
      addShortcut(pattern, desc, cmdFunc, scope) {
        this.shortcuts.add(pattern, desc, cmdFunc, scope);
      }
      execCommand(cmd, ui, value, args) {
        return this.editorCommands.execCommand(cmd, ui, value, args);
      }
      queryCommandState(cmd) {
        return this.editorCommands.queryCommandState(cmd);
      }
      queryCommandValue(cmd) {
        return this.editorCommands.queryCommandValue(cmd);
      }
      queryCommandSupported(cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      }
      show() {
        const self = this;
        if (self.hidden) {
          self.hidden = false;
          if (self.inline) {
            self.getBody().contentEditable = 'true';
          } else {
            DOM$1.show(self.getContainer());
            DOM$1.hide(self.id);
          }
          self.load();
          self.dispatch('show');
        }
      }
      hide() {
        const self = this;
        if (!self.hidden) {
          self.save();
          if (self.inline) {
            self.getBody().contentEditable = 'false';
            if (self === self.editorManager.focusedEditor) {
              self.editorManager.focusedEditor = null;
            }
          } else {
            DOM$1.hide(self.getContainer());
            DOM$1.setStyle(self.id, 'display', self.orgDisplay);
          }
          self.hidden = true;
          self.dispatch('hide');
        }
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(state, time) {
        this.dispatch('ProgressState', {
          state,
          time
        });
      }
      load(args = {}) {
        const self = this;
        const elm = self.getElement();
        if (self.removed) {
          return '';
        }
        if (elm) {
          const loadArgs = {
            ...args,
            load: true
          };
          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
          const html = self.setContent(value, loadArgs);
          if (!loadArgs.no_events) {
            self.dispatch('LoadContent', {
              ...loadArgs,
              element: elm
            });
          }
          return html;
        } else {
          return '';
        }
      }
      save(args = {}) {
        const self = this;
        let elm = self.getElement();
        if (!elm || !self.initialized || self.removed) {
          return '';
        }
        const getArgs = {
          ...args,
          save: true,
          element: elm
        };
        let html = self.getContent(getArgs);
        const saveArgs = {
          ...getArgs,
          content: html
        };
        if (!saveArgs.no_events) {
          self.dispatch('SaveContent', saveArgs);
        }
        if (saveArgs.format === 'raw') {
          self.dispatch('RawSaveContent', saveArgs);
        }
        html = saveArgs.content;
        if (!isTextareaOrInput(elm)) {
          if (args.is_removing || !self.inline) {
            elm.innerHTML = html;
          }
          const form = DOM$1.getParent(self.id, 'form');
          if (form) {
            each$1(form.elements, elm => {
              if (elm.name === self.id) {
                elm.value = html;
                return false;
              } else {
                return true;
              }
            });
          }
        } else {
          elm.value = html;
        }
        saveArgs.element = getArgs.element = elm = null;
        if (saveArgs.set_dirty !== false) {
          self.setDirty(false);
        }
        return html;
      }
      setContent(content, args) {
        return setContent(this, content, args);
      }
      getContent(args) {
        return getContent(this, args);
      }
      insertContent(content, args) {
        if (args) {
          content = extend({ content }, args);
        }
        this.execCommand('mceInsertContent', false, content);
      }
      resetContent(initialContent) {
        if (initialContent === undefined) {
          setContent(this, this.startContent, { format: 'raw' });
        } else {
          setContent(this, initialContent);
        }
        this.undoManager.reset();
        this.setDirty(false);
        this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(state) {
        const oldState = !this.isNotDirty;
        this.isNotDirty = !state;
        if (state && state !== oldState) {
          this.dispatch('dirty');
        }
      }
      getContainer() {
        const self = this;
        if (!self.container) {
          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');
        }
        return self.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        if (!this.targetElm) {
          this.targetElm = DOM$1.get(this.id);
        }
        return this.targetElm;
      }
      getWin() {
        const self = this;
        if (!self.contentWindow) {
          const elm = self.iframeElement;
          if (elm) {
            self.contentWindow = elm.contentWindow;
          }
        }
        return self.contentWindow;
      }
      getDoc() {
        const self = this;
        if (!self.contentDocument) {
          const win = self.getWin();
          if (win) {
            self.contentDocument = win.document;
          }
        }
        return self.contentDocument;
      }
      getBody() {
        var _a, _b;
        const doc = this.getDoc();
        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
      }
      convertURL(url, name, elm) {
        const self = this, getOption = self.options.get;
        const urlConverterCallback = getUrlConverterCallback(self);
        if (isFunction(urlConverterCallback)) {
          return urlConverterCallback.call(self, url, elm, true, name);
        }
        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {
          return url;
        }
        if (getOption('relative_urls')) {
          return self.documentBaseURI.toRelative(url);
        }
        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));
        return url;
      }
      addVisual(elm) {
        addVisual(this, elm);
      }
      setEditableRoot(state) {
        setEditableRoot(this, state);
      }
      hasEditableRoot() {
        return hasEditableRoot(this);
      }
      remove() {
        remove$1(this);
      }
      destroy(automatic) {
        destroy(this, automatic);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }

    const DOM = DOMUtils.DOM;
    const each = Tools.each;
    let boundGlobalEvents = false;
    let beforeUnloadDelegate;
    let editors = [];
    const globalEventDelegate = e => {
      const type = e.type;
      each(EditorManager.get(), editor => {
        switch (type) {
        case 'scroll':
          editor.dispatch('ScrollWindow', e);
          break;
        case 'resize':
          editor.dispatch('ResizeWindow', e);
          break;
        }
      });
    };
    const toggleGlobalEvents = state => {
      if (state !== boundGlobalEvents) {
        const DOM = DOMUtils.DOM;
        if (state) {
          DOM.bind(window, 'resize', globalEventDelegate);
          DOM.bind(window, 'scroll', globalEventDelegate);
        } else {
          DOM.unbind(window, 'resize', globalEventDelegate);
          DOM.unbind(window, 'scroll', globalEventDelegate);
        }
        boundGlobalEvents = state;
      }
    };
    const removeEditorFromList = targetEditor => {
      const oldEditors = editors;
      editors = filter$5(editors, editor => {
        return targetEditor !== editor;
      });
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }
      return oldEditors.length !== editors.length;
    };
    const purgeDestroyedEditor = editor => {
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(true);
        editor.removed = true;
      }
    };
    const isQuirksMode = document.compatMode !== 'CSS1Compat';
    const EditorManager = {
      ...Observable,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: '6',
      minorVersion: '7.0',
      releaseDate: '2023-08-30',
      i18n: I18n,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const self = this;
        let baseURL = '';
        let suffix = '';
        let documentBaseURL = URI.getDocumentBaseUrl(document.location);
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
          if (!/[\/\\]$/.test(documentBaseURL)) {
            documentBaseURL += '/';
          }
        }
        const preInit = window.tinymce || window.tinyMCEPreInit;
        if (preInit) {
          baseURL = preInit.base || preInit.baseURL;
          suffix = preInit.suffix;
        } else {
          const scripts = document.getElementsByTagName('script');
          for (let i = 0; i < scripts.length; i++) {
            const src = scripts[i].src || '';
            if (src === '') {
              continue;
            }
            const srcScript = src.substring(src.lastIndexOf('/'));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
              if (srcScript.indexOf('.min') !== -1) {
                suffix = '.min';
              }
              baseURL = src.substring(0, src.lastIndexOf('/'));
              break;
            }
          }
          if (!baseURL && document.currentScript) {
            const src = document.currentScript.src;
            if (src.indexOf('.min') !== -1) {
              suffix = '.min';
            }
            baseURL = src.substring(0, src.lastIndexOf('/'));
          }
        }
        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
        self.documentBaseURL = documentBaseURL;
        self.baseURI = new URI(self.baseURL);
        self.suffix = suffix;
        setup$v(self);
      },
      overrideDefaults(defaultOptions) {
        const baseUrl = defaultOptions.base_url;
        if (baseUrl) {
          this._setBaseUrl(baseUrl);
        }
        const suffix = defaultOptions.suffix;
        if (suffix) {
          this.suffix = suffix;
        }
        this.defaultOptions = defaultOptions;
        const pluginBaseUrls = defaultOptions.plugin_base_urls;
        if (pluginBaseUrls !== undefined) {
          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
          });
        }
      },
      init(options) {
        const self = this;
        let result;
        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
        const createId = elm => {
          let id = elm.id;
          if (!id) {
            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);
            elm.setAttribute('id', id);
          }
          return id;
        };
        const execCallback = name => {
          const callback = options[name];
          if (!callback) {
            return;
          }
          return callback.apply(self, []);
        };
        const findTargets = options => {
          if (Env.browser.isIE() || Env.browser.isEdge()) {
            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');
            return [];
          } else if (isQuirksMode) {
            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');
            return [];
          } else if (isString(options.selector)) {
            return DOM.select(options.selector);
          } else if (isNonNullable(options.target)) {
            return [options.target];
          } else {
            return [];
          }
        };
        let provideResults = editors => {
          result = editors;
        };
        const initEditors = () => {
          let initCount = 0;
          const editors = [];
          let targets;
          const createEditor = (id, options, targetElm) => {
            const editor = new Editor(id, options, self);
            editors.push(editor);
            editor.on('init', () => {
              if (++initCount === targets.length) {
                provideResults(editors);
              }
            });
            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          };
          DOM.unbind(window, 'ready', initEditors);
          execCallback('onpageload');
          targets = unique$1(findTargets(options));
          Tools.each(targets, elm => {
            purgeDestroyedEditor(self.get(elm.id));
          });
          targets = Tools.grep(targets, elm => {
            return !self.get(elm.id);
          });
          if (targets.length === 0) {
            provideResults([]);
          } else {
            each(targets, elm => {
              if (isInvalidInlineTarget(options, elm)) {
                initError('Could not initialize inline editor on invalid inline target element', elm);
              } else {
                createEditor(createId(elm), options, elm);
              }
            });
          }
        };
        DOM.bind(window, 'ready', initEditors);
        return new Promise(resolve => {
          if (result) {
            resolve(result);
          } else {
            provideResults = editors => {
              resolve(editors);
            };
          }
        });
      },
      get(id) {
        if (arguments.length === 0) {
          return editors.slice(0);
        } else if (isString(id)) {
          return find$2(editors, editor => {
            return editor.id === id;
          }).getOr(null);
        } else if (isNumber(id)) {
          return editors[id] ? editors[id] : null;
        } else {
          return null;
        }
      },
      add(editor) {
        const self = this;
        const existingEditor = self.get(editor.id);
        if (existingEditor === editor) {
          return editor;
        }
        if (existingEditor === null) {
          editors.push(editor);
        }
        toggleGlobalEvents(true);
        self.activeEditor = editor;
        self.dispatch('AddEditor', { editor });
        if (!beforeUnloadDelegate) {
          beforeUnloadDelegate = e => {
            const event = self.dispatch('BeforeUnload');
            if (event.returnValue) {
              e.preventDefault();
              e.returnValue = event.returnValue;
              return event.returnValue;
            }
          };
          window.addEventListener('beforeunload', beforeUnloadDelegate);
        }
        return editor;
      },
      createEditor(id, options) {
        return this.add(new Editor(id, options, this));
      },
      remove(selector) {
        const self = this;
        let editor;
        if (!selector) {
          for (let i = editors.length - 1; i >= 0; i--) {
            self.remove(editors[i]);
          }
          return;
        }
        if (isString(selector)) {
          each(DOM.select(selector), elm => {
            editor = self.get(elm.id);
            if (editor) {
              self.remove(editor);
            }
          });
          return;
        }
        editor = selector;
        if (isNull(self.get(editor.id))) {
          return null;
        }
        if (removeEditorFromList(editor)) {
          self.dispatch('RemoveEditor', { editor });
        }
        if (editors.length === 0) {
          window.removeEventListener('beforeunload', beforeUnloadDelegate);
        }
        editor.remove();
        toggleGlobalEvents(editors.length > 0);
        return editor;
      },
      execCommand(cmd, ui, value) {
        var _a;
        const self = this;
        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;
        switch (cmd) {
        case 'mceAddEditor': {
            if (!self.get(editorId)) {
              const editorOptions = value.options;
              new Editor(editorId, editorOptions, self).render();
            }
            return true;
          }
        case 'mceRemoveEditor': {
            const editor = self.get(editorId);
            if (editor) {
              editor.remove();
            }
            return true;
          }
        case 'mceToggleEditor': {
            const editor = self.get(editorId);
            if (!editor) {
              self.execCommand('mceAddEditor', false, value);
              return true;
            }
            if (editor.isHidden()) {
              editor.show();
            } else {
              editor.hide();
            }
            return true;
          }
        }
        if (self.activeEditor) {
          return self.activeEditor.execCommand(cmd, ui, value);
        }
        return false;
      },
      triggerSave: () => {
        each(editors, editor => {
          editor.save();
        });
      },
      addI18n: (code, items) => {
        I18n.add(code, items);
      },
      translate: text => {
        return I18n.translate(text);
      },
      setActive(editor) {
        const activeEditor = this.activeEditor;
        if (this.activeEditor !== editor) {
          if (activeEditor) {
            activeEditor.dispatch('deactivate', { relatedTarget: editor });
          }
          editor.dispatch('activate', { relatedTarget: activeEditor });
        }
        this.activeEditor = editor;
      },
      _setBaseUrl(baseUrl) {
        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
        this.baseURI = new URI(this.baseURL);
      }
    };
    EditorManager.setup();

    const setup = () => {
      const dataValue = value$2();
      const FakeClipboardItem = items => ({
        items,
        types: keys(items),
        getType: type => get$a(items, type).getOrUndefined()
      });
      const write = data => {
        dataValue.set(data);
      };
      const read = () => dataValue.get().getOrUndefined();
      const clear = dataValue.clear;
      return {
        FakeClipboardItem,
        write,
        read,
        clear
      };
    };
    const FakeClipboard = setup();

    const min = Math.min, max = Math.max, round = Math.round;
    const relativePosition = (rect, targetRect, rel) => {
      let x = targetRect.x;
      let y = targetRect.y;
      const w = rect.w;
      const h = rect.h;
      const targetW = targetRect.w;
      const targetH = targetRect.h;
      const relChars = (rel || '').split('');
      if (relChars[0] === 'b') {
        y += targetH;
      }
      if (relChars[1] === 'r') {
        x += targetW;
      }
      if (relChars[0] === 'c') {
        y += round(targetH / 2);
      }
      if (relChars[1] === 'c') {
        x += round(targetW / 2);
      }
      if (relChars[3] === 'b') {
        y -= h;
      }
      if (relChars[4] === 'r') {
        x -= w;
      }
      if (relChars[3] === 'c') {
        y -= round(h / 2);
      }
      if (relChars[4] === 'c') {
        x -= round(w / 2);
      }
      return create$2(x, y, w, h);
    };
    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
      for (let i = 0; i < rels.length; i++) {
        const pos = relativePosition(rect, targetRect, rels[i]);
        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }
      return null;
    };
    const inflate = (rect, w, h) => {
      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    const intersect = (rect, cropRect) => {
      const x1 = max(rect.x, cropRect.x);
      const y1 = max(rect.y, cropRect.y);
      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    const clamp = (rect, clampRect, fixedSize) => {
      let x1 = rect.x;
      let y1 = rect.y;
      let x2 = rect.x + rect.w;
      let y2 = rect.y + rect.h;
      const cx2 = clampRect.x + clampRect.w;
      const cy2 = clampRect.y + clampRect.h;
      const underflowX1 = max(0, clampRect.x - x1);
      const underflowY1 = max(0, clampRect.y - y1);
      const overflowX2 = max(0, x2 - cx2);
      const overflowY2 = max(0, y2 - cy2);
      x1 += underflowX1;
      y1 += underflowY1;
      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }
      x2 -= overflowX2;
      y2 -= overflowY2;
      return create$2(x1, y1, x2 - x1, y2 - y1);
    };
    const create$2 = (x, y, w, h) => {
      return {
        x,
        y,
        w,
        h
      };
    };
    const fromClientRect = clientRect => {
      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    const Rect = {
      inflate,
      relativePosition,
      findBestRelativePosition,
      intersect,
      clamp,
      create: create$2,
      fromClientRect
    };

    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {
      let done = false;
      let timer = null;
      const complete = completer => (...args) => {
        if (!done) {
          done = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          completer.apply(null, args);
        }
      };
      const resolve = complete(resolveCb);
      const reject = complete(rejectCb);
      const start = (...args) => {
        if (!done && timer === null) {
          timer = setTimeout(() => reject.apply(null, args), timeout);
        }
      };
      return {
        start,
        resolve,
        reject
      };
    };
    const create$1 = () => {
      const tasks = {};
      const resultFns = {};
      const load = (id, url) => {
        const loadErrMsg = `Script at URL "${ url }" failed to load`;
        const runErrMsg = `Script at URL "${ url }" did not call \`tinymce.Resource.add('${ id }', data)\` within 1 second`;
        if (tasks[id] !== undefined) {
          return tasks[id];
        } else {
          const task = new Promise((resolve, reject) => {
            const waiter = awaiter(resolve, reject);
            resultFns[id] = waiter.resolve;
            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
          });
          tasks[id] = task;
          return task;
        }
      };
      const add = (id, data) => {
        if (resultFns[id] !== undefined) {
          resultFns[id](data);
          delete resultFns[id];
        }
        tasks[id] = Promise.resolve(data);
      };
      const unload = id => {
        delete tasks[id];
      };
      return {
        load,
        add,
        unload
      };
    };
    const Resource = create$1();

    const create = () => (() => {
      let data = {};
      let keys = [];
      const storage = {
        getItem: key => {
          const item = data[key];
          return item ? item : null;
        },
        setItem: (key, value) => {
          keys.push(key);
          data[key] = String(value);
        },
        key: index => {
          return keys[index];
        },
        removeItem: key => {
          keys = keys.filter(k => k === key);
          delete data[key];
        },
        clear: () => {
          keys = [];
          data = {};
        },
        length: 0
      };
      Object.defineProperty(storage, 'length', {
        get: () => keys.length,
        configurable: false,
        enumerable: false
      });
      return storage;
    })();

    let localStorage;
    try {
      const test = '__storage_test__';
      localStorage = window.localStorage;
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
    } catch (e) {
      localStorage = create();
    }
    var LocalStorage = localStorage;

    const publicApi = {
      geom: { Rect },
      util: {
        Delay,
        Tools,
        VK,
        URI,
        EventDispatcher,
        Observable,
        I18n,
        LocalStorage,
        ImageUploader
      },
      dom: {
        EventUtils,
        TreeWalker: DomTreeWalker,
        TextSeeker,
        DOMUtils,
        ScriptLoader,
        RangeUtils,
        Serializer: DomSerializer,
        StyleSheetLoader,
        ControlSelection,
        BookmarkManager,
        Selection: EditorSelection,
        Event: EventUtils.Event
      },
      html: {
        Styles,
        Entities,
        Node: AstNode,
        Schema,
        DomParser,
        Writer,
        Serializer: HtmlSerializer
      },
      Env,
      AddOnManager,
      Annotator,
      Formatter,
      UndoManager,
      EditorCommands,
      WindowManager,
      NotificationManager,
      EditorObservable,
      Shortcuts,
      Editor,
      FocusManager,
      EditorManager,
      DOM: DOMUtils.DOM,
      ScriptLoader: ScriptLoader.ScriptLoader,
      PluginManager,
      ThemeManager,
      ModelManager,
      IconManager,
      Resource,
      FakeClipboard,
      trim: Tools.trim,
      isArray: Tools.isArray,
      is: Tools.is,
      toArray: Tools.toArray,
      makeMap: Tools.makeMap,
      each: Tools.each,
      map: Tools.map,
      grep: Tools.grep,
      inArray: Tools.inArray,
      extend: Tools.extend,
      walk: Tools.walk,
      resolve: Tools.resolve,
      explode: Tools.explode,
      _addCacheSuffix: Tools._addCacheSuffix
    };
    const tinymce = Tools.extend(EditorManager, publicApi);

    const exportToModuleLoaders = tinymce => {
      if (true) {
        try {
          module.exports = tinymce;
        } catch (_) {
        }
      }
    };
    const exportToWindowGlobal = tinymce => {
      window.tinymce = tinymce;
      window.tinyMCE = tinymce;
    };
    exportToWindowGlobal(tinymce);
    exportToModuleLoaders(tinymce);

})();


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/tinymce/tinymce.js"));
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGlueW1jZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYLFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0EsK0RBQStEO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0EsNENBQTRDO0FBQzVDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtJQUFrSSx5QkFBeUI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsd0JBQXdCO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUhBQW1ILCtCQUErQjtBQUNsSixxREFBcUQsaUJBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsb0NBQW9DO0FBQ3BDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsVUFBVTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQkFBK0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0JBQWtCLEtBQUssSUFBSTtBQUMzRztBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQiw2QkFBNkIsa0JBQWtCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQixLQUFLLEtBQUs7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEtBQUssTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYSxJQUFJLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxvQkFBb0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVMsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLHFCQUFxQjtBQUN4RCxpQ0FBaUMscUJBQXFCO0FBQ3RELGlDQUFpQyxxQkFBcUI7QUFDdEQsdUNBQXVDLHFCQUFxQjtBQUM1RCxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFDQUFxQyxxQkFBcUI7QUFDMUQsMENBQTBDLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DLHFCQUFxQjtBQUN6RCxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJDQUEyQyxxQkFBcUI7QUFDaEUseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyx1QkFBdUI7QUFDdkQsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLHFCQUFxQjtBQUMvRCxrREFBa0QscUJBQXFCO0FBQ3ZFLDJDQUEyQyxxQkFBcUI7QUFDaEUseUNBQXlDLG9DQUFvQztBQUM3RSx5Q0FBeUMscUJBQXFCO0FBQzlELHdDQUF3QyxvQ0FBb0M7QUFDNUUseUNBQXlDLHFCQUFxQjtBQUM5RCx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMsdURBQXVEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMsdUJBQXVCO0FBQ2xFLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLDZCQUE2QixvQ0FBb0MsTUFBTSwrQkFBK0IsbUJBQW1CLE1BQU0sd0JBQXdCLHdCQUF3QixtQkFBbUIsaUJBQWlCLFlBQVksZUFBZSxnQkFBZ0IsTUFBTTtBQUMzVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDRCQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsa0JBQWtCLElBQUksMkJBQTJCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0Isa0JBQWtCO0FBQ3hDLGFBQWEsZUFBZSxnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0MseUJBQXlCLGtCQUFrQjtBQUMzQyx5QkFBeUIsd0JBQXdCO0FBQ2pELCtDQUErQyw0QkFBNEI7QUFDM0UsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRCx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrR0FBa0csT0FBTztBQUN6Ryx3R0FBd0csT0FBTzs7QUFFL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0IsUUFBUSxzQkFBc0I7QUFDdEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsOEJBQThCO0FBQ25FO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxXQUFXLGFBQWEsT0FBTyw2QkFBNkIsV0FBVztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksV0FBVztBQUN2SixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCwySUFBMkksV0FBVztBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQW9CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVGQUF1RjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsMERBQTBELDBDQUEwQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrREFBa0Q7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNERBQTRELElBQUksdUJBQXVCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFELG1GQUFtRjtBQUNuRiwwQkFBMEIsT0FBTztBQUNqQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQ0FBbUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFVBQVU7QUFDbEIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1Q0FBdUM7QUFDdkY7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwQkFBMEI7QUFDM0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxpQkFBaUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQ0FBa0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssWUFBWSxPQUFPO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVELEtBQUssWUFBWSxPQUFPO0FBQy9FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLElBQUksTUFBTSxLQUFLLFVBQVU7QUFDaEYsbUhBQW1ILFNBQVMsNEJBQTRCLFNBQVM7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkIsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLGdGQUFnRjtBQUNuRztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxxRUFBcUU7QUFDbEY7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLDJEQUEyRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywrQ0FBK0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLGlCQUFpQjtBQUNqRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FLG1FQUFtRSxZQUFZLEdBQUcsaUNBQWlDO0FBQ25ILG1FQUFtRSxZQUFZLEdBQUcsaUNBQWlDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxpQkFBaUIsb0JBQW9CO0FBQzlELFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFlBQVksR0FBRyw4REFBOEQ7QUFDbkosc0VBQXNFLFlBQVksR0FBRyxvQ0FBb0M7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0IsbUJBQW1CO0FBQ25GO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0EsMkVBQTJFLE1BQU0sS0FBSyxPQUFPLFlBQVksS0FBSyx1QkFBdUIsT0FBTyxRQUFRLEtBQUs7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBLHFCQUFxQixTQUFTLElBQUksS0FBSyxJQUFJLGdCQUFnQjtBQUMzRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0IsSUFBSSwwRUFBMEU7QUFDekksa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixlQUFlO0FBQ3BDLHVCQUF1QixlQUFlO0FBQ3RDLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsNkNBQTZDO0FBQzdDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSw0QkFBNEI7QUFDcEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QixRQUFRLG9CQUFvQjtBQUM1QixRQUFRLGtCQUFrQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWUsWUFBWSxZQUFZO0FBQ25JLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMklBQTJJLE9BQU8scUJBQXFCLG1CQUFtQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFLG9CQUFvQjtBQUNwQjtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWtEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMERBQTBELHVCQUF1QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzSUFBc0ksbUJBQW1CO0FBQ3pKO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFdBQVc7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsV0FBVztBQUM5RTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxhQUFhLGNBQWMsa0JBQWtCO0FBQzFGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBLHFIQUFxSCxvQkFBb0I7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnREFBZ0Q7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakUsMENBQTBDLGdCQUFnQjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkNBQTZDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHNCQUFzQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtIQUErSCxLQUFLO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQyxvQkFBb0IsMEJBQTBCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNULHNEQUFzRCw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVEsNkJBQTZCLFdBQVcsY0FBYyxXQUFXLGlCQUFpQixvQkFBb0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw4QkFBOEIsVUFBVSxjQUFjO0FBQ3RIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE9BQU8sU0FBUyxRQUFRO0FBQ2hIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLE9BQU8sU0FBUyxRQUFRO0FBQzFIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsOEJBQThCLFVBQVUsTUFBTSxTQUFTLFFBQVE7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRLFVBQVUsUUFBUTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSwyREFBMkQ7QUFDM0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwRkFBMEYsYUFBYTtBQUM5SjtBQUNBLGdNQUFnTSxJQUFJLHVGQUF1RjtBQUMzUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsUUFBUTtBQUNSLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RCxRQUFRO0FBQ1IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0RBQStELFlBQVk7QUFDM0UsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlFQUF5RSxhQUFhLGtDQUFrQyxnQkFBZ0I7QUFDeEksU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlDQUFpQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QywyQkFBMkI7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLE9BQU87QUFDekMsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQ0FBMEMsbUNBQW1DO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSxXQUFXLDBCQUEwQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZFQUE2RSxNQUFNO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtGQUFrRixNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsTUFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCLEdBQUc7QUFDekI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9ELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsNkNBQTZDLEtBQUssMENBQTBDLElBQUk7QUFDaEc7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsSUFBMEI7QUFDcEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55bWNlL3RpbnltY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaW55TUNFIHZlcnNpb24gNi43LjAgKDIwMjMtMDgtMzApXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdHlwZU9mJDEgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuICAgICAgdmFyIHQgPSB0eXBlb2YgeDtcbiAgICAgIGlmICh0ID09PSAnb2JqZWN0JyAmJiAoQXJyYXkucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheScpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfVxuICAgICAgaWYgKHQgPT09ICdvYmplY3QnICYmIChTdHJpbmcucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHZhciBpc0VxdWF0YWJsZVR5cGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdib29sZWFuJyxcbiAgICAgICAgJ251bWJlcicsXG4gICAgICAgICdzdHJpbmcnLFxuICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAneG1sJyxcbiAgICAgICAgJ251bGwnXG4gICAgICBdLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICB2YXIgc29ydCQxID0gZnVuY3Rpb24gKHhzLCBjb21wYXJlRm4pIHtcbiAgICAgIHZhciBjbG9uZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHhzKTtcbiAgICAgIHJldHVybiBjbG9uZS5zb3J0KGNvbXBhcmVGbik7XG4gICAgfTtcblxuICAgIHZhciBjb250cmFtYXAgPSBmdW5jdGlvbiAoZXFhLCBmKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gZXFhLmVxKGYoeCksIGYoeSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXEkMiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4geyBlcTogZiB9O1xuICAgIH07XG4gICAgdmFyIHRyaXBsZUVxID0gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgcmV0dXJuIHggPT09IHk7XG4gICAgfSk7XG4gICAgdmFyIGVxU3RyaW5nID0gdHJpcGxlRXE7XG4gICAgdmFyIGVxQXJyYXkgPSBmdW5jdGlvbiAoZXFhKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSB4Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICghZXFhLmVxKHhbaV0sIHlbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXFTb3J0ZWRBcnJheSA9IGZ1bmN0aW9uIChlcWEsIGNvbXBhcmVGbikge1xuICAgICAgcmV0dXJuIGNvbnRyYW1hcChlcUFycmF5KGVxYSksIGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gc29ydCQxKHhzLCBjb21wYXJlRm4pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgZXFSZWNvcmQgPSBmdW5jdGlvbiAoZXFhKSB7XG4gICAgICByZXR1cm4gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIga3ggPSBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgdmFyIGt5ID0gT2JqZWN0LmtleXMoeSk7XG4gICAgICAgIGlmICghZXFTb3J0ZWRBcnJheShlcVN0cmluZykuZXEoa3gsIGt5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0ga3gubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHEgPSBreFtpXTtcbiAgICAgICAgICBpZiAoIWVxYS5lcSh4W3FdLCB5W3FdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGVxQW55ID0gZXEkMihmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgdHggPSB0eXBlT2YkMSh4KTtcbiAgICAgIHZhciB0eSA9IHR5cGVPZiQxKHkpO1xuICAgICAgaWYgKHR4ICE9PSB0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNFcXVhdGFibGVUeXBlKHR4KSkge1xuICAgICAgICByZXR1cm4geCA9PT0geTtcbiAgICAgIH0gZWxzZSBpZiAodHggPT09ICdhcnJheScpIHtcbiAgICAgICAgcmV0dXJuIGVxQXJyYXkoZXFBbnkpLmVxKHgsIHkpO1xuICAgICAgfSBlbHNlIGlmICh0eCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGVxUmVjb3JkKGVxQW55KS5lcSh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldFByb3RvdHlwZU9mJDIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gICAgY29uc3QgaGFzUHJvdG8gPSAodiwgY29uc3RydWN0b3IsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB2LmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09IGNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0eXBlT2YgPSB4ID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnICYmIGhhc1Byb3RvKHgsIFN0cmluZywgKG8sIHByb3RvKSA9PiBwcm90by5pc1Byb3RvdHlwZU9mKG8pKSkge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVHlwZSQxID0gdHlwZSA9PiB2YWx1ZSA9PiB0eXBlT2YodmFsdWUpID09PSB0eXBlO1xuICAgIGNvbnN0IGlzU2ltcGxlVHlwZSA9IHR5cGUgPT4gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSB0eXBlO1xuICAgIGNvbnN0IGVxJDEgPSB0ID0+IGEgPT4gdCA9PT0gYTtcbiAgICBjb25zdCBpcyQ0ID0gKHZhbHVlLCBjb25zdHJ1Y3RvcikgPT4gaXNPYmplY3QodmFsdWUpICYmIGhhc1Byb3RvKHZhbHVlLCBjb25zdHJ1Y3RvciwgKG8sIHByb3RvKSA9PiBnZXRQcm90b3R5cGVPZiQyKG8pID09PSBwcm90byk7XG4gICAgY29uc3QgaXNTdHJpbmcgPSBpc1R5cGUkMSgnc3RyaW5nJyk7XG4gICAgY29uc3QgaXNPYmplY3QgPSBpc1R5cGUkMSgnb2JqZWN0Jyk7XG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IHZhbHVlID0+IGlzJDQodmFsdWUsIE9iamVjdCk7XG4gICAgY29uc3QgaXNBcnJheSQxID0gaXNUeXBlJDEoJ2FycmF5Jyk7XG4gICAgY29uc3QgaXNOdWxsID0gZXEkMShudWxsKTtcbiAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NpbXBsZVR5cGUoJ2Jvb2xlYW4nKTtcbiAgICBjb25zdCBpc1VuZGVmaW5lZCA9IGVxJDEodW5kZWZpbmVkKTtcbiAgICBjb25zdCBpc051bGxhYmxlID0gYSA9PiBhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpc05vbk51bGxhYmxlID0gYSA9PiAhaXNOdWxsYWJsZShhKTtcbiAgICBjb25zdCBpc0Z1bmN0aW9uID0gaXNTaW1wbGVUeXBlKCdmdW5jdGlvbicpO1xuICAgIGNvbnN0IGlzTnVtYmVyID0gaXNTaW1wbGVUeXBlKCdudW1iZXInKTtcbiAgICBjb25zdCBpc0FycmF5T2YgPSAodmFsdWUsIHByZWQpID0+IHtcbiAgICAgIGlmIChpc0FycmF5JDEodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmICghcHJlZCh2YWx1ZVtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCBjb21wb3NlID0gKGZhLCBmYikgPT4ge1xuICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHJldHVybiBmYShmYi5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29tcG9zZTEgPSAoZmJjLCBmYWIpID0+IGEgPT4gZmJjKGZhYihhKSk7XG4gICAgY29uc3QgY29uc3RhbnQgPSB2YWx1ZSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaWRlbnRpdHkgPSB4ID0+IHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgY29uc3QgdHJpcGxlRXF1YWxzID0gKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY3VycnkoZm4sIC4uLmluaXRpYWxBcmdzKSB7XG4gICAgICByZXR1cm4gKC4uLnJlc3RBcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbCA9IGluaXRpYWxBcmdzLmNvbmNhdChyZXN0QXJncyk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhbGwpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgbm90ID0gZiA9PiB0ID0+ICFmKHQpO1xuICAgIGNvbnN0IGRpZSA9IG1zZyA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhcHBseSQxID0gZiA9PiB7XG4gICAgICByZXR1cm4gZigpO1xuICAgIH07XG4gICAgY29uc3QgY2FsbCA9IGYgPT4ge1xuICAgICAgZigpO1xuICAgIH07XG4gICAgY29uc3QgbmV2ZXIgPSBjb25zdGFudChmYWxzZSk7XG4gICAgY29uc3QgYWx3YXlzID0gY29uc3RhbnQodHJ1ZSk7XG5cbiAgICBjbGFzcyBPcHRpb25hbCB7XG4gICAgICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdGF0aWMgc29tZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9wdGlvbmFsKHRydWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRpYyBub25lKCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc2luZ2xldG9uTm9uZTtcbiAgICAgIH1cbiAgICAgIGZvbGQob25Ob25lLCBvblNvbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG9uU29tZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb25Ob25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzU29tZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgICAgfVxuICAgICAgaXNOb25lKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudGFnO1xuICAgICAgfVxuICAgICAgbWFwKG1hcHBlcikge1xuICAgICAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShtYXBwZXIodGhpcy52YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJpbmQoYmluZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgICAgIHJldHVybiBiaW5kZXIodGhpcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhpc3RzKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgICAgZm9yYWxsKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gIXRoaXMudGFnIHx8IHByZWRpY2F0ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhZyB8fCBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRPcihyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzLnZhbHVlIDogcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgICBvcihyZXBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzIDogcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgICBnZXRPclRodW5rKHRodW5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgOiB0aHVuaygpO1xuICAgICAgfVxuICAgICAgb3JUaHVuayh0aHVuaykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzIDogdGh1bmsoKTtcbiAgICAgIH1cbiAgICAgIGdldE9yRGllKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnQ2FsbGVkIGdldE9yRGllIG9uIE5vbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodmFsdWUpID8gT3B0aW9uYWwuc29tZSh2YWx1ZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBnZXRPck51bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgOiBudWxsO1xuICAgICAgfVxuICAgICAgZ2V0T3JVbmRlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgICAgZWFjaCh3b3JrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICAgICAgd29ya2VyKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyBbdGhpcy52YWx1ZV0gOiBbXTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcgPyBgc29tZSgkeyB0aGlzLnZhbHVlIH0pYCA6ICdub25lKCknO1xuICAgICAgfVxuICAgIH1cbiAgICBPcHRpb25hbC5zaW5nbGV0b25Ob25lID0gbmV3IE9wdGlvbmFsKGZhbHNlKTtcblxuICAgIGNvbnN0IG5hdGl2ZVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIGNvbnN0IG5hdGl2ZUluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICBjb25zdCBuYXRpdmVQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG4gICAgY29uc3QgcmF3SW5kZXhPZiA9ICh0cywgdCkgPT4gbmF0aXZlSW5kZXhPZi5jYWxsKHRzLCB0KTtcbiAgICBjb25zdCBpbmRleE9mJDEgPSAoeHMsIHgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSByYXdJbmRleE9mKHhzLCB4KTtcbiAgICAgIHJldHVybiByID09PSAtMSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUocik7XG4gICAgfTtcbiAgICBjb25zdCBjb250YWlucyQyID0gKHhzLCB4KSA9PiByYXdJbmRleE9mKHhzLCB4KSA+IC0xO1xuICAgIGNvbnN0IGV4aXN0cyA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWFwJDMgPSAoeHMsIGYpID0+IHtcbiAgICAgIGNvbnN0IGxlbiA9IHhzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICByW2ldID0gZih4LCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgZWFjaCRlID0gKHhzLCBmKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBmKHgsIGkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZWFjaHIgPSAoeHMsIGYpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSB4cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGYoeCwgaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXJ0aXRpb24kMiA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgcGFzcyA9IFtdO1xuICAgICAgY29uc3QgZmFpbCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgY29uc3QgYXJyID0gcHJlZCh4LCBpKSA/IHBhc3MgOiBmYWlsO1xuICAgICAgICBhcnIucHVzaCh4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhc3MsXG4gICAgICAgIGZhaWxcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkNSA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgICAgICByLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgZm9sZHIgPSAoeHMsIGYsIGFjYykgPT4ge1xuICAgICAgZWFjaHIoeHMsICh4LCBpKSA9PiB7XG4gICAgICAgIGFjYyA9IGYoYWNjLCB4LCBpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZvbGRsID0gKHhzLCBmLCBhY2MpID0+IHtcbiAgICAgIGVhY2gkZSh4cywgKHgsIGkpID0+IHtcbiAgICAgICAgYWNjID0gZihhY2MsIHgsIGkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH07XG4gICAgY29uc3QgZmluZFVudGlsJDEgPSAoeHMsIHByZWQsIHVudGlsKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBpZiAocHJlZCh4LCBpKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHgpO1xuICAgICAgICB9IGVsc2UgaWYgKHVudGlsKHgsIGkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kJDIgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIHJldHVybiBmaW5kVW50aWwkMSh4cywgcHJlZCwgbmV2ZXIpO1xuICAgIH07XG4gICAgY29uc3QgZmluZEluZGV4JDIgPSAoeHMsIHByZWQpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmbGF0dGVuID0geHMgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICghaXNBcnJheSQxKHhzW2ldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyLmZsYXR0ZW4gaXRlbSAnICsgaSArICcgd2FzIG5vdCBhbiBhcnJheSwgaW5wdXQ6ICcgKyB4cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmF0aXZlUHVzaC5hcHBseShyLCB4c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMyA9ICh4cywgZikgPT4gZmxhdHRlbihtYXAkMyh4cywgZikpO1xuICAgIGNvbnN0IGZvcmFsbCA9ICh4cywgcHJlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgaWYgKHByZWQoeCwgaSkgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgcmV2ZXJzZSA9IHhzID0+IHtcbiAgICAgIGNvbnN0IHIgPSBuYXRpdmVTbGljZS5jYWxsKHhzLCAwKTtcbiAgICAgIHIucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0gKGExLCBhMikgPT4gZmlsdGVyJDUoYTEsIHggPT4gIWNvbnRhaW5zJDIoYTIsIHgpKTtcbiAgICBjb25zdCBtYXBUb09iamVjdCA9ICh4cywgZikgPT4ge1xuICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICAgICAgcltTdHJpbmcoeCldID0gZih4LCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3Qgc29ydCA9ICh4cywgY29tcGFyYXRvcikgPT4ge1xuICAgICAgY29uc3QgY29weSA9IG5hdGl2ZVNsaWNlLmNhbGwoeHMsIDApO1xuICAgICAgY29weS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQkYiA9ICh4cywgaSkgPT4gaSA+PSAwICYmIGkgPCB4cy5sZW5ndGggPyBPcHRpb25hbC5zb21lKHhzW2ldKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICBjb25zdCBoZWFkID0geHMgPT4gZ2V0JGIoeHMsIDApO1xuICAgIGNvbnN0IGxhc3QkMyA9IHhzID0+IGdldCRiKHhzLCB4cy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBmcm9tID0gaXNGdW5jdGlvbihBcnJheS5mcm9tKSA/IEFycmF5LmZyb20gOiB4ID0+IG5hdGl2ZVNsaWNlLmNhbGwoeCk7XG4gICAgY29uc3QgZmluZE1hcCA9IChhcnIsIGYpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHIgPSBmKGFycltpXSwgaSk7XG4gICAgICAgIGlmIChyLmlzU29tZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCB1bmlxdWUkMSA9ICh4cywgY29tcGFyYXRvcikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgY29uc3QgaXNEdXBsaWNhdGVkID0gaXNGdW5jdGlvbihjb21wYXJhdG9yKSA/IHggPT4gZXhpc3RzKHIsIGkgPT4gY29tcGFyYXRvcihpLCB4KSkgOiB4ID0+IGNvbnRhaW5zJDIociwgeCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHhzW2ldO1xuICAgICAgICBpZiAoIWlzRHVwbGljYXRlZCh4KSkge1xuICAgICAgICAgIHIucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbiAgICBjb25zdCBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICAgIGNvbnN0IGVhY2gkZCA9IChvYmosIGYpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0ga2V5cyhvYmopO1xuICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IHByb3BzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwcm9wc1trXTtcbiAgICAgICAgY29uc3QgeCA9IG9ialtpXTtcbiAgICAgICAgZih4LCBpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hcCQyID0gKG9iaiwgZikgPT4ge1xuICAgICAgcmV0dXJuIHR1cGxlTWFwKG9iaiwgKHgsIGkpID0+ICh7XG4gICAgICAgIGs6IGksXG4gICAgICAgIHY6IGYoeCwgaSlcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlTWFwID0gKG9iaiwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgZWFjaCRkKG9iaiwgKHgsIGkpID0+IHtcbiAgICAgICAgY29uc3QgdHVwbGUgPSBmKHgsIGkpO1xuICAgICAgICByW3R1cGxlLmtdID0gdHVwbGUudjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCBvYmpBY2MgPSByID0+ICh4LCBpKSA9PiB7XG4gICAgICByW2ldID0geDtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsRmlsdGVyID0gKG9iaiwgcHJlZCwgb25UcnVlLCBvbkZhbHNlKSA9PiB7XG4gICAgICBlYWNoJGQob2JqLCAoeCwgaSkgPT4ge1xuICAgICAgICAocHJlZCh4LCBpKSA/IG9uVHJ1ZSA6IG9uRmFsc2UpKHgsIGkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBiaWZpbHRlciA9IChvYmosIHByZWQpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGNvbnN0IGYgPSB7fTtcbiAgICAgIGludGVybmFsRmlsdGVyKG9iaiwgcHJlZCwgb2JqQWNjKHQpLCBvYmpBY2MoZikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdCxcbiAgICAgICAgZlxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlciQ0ID0gKG9iaiwgcHJlZCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgaW50ZXJuYWxGaWx0ZXIob2JqLCBwcmVkLCBvYmpBY2ModCksIG5vb3ApO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBjb25zdCBtYXBUb0FycmF5ID0gKG9iaiwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgZWFjaCRkKG9iaiwgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIHIucHVzaChmKHZhbHVlLCBuYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgdmFsdWVzID0gb2JqID0+IHtcbiAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iaiwgaWRlbnRpdHkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0JGEgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBoYXMkMihvYmosIGtleSkgPyBPcHRpb25hbC5mcm9tKG9ialtrZXldKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhcyQyID0gKG9iaiwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwob2JqLCBrZXkpO1xuICAgIGNvbnN0IGhhc05vbk51bGxhYmxlS2V5ID0gKG9iaiwga2V5KSA9PiBoYXMkMihvYmosIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCAmJiBvYmpba2V5XSAhPT0gbnVsbDtcbiAgICBjb25zdCBlcXVhbCQxID0gKGExLCBhMiwgZXEgPSBlcUFueSkgPT4gZXFSZWNvcmQoZXEpLmVxKGExLCBhMik7XG5cbiAgICBjb25zdCBzdHJpbmdBcnJheSA9IGEgPT4ge1xuICAgICAgY29uc3QgYWxsID0ge307XG4gICAgICBlYWNoJGUoYSwga2V5ID0+IHtcbiAgICAgICAgYWxsW2tleV0gPSB7fTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleXMoYWxsKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNBcnJheUxpa2UgPSBvID0+IG8ubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgY29uc3QgdG9BcnJheSQxID0gb2JqID0+IHtcbiAgICAgIGlmICghaXNBcnJheShvYmopKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFycmF5W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlYWNoJGMgPSAobywgY2IsIHMpID0+IHtcbiAgICAgIGlmICghbykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzID0gcyB8fCBvO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKG8pKSB7XG4gICAgICAgIGZvciAobGV0IG4gPSAwLCBsID0gby5sZW5ndGg7IG4gPCBsOyBuKyspIHtcbiAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBpbiBvKSB7XG4gICAgICAgICAgaWYgKGhhcyQyKG8sIG4pKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChzLCBvW25dLCBuLCBvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtYXAkMSA9IChhcnJheSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgZWFjaCRjKGFycmF5LCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgb3V0LnB1c2goY2FsbGJhY2soaXRlbSwgaW5kZXgsIGFycmF5KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkMyA9IChhLCBmKSA9PiB7XG4gICAgICBjb25zdCBvID0gW107XG4gICAgICBlYWNoJGMoYSwgKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICghZiB8fCBmKHYsIGluZGV4LCBhKSkge1xuICAgICAgICAgIG8ucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGNvbnN0IGluZGV4T2YgPSAoYSwgdikgPT4ge1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChhW2ldID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZHVjZSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpID0+IHtcbiAgICAgIGxldCBhY2MgPSBpc1VuZGVmaW5lZChhY2N1bXVsYXRvcikgPyBjb2xsZWN0aW9uWzBdIDogYWNjdW11bGF0b3I7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjID0gaXRlcmF0ZWUuY2FsbCh0aGlzQXJnLCBhY2MsIGNvbGxlY3Rpb25baV0sIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmRleCQxID0gKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IGxhc3QkMiA9IGNvbGxlY3Rpb24gPT4gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdO1xuXG4gICAgY29uc3QgY2FjaGVkID0gZiA9PiB7XG4gICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICBsZXQgcjtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgciA9IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBEZXZpY2VUeXBlID0gKG9zLCBicm93c2VyLCB1c2VyQWdlbnQsIG1lZGlhTWF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGlzaVBhZCA9IG9zLmlzaU9TKCkgJiYgL2lwYWQvaS50ZXN0KHVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBjb25zdCBpc2lQaG9uZSA9IG9zLmlzaU9TKCkgJiYgIWlzaVBhZDtcbiAgICAgIGNvbnN0IGlzTW9iaWxlID0gb3MuaXNpT1MoKSB8fCBvcy5pc0FuZHJvaWQoKTtcbiAgICAgIGNvbnN0IGlzVG91Y2ggPSBpc01vYmlsZSB8fCBtZWRpYU1hdGNoKCcocG9pbnRlcjpjb2Fyc2UpJyk7XG4gICAgICBjb25zdCBpc1RhYmxldCA9IGlzaVBhZCB8fCAhaXNpUGhvbmUgJiYgaXNNb2JpbGUgJiYgbWVkaWFNYXRjaCgnKG1pbi1kZXZpY2Utd2lkdGg6NzY4cHgpJyk7XG4gICAgICBjb25zdCBpc1Bob25lID0gaXNpUGhvbmUgfHwgaXNNb2JpbGUgJiYgIWlzVGFibGV0O1xuICAgICAgY29uc3QgaU9Td2VidmlldyA9IGJyb3dzZXIuaXNTYWZhcmkoKSAmJiBvcy5pc2lPUygpICYmIC9zYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkgPT09IGZhbHNlO1xuICAgICAgY29uc3QgaXNEZXNrdG9wID0gIWlzUGhvbmUgJiYgIWlzVGFibGV0ICYmICFpT1N3ZWJ2aWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNpUGFkOiBjb25zdGFudChpc2lQYWQpLFxuICAgICAgICBpc2lQaG9uZTogY29uc3RhbnQoaXNpUGhvbmUpLFxuICAgICAgICBpc1RhYmxldDogY29uc3RhbnQoaXNUYWJsZXQpLFxuICAgICAgICBpc1Bob25lOiBjb25zdGFudChpc1Bob25lKSxcbiAgICAgICAgaXNUb3VjaDogY29uc3RhbnQoaXNUb3VjaCksXG4gICAgICAgIGlzQW5kcm9pZDogb3MuaXNBbmRyb2lkLFxuICAgICAgICBpc2lPUzogb3MuaXNpT1MsXG4gICAgICAgIGlzV2ViVmlldzogY29uc3RhbnQoaU9Td2VidmlldyksXG4gICAgICAgIGlzRGVza3RvcDogY29uc3RhbnQoaXNEZXNrdG9wKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlyc3RNYXRjaCA9IChyZWdleGVzLCBzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZ2V4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IHJlZ2V4ZXNbaV07XG4gICAgICAgIGlmICh4LnRlc3QocykpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmQkMSA9IChyZWdleGVzLCBhZ2VudCkgPT4ge1xuICAgICAgY29uc3QgciA9IGZpcnN0TWF0Y2gocmVnZXhlcywgYWdlbnQpO1xuICAgICAgaWYgKCFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWFqb3I6IDAsXG4gICAgICAgICAgbWlub3I6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gaSA9PiB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYWdlbnQucmVwbGFjZShyLCAnJCcgKyBpKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG51JDMoZ3JvdXAoMSksIGdyb3VwKDIpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRldGVjdCQ1ID0gKHZlcnNpb25SZWdleGVzLCBhZ2VudCkgPT4ge1xuICAgICAgY29uc3QgY2xlYW5lZEFnZW50ID0gU3RyaW5nKGFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHZlcnNpb25SZWdleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5rbm93biQyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZCQxKHZlcnNpb25SZWdleGVzLCBjbGVhbmVkQWdlbnQpO1xuICAgIH07XG4gICAgY29uc3QgdW5rbm93biQyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG51JDMoMCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBudSQzID0gKG1ham9yLCBtaW5vcikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFqb3IsXG4gICAgICAgIG1pbm9yXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgVmVyc2lvbiA9IHtcbiAgICAgIG51OiBudSQzLFxuICAgICAgZGV0ZWN0OiBkZXRlY3QkNSxcbiAgICAgIHVua25vd246IHVua25vd24kMlxuICAgIH07XG5cbiAgICBjb25zdCBkZXRlY3RCcm93c2VyJDEgPSAoYnJvd3NlcnMsIHVzZXJBZ2VudERhdGEpID0+IHtcbiAgICAgIHJldHVybiBmaW5kTWFwKHVzZXJBZ2VudERhdGEuYnJhbmRzLCB1YUJyYW5kID0+IHtcbiAgICAgICAgY29uc3QgbGNCcmFuZCA9IHVhQnJhbmQuYnJhbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGZpbmQkMihicm93c2VycywgYnJvd3NlciA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiBsY0JyYW5kID09PSAoKF9hID0gYnJvd3Nlci5icmFuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9KS5tYXAoaW5mbyA9PiAoe1xuICAgICAgICAgIGN1cnJlbnQ6IGluZm8ubmFtZSxcbiAgICAgICAgICB2ZXJzaW9uOiBWZXJzaW9uLm51KHBhcnNlSW50KHVhQnJhbmQudmVyc2lvbiwgMTApLCAwKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGV0ZWN0JDQgPSAoY2FuZGlkYXRlcywgdXNlckFnZW50KSA9PiB7XG4gICAgICBjb25zdCBhZ2VudCA9IFN0cmluZyh1c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZmluZCQyKGNhbmRpZGF0ZXMsIGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUuc2VhcmNoKGFnZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGV0ZWN0QnJvd3NlciA9IChicm93c2VycywgdXNlckFnZW50KSA9PiB7XG4gICAgICByZXR1cm4gZGV0ZWN0JDQoYnJvd3NlcnMsIHVzZXJBZ2VudCkubWFwKGJyb3dzZXIgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbi5kZXRlY3QoYnJvd3Nlci52ZXJzaW9uUmVnZXhlcywgdXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJyZW50OiBicm93c2VyLm5hbWUsXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkZXRlY3RPcyA9IChvc2VzLCB1c2VyQWdlbnQpID0+IHtcbiAgICAgIHJldHVybiBkZXRlY3QkNChvc2VzLCB1c2VyQWdlbnQpLm1hcChvcyA9PiB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBWZXJzaW9uLmRldGVjdChvcy52ZXJzaW9uUmVnZXhlcywgdXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjdXJyZW50OiBvcy5uYW1lLFxuICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVGcm9tU3RhcnQgPSAoc3RyLCBudW1DaGFycykgPT4ge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcobnVtQ2hhcnMpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGVja1JhbmdlID0gKHN0ciwgc3Vic3RyLCBzdGFydCkgPT4gc3Vic3RyID09PSAnJyB8fCBzdHIubGVuZ3RoID49IHN1YnN0ci5sZW5ndGggJiYgc3RyLnN1YnN0cihzdGFydCwgc3RhcnQgKyBzdWJzdHIubGVuZ3RoKSA9PT0gc3Vic3RyO1xuICAgIGNvbnN0IHJlbW92ZUxlYWRpbmcgPSAoc3RyLCBwcmVmaXgpID0+IHtcbiAgICAgIHJldHVybiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSA/IHJlbW92ZUZyb21TdGFydChzdHIsIHByZWZpeC5sZW5ndGgpIDogc3RyO1xuICAgIH07XG4gICAgY29uc3QgY29udGFpbnMkMSA9IChzdHIsIHN1YnN0ciwgc3RhcnQgPSAwLCBlbmQpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IHN0ci5pbmRleE9mKHN1YnN0ciwgc3RhcnQpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGVuZCkgPyB0cnVlIDogaWR4ICsgc3Vic3RyLmxlbmd0aCA8PSBlbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGFydHNXaXRoID0gKHN0ciwgcHJlZml4KSA9PiB7XG4gICAgICByZXR1cm4gY2hlY2tSYW5nZShzdHIsIHByZWZpeCwgMCk7XG4gICAgfTtcbiAgICBjb25zdCBlbmRzV2l0aCA9IChzdHIsIHN1ZmZpeCkgPT4ge1xuICAgICAgcmV0dXJuIGNoZWNrUmFuZ2Uoc3RyLCBzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICB9O1xuICAgIGNvbnN0IGJsYW5rID0gciA9PiBzID0+IHMucmVwbGFjZShyLCAnJyk7XG4gICAgY29uc3QgdHJpbSQzID0gYmxhbmsoL15cXHMrfFxccyskL2cpO1xuICAgIGNvbnN0IGxUcmltID0gYmxhbmsoL15cXHMrL2cpO1xuICAgIGNvbnN0IHJUcmltID0gYmxhbmsoL1xccyskL2cpO1xuICAgIGNvbnN0IGlzTm90RW1wdHkgPSBzID0+IHMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBpc0VtcHR5JDMgPSBzID0+ICFpc05vdEVtcHR5KHMpO1xuICAgIGNvbnN0IHJlcGVhdCA9IChzLCBjb3VudCkgPT4gY291bnQgPD0gMCA/ICcnIDogbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihzKTtcbiAgICBjb25zdCB0b0ludCA9ICh2YWx1ZSwgcmFkaXggPSAxMCkgPT4ge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUsIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihudW0pID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuc29tZShudW0pO1xuICAgIH07XG5cbiAgICBjb25zdCBub3JtYWxWZXJzaW9uUmVnZXggPSAvLio/dmVyc2lvblxcL1xcID8oWzAtOV0rKVxcLihbMC05XSspLiovO1xuICAgIGNvbnN0IGNoZWNrQ29udGFpbnMgPSB0YXJnZXQgPT4ge1xuICAgICAgcmV0dXJuIHVhc3RyaW5nID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEodWFzdHJpbmcsIHRhcmdldCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgYnJvd3NlcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdFZGdlJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFsvLio/ZWRnZVxcLyA/KFswLTldKylcXC4oWzAtOV0rKSQvXSxcbiAgICAgICAgc2VhcmNoOiB1YXN0cmluZyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEodWFzdHJpbmcsICdlZGdlLycpICYmIGNvbnRhaW5zJDEodWFzdHJpbmcsICdjaHJvbWUnKSAmJiBjb250YWlucyQxKHVhc3RyaW5nLCAnc2FmYXJpJykgJiYgY29udGFpbnMkMSh1YXN0cmluZywgJ2FwcGxld2Via2l0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWl1bScsXG4gICAgICAgIGJyYW5kOiAnQ2hyb21pdW0nLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW1xuICAgICAgICAgIC8uKj9jaHJvbWVcXC8oWzAtOV0rKVxcLihbMC05XSspLiovLFxuICAgICAgICAgIG5vcm1hbFZlcnNpb25SZWdleFxuICAgICAgICBdLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgJ2Nocm9tZScpICYmICFjb250YWlucyQxKHVhc3RyaW5nLCAnY2hyb21lZnJhbWUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0lFJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICAvLio/bXNpZVxcID8oWzAtOV0rKVxcLihbMC05XSspLiovLFxuICAgICAgICAgIC8uKj9ydjooWzAtOV0rKVxcLihbMC05XSspLiovXG4gICAgICAgIF0sXG4gICAgICAgIHNlYXJjaDogdWFzdHJpbmcgPT4ge1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQxKHVhc3RyaW5nLCAnbXNpZScpIHx8IGNvbnRhaW5zJDEodWFzdHJpbmcsICd0cmlkZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdPcGVyYScsXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXG4gICAgICAgICAgbm9ybWFsVmVyc2lvblJlZ2V4LFxuICAgICAgICAgIC8uKj9vcGVyYVxcLyhbMC05XSspXFwuKFswLTldKykuKi9cbiAgICAgICAgXSxcbiAgICAgICAgc2VhcmNoOiBjaGVja0NvbnRhaW5zKCdvcGVyYScpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnRmlyZWZveCcsXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP2ZpcmVmb3hcXC9cXCA/KFswLTldKylcXC4oWzAtOV0rKS4qL10sXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnZmlyZWZveCcpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtcbiAgICAgICAgICBub3JtYWxWZXJzaW9uUmVnZXgsXG4gICAgICAgICAgLy4qP2NwdSBvcyAoWzAtOV0rKV8oWzAtOV0rKS4qL1xuICAgICAgICBdLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gKGNvbnRhaW5zJDEodWFzdHJpbmcsICdzYWZhcmknKSB8fCBjb250YWlucyQxKHVhc3RyaW5nLCAnbW9iaWxlLycpKSAmJiBjb250YWlucyQxKHVhc3RyaW5nLCAnYXBwbGV3ZWJraXQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gICAgY29uc3Qgb3NlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1dpbmRvd3MnLFxuICAgICAgICBzZWFyY2g6IGNoZWNrQ29udGFpbnMoJ3dpbicpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj93aW5kb3dzXFwgbnRcXCA/KFswLTldKylcXC4oWzAtOV0rKS4qL11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpT1MnLFxuICAgICAgICBzZWFyY2g6IHVhc3RyaW5nID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMSh1YXN0cmluZywgJ2lwaG9uZScpIHx8IGNvbnRhaW5zJDEodWFzdHJpbmcsICdpcGFkJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbXG4gICAgICAgICAgLy4qP3ZlcnNpb25cXC9cXCA/KFswLTldKylcXC4oWzAtOV0rKS4qLyxcbiAgICAgICAgICAvLipjcHUgb3MgKFswLTldKylfKFswLTldKykuKi8sXG4gICAgICAgICAgLy4qY3B1IGlwaG9uZSBvcyAoWzAtOV0rKV8oWzAtOV0rKS4qL1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnQW5kcm9pZCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnYW5kcm9pZCcpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj9hbmRyb2lkXFwgPyhbMC05XSspXFwuKFswLTldKykuKi9dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnbWFjT1MnLFxuICAgICAgICBzZWFyY2g6IGNoZWNrQ29udGFpbnMoJ21hYyBvcyB4JyksXG4gICAgICAgIHZlcnNpb25SZWdleGVzOiBbLy4qP21hY1xcIG9zXFwgeFxcID8oWzAtOV0rKV8oWzAtOV0rKS4qL11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdMaW51eCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnbGludXgnKSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnU29sYXJpcycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnc3Vub3MnKSxcbiAgICAgICAgdmVyc2lvblJlZ2V4ZXM6IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnRnJlZUJTRCcsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnZnJlZWJzZCcpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogW11cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWVPUycsXG4gICAgICAgIHNlYXJjaDogY2hlY2tDb250YWlucygnY3JvcycpLFxuICAgICAgICB2ZXJzaW9uUmVnZXhlczogWy8uKj9jaHJvbWVcXC8oWzAtOV0rKVxcLihbMC05XSspLiovXVxuICAgICAgfVxuICAgIF07XG4gICAgY29uc3QgUGxhdGZvcm1JbmZvID0ge1xuICAgICAgYnJvd3NlcnM6IGNvbnN0YW50KGJyb3dzZXJzKSxcbiAgICAgIG9zZXM6IGNvbnN0YW50KG9zZXMpXG4gICAgfTtcblxuICAgIGNvbnN0IGVkZ2UgPSAnRWRnZSc7XG4gICAgY29uc3QgY2hyb21pdW0gPSAnQ2hyb21pdW0nO1xuICAgIGNvbnN0IGllID0gJ0lFJztcbiAgICBjb25zdCBvcGVyYSA9ICdPcGVyYSc7XG4gICAgY29uc3QgZmlyZWZveCA9ICdGaXJlZm94JztcbiAgICBjb25zdCBzYWZhcmkgPSAnU2FmYXJpJztcbiAgICBjb25zdCB1bmtub3duJDEgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbnUkMih7XG4gICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyc2lvbjogVmVyc2lvbi51bmtub3duKClcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbnUkMiA9IGluZm8gPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGluZm8uY3VycmVudDtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBpbmZvLnZlcnNpb247XG4gICAgICBjb25zdCBpc0Jyb3dzZXIgPSBuYW1lID0+ICgpID0+IGN1cnJlbnQgPT09IG5hbWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50LFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBpc0VkZ2U6IGlzQnJvd3NlcihlZGdlKSxcbiAgICAgICAgaXNDaHJvbWl1bTogaXNCcm93c2VyKGNocm9taXVtKSxcbiAgICAgICAgaXNJRTogaXNCcm93c2VyKGllKSxcbiAgICAgICAgaXNPcGVyYTogaXNCcm93c2VyKG9wZXJhKSxcbiAgICAgICAgaXNGaXJlZm94OiBpc0Jyb3dzZXIoZmlyZWZveCksXG4gICAgICAgIGlzU2FmYXJpOiBpc0Jyb3dzZXIoc2FmYXJpKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEJyb3dzZXIgPSB7XG4gICAgICB1bmtub3duOiB1bmtub3duJDEsXG4gICAgICBudTogbnUkMixcbiAgICAgIGVkZ2U6IGNvbnN0YW50KGVkZ2UpLFxuICAgICAgY2hyb21pdW06IGNvbnN0YW50KGNocm9taXVtKSxcbiAgICAgIGllOiBjb25zdGFudChpZSksXG4gICAgICBvcGVyYTogY29uc3RhbnQob3BlcmEpLFxuICAgICAgZmlyZWZveDogY29uc3RhbnQoZmlyZWZveCksXG4gICAgICBzYWZhcmk6IGNvbnN0YW50KHNhZmFyaSlcbiAgICB9O1xuXG4gICAgY29uc3Qgd2luZG93cyA9ICdXaW5kb3dzJztcbiAgICBjb25zdCBpb3MgPSAnaU9TJztcbiAgICBjb25zdCBhbmRyb2lkID0gJ0FuZHJvaWQnO1xuICAgIGNvbnN0IGxpbnV4ID0gJ0xpbnV4JztcbiAgICBjb25zdCBtYWNvcyA9ICdtYWNPUyc7XG4gICAgY29uc3Qgc29sYXJpcyA9ICdTb2xhcmlzJztcbiAgICBjb25zdCBmcmVlYnNkID0gJ0ZyZWVCU0QnO1xuICAgIGNvbnN0IGNocm9tZW9zID0gJ0Nocm9tZU9TJztcbiAgICBjb25zdCB1bmtub3duID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG51JDEoe1xuICAgICAgICBjdXJyZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHZlcnNpb246IFZlcnNpb24udW5rbm93bigpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG51JDEgPSBpbmZvID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBpbmZvLmN1cnJlbnQ7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gaW5mby52ZXJzaW9uO1xuICAgICAgY29uc3QgaXNPUyA9IG5hbWUgPT4gKCkgPT4gY3VycmVudCA9PT0gbmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGlzV2luZG93czogaXNPUyh3aW5kb3dzKSxcbiAgICAgICAgaXNpT1M6IGlzT1MoaW9zKSxcbiAgICAgICAgaXNBbmRyb2lkOiBpc09TKGFuZHJvaWQpLFxuICAgICAgICBpc01hY09TOiBpc09TKG1hY29zKSxcbiAgICAgICAgaXNMaW51eDogaXNPUyhsaW51eCksXG4gICAgICAgIGlzU29sYXJpczogaXNPUyhzb2xhcmlzKSxcbiAgICAgICAgaXNGcmVlQlNEOiBpc09TKGZyZWVic2QpLFxuICAgICAgICBpc0Nocm9tZU9TOiBpc09TKGNocm9tZW9zKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IE9wZXJhdGluZ1N5c3RlbSA9IHtcbiAgICAgIHVua25vd24sXG4gICAgICBudTogbnUkMSxcbiAgICAgIHdpbmRvd3M6IGNvbnN0YW50KHdpbmRvd3MpLFxuICAgICAgaW9zOiBjb25zdGFudChpb3MpLFxuICAgICAgYW5kcm9pZDogY29uc3RhbnQoYW5kcm9pZCksXG4gICAgICBsaW51eDogY29uc3RhbnQobGludXgpLFxuICAgICAgbWFjb3M6IGNvbnN0YW50KG1hY29zKSxcbiAgICAgIHNvbGFyaXM6IGNvbnN0YW50KHNvbGFyaXMpLFxuICAgICAgZnJlZWJzZDogY29uc3RhbnQoZnJlZWJzZCksXG4gICAgICBjaHJvbWVvczogY29uc3RhbnQoY2hyb21lb3MpXG4gICAgfTtcblxuICAgIGNvbnN0IGRldGVjdCQzID0gKHVzZXJBZ2VudCwgdXNlckFnZW50RGF0YU9wdCwgbWVkaWFNYXRjaCkgPT4ge1xuICAgICAgY29uc3QgYnJvd3NlcnMgPSBQbGF0Zm9ybUluZm8uYnJvd3NlcnMoKTtcbiAgICAgIGNvbnN0IG9zZXMgPSBQbGF0Zm9ybUluZm8ub3NlcygpO1xuICAgICAgY29uc3QgYnJvd3NlciA9IHVzZXJBZ2VudERhdGFPcHQuYmluZCh1c2VyQWdlbnREYXRhID0+IGRldGVjdEJyb3dzZXIkMShicm93c2VycywgdXNlckFnZW50RGF0YSkpLm9yVGh1bmsoKCkgPT4gZGV0ZWN0QnJvd3Nlcihicm93c2VycywgdXNlckFnZW50KSkuZm9sZChCcm93c2VyLnVua25vd24sIEJyb3dzZXIubnUpO1xuICAgICAgY29uc3Qgb3MgPSBkZXRlY3RPcyhvc2VzLCB1c2VyQWdlbnQpLmZvbGQoT3BlcmF0aW5nU3lzdGVtLnVua25vd24sIE9wZXJhdGluZ1N5c3RlbS5udSk7XG4gICAgICBjb25zdCBkZXZpY2VUeXBlID0gRGV2aWNlVHlwZShvcywgYnJvd3NlciwgdXNlckFnZW50LCBtZWRpYU1hdGNoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJyb3dzZXIsXG4gICAgICAgIG9zLFxuICAgICAgICBkZXZpY2VUeXBlXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgUGxhdGZvcm1EZXRlY3Rpb24gPSB7IGRldGVjdDogZGV0ZWN0JDMgfTtcblxuICAgIGNvbnN0IG1lZGlhTWF0Y2ggPSBxdWVyeSA9PiB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbiAgICBsZXQgcGxhdGZvcm0kNCA9IGNhY2hlZCgoKSA9PiBQbGF0Zm9ybURldGVjdGlvbi5kZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCwgT3B0aW9uYWwuZnJvbShuYXZpZ2F0b3IudXNlckFnZW50RGF0YSksIG1lZGlhTWF0Y2gpKTtcbiAgICBjb25zdCBkZXRlY3QkMiA9ICgpID0+IHBsYXRmb3JtJDQoKTtcblxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgcGxhdGZvcm0kMyA9IGRldGVjdCQyKCk7XG4gICAgY29uc3QgYnJvd3NlciQzID0gcGxhdGZvcm0kMy5icm93c2VyO1xuICAgIGNvbnN0IG9zJDEgPSBwbGF0Zm9ybSQzLm9zO1xuICAgIGNvbnN0IGRldmljZVR5cGUgPSBwbGF0Zm9ybSQzLmRldmljZVR5cGU7XG4gICAgY29uc3Qgd2luZG93c1Bob25lID0gdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSAhPT0gLTE7XG4gICAgY29uc3QgRW52ID0ge1xuICAgICAgdHJhbnNwYXJlbnRTcmM6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnLFxuICAgICAgZG9jdW1lbnRNb2RlOiBicm93c2VyJDMuaXNJRSgpID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IDcgOiAxMCxcbiAgICAgIGNhY2hlU3VmZml4OiBudWxsLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgY2FuSGF2ZUNTUDogIWJyb3dzZXIkMy5pc0lFKCksXG4gICAgICB3aW5kb3dzUGhvbmUsXG4gICAgICBicm93c2VyOiB7XG4gICAgICAgIGN1cnJlbnQ6IGJyb3dzZXIkMy5jdXJyZW50LFxuICAgICAgICB2ZXJzaW9uOiBicm93c2VyJDMudmVyc2lvbixcbiAgICAgICAgaXNDaHJvbWl1bTogYnJvd3NlciQzLmlzQ2hyb21pdW0sXG4gICAgICAgIGlzRWRnZTogYnJvd3NlciQzLmlzRWRnZSxcbiAgICAgICAgaXNGaXJlZm94OiBicm93c2VyJDMuaXNGaXJlZm94LFxuICAgICAgICBpc0lFOiBicm93c2VyJDMuaXNJRSxcbiAgICAgICAgaXNPcGVyYTogYnJvd3NlciQzLmlzT3BlcmEsXG4gICAgICAgIGlzU2FmYXJpOiBicm93c2VyJDMuaXNTYWZhcmlcbiAgICAgIH0sXG4gICAgICBvczoge1xuICAgICAgICBjdXJyZW50OiBvcyQxLmN1cnJlbnQsXG4gICAgICAgIHZlcnNpb246IG9zJDEudmVyc2lvbixcbiAgICAgICAgaXNBbmRyb2lkOiBvcyQxLmlzQW5kcm9pZCxcbiAgICAgICAgaXNDaHJvbWVPUzogb3MkMS5pc0Nocm9tZU9TLFxuICAgICAgICBpc0ZyZWVCU0Q6IG9zJDEuaXNGcmVlQlNELFxuICAgICAgICBpc2lPUzogb3MkMS5pc2lPUyxcbiAgICAgICAgaXNMaW51eDogb3MkMS5pc0xpbnV4LFxuICAgICAgICBpc01hY09TOiBvcyQxLmlzTWFjT1MsXG4gICAgICAgIGlzU29sYXJpczogb3MkMS5pc1NvbGFyaXMsXG4gICAgICAgIGlzV2luZG93czogb3MkMS5pc1dpbmRvd3NcbiAgICAgIH0sXG4gICAgICBkZXZpY2VUeXBlOiB7XG4gICAgICAgIGlzRGVza3RvcDogZGV2aWNlVHlwZS5pc0Rlc2t0b3AsXG4gICAgICAgIGlzaVBhZDogZGV2aWNlVHlwZS5pc2lQYWQsXG4gICAgICAgIGlzaVBob25lOiBkZXZpY2VUeXBlLmlzaVBob25lLFxuICAgICAgICBpc1Bob25lOiBkZXZpY2VUeXBlLmlzUGhvbmUsXG4gICAgICAgIGlzVGFibGV0OiBkZXZpY2VUeXBlLmlzVGFibGV0LFxuICAgICAgICBpc1RvdWNoOiBkZXZpY2VUeXBlLmlzVG91Y2gsXG4gICAgICAgIGlzV2ViVmlldzogZGV2aWNlVHlwZS5pc1dlYlZpZXdcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgd2hpdGVTcGFjZVJlZ0V4cCQxID0gL15cXHMqfFxccyokL2c7XG4gICAgY29uc3QgdHJpbSQyID0gc3RyID0+IHtcbiAgICAgIHJldHVybiBpc051bGxhYmxlKHN0cikgPyAnJyA6ICgnJyArIHN0cikucmVwbGFjZSh3aGl0ZVNwYWNlUmVnRXhwJDEsICcnKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzJDMgPSAob2JqLCB0eXBlKSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhcnJheScgJiYgaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IHR5cGU7XG4gICAgfTtcbiAgICBjb25zdCBtYWtlTWFwJDQgPSAoaXRlbXMsIGRlbGltLCBtYXAgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRJdGVtcyA9IGlzU3RyaW5nKGl0ZW1zKSA/IGl0ZW1zLnNwbGl0KGRlbGltIHx8ICcsJykgOiBpdGVtcyB8fCBbXTtcbiAgICAgIGxldCBpID0gcmVzb2x2ZWRJdGVtcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG1hcFtyZXNvbHZlZEl0ZW1zW2ldXSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIGNvbnN0IGhhc093blByb3BlcnR5JDEgPSBoYXMkMjtcbiAgICBjb25zdCBleHRlbmQkMyA9IChvYmosIC4uLmV4dHMpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBleHQgPSBleHRzW2ldO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXh0KSB7XG4gICAgICAgICAgaWYgKGhhcyQyKGV4dCwgbmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXh0W25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgY29uc3Qgd2FsayQ0ID0gZnVuY3Rpb24gKG8sIGYsIG4sIHMpIHtcbiAgICAgIHMgPSBzIHx8IHRoaXM7XG4gICAgICBpZiAobykge1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIG8gPSBvW25dO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkYyhvLCAobywgaSkgPT4ge1xuICAgICAgICAgIGlmIChmLmNhbGwocywgbywgaSwgbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhbGskNChvLCBmLCBuLCBzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlJDMgPSAobiwgbyA9IHdpbmRvdykgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IG4uc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbyA9IG9bcGF0aFtpXV07XG4gICAgICAgIGlmICghbykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIGNvbnN0IGV4cGxvZGUkMyA9IChzLCBkKSA9PiB7XG4gICAgICBpZiAoaXNBcnJheSQxKHMpKSB7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSBlbHNlIGlmIChzID09PSAnJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFwJDEocy5zcGxpdChkIHx8ICcsJyksIHRyaW0kMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfYWRkQ2FjaGVTdWZmaXggPSB1cmwgPT4ge1xuICAgICAgY29uc3QgY2FjaGVTdWZmaXggPSBFbnYuY2FjaGVTdWZmaXg7XG4gICAgICBpZiAoY2FjaGVTdWZmaXgpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBjYWNoZVN1ZmZpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICBjb25zdCBUb29scyA9IHtcbiAgICAgIHRyaW06IHRyaW0kMixcbiAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICBpczogaXMkMyxcbiAgICAgIHRvQXJyYXk6IHRvQXJyYXkkMSxcbiAgICAgIG1ha2VNYXA6IG1ha2VNYXAkNCxcbiAgICAgIGVhY2g6IGVhY2gkYyxcbiAgICAgIG1hcDogbWFwJDEsXG4gICAgICBncmVwOiBmaWx0ZXIkMyxcbiAgICAgIGluQXJyYXk6IGluZGV4T2YsXG4gICAgICBoYXNPd246IGhhc093blByb3BlcnR5JDEsXG4gICAgICBleHRlbmQ6IGV4dGVuZCQzLFxuICAgICAgd2Fsazogd2FsayQ0LFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSQzLFxuICAgICAgZXhwbG9kZTogZXhwbG9kZSQzLFxuICAgICAgX2FkZENhY2hlU3VmZml4XG4gICAgfTtcblxuICAgIGNvbnN0IGlzJDIgPSAobGhzLCByaHMsIGNvbXBhcmF0b3IgPSB0cmlwbGVFcXVhbHMpID0+IGxocy5leGlzdHMobGVmdCA9PiBjb21wYXJhdG9yKGxlZnQsIHJocykpO1xuICAgIGNvbnN0IGVxdWFscyA9IChsaHMsIHJocywgY29tcGFyYXRvciA9IHRyaXBsZUVxdWFscykgPT4gbGlmdDIobGhzLCByaHMsIGNvbXBhcmF0b3IpLmdldE9yKGxocy5pc05vbmUoKSAmJiByaHMuaXNOb25lKCkpO1xuICAgIGNvbnN0IGNhdCA9IGFyciA9PiB7XG4gICAgICBjb25zdCByID0gW107XG4gICAgICBjb25zdCBwdXNoID0geCA9PiB7XG4gICAgICAgIHIucHVzaCh4KTtcbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0uZWFjaChwdXNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgY29uc3QgbGlmdDIgPSAob2EsIG9iLCBmKSA9PiBvYS5pc1NvbWUoKSAmJiBvYi5pc1NvbWUoKSA/IE9wdGlvbmFsLnNvbWUoZihvYS5nZXRPckRpZSgpLCBvYi5nZXRPckRpZSgpKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgY29uc3QgbGlmdDMgPSAob2EsIG9iLCBvYywgZikgPT4gb2EuaXNTb21lKCkgJiYgb2IuaXNTb21lKCkgJiYgb2MuaXNTb21lKCkgPyBPcHRpb25hbC5zb21lKGYob2EuZ2V0T3JEaWUoKSwgb2IuZ2V0T3JEaWUoKSwgb2MuZ2V0T3JEaWUoKSkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIGNvbnN0IHNvbWVJZiA9IChiLCBhKSA9PiBiID8gT3B0aW9uYWwuc29tZShhKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICAgIGNvbnN0IEdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogRnVuY3Rpb24oJ3JldHVybiB0aGlzOycpKCk7XG5cbiAgICBjb25zdCBwYXRoID0gKHBhcnRzLCBzY29wZSkgPT4ge1xuICAgICAgbGV0IG8gPSBzY29wZSAhPT0gdW5kZWZpbmVkICYmIHNjb3BlICE9PSBudWxsID8gc2NvcGUgOiBHbG9iYWw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAmJiBvICE9PSB1bmRlZmluZWQgJiYgbyAhPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIG8gPSBvW3BhcnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgY29uc3QgcmVzb2x2ZSQyID0gKHAsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHAuc3BsaXQoJy4nKTtcbiAgICAgIHJldHVybiBwYXRoKHBhcnRzLCBzY29wZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHVuc2FmZSA9IChuYW1lLCBzY29wZSkgPT4ge1xuICAgICAgcmV0dXJuIHJlc29sdmUkMihuYW1lLCBzY29wZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRPckRpZSA9IChuYW1lLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgYWN0dWFsID0gdW5zYWZlKG5hbWUsIHNjb3BlKTtcbiAgICAgIGlmIChhY3R1YWwgPT09IHVuZGVmaW5lZCB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG5vdCBhdmFpbGFibGUgb24gdGhpcyBicm93c2VyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0dWFsO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRQcm90b3R5cGVPZiQxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIGNvbnN0IHNhbmRIVE1MRWxlbWVudCA9IHNjb3BlID0+IHtcbiAgICAgIHJldHVybiBnZXRPckRpZSgnSFRNTEVsZW1lbnQnLCBzY29wZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1Byb3RvdHlwZU9mID0geCA9PiB7XG4gICAgICBjb25zdCBzY29wZSA9IHJlc29sdmUkMignb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldycsIHgpO1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIChzYW5kSFRNTEVsZW1lbnQoc2NvcGUpLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHgpIHx8IC9eSFRNTFxcdypFbGVtZW50JC8udGVzdChnZXRQcm90b3R5cGVPZiQxKHgpLmNvbnN0cnVjdG9yLm5hbWUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgQ09NTUVOVCA9IDg7XG4gICAgY29uc3QgRE9DVU1FTlQgPSA5O1xuICAgIGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UID0gMTE7XG4gICAgY29uc3QgRUxFTUVOVCA9IDE7XG4gICAgY29uc3QgVEVYVCA9IDM7XG5cbiAgICBjb25zdCBuYW1lID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCByID0gZWxlbWVudC5kb20ubm9kZU5hbWU7XG4gICAgICByZXR1cm4gci50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgY29uc3QgdHlwZSQxID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5ub2RlVHlwZTtcbiAgICBjb25zdCBpc1R5cGUgPSB0ID0+IGVsZW1lbnQgPT4gdHlwZSQxKGVsZW1lbnQpID09PSB0O1xuICAgIGNvbnN0IGlzQ29tbWVudCQxID0gZWxlbWVudCA9PiB0eXBlJDEoZWxlbWVudCkgPT09IENPTU1FTlQgfHwgbmFtZShlbGVtZW50KSA9PT0gJyNjb21tZW50JztcbiAgICBjb25zdCBpc0hUTUxFbGVtZW50ID0gZWxlbWVudCA9PiBpc0VsZW1lbnQkNyhlbGVtZW50KSAmJiBpc1Byb3RvdHlwZU9mKGVsZW1lbnQuZG9tKTtcbiAgICBjb25zdCBpc0VsZW1lbnQkNyA9IGlzVHlwZShFTEVNRU5UKTtcbiAgICBjb25zdCBpc1RleHQkYiA9IGlzVHlwZShURVhUKTtcbiAgICBjb25zdCBpc0RvY3VtZW50JDIgPSBpc1R5cGUoRE9DVU1FTlQpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnRGcmFnbWVudCQxID0gaXNUeXBlKERPQ1VNRU5UX0ZSQUdNRU5UKTtcbiAgICBjb25zdCBpc1RhZyA9IHRhZyA9PiBlID0+IGlzRWxlbWVudCQ3KGUpICYmIG5hbWUoZSkgPT09IHRhZztcblxuICAgIGNvbnN0IHJhd1NldCA9IChkb20sIGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlICsgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBjYWxsIHRvIEF0dHJpYnV0ZS5zZXQuIEtleSAnLCBrZXksICc6OiBWYWx1ZSAnLCB2YWx1ZSwgJzo6IEVsZW1lbnQgJywgZG9tKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgd2FzIG5vdCBzaW1wbGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldCQzID0gKGVsZW1lbnQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHJhd1NldChlbGVtZW50LmRvbSwga2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRBbGwkMSA9IChlbGVtZW50LCBhdHRycykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBlYWNoJGQoYXR0cnMsICh2LCBrKSA9PiB7XG4gICAgICAgIHJhd1NldChkb20sIGssIHYpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQkOSA9IChlbGVtZW50LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBlbGVtZW50LmRvbS5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIHJldHVybiB2ID09PSBudWxsID8gdW5kZWZpbmVkIDogdjtcbiAgICB9O1xuICAgIGNvbnN0IGdldE9wdCA9IChlbGVtZW50LCBrZXkpID0+IE9wdGlvbmFsLmZyb20oZ2V0JDkoZWxlbWVudCwga2V5KSk7XG4gICAgY29uc3QgaGFzJDEgPSAoZWxlbWVudCwga2V5KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIHJldHVybiBkb20gJiYgZG9tLmhhc0F0dHJpYnV0ZSA/IGRvbS5oYXNBdHRyaWJ1dGUoa2V5KSA6IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJGEgPSAoZWxlbWVudCwga2V5KSA9PiB7XG4gICAgICBlbGVtZW50LmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc05vbmUgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGF0dHJzID0gZWxlbWVudC5kb20uYXR0cmlidXRlcztcbiAgICAgIHJldHVybiBhdHRycyA9PT0gdW5kZWZpbmVkIHx8IGF0dHJzID09PSBudWxsIHx8IGF0dHJzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGNsb25lJDQgPSBlbGVtZW50ID0+IGZvbGRsKGVsZW1lbnQuZG9tLmF0dHJpYnV0ZXMsIChhY2MsIGF0dHIpID0+IHtcbiAgICAgIGFjY1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgY29uc3QgcmVhZCQ0ID0gKGVsZW1lbnQsIGF0dHIpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0JDkoZWxlbWVudCwgYXR0cik7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycgPyBbXSA6IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgfTtcbiAgICBjb25zdCBhZGQkNCA9IChlbGVtZW50LCBhdHRyLCBpZCkgPT4ge1xuICAgICAgY29uc3Qgb2xkID0gcmVhZCQ0KGVsZW1lbnQsIGF0dHIpO1xuICAgICAgY29uc3QgbnUgPSBvbGQuY29uY2F0KFtpZF0pO1xuICAgICAgc2V0JDMoZWxlbWVudCwgYXR0ciwgbnUuam9pbignICcpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDkgPSAoZWxlbWVudCwgYXR0ciwgaWQpID0+IHtcbiAgICAgIGNvbnN0IG51ID0gZmlsdGVyJDUocmVhZCQ0KGVsZW1lbnQsIGF0dHIpLCB2ID0+IHYgIT09IGlkKTtcbiAgICAgIGlmIChudS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldCQzKGVsZW1lbnQsIGF0dHIsIG51LmpvaW4oJyAnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmUkYShlbGVtZW50LCBhdHRyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc3VwcG9ydHMgPSBlbGVtZW50ID0+IGVsZW1lbnQuZG9tLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGdldCQ4ID0gZWxlbWVudCA9PiByZWFkJDQoZWxlbWVudCwgJ2NsYXNzJyk7XG4gICAgY29uc3QgYWRkJDMgPSAoZWxlbWVudCwgY2xhenopID0+IGFkZCQ0KGVsZW1lbnQsICdjbGFzcycsIGNsYXp6KTtcbiAgICBjb25zdCByZW1vdmUkOCA9IChlbGVtZW50LCBjbGF6eikgPT4gcmVtb3ZlJDkoZWxlbWVudCwgJ2NsYXNzJywgY2xhenopO1xuICAgIGNvbnN0IHRvZ2dsZSQyID0gKGVsZW1lbnQsIGNsYXp6KSA9PiB7XG4gICAgICBpZiAoY29udGFpbnMkMihnZXQkOChlbGVtZW50KSwgY2xhenopKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUkOChlbGVtZW50LCBjbGF6eik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYWRkJDMoZWxlbWVudCwgY2xhenopO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBhZGQkMiA9IChlbGVtZW50LCBjbGF6eikgPT4ge1xuICAgICAgaWYgKHN1cHBvcnRzKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuZG9tLmNsYXNzTGlzdC5hZGQoY2xhenopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkJDMoZWxlbWVudCwgY2xhenopO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xlYW5DbGFzcyA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gc3VwcG9ydHMoZWxlbWVudCkgPyBlbGVtZW50LmRvbS5jbGFzc0xpc3QgOiBnZXQkOChlbGVtZW50KTtcbiAgICAgIGlmIChjbGFzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZSRhKGVsZW1lbnQsICdjbGFzcycpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDcgPSAoZWxlbWVudCwgY2xhenopID0+IHtcbiAgICAgIGlmIChzdXBwb3J0cyhlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbGVtZW50LmRvbS5jbGFzc0xpc3Q7XG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhenopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlJDgoZWxlbWVudCwgY2xhenopO1xuICAgICAgfVxuICAgICAgY2xlYW5DbGFzcyhlbGVtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHRvZ2dsZSQxID0gKGVsZW1lbnQsIGNsYXp6KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzdXBwb3J0cyhlbGVtZW50KSA/IGVsZW1lbnQuZG9tLmNsYXNzTGlzdC50b2dnbGUoY2xhenopIDogdG9nZ2xlJDIoZWxlbWVudCwgY2xhenopO1xuICAgICAgY2xlYW5DbGFzcyhlbGVtZW50KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBoYXMgPSAoZWxlbWVudCwgY2xhenopID0+IHN1cHBvcnRzKGVsZW1lbnQpICYmIGVsZW1lbnQuZG9tLmNsYXNzTGlzdC5jb250YWlucyhjbGF6eik7XG5cbiAgICBjb25zdCBmcm9tSHRtbCQxID0gKGh0bWwsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgaWYgKCFkaXYuaGFzQ2hpbGROb2RlcygpIHx8IGRpdi5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdIVE1MIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgcm9vdCBub2RlJztcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBodG1sKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21Eb20kMihkaXYuY2hpbGROb2Rlc1swXSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tVGFnID0gKHRhZywgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3Qgbm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICByZXR1cm4gZnJvbURvbSQyKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVRleHQgPSAodGV4dCwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICAgICAgY29uc3Qgbm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIHJldHVybiBmcm9tRG9tJDIobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tRG9tJDIgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb206IG5vZGUgfTtcbiAgICB9O1xuICAgIGNvbnN0IGZyb21Qb2ludCQyID0gKGRvY0VsbSwgeCwgeSkgPT4gT3B0aW9uYWwuZnJvbShkb2NFbG0uZG9tLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSkpLm1hcChmcm9tRG9tJDIpO1xuICAgIGNvbnN0IFN1Z2FyRWxlbWVudCA9IHtcbiAgICAgIGZyb21IdG1sOiBmcm9tSHRtbCQxLFxuICAgICAgZnJvbVRhZyxcbiAgICAgIGZyb21UZXh0LFxuICAgICAgZnJvbURvbTogZnJvbURvbSQyLFxuICAgICAgZnJvbVBvaW50OiBmcm9tUG9pbnQkMlxuICAgIH07XG5cbiAgICBjb25zdCB0b0FycmF5ID0gKHRhcmdldCwgZikgPT4ge1xuICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGUgPT4ge1xuICAgICAgICByLnB1c2goZSk7XG4gICAgICAgIHJldHVybiBmKGUpO1xuICAgICAgfTtcbiAgICAgIGxldCBjdXIgPSBmKHRhcmdldCk7XG4gICAgICBkbyB7XG4gICAgICAgIGN1ciA9IGN1ci5iaW5kKHJlY3Vyc2UpO1xuICAgICAgfSB3aGlsZSAoY3VyLmlzU29tZSgpKTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICBjb25zdCBpcyQxID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChkb20ubm9kZVR5cGUgIT09IEVMRU1FTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvbTtcbiAgICAgICAgaWYgKGVsZW0ubWF0Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbS5tc01hdGNoZXNTZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBsYWNrcyBuYXRpdmUgc2VsZWN0b3JzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJ5cGFzc1NlbGVjdG9yID0gZG9tID0+IGRvbS5ub2RlVHlwZSAhPT0gRUxFTUVOVCAmJiBkb20ubm9kZVR5cGUgIT09IERPQ1VNRU5UICYmIGRvbS5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfRlJBR01FTlQgfHwgZG9tLmNoaWxkRWxlbWVudENvdW50ID09PSAwO1xuICAgIGNvbnN0IGFsbCA9IChzZWxlY3Rvciwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gZG9jdW1lbnQgOiBzY29wZS5kb207XG4gICAgICByZXR1cm4gYnlwYXNzU2VsZWN0b3IoYmFzZSkgPyBbXSA6IG1hcCQzKGJhc2UucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uZSA9IChzZWxlY3Rvciwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gZG9jdW1lbnQgOiBzY29wZS5kb207XG4gICAgICByZXR1cm4gYnlwYXNzU2VsZWN0b3IoYmFzZSkgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5mcm9tKGJhc2UucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVxID0gKGUxLCBlMikgPT4gZTEuZG9tID09PSBlMi5kb207XG4gICAgY29uc3QgY29udGFpbnMgPSAoZTEsIGUyKSA9PiB7XG4gICAgICBjb25zdCBkMSA9IGUxLmRvbTtcbiAgICAgIGNvbnN0IGQyID0gZTIuZG9tO1xuICAgICAgcmV0dXJuIGQxID09PSBkMiA/IGZhbHNlIDogZDEuY29udGFpbnMoZDIpO1xuICAgIH07XG5cbiAgICBjb25zdCBvd25lciQxID0gZWxlbWVudCA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LmRvbS5vd25lckRvY3VtZW50KTtcbiAgICBjb25zdCBkb2N1bWVudE9yT3duZXIgPSBkb3MgPT4gaXNEb2N1bWVudCQyKGRvcykgPyBkb3MgOiBvd25lciQxKGRvcyk7XG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZWxlbWVudCA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShkb2N1bWVudE9yT3duZXIoZWxlbWVudCkuZG9tLmRvY3VtZW50RWxlbWVudCk7XG4gICAgY29uc3QgZGVmYXVsdFZpZXcgPSBlbGVtZW50ID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb20uZGVmYXVsdFZpZXcpO1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQgPT4gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5wYXJlbnROb2RlKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBlbGVtZW50ID0+IE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ucGFyZW50RWxlbWVudCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBwYXJlbnRzJDEgPSAoZWxlbWVudCwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBzdG9wID0gaXNGdW5jdGlvbihpc1Jvb3QpID8gaXNSb290IDogbmV2ZXI7XG4gICAgICBsZXQgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBkb20ucGFyZW50Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJhd1BhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBwID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocmF3UGFyZW50KTtcbiAgICAgICAgcmV0LnB1c2gocCk7XG4gICAgICAgIGlmIChzdG9wKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tID0gcmF3UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlclNlbGYgPSBlbGVtZW50cyA9PiBmaWx0ZXIkNShlbGVtZW50cywgeCA9PiAhZXEoZWxlbWVudCwgeCkpO1xuICAgICAgcmV0dXJuIHBhcmVudChlbGVtZW50KS5tYXAoY2hpbGRyZW4kMSkubWFwKGZpbHRlclNlbGYpLmdldE9yKFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gZWxlbWVudCA9PiBPcHRpb25hbC5mcm9tKGVsZW1lbnQuZG9tLnByZXZpb3VzU2libGluZykubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IGVsZW1lbnQgPT4gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5uZXh0U2libGluZykubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICBjb25zdCBwcmV2U2libGluZ3MgPSBlbGVtZW50ID0+IHJldmVyc2UodG9BcnJheShlbGVtZW50LCBwcmV2U2libGluZykpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGVsZW1lbnQgPT4gdG9BcnJheShlbGVtZW50LCBuZXh0U2libGluZyk7XG4gICAgY29uc3QgY2hpbGRyZW4kMSA9IGVsZW1lbnQgPT4gbWFwJDMoZWxlbWVudC5kb20uY2hpbGROb2RlcywgU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IGNoaWxkJDEgPSAoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNzID0gZWxlbWVudC5kb20uY2hpbGROb2RlcztcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGNzW2luZGV4XSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBlbGVtZW50ID0+IGNoaWxkJDEoZWxlbWVudCwgMCk7XG4gICAgY29uc3QgbGFzdENoaWxkID0gZWxlbWVudCA9PiBjaGlsZCQxKGVsZW1lbnQsIGVsZW1lbnQuZG9tLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgY2hpbGROb2Rlc0NvdW50ID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBoYXNDaGlsZE5vZGVzID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5oYXNDaGlsZE5vZGVzKCk7XG5cbiAgICBjb25zdCBnZXRIZWFkID0gZG9jID0+IHtcbiAgICAgIGNvbnN0IGIgPSBkb2MuZG9tLmhlYWQ7XG4gICAgICBpZiAoYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkIGlzIG5vdCBhdmFpbGFibGUgeWV0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3VnYXJFbGVtZW50LmZyb21Eb20oYik7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzU2hhZG93Um9vdCA9IGRvcyA9PiBpc0RvY3VtZW50RnJhZ21lbnQkMShkb3MpICYmIGlzTm9uTnVsbGFibGUoZG9zLmRvbS5ob3N0KTtcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSBpc0Z1bmN0aW9uKEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdykgJiYgaXNGdW5jdGlvbihOb2RlLnByb3RvdHlwZS5nZXRSb290Tm9kZSk7XG4gICAgY29uc3QgaXNTdXBwb3J0ZWQkMSA9IGNvbnN0YW50KHN1cHBvcnRlZCk7XG4gICAgY29uc3QgZ2V0Um9vdE5vZGUgPSBzdXBwb3J0ZWQgPyBlID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUuZG9tLmdldFJvb3ROb2RlKCkpIDogZG9jdW1lbnRPck93bmVyO1xuICAgIGNvbnN0IGdldFN0eWxlQ29udGFpbmVyID0gZG9zID0+IGlzU2hhZG93Um9vdChkb3MpID8gZG9zIDogZ2V0SGVhZChkb2N1bWVudE9yT3duZXIoZG9zKSk7XG4gICAgY29uc3QgZ2V0Q29udGVudENvbnRhaW5lciA9IGRvcyA9PiBpc1NoYWRvd1Jvb3QoZG9zKSA/IGRvcyA6IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihkb3MpLmRvbS5ib2R5KTtcbiAgICBjb25zdCBnZXRTaGFkb3dSb290ID0gZSA9PiB7XG4gICAgICBjb25zdCByID0gZ2V0Um9vdE5vZGUoZSk7XG4gICAgICByZXR1cm4gaXNTaGFkb3dSb290KHIpID8gT3B0aW9uYWwuc29tZShyKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNoYWRvd0hvc3QgPSBlID0+IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUuZG9tLmhvc3QpO1xuICAgIGNvbnN0IGdldE9yaWdpbmFsRXZlbnRUYXJnZXQgPSBldmVudCA9PiB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQkMSgpICYmIGlzTm9uTnVsbGFibGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNyhlbCkgJiYgaXNPcGVuU2hhZG93SG9zdChlbCkpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuY29tcG9zZWQgJiYgZXZlbnQuY29tcG9zZWRQYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NlZFBhdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlYWQoY29tcG9zZWRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGV2ZW50LnRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBpc09wZW5TaGFkb3dIb3N0ID0gZWxlbWVudCA9PiBpc05vbk51bGxhYmxlKGVsZW1lbnQuZG9tLnNoYWRvd1Jvb3QpO1xuXG4gICAgY29uc3QgaW5Cb2R5ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBpc1RleHQkYihlbGVtZW50KSA/IGVsZW1lbnQuZG9tLnBhcmVudE5vZGUgOiBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChkb20gPT09IHVuZGVmaW5lZCB8fCBkb20gPT09IG51bGwgfHwgZG9tLm93bmVyRG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZ2V0U2hhZG93Um9vdChTdWdhckVsZW1lbnQuZnJvbURvbShkb20pKS5mb2xkKCgpID0+IGRvYy5ib2R5LmNvbnRhaW5zKGRvbSksIGNvbXBvc2UxKGluQm9keSwgZ2V0U2hhZG93SG9zdCkpO1xuICAgIH07XG5cbiAgICB2YXIgQ2xvc2VzdE9yQW5jZXN0b3IgPSAoaXMsIGFuY2VzdG9yLCBzY29wZSwgYSwgaXNSb290KSA9PiB7XG4gICAgICBpZiAoaXMoc2NvcGUsIGEpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihpc1Jvb3QpICYmIGlzUm9vdChzY29wZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcihzY29wZSwgYSwgaXNSb290KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkNCA9IChzY29wZSwgcHJlZGljYXRlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgY29uc3Qgc3RvcCA9IGlzRnVuY3Rpb24oaXNSb290KSA/IGlzUm9vdCA6IG5ldmVyO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlZGljYXRlKGVsKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9wKGVsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQ0ID0gKHNjb3BlLCBwcmVkaWNhdGUsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgaXMgPSAocywgdGVzdCkgPT4gdGVzdChzKTtcbiAgICAgIHJldHVybiBDbG9zZXN0T3JBbmNlc3RvcihpcywgYW5jZXN0b3IkNCwgc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KTtcbiAgICB9O1xuICAgIGNvbnN0IHNpYmxpbmckMSA9IChzY29wZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZChTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LnBhcmVudE5vZGUpLCB4ID0+ICFlcShzY29wZSwgeCkgJiYgcHJlZGljYXRlKHgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHByZWQgPSBub2RlID0+IHByZWRpY2F0ZShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBmaW5kJDIoc2NvcGUuZG9tLmNoaWxkTm9kZXMsIHByZWQpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIH07XG4gICAgY29uc3QgZGVzY2VuZGFudCQxID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmQgPSBub2RlID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzID0gZGVzY2VuZChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIGlmIChyZXMuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlc2NlbmQoc2NvcGUuZG9tKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMyA9IChzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCkgPT4gYW5jZXN0b3IkNChzY29wZSwgZSA9PiBpcyQxKGUsIHNlbGVjdG9yKSwgaXNSb290KTtcbiAgICBjb25zdCBkZXNjZW5kYW50ID0gKHNjb3BlLCBzZWxlY3RvcikgPT4gb25lKHNlbGVjdG9yLCBzY29wZSk7XG4gICAgY29uc3QgY2xvc2VzdCQzID0gKHNjb3BlLCBzZWxlY3RvciwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBpcyA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gaXMkMShlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gQ2xvc2VzdE9yQW5jZXN0b3IoaXMsIGFuY2VzdG9yJDMsIHNjb3BlLCBzZWxlY3RvciwgaXNSb290KTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvc2VzdCQyID0gdGFyZ2V0ID0+IGNsb3Nlc3QkMyh0YXJnZXQsICdbY29udGVudGVkaXRhYmxlXScpO1xuICAgIGNvbnN0IGlzRWRpdGFibGUkMyA9IChlbGVtZW50LCBhc3N1bWVFZGl0YWJsZSA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAoaW5Cb2R5KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmRvbS5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbG9zZXN0JDIoZWxlbWVudCkuZm9sZChjb25zdGFudChhc3N1bWVFZGl0YWJsZSksIGVkaXRhYmxlID0+IGdldFJhdyQxKGVkaXRhYmxlKSA9PT0gJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFJhdyQxID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5jb250ZW50RWRpdGFibGU7XG5cbiAgICBjb25zdCBpc1N1cHBvcnRlZCA9IGRvbSA9PiBkb20uc3R5bGUgIT09IHVuZGVmaW5lZCAmJiBpc0Z1bmN0aW9uKGRvbS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKTtcblxuICAgIGNvbnN0IGludGVybmFsU2V0ID0gKGRvbSwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIWlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGNhbGwgdG8gQ1NTLnNldC4gUHJvcGVydHkgJywgcHJvcGVydHksICc6OiBWYWx1ZSAnLCB2YWx1ZSwgJzo6IEVsZW1lbnQgJywgZG9tKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1MgdmFsdWUgbXVzdCBiZSBhIHN0cmluZzogJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N1cHBvcnRlZChkb20pKSB7XG4gICAgICAgIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW1vdmUgPSAoZG9tLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKGRvbSkpIHtcbiAgICAgICAgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldCQyID0gKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gICAgICBpbnRlcm5hbFNldChkb20sIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRBbGwgPSAoZWxlbWVudCwgY3NzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGVhY2gkZChjc3MsICh2LCBrKSA9PiB7XG4gICAgICAgIGludGVybmFsU2V0KGRvbSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCQ3ID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSk7XG4gICAgICBjb25zdCByID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHIgPT09ICcnICYmICFpbkJvZHkoZWxlbWVudCkgPyBnZXRVbnNhZmVQcm9wZXJ0eShkb20sIHByb3BlcnR5KSA6IHI7XG4gICAgfTtcbiAgICBjb25zdCBnZXRVbnNhZmVQcm9wZXJ0eSA9IChkb20sIHByb3BlcnR5KSA9PiBpc1N1cHBvcnRlZChkb20pID8gZG9tLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIDogJyc7XG4gICAgY29uc3QgZ2V0UmF3ID0gKGVsZW1lbnQsIHByb3BlcnR5KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGNvbnN0IHJhdyA9IGdldFVuc2FmZVByb3BlcnR5KGRvbSwgcHJvcGVydHkpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20ocmF3KS5maWx0ZXIociA9PiByLmxlbmd0aCA+IDApO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QWxsUmF3ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjc3MgPSB7fTtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKGRvbSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20uc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBydWxlTmFtZSA9IGRvbS5zdHlsZS5pdGVtKGkpO1xuICAgICAgICAgIGNzc1tydWxlTmFtZV0gPSBkb20uc3R5bGVbcnVsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3NzO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDYgPSAoZWxlbWVudCwgcHJvcGVydHkpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgaW50ZXJuYWxSZW1vdmUoZG9tLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoaXMkMihnZXRPcHQoZWxlbWVudCwgJ3N0eWxlJykubWFwKHRyaW0kMyksICcnKSkge1xuICAgICAgICByZW1vdmUkYShlbGVtZW50LCAnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZmxvdyA9IGUgPT4gZS5kb20ub2Zmc2V0V2lkdGg7XG5cbiAgICBjb25zdCBiZWZvcmUkMyA9IChtYXJrZXIsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCQxID0gcGFyZW50KG1hcmtlcik7XG4gICAgICBwYXJlbnQkMS5lYWNoKHYgPT4ge1xuICAgICAgICB2LmRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudC5kb20sIG1hcmtlci5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlciQ0ID0gKG1hcmtlciwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZyA9IG5leHRTaWJsaW5nKG1hcmtlcik7XG4gICAgICBzaWJsaW5nLmZvbGQoKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQkMSA9IHBhcmVudChtYXJrZXIpO1xuICAgICAgICBwYXJlbnQkMS5lYWNoKHYgPT4ge1xuICAgICAgICAgIGFwcGVuZCQxKHYsIGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHYgPT4ge1xuICAgICAgICBiZWZvcmUkMyh2LCBlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGVuZCA9IChwYXJlbnQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQkMSA9IGZpcnN0Q2hpbGQocGFyZW50KTtcbiAgICAgIGZpcnN0Q2hpbGQkMS5mb2xkKCgpID0+IHtcbiAgICAgICAgYXBwZW5kJDEocGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0sIHYgPT4ge1xuICAgICAgICBwYXJlbnQuZG9tLmluc2VydEJlZm9yZShlbGVtZW50LmRvbSwgdi5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmQkMSA9IChwYXJlbnQsIGVsZW1lbnQpID0+IHtcbiAgICAgIHBhcmVudC5kb20uYXBwZW5kQ2hpbGQoZWxlbWVudC5kb20pO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcCQyID0gKGVsZW1lbnQsIHdyYXBwZXIpID0+IHtcbiAgICAgIGJlZm9yZSQzKGVsZW1lbnQsIHdyYXBwZXIpO1xuICAgICAgYXBwZW5kJDEod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFmdGVyJDMgPSAobWFya2VyLCBlbGVtZW50cykgPT4ge1xuICAgICAgZWFjaCRlKGVsZW1lbnRzLCAoeCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBlID0gaSA9PT0gMCA/IG1hcmtlciA6IGVsZW1lbnRzW2kgLSAxXTtcbiAgICAgICAgYWZ0ZXIkNChlLCB4KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kID0gKHBhcmVudCwgZWxlbWVudHMpID0+IHtcbiAgICAgIGVhY2gkZShlbGVtZW50cywgeCA9PiB7XG4gICAgICAgIGFwcGVuZCQxKHBhcmVudCwgeCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZW1wdHkgPSBlbGVtZW50ID0+IHtcbiAgICAgIGVsZW1lbnQuZG9tLnRleHRDb250ZW50ID0gJyc7XG4gICAgICBlYWNoJGUoY2hpbGRyZW4kMShlbGVtZW50KSwgcm9ndWUgPT4ge1xuICAgICAgICByZW1vdmUkNShyb2d1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSQ1ID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIGlmIChkb20ucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW53cmFwID0gd3JhcHBlciA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuJDEod3JhcHBlcik7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBhZnRlciQzKHdyYXBwZXIsIGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSQ1KHdyYXBwZXIpO1xuICAgIH07XG5cbiAgICBjb25zdCBmcm9tSHRtbCA9IChodG1sLCBzY29wZSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gc2NvcGUgfHwgZG9jdW1lbnQ7XG4gICAgICBjb25zdCBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBjaGlsZHJlbiQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRpdikpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbURvbSQxID0gbm9kZXMgPT4gbWFwJDMobm9kZXMsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcblxuICAgIGNvbnN0IGdldCQ2ID0gZWxlbWVudCA9PiBlbGVtZW50LmRvbS5pbm5lckhUTUw7XG4gICAgY29uc3Qgc2V0JDEgPSAoZWxlbWVudCwgY29udGVudCkgPT4ge1xuICAgICAgY29uc3Qgb3duZXIgPSBvd25lciQxKGVsZW1lbnQpO1xuICAgICAgY29uc3QgZG9jRG9tID0gb3duZXIuZG9tO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShkb2NEb20uY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50cyA9IGZyb21IdG1sKGNvbnRlbnQsIGRvY0RvbSk7XG4gICAgICBhcHBlbmQoZnJhZ21lbnQsIGNvbnRlbnRFbGVtZW50cyk7XG4gICAgICBlbXB0eShlbGVtZW50KTtcbiAgICAgIGFwcGVuZCQxKGVsZW1lbnQsIGZyYWdtZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldE91dGVyID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnZGl2Jyk7XG4gICAgICBjb25zdCBjbG9uZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQuZG9tLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICBhcHBlbmQkMShjb250YWluZXIsIGNsb25lKTtcbiAgICAgIHJldHVybiBnZXQkNihjb250YWluZXIpO1xuICAgIH07XG5cbiAgICBjb25zdCBta0V2ZW50ID0gKHRhcmdldCwgeCwgeSwgc3RvcCwgcHJldmVudCwga2lsbCwgcmF3KSA9PiAoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBzdG9wLFxuICAgICAgcHJldmVudCxcbiAgICAgIGtpbGwsXG4gICAgICByYXdcbiAgICB9KTtcbiAgICBjb25zdCBmcm9tUmF3RXZlbnQgPSByYXdFdmVudCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShnZXRPcmlnaW5hbEV2ZW50VGFyZ2V0KHJhd0V2ZW50KS5nZXRPcihyYXdFdmVudC50YXJnZXQpKTtcbiAgICAgIGNvbnN0IHN0b3AgPSAoKSA9PiByYXdFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHByZXZlbnQgPSAoKSA9PiByYXdFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3Qga2lsbCA9IGNvbXBvc2UocHJldmVudCwgc3RvcCk7XG4gICAgICByZXR1cm4gbWtFdmVudCh0YXJnZXQsIHJhd0V2ZW50LmNsaWVudFgsIHJhd0V2ZW50LmNsaWVudFksIHN0b3AsIHByZXZlbnQsIGtpbGwsIHJhd0V2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZSQxID0gKGZpbHRlciwgaGFuZGxlcikgPT4gcmF3RXZlbnQgPT4ge1xuICAgICAgaWYgKGZpbHRlcihyYXdFdmVudCkpIHtcbiAgICAgICAgaGFuZGxlcihmcm9tUmF3RXZlbnQocmF3RXZlbnQpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJpbmRlciA9IChlbGVtZW50LCBldmVudCwgZmlsdGVyLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVkID0gaGFuZGxlJDEoZmlsdGVyLCBoYW5kbGVyKTtcbiAgICAgIGVsZW1lbnQuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHdyYXBwZWQsIHVzZUNhcHR1cmUpO1xuICAgICAgcmV0dXJuIHsgdW5iaW5kOiBjdXJyeSh1bmJpbmQsIGVsZW1lbnQsIGV2ZW50LCB3cmFwcGVkLCB1c2VDYXB0dXJlKSB9O1xuICAgIH07XG4gICAgY29uc3QgYmluZCQyID0gKGVsZW1lbnQsIGV2ZW50LCBmaWx0ZXIsIGhhbmRsZXIpID0+IGJpbmRlcihlbGVtZW50LCBldmVudCwgZmlsdGVyLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgY29uc3QgdW5iaW5kID0gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSA9PiB7XG4gICAgICBlbGVtZW50LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgciA9IChsZWZ0LCB0b3ApID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9ICh4LCB5KSA9PiByKGxlZnQgKyB4LCB0b3AgKyB5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgdHJhbnNsYXRlXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgU3VnYXJQb3NpdGlvbiA9IHI7XG5cbiAgICBjb25zdCBib3hQb3NpdGlvbiA9IGRvbSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4gU3VnYXJQb3NpdGlvbihib3gubGVmdCwgYm94LnRvcCk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJzdERlZmluZWRPclplcm8gPSAoYSwgYikgPT4ge1xuICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiICE9PSB1bmRlZmluZWQgPyBiIDogMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFic29sdXRlID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBlbGVtZW50LmRvbS5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3QgYm9keSA9IGRvYy5ib2R5O1xuICAgICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgY29uc3QgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBpZiAoYm9keSA9PT0gZWxlbWVudC5kb20pIHtcbiAgICAgICAgcmV0dXJuIFN1Z2FyUG9zaXRpb24oYm9keS5vZmZzZXRMZWZ0LCBib2R5Lm9mZnNldFRvcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBmaXJzdERlZmluZWRPclplcm8od2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLnBhZ2VZT2Zmc2V0LCBodG1sLnNjcm9sbFRvcCk7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZmlyc3REZWZpbmVkT3JaZXJvKHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5wYWdlWE9mZnNldCwgaHRtbC5zY3JvbGxMZWZ0KTtcbiAgICAgIGNvbnN0IGNsaWVudFRvcCA9IGZpcnN0RGVmaW5lZE9yWmVybyhodG1sLmNsaWVudFRvcCwgYm9keS5jbGllbnRUb3ApO1xuICAgICAgY29uc3QgY2xpZW50TGVmdCA9IGZpcnN0RGVmaW5lZE9yWmVybyhodG1sLmNsaWVudExlZnQsIGJvZHkuY2xpZW50TGVmdCk7XG4gICAgICByZXR1cm4gdmlld3BvcnQoZWxlbWVudCkudHJhbnNsYXRlKHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0LCBzY3JvbGxUb3AgLSBjbGllbnRUb3ApO1xuICAgIH07XG4gICAgY29uc3Qgdmlld3BvcnQgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgY29uc3QgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gICAgICBpZiAoYm9keSA9PT0gZG9tKSB7XG4gICAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKGJvZHkub2Zmc2V0TGVmdCwgYm9keS5vZmZzZXRUb3ApO1xuICAgICAgfVxuICAgICAgaWYgKCFpbkJvZHkoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN1Z2FyUG9zaXRpb24oMCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94UG9zaXRpb24oZG9tKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0JDUgPSBfRE9DID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IF9ET0MgIT09IHVuZGVmaW5lZCA/IF9ET0MuZG9tIDogZG9jdW1lbnQ7XG4gICAgICBjb25zdCB4ID0gZG9jLmJvZHkuc2Nyb2xsTGVmdCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICBjb25zdCB5ID0gZG9jLmJvZHkuc2Nyb2xsVG9wIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgcmV0dXJuIFN1Z2FyUG9zaXRpb24oeCwgeSk7XG4gICAgfTtcbiAgICBjb25zdCB0byA9ICh4LCB5LCBfRE9DKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBfRE9DICE9PSB1bmRlZmluZWQgPyBfRE9DLmRvbSA6IGRvY3VtZW50O1xuICAgICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgaWYgKHdpbikge1xuICAgICAgICB3aW4uc2Nyb2xsVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRvVmlldyA9IChlbGVtZW50LCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBpc1NhZmFyaSA9IGRldGVjdCQyKCkuYnJvd3Nlci5pc1NhZmFyaSgpO1xuICAgICAgaWYgKGlzU2FmYXJpICYmIGlzRnVuY3Rpb24oZWxlbWVudC5kb20uc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCkpIHtcbiAgICAgICAgZWxlbWVudC5kb20uc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRvbS5zY3JvbGxJbnRvVmlldyhhbGlnblRvVG9wKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0JDQgPSBfd2luID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IF93aW4gPT09IHVuZGVmaW5lZCA/IHdpbmRvdyA6IF93aW47XG4gICAgICBpZiAoZGV0ZWN0JDIoKS5icm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbSh3aW4udmlzdWFsVmlld3BvcnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYm91bmRzID0gKHgsIHksIHdpZHRoLCBoZWlnaHQpID0+ICh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodFxuICAgIH0pO1xuICAgIGNvbnN0IGdldEJvdW5kcyA9IF93aW4gPT4ge1xuICAgICAgY29uc3Qgd2luID0gX3dpbiA9PT0gdW5kZWZpbmVkID8gd2luZG93IDogX3dpbjtcbiAgICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IGdldCQ1KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvYykpO1xuICAgICAgcmV0dXJuIGdldCQ0KHdpbikuZm9sZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICByZXR1cm4gYm91bmRzKHNjcm9sbC5sZWZ0LCBzY3JvbGwudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sIHZpc3VhbFZpZXdwb3J0ID0+IGJvdW5kcyhNYXRoLm1heCh2aXN1YWxWaWV3cG9ydC5wYWdlTGVmdCwgc2Nyb2xsLmxlZnQpLCBNYXRoLm1heCh2aXN1YWxWaWV3cG9ydC5wYWdlVG9wLCBzY3JvbGwudG9wKSwgdmlzdWFsVmlld3BvcnQud2lkdGgsIHZpc3VhbFZpZXdwb3J0LmhlaWdodCkpO1xuICAgIH07XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IChzY29wZSwgcHJlZGljYXRlKSA9PiBmaWx0ZXIkNShjaGlsZHJlbiQxKHNjb3BlKSwgcHJlZGljYXRlKTtcbiAgICBjb25zdCBkZXNjZW5kYW50cyQxID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGVhY2gkZShjaGlsZHJlbiQxKHNjb3BlKSwgeCA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoeCkpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KFt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChkZXNjZW5kYW50cyQxKHgsIHByZWRpY2F0ZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBjb25zdCBkZXNjZW5kYW50cyA9IChzY29wZSwgc2VsZWN0b3IpID0+IGFsbChzZWxlY3Rvciwgc2NvcGUpO1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMiA9IChzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCkgPT4gYW5jZXN0b3IkMyhzY29wZSwgc2VsZWN0b3IsIGlzUm9vdCkuaXNTb21lKCk7XG5cbiAgICBjbGFzcyBEb21UcmVlV2Fsa2VyIHtcbiAgICAgIGNvbnN0cnVjdG9yKHN0YXJ0Tm9kZSwgcm9vdE5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gc3RhcnROb2RlO1xuICAgICAgICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm5leHQgPSB0aGlzLm5leHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdGhpcy5wcmV2LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJldjIgPSB0aGlzLnByZXYyLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgICBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgfVxuICAgICAgbmV4dChzaGFsbG93KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMuZmluZFNpYmxpbmcodGhpcy5ub2RlLCAnZmlyc3RDaGlsZCcsICduZXh0U2libGluZycsIHNoYWxsb3cpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgfVxuICAgICAgcHJldihzaGFsbG93KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMuZmluZFNpYmxpbmcodGhpcy5ub2RlLCAnbGFzdENoaWxkJywgJ3ByZXZpb3VzU2libGluZycsIHNoYWxsb3cpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgfVxuICAgICAgcHJldjIoc2hhbGxvdykge1xuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLmZpbmRQcmV2aW91c05vZGUodGhpcy5ub2RlLCBzaGFsbG93KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICAgIH1cbiAgICAgIGZpbmRTaWJsaW5nKG5vZGUsIHN0YXJ0TmFtZSwgc2libGluZ05hbWUsIHNoYWxsb3cpIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIXNoYWxsb3cgJiYgbm9kZVtzdGFydE5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtzdGFydE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290Tm9kZSkge1xuICAgICAgICAgICAgbGV0IHNpYmxpbmcgPSBub2RlW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9PSB0aGlzLnJvb3ROb2RlOyBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50W3NpYmxpbmdOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZmluZFByZXZpb3VzTm9kZShub2RlLCBzaGFsbG93KSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGlmICh0aGlzLnJvb3ROb2RlICYmIHNpYmxpbmcgPT09IHRoaXMucm9vdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmICghc2hhbGxvdykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IHNpYmxpbmcubGFzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gdGhpcy5yb290Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc05vZGVUeXBlID0gdHlwZSA9PiB7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiAhIW5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gdHlwZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc1Jlc3RyaWN0ZWROb2RlID0gbm9kZSA9PiAhIW5vZGUgJiYgIU9iamVjdC5nZXRQcm90b3R5cGVPZihub2RlKTtcbiAgICBjb25zdCBpc0VsZW1lbnQkNiA9IGlzTm9kZVR5cGUoMSk7XG4gICAgY29uc3QgbWF0Y2hOb2RlTmFtZSA9IG5hbWUgPT4ge1xuICAgICAgY29uc3QgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gbm9kZSA9PiBpc05vbk51bGxhYmxlKG5vZGUpICYmIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJDYXNlZE5hbWU7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaE5vZGVOYW1lcyA9IG5hbWVzID0+IHtcbiAgICAgIGNvbnN0IGxvd2VyQ2FzZWROYW1lcyA9IG5hbWVzLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSk7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMkMihsb3dlckNhc2VkTmFtZXMsIG5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hTdHlsZVZhbHVlcyA9IChuYW1lLCB2YWx1ZXMpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gdmFsdWVzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgICAgICAgICAgICAgY29uc3QgY3NzVmFsdWUgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgOiBudWxsO1xuICAgICAgICAgICAgICBpZiAoY3NzVmFsdWUgPT09IGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc0F0dHJpYnV0ZSA9IGF0dHJOYW1lID0+IHtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBoYXNBdHRyaWJ1dGVWYWx1ZSA9IChhdHRyTmFtZSwgYXR0clZhbHVlKSA9PiB7XG4gICAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT09IGF0dHJWYWx1ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc0JvZ3VzJDIgPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpO1xuICAgIGNvbnN0IGlzQm9ndXNBbGwkMSA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgPT09ICdhbGwnO1xuICAgIGNvbnN0IGlzVGFibGUkMiA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS50YWdOYW1lID09PSAnVEFCTEUnO1xuICAgIGNvbnN0IGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gdmFsdWUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXNUZXh0YXJlYU9ySW5wdXQgPSBtYXRjaE5vZGVOYW1lcyhbXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ2lucHV0J1xuICAgIF0pO1xuICAgIGNvbnN0IGlzVGV4dCRhID0gaXNOb2RlVHlwZSgzKTtcbiAgICBjb25zdCBpc0NEYXRhID0gaXNOb2RlVHlwZSg0KTtcbiAgICBjb25zdCBpc1BpID0gaXNOb2RlVHlwZSg3KTtcbiAgICBjb25zdCBpc0NvbW1lbnQgPSBpc05vZGVUeXBlKDgpO1xuICAgIGNvbnN0IGlzRG9jdW1lbnQkMSA9IGlzTm9kZVR5cGUoOSk7XG4gICAgY29uc3QgaXNEb2N1bWVudEZyYWdtZW50ID0gaXNOb2RlVHlwZSgxMSk7XG4gICAgY29uc3QgaXNCciQ2ID0gbWF0Y2hOb2RlTmFtZSgnYnInKTtcbiAgICBjb25zdCBpc0ltZyA9IG1hdGNoTm9kZU5hbWUoJ2ltZycpO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzID0gaGFzQ29udGVudEVkaXRhYmxlU3RhdGUoJ3RydWUnKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIgPSBoYXNDb250ZW50RWRpdGFibGVTdGF0ZSgnZmFsc2UnKTtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbCQzID0gbWF0Y2hOb2RlTmFtZXMoW1xuICAgICAgJ3RkJyxcbiAgICAgICd0aCdcbiAgICBdKTtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbE9yQ2FwdGlvbiA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICd0ZCcsXG4gICAgICAndGgnLFxuICAgICAgJ2NhcHRpb24nXG4gICAgXSk7XG4gICAgY29uc3QgaXNNZWRpYSQyID0gbWF0Y2hOb2RlTmFtZXMoW1xuICAgICAgJ3ZpZGVvJyxcbiAgICAgICdhdWRpbycsXG4gICAgICAnb2JqZWN0JyxcbiAgICAgICdlbWJlZCdcbiAgICBdKTtcbiAgICBjb25zdCBpc0xpc3RJdGVtJDIgPSBtYXRjaE5vZGVOYW1lKCdsaScpO1xuICAgIGNvbnN0IGlzRGV0YWlscyA9IG1hdGNoTm9kZU5hbWUoJ2RldGFpbHMnKTtcbiAgICBjb25zdCBpc1N1bW1hcnkgPSBtYXRjaE5vZGVOYW1lKCdzdW1tYXJ5Jyk7XG5cbiAgICBjb25zdCB6ZXJvV2lkdGggPSAnXFx1RkVGRic7XG4gICAgY29uc3QgbmJzcCA9ICdcXHhBMCc7XG4gICAgY29uc3QgaXNad3NwJDIgPSBjaGFyID0+IGNoYXIgPT09IHplcm9XaWR0aDtcbiAgICBjb25zdCByZW1vdmVad3NwID0gcyA9PiBzLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpO1xuXG4gICAgY29uc3QgTm9kZVZhbHVlID0gKGlzLCBuYW1lKSA9PiB7XG4gICAgICBjb25zdCBnZXQgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKCFpcyhlbGVtZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgZ2V0ICcgKyBuYW1lICsgJyB2YWx1ZSBvZiBhICcgKyBuYW1lICsgJyBub2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldE9wdGlvbihlbGVtZW50KS5nZXRPcignJyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0T3B0aW9uID0gZWxlbWVudCA9PiBpcyhlbGVtZW50KSA/IE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ubm9kZVZhbHVlKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIGNvbnN0IHNldCA9IChlbGVtZW50LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIWlzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBzZXQgcmF3ICcgKyBuYW1lICsgJyB2YWx1ZSBvZiBhICcgKyBuYW1lICsgJyBub2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5kb20ubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXRPcHRpb24sXG4gICAgICAgIHNldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpJDEgPSBOb2RlVmFsdWUoaXNUZXh0JGIsICd0ZXh0Jyk7XG4gICAgY29uc3QgZ2V0JDMgPSBlbGVtZW50ID0+IGFwaSQxLmdldChlbGVtZW50KTtcbiAgICBjb25zdCBnZXRPcHRpb24gPSBlbGVtZW50ID0+IGFwaSQxLmdldE9wdGlvbihlbGVtZW50KTtcbiAgICBjb25zdCBzZXQgPSAoZWxlbWVudCwgdmFsdWUpID0+IGFwaSQxLnNldChlbGVtZW50LCB2YWx1ZSk7XG5cbiAgICBjb25zdCBibG9ja3MgPSBbXG4gICAgICAnYXJ0aWNsZScsXG4gICAgICAnYXNpZGUnLFxuICAgICAgJ2RldGFpbHMnLFxuICAgICAgJ2RpdicsXG4gICAgICAnZHQnLFxuICAgICAgJ2ZpZ2NhcHRpb24nLFxuICAgICAgJ2Zvb3RlcicsXG4gICAgICAnZm9ybScsXG4gICAgICAnZmllbGRzZXQnLFxuICAgICAgJ2hlYWRlcicsXG4gICAgICAnaGdyb3VwJyxcbiAgICAgICdodG1sJyxcbiAgICAgICdtYWluJyxcbiAgICAgICduYXYnLFxuICAgICAgJ3NlY3Rpb24nLFxuICAgICAgJ3N1bW1hcnknLFxuICAgICAgJ2JvZHknLFxuICAgICAgJ3AnLFxuICAgICAgJ2RsJyxcbiAgICAgICdtdWx0aWNvbCcsXG4gICAgICAnZGQnLFxuICAgICAgJ2ZpZ3VyZScsXG4gICAgICAnYWRkcmVzcycsXG4gICAgICAnY2VudGVyJyxcbiAgICAgICdibG9ja3F1b3RlJyxcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2JyxcbiAgICAgICdsaXN0aW5nJyxcbiAgICAgICd4bXAnLFxuICAgICAgJ3ByZScsXG4gICAgICAncGxhaW50ZXh0JyxcbiAgICAgICdtZW51JyxcbiAgICAgICdkaXInLFxuICAgICAgJ3VsJyxcbiAgICAgICdvbCcsXG4gICAgICAnbGknLFxuICAgICAgJ2hyJyxcbiAgICAgICd0YWJsZScsXG4gICAgICAndGJvZHknLFxuICAgICAgJ3RoZWFkJyxcbiAgICAgICd0Zm9vdCcsXG4gICAgICAndGgnLFxuICAgICAgJ3RyJyxcbiAgICAgICd0ZCcsXG4gICAgICAnY2FwdGlvbidcbiAgICBdO1xuICAgIGNvbnN0IHRhYmxlQ2VsbHMgPSBbXG4gICAgICAndGQnLFxuICAgICAgJ3RoJ1xuICAgIF07XG4gICAgY29uc3QgdGFibGVTZWN0aW9ucyA9IFtcbiAgICAgICd0aGVhZCcsXG4gICAgICAndGJvZHknLFxuICAgICAgJ3Rmb290J1xuICAgIF07XG4gICAgY29uc3QgdGV4dEJsb2NrcyA9IFtcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2JyxcbiAgICAgICdwJyxcbiAgICAgICdkaXYnLFxuICAgICAgJ2FkZHJlc3MnLFxuICAgICAgJ3ByZScsXG4gICAgICAnZm9ybScsXG4gICAgICAnYmxvY2txdW90ZScsXG4gICAgICAnY2VudGVyJyxcbiAgICAgICdkaXInLFxuICAgICAgJ2ZpZWxkc2V0JyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJ2Zvb3RlcicsXG4gICAgICAnYXJ0aWNsZScsXG4gICAgICAnc2VjdGlvbicsXG4gICAgICAnaGdyb3VwJyxcbiAgICAgICdhc2lkZScsXG4gICAgICAnbmF2JyxcbiAgICAgICdmaWd1cmUnXG4gICAgXTtcbiAgICBjb25zdCBoZWFkaW5ncyA9IFtcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2J1xuICAgIF07XG4gICAgY29uc3QgbGlzdEl0ZW1zJDEgPSBbXG4gICAgICAnbGknLFxuICAgICAgJ2RkJyxcbiAgICAgICdkdCdcbiAgICBdO1xuICAgIGNvbnN0IGxpc3RzID0gW1xuICAgICAgJ3VsJyxcbiAgICAgICdvbCcsXG4gICAgICAnZGwnXG4gICAgXTtcbiAgICBjb25zdCB3c0VsZW1lbnRzID0gW1xuICAgICAgJ3ByZScsXG4gICAgICAnc2NyaXB0JyxcbiAgICAgICd0ZXh0YXJlYScsXG4gICAgICAnc3R5bGUnXG4gICAgXTtcbiAgICBjb25zdCB3cmFwQmxvY2tFbGVtZW50cyA9IFsncHJlJ10uY29uY2F0KGhlYWRpbmdzKTtcbiAgICBjb25zdCBsYXp5TG9va3VwID0gaXRlbXMgPT4ge1xuICAgICAgbGV0IGxvb2t1cDtcbiAgICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgICAgbG9va3VwID0gbG9va3VwID8gbG9va3VwIDogbWFwVG9PYmplY3QoaXRlbXMsIGFsd2F5cyk7XG4gICAgICAgIHJldHVybiBoYXMkMihsb29rdXAsIG5hbWUobm9kZSkpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmxvY2skMiA9IGxhenlMb29rdXAoYmxvY2tzKTtcbiAgICBjb25zdCBpc1RhYmxlJDEgPSBub2RlID0+IG5hbWUobm9kZSkgPT09ICd0YWJsZSc7XG4gICAgY29uc3QgaXNJbmxpbmUkMSA9IG5vZGUgPT4gaXNFbGVtZW50JDcobm9kZSkgJiYgIWlzQmxvY2skMihub2RlKTtcbiAgICBjb25zdCBpc0JyJDUgPSBub2RlID0+IGlzRWxlbWVudCQ3KG5vZGUpICYmIG5hbWUobm9kZSkgPT09ICdicic7XG4gICAgY29uc3QgaXNUZXh0QmxvY2skMiA9IGxhenlMb29rdXAodGV4dEJsb2Nrcyk7XG4gICAgY29uc3QgaXNMaXN0ID0gbGF6eUxvb2t1cChsaXN0cyk7XG4gICAgY29uc3QgaXNMaXN0SXRlbSQxID0gbGF6eUxvb2t1cChsaXN0SXRlbXMkMSk7XG4gICAgY29uc3QgaXNUYWJsZVNlY3Rpb24gPSBsYXp5TG9va3VwKHRhYmxlU2VjdGlvbnMpO1xuICAgIGNvbnN0IGlzVGFibGVDZWxsJDIgPSBsYXp5TG9va3VwKHRhYmxlQ2VsbHMpO1xuICAgIGNvbnN0IGlzV3NQcmVzZXJ2ZUVsZW1lbnQgPSBsYXp5TG9va3VwKHdzRWxlbWVudHMpO1xuICAgIGNvbnN0IGlzV3JhcEJsb2NrRWxlbWVudCA9IGxhenlMb29rdXAod3JhcEJsb2NrRWxlbWVudHMpO1xuICAgIGNvbnN0IGlzV3JhcEVsZW1lbnQgPSBub2RlID0+IGlzV3JhcEJsb2NrRWxlbWVudChub2RlKSB8fCBpc0lubGluZSQxKG5vZGUpO1xuXG4gICAgY29uc3QgZ2V0TGFzdENoaWxkcmVuJDEgPSBlbG0gPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgIGxldCByYXdOb2RlID0gZWxtLmRvbTtcbiAgICAgIHdoaWxlIChyYXdOb2RlKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goU3VnYXJFbGVtZW50LmZyb21Eb20ocmF3Tm9kZSkpO1xuICAgICAgICByYXdOb2RlID0gcmF3Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVUcmFpbGluZ0JyID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGFsbEJycyA9IGRlc2NlbmRhbnRzKGVsbSwgJ2JyJyk7XG4gICAgICBjb25zdCBicnMgPSBmaWx0ZXIkNShnZXRMYXN0Q2hpbGRyZW4kMShlbG0pLnNsaWNlKC0xKSwgaXNCciQ1KTtcbiAgICAgIGlmIChhbGxCcnMubGVuZ3RoID09PSBicnMubGVuZ3RoKSB7XG4gICAgICAgIGVhY2gkZShicnMsIHJlbW92ZSQ1KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBhZGRpbmdCciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJyID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJyk7XG4gICAgICBzZXQkMyhiciwgJ2RhdGEtbWNlLWJvZ3VzJywgJzEnKTtcbiAgICAgIHJldHVybiBicjtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxXaXRoUGFkZGluZ0JyID0gZWxtID0+IHtcbiAgICAgIGVtcHR5KGVsbSk7XG4gICAgICBhcHBlbmQkMShlbG0sIGNyZWF0ZVBhZGRpbmdCcigpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1CbG9ja1RyYWlsaW5nQnIgPSBlbG0gPT4ge1xuICAgICAgbGFzdENoaWxkKGVsbSkuZWFjaChsYXN0Q2hpbGQgPT4ge1xuICAgICAgICBwcmV2U2libGluZyhsYXN0Q2hpbGQpLmVhY2gobGFzdENoaWxkUHJldlNpYmxpbmcgPT4ge1xuICAgICAgICAgIGlmIChpc0Jsb2NrJDIoZWxtKSAmJiBpc0JyJDUobGFzdENoaWxkKSAmJiBpc0Jsb2NrJDIobGFzdENoaWxkUHJldlNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZW1vdmUkNShsYXN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgWldTUCQxID0gemVyb1dpZHRoO1xuICAgIGNvbnN0IGlzWndzcCQxID0gaXNad3NwJDI7XG4gICAgY29uc3QgdHJpbSQxID0gcmVtb3ZlWndzcDtcblxuICAgIGNvbnN0IGlzRWxlbWVudCQ1ID0gaXNFbGVtZW50JDY7XG4gICAgY29uc3QgaXNUZXh0JDkgPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyQmxvY2skMSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKGlzVGV4dCQ5KG5vZGUpKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbGVtZW50JDUobm9kZSkgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVySW5saW5lID0gbm9kZSA9PiBpc1RleHQkOShub2RlKSAmJiBpc1p3c3AkMShub2RlLmRhdGEpO1xuICAgIGNvbnN0IGlzQ2FyZXRDb250YWluZXIkMiA9IG5vZGUgPT4gaXNDYXJldENvbnRhaW5lckJsb2NrJDEobm9kZSkgfHwgaXNDYXJldENvbnRhaW5lcklubGluZShub2RlKTtcbiAgICBjb25zdCBoYXNDb250ZW50ID0gbm9kZSA9PiBub2RlLmZpcnN0Q2hpbGQgIT09IG5vZGUubGFzdENoaWxkIHx8ICFpc0JyJDYobm9kZS5maXJzdENoaWxkKTtcbiAgICBjb25zdCBpbnNlcnRJbmxpbmUkMSA9IChub2RlLCBiZWZvcmUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRvYyA9IChfYSA9IG5vZGUub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnQ7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZShaV1NQJDEpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmICghYmVmb3JlKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoaXNUZXh0JDkoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLnNwbGl0VGV4dCgxKTtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKGlzVGV4dCQ5KHNpYmxpbmcpKSB7XG4gICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMihzaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEoc2libGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLnNwbGl0VGV4dChzaWJsaW5nLmRhdGEubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH07XG4gICAgY29uc3QgaXNCZWZvcmVJbmxpbmUgPSBwb3MgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgaWYgKCFpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIuZGF0YS5jaGFyQXQocG9zLm9mZnNldCgpKSA9PT0gWldTUCQxIHx8IHBvcy5pc0F0U3RhcnQoKSAmJiBpc0NhcmV0Q29udGFpbmVySW5saW5lKGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgaXNBZnRlcklubGluZSA9IHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBpZiAoIWlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lci5kYXRhLmNoYXJBdChwb3Mub2Zmc2V0KCkgLSAxKSA9PT0gWldTUCQxIHx8IHBvcy5pc0F0RW5kKCkgJiYgaXNDYXJldENvbnRhaW5lcklubGluZShjb250YWluZXIubmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QmxvY2sgPSAoYmxvY2tOYW1lLCBub2RlLCBiZWZvcmUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRvYyA9IChfYSA9IG5vZGUub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnQ7XG4gICAgICBjb25zdCBibG9ja05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChibG9ja05hbWUpO1xuICAgICAgYmxvY2tOb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnLCBiZWZvcmUgPyAnYmVmb3JlJyA6ICdhZnRlcicpO1xuICAgICAgYmxvY2tOb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnLCAnYWxsJyk7XG4gICAgICBibG9ja05vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlUGFkZGluZ0JyKCkuZG9tKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmxvY2tOb2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnROb2RlID09PSBudWxsIHx8IHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYmxvY2tOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Tm9kZSA9PT0gbnVsbCB8fCBwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnROb2RlLmluc2VydEJlZm9yZShibG9ja05vZGUsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2NrTm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciQxID0gbm9kZSA9PiBpc1RleHQkOShub2RlKSAmJiBub2RlLmRhdGFbMF0gPT09IFpXU1AkMTtcbiAgICBjb25zdCBlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEgPSBub2RlID0+IGlzVGV4dCQ5KG5vZGUpICYmIG5vZGUuZGF0YVtub2RlLmRhdGEubGVuZ3RoIC0gMV0gPT09IFpXU1AkMTtcbiAgICBjb25zdCB0cmltQm9ndXNCciA9IGVsbSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBicnMgPSBlbG0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JyJyk7XG4gICAgICBjb25zdCBsYXN0QnIgPSBicnNbYnJzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlzQm9ndXMkMihsYXN0QnIpKSB7XG4gICAgICAgIChfYSA9IGxhc3RCci5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQobGFzdEJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNob3dDYXJldENvbnRhaW5lckJsb2NrID0gY2FyZXRDb250YWluZXIgPT4ge1xuICAgICAgaWYgKGNhcmV0Q29udGFpbmVyICYmIGNhcmV0Q29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSkge1xuICAgICAgICB0cmltQm9ndXNCcihjYXJldENvbnRhaW5lcik7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKTtcbiAgICAgICAgY2FyZXRDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpO1xuICAgICAgICBjYXJldENvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3R5bGUnKTtcbiAgICAgICAgY2FyZXRDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdfbW96X2Fic3BvcycpO1xuICAgICAgICByZXR1cm4gY2FyZXRDb250YWluZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyQmxvY2sgPSByYW5nZSA9PiBpc0NhcmV0Q29udGFpbmVyQmxvY2skMShyYW5nZS5zdGFydENvbnRhaW5lcik7XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMiA9IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYjtcbiAgICBjb25zdCBpc0JyJDQgPSBpc0JyJDY7XG4gICAgY29uc3QgaXNUZXh0JDggPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0ludmFsaWRUZXh0RWxlbWVudCA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICdzY3JpcHQnLFxuICAgICAgJ3N0eWxlJyxcbiAgICAgICd0ZXh0YXJlYSdcbiAgICBdKTtcbiAgICBjb25zdCBpc0F0b21pY0lubGluZSA9IG1hdGNoTm9kZU5hbWVzKFtcbiAgICAgICdpbWcnLFxuICAgICAgJ2lucHV0JyxcbiAgICAgICd0ZXh0YXJlYScsXG4gICAgICAnaHInLFxuICAgICAgJ2lmcmFtZScsXG4gICAgICAndmlkZW8nLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdvYmplY3QnLFxuICAgICAgJ2VtYmVkJ1xuICAgIF0pO1xuICAgIGNvbnN0IGlzVGFibGUgPSBtYXRjaE5vZGVOYW1lcyhbJ3RhYmxlJ10pO1xuICAgIGNvbnN0IGlzQ2FyZXRDb250YWluZXIkMSA9IGlzQ2FyZXRDb250YWluZXIkMjtcbiAgICBjb25zdCBpc0NhcmV0Q2FuZGlkYXRlJDMgPSBub2RlID0+IHtcbiAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDEobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dCQ4KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAhaXNJbnZhbGlkVGV4dEVsZW1lbnQobm9kZS5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0F0b21pY0lubGluZShub2RlKSB8fCBpc0JyJDQobm9kZSkgfHwgaXNUYWJsZShub2RlKSB8fCBpc05vblVpQ29udGVudEVkaXRhYmxlRmFsc2Uobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1Vuc2VsZWN0YWJsZSA9IG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScpID09PSAndHJ1ZSc7XG4gICAgY29uc3QgaXNOb25VaUNvbnRlbnRFZGl0YWJsZUZhbHNlID0gbm9kZSA9PiAhaXNVbnNlbGVjdGFibGUobm9kZSkgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRhKG5vZGUpO1xuICAgIGNvbnN0IGlzSW5FZGl0YWJsZSA9IChub2RlLCByb290KSA9PiB7XG4gICAgICBmb3IgKGxldCB0ZW1wTm9kZSA9IG5vZGUucGFyZW50Tm9kZTsgdGVtcE5vZGUgJiYgdGVtcE5vZGUgIT09IHJvb3Q7IHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoaXNOb25VaUNvbnRlbnRFZGl0YWJsZUZhbHNlKHRlbXBOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVUcnVlJDIodGVtcE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNBdG9taWNDb250ZW50RWRpdGFibGVGYWxzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFpc05vblVpQ29udGVudEVkaXRhYmxlRmFsc2Uobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFmb2xkbChmcm9tKG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSksIChyZXN1bHQsIGVsbSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQyKGVsbSk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0F0b21pYyQxID0gbm9kZSA9PiBpc0F0b21pY0lubGluZShub2RlKSB8fCBpc0F0b21pY0NvbnRlbnRFZGl0YWJsZUZhbHNlKG5vZGUpO1xuICAgIGNvbnN0IGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSQxID0gKG5vZGUsIHJvb3QpID0+IGlzQ2FyZXRDYW5kaWRhdGUkMyhub2RlKSAmJiBpc0luRWRpdGFibGUobm9kZSwgcm9vdCk7XG5cbiAgICBjb25zdCB3aGl0ZVNwYWNlUmVnRXhwID0gL15bIFxcdFxcclxcbl0qJC87XG4gICAgY29uc3QgaXNXaGl0ZXNwYWNlVGV4dCA9IHRleHQgPT4gd2hpdGVTcGFjZVJlZ0V4cC50ZXN0KHRleHQpO1xuICAgIGNvbnN0IGlzWndzcCA9IHRleHQgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIHRleHQpIHtcbiAgICAgICAgaWYgKCFpc1p3c3AkMihjKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZSQxID0gYyA9PiAnIFxcZlxcdFxceDBCJy5pbmRleE9mKGMpICE9PSAtMTtcbiAgICBjb25zdCBpc05ld0xpbmVDaGFyID0gYyA9PiBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJztcbiAgICBjb25zdCBpc05ld2xpbmUgPSAodGV4dCwgaWR4KSA9PiBpZHggPCB0ZXh0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlzTmV3TGluZUNoYXIodGV4dFtpZHhdKSA6IGZhbHNlO1xuICAgIGNvbnN0IG5vcm1hbGl6ZSQ0ID0gKHRleHQsIHRhYlNwYWNlcyA9IDQsIGlzU3RhcnRPZkNvbnRlbnQgPSB0cnVlLCBpc0VuZE9mQ29udGVudCA9IHRydWUpID0+IHtcbiAgICAgIGNvbnN0IHRhYlNwYWNlID0gcmVwZWF0KCcgJywgdGFiU3BhY2VzKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHQvZywgdGFiU3BhY2UpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9sZGwobm9ybWFsaXplZFRleHQsIChhY2MsIGMpID0+IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2libGVXaGl0ZXNwYWNlJDEoYykgfHwgYyA9PT0gbmJzcCkge1xuICAgICAgICAgIGlmIChhY2MucGNJc1NwYWNlIHx8IGFjYy5zdHIgPT09ICcnICYmIGlzU3RhcnRPZkNvbnRlbnQgfHwgYWNjLnN0ci5sZW5ndGggPT09IG5vcm1hbGl6ZWRUZXh0Lmxlbmd0aCAtIDEgJiYgaXNFbmRPZkNvbnRlbnQgfHwgaXNOZXdsaW5lKG5vcm1hbGl6ZWRUZXh0LCBhY2Muc3RyLmxlbmd0aCArIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgICBzdHI6IGFjYy5zdHIgKyBuYnNwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwY0lzU3BhY2U6IHRydWUsXG4gICAgICAgICAgICAgIHN0cjogYWNjLnN0ciArICcgJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBjSXNTcGFjZTogaXNOZXdMaW5lQ2hhcihjKSxcbiAgICAgICAgICAgIHN0cjogYWNjLnN0ciArIGNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBjSXNTcGFjZTogZmFsc2UsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdHI7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQcmVzZXJ2ZVBhcmVudCA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSk7XG4gICAgICBjb25zdCBzdGFydE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIHJldHVybiBhbmNlc3RvciQyKHN0YXJ0Tm9kZSwgJ3ByZSxjb2RlJywgY3VycnkoZXEsIHJvb3RFbGVtZW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1doaXRlc3BhY2UkMSA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIGlzVGV4dCRhKG5vZGUpICYmIGlzV2hpdGVzcGFjZVRleHQobm9kZS5kYXRhKSAmJiAhaGFzV2hpdGVzcGFjZVByZXNlcnZlUGFyZW50KG5vZGUsIHJvb3ROb2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTmFtZWRBbmNob3IgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLm5vZGVOYW1lID09PSAnQScgJiYgIW5vZGUuaGFzQXR0cmlidXRlKCdocmVmJykgJiYgKG5vZGUuaGFzQXR0cmlidXRlKCduYW1lJykgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ2lkJykpO1xuICAgIH07XG4gICAgY29uc3QgaXNDb250ZW50JDEgPSAobm9kZSwgcm9vdE5vZGUpID0+IHtcbiAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMobm9kZSkgJiYgIWlzV2hpdGVzcGFjZSQxKG5vZGUsIHJvb3ROb2RlKSB8fCBpc05hbWVkQW5jaG9yKG5vZGUpIHx8IGlzQm9va21hcmsobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Jvb2ttYXJrID0gaGFzQXR0cmlidXRlKCdkYXRhLW1jZS1ib29rbWFyaycpO1xuICAgIGNvbnN0IGlzQm9ndXMkMSA9IGhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKTtcbiAgICBjb25zdCBpc0JvZ3VzQWxsID0gaGFzQXR0cmlidXRlVmFsdWUoJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgIGNvbnN0IGlzRW1wdHlOb2RlID0gKHRhcmdldE5vZGUsIHNraXBCb2d1cykgPT4ge1xuICAgICAgbGV0IGJyQ291bnQgPSAwO1xuICAgICAgaWYgKGlzQ29udGVudCQxKHRhcmdldE5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBub2RlID0gdGFyZ2V0Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChza2lwQm9ndXMpIHtcbiAgICAgICAgICAgIGlmIChpc0JvZ3VzQWxsKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb2d1cyQxKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQnIkNihub2RlKSkge1xuICAgICAgICAgICAgYnJDb3VudCsrO1xuICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29udGVudCQxKG5vZGUsIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChub2RlKTtcbiAgICAgICAgcmV0dXJuIGJyQ291bnQgPD0gMTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMiA9IChlbG0sIHNraXBCb2d1cyA9IHRydWUpID0+IGlzRW1wdHlOb2RlKGVsbS5kb20sIHNraXBCb2d1cyk7XG5cbiAgICBjb25zdCB0cmFuc3BhcmVudEJsb2NrQXR0ciA9ICdkYXRhLW1jZS1ibG9jayc7XG4gICAgY29uc3QgZWxlbWVudE5hbWVzID0gbWFwID0+IGZpbHRlciQ1KGtleXMobWFwKSwga2V5ID0+ICEvW0EtWl0vLnRlc3Qoa2V5KSk7XG4gICAgY29uc3QgbWFrZVNlbGVjdG9yRnJvbVNjaGVtYU1hcCA9IG1hcCA9PiBlbGVtZW50TmFtZXMobWFwKS5qb2luKCcsJyk7XG4gICAgY29uc3QgdXBkYXRlVHJhbnNwYXJlbnQgPSAoYmxvY2tzU2VsZWN0b3IsIHRyYW5zcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZSh0cmFuc3BhcmVudC5xdWVyeVNlbGVjdG9yKGJsb2Nrc1NlbGVjdG9yKSkpIHtcbiAgICAgICAgdHJhbnNwYXJlbnQuc2V0QXR0cmlidXRlKHRyYW5zcGFyZW50QmxvY2tBdHRyLCAndHJ1ZScpO1xuICAgICAgICBpZiAodHJhbnNwYXJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1zZWxlY3RlZCcpID09PSAnaW5saW5lLWJvdW5kYXJ5Jykge1xuICAgICAgICAgIHRyYW5zcGFyZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zcGFyZW50LnJlbW92ZUF0dHJpYnV0ZSh0cmFuc3BhcmVudEJsb2NrQXR0cik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuID0gKHNjaGVtYSwgc2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50U2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRUcmFuc3BhcmVudEVsZW1lbnRzKCkpO1xuICAgICAgY29uc3QgYmxvY2tzU2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwodHJhbnNwYXJlbnRTZWxlY3RvciksIHRyYW5zcGFyZW50ID0+IHVwZGF0ZVRyYW5zcGFyZW50KGJsb2Nrc1NlbGVjdG9yLCB0cmFuc3BhcmVudCkpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUVkZ2UgPSAoZWwsIGxlZnRTaWRlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjaGlsZFByb3BlcnR5TmFtZSA9IGxlZnRTaWRlID8gJ2xhc3RDaGlsZCcgOiAnZmlyc3RDaGlsZCc7XG4gICAgICBmb3IgKGxldCBjaGlsZCA9IGVsW2NoaWxkUHJvcGVydHlOYW1lXTsgY2hpbGQ7IGNoaWxkID0gY2hpbGRbY2hpbGRQcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgIGlmIChpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oY2hpbGQpKSkge1xuICAgICAgICAgIChfYSA9IGNoaWxkLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzcGxpdCQyID0gKHBhcmVudEVsbSwgc3BsaXRFbG0pID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKHBhcmVudEVsbSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShzcGxpdEVsbSk7XG4gICAgICAgIGNvbnN0IGJlZm9yZUZyYWdtZW50ID0gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgICAgIHRyaW1FZGdlKGJlZm9yZUZyYWdtZW50LCB0cnVlKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihzcGxpdEVsbSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKHBhcmVudEVsbSk7XG4gICAgICAgIGNvbnN0IGFmdGVyRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgdHJpbUVkZ2UoYWZ0ZXJGcmFnbWVudCwgZmFsc2UpO1xuICAgICAgICBpZiAoIWlzRW1wdHkkMihTdWdhckVsZW1lbnQuZnJvbURvbShiZWZvcmVGcmFnbWVudCkpKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYmVmb3JlRnJhZ21lbnQsIHBhcmVudEVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20oc3BsaXRFbG0pKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwbGl0RWxtLCBwYXJlbnRFbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbXB0eSQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGFmdGVyRnJhZ21lbnQpKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGFmdGVyRnJhZ21lbnQsIHBhcmVudEVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnRFbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3BsaXRJbnZhbGlkQ2hpbGRyZW4gPSAoc2NoZW1hLCBzY29wZSwgdHJhbnNwYXJlbnRCbG9ja3MpID0+IHtcbiAgICAgIGNvbnN0IGJsb2Nrc0VsZW1lbnRzID0gc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20oc2NvcGUpO1xuICAgICAgY29uc3QgaXNCbG9jayA9IGVsID0+IG5hbWUoZWwpIGluIGJsb2Nrc0VsZW1lbnRzO1xuICAgICAgY29uc3QgaXNSb290ID0gZWwgPT4gZXEoZWwsIHJvb3ROb2RlKTtcbiAgICAgIGVhY2gkZShmcm9tRG9tJDEodHJhbnNwYXJlbnRCbG9ja3MpLCB0cmFuc3BhcmVudEJsb2NrID0+IHtcbiAgICAgICAgYW5jZXN0b3IkNCh0cmFuc3BhcmVudEJsb2NrLCBpc0Jsb2NrLCBpc1Jvb3QpLmVhY2gocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICAgIGNvbnN0IGludmFsaWRDaGlsZHJlbiA9IGNoaWxkcmVuKHRyYW5zcGFyZW50QmxvY2ssIGVsID0+IGlzQmxvY2soZWwpICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKG5hbWUocGFyZW50QmxvY2spLCBuYW1lKGVsKSkpO1xuICAgICAgICAgIGlmIChpbnZhbGlkQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVTY29wZSA9IHBhcmVudEVsZW1lbnQocGFyZW50QmxvY2spO1xuICAgICAgICAgICAgZWFjaCRlKGludmFsaWRDaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgICBhbmNlc3RvciQ0KGNoaWxkLCBpc0Jsb2NrLCBpc1Jvb3QpLmVhY2gocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIHNwbGl0JDIocGFyZW50QmxvY2suZG9tLCBjaGlsZC5kb20pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGVTY29wZS5lYWNoKHNjb3BlID0+IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuKHNjaGVtYSwgc2NvcGUuZG9tKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdW53cmFwSW52YWxpZENoaWxkcmVuID0gKHNjaGVtYSwgc2NvcGUsIHRyYW5zcGFyZW50QmxvY2tzKSA9PiB7XG4gICAgICBlYWNoJGUoW1xuICAgICAgICAuLi50cmFuc3BhcmVudEJsb2NrcyxcbiAgICAgICAgLi4uaXNUcmFuc3BhcmVudEJsb2NrKHNjaGVtYSwgc2NvcGUpID8gW3Njb3BlXSA6IFtdXG4gICAgICBdLCBibG9jayA9PiBlYWNoJGUoZGVzY2VuZGFudHMoU3VnYXJFbGVtZW50LmZyb21Eb20oYmxvY2spLCBibG9jay5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSwgZWxtID0+IHtcbiAgICAgICAgaWYgKGlzVHJhbnNwYXJlbnRJbmxpbmUoc2NoZW1hLCBlbG0uZG9tKSkge1xuICAgICAgICAgIHVud3JhcChlbG0pO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDaGlsZHJlbiA9IChzY2hlbWEsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudEJsb2NrcyA9IHVwZGF0ZUJsb2NrU3RhdGVPbkNoaWxkcmVuKHNjaGVtYSwgc2NvcGUpO1xuICAgICAgc3BsaXRJbnZhbGlkQ2hpbGRyZW4oc2NoZW1hLCBzY29wZSwgdHJhbnNwYXJlbnRCbG9ja3MpO1xuICAgICAgdW53cmFwSW52YWxpZENoaWxkcmVuKHNjaGVtYSwgc2NvcGUsIHRyYW5zcGFyZW50QmxvY2tzKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVsZW1lbnQgPSAoc2NoZW1hLCB0YXJnZXQpID0+IHtcbiAgICAgIGlmIChpc1RyYW5zcGFyZW50RWxlbWVudChzY2hlbWEsIHRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tzU2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JGcm9tU2NoZW1hTWFwKHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgICB1cGRhdGVUcmFuc3BhcmVudChibG9ja3NTZWxlY3RvciwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUNhcmV0ID0gKHNjaGVtYSwgcm9vdCwgY2FyZXRQYXJlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsID0+IGVxKGVsLCBTdWdhckVsZW1lbnQuZnJvbURvbShyb290KSk7XG4gICAgICBjb25zdCBwYXJlbnRzID0gcGFyZW50cyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGNhcmV0UGFyZW50KSwgaXNSb290KTtcbiAgICAgIGdldCRiKHBhcmVudHMsIHBhcmVudHMubGVuZ3RoIC0gMikuZmlsdGVyKGlzRWxlbWVudCQ3KS5mb2xkKCgpID0+IHVwZGF0ZUNoaWxkcmVuKHNjaGVtYSwgcm9vdCksIHNjb3BlID0+IHVwZGF0ZUNoaWxkcmVuKHNjaGVtYSwgc2NvcGUuZG9tKSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNCbG9ja0F0dHIgPSBlbCA9PiBlbC5oYXNBdHRyaWJ1dGUodHJhbnNwYXJlbnRCbG9ja0F0dHIpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnRFbGVtZW50TmFtZSA9IChzY2hlbWEsIG5hbWUpID0+IGhhcyQyKHNjaGVtYS5nZXRUcmFuc3BhcmVudEVsZW1lbnRzKCksIG5hbWUpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnRFbGVtZW50ID0gKHNjaGVtYSwgbm9kZSkgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgaXNUcmFuc3BhcmVudEVsZW1lbnROYW1lKHNjaGVtYSwgbm9kZS5ub2RlTmFtZSk7XG4gICAgY29uc3QgaXNUcmFuc3BhcmVudEJsb2NrID0gKHNjaGVtYSwgbm9kZSkgPT4gaXNUcmFuc3BhcmVudEVsZW1lbnQoc2NoZW1hLCBub2RlKSAmJiBoYXNCbG9ja0F0dHIobm9kZSk7XG4gICAgY29uc3QgaXNUcmFuc3BhcmVudElubGluZSA9IChzY2hlbWEsIG5vZGUpID0+IGlzVHJhbnNwYXJlbnRFbGVtZW50KHNjaGVtYSwgbm9kZSkgJiYgIWhhc0Jsb2NrQXR0cihub2RlKTtcbiAgICBjb25zdCBpc1RyYW5zcGFyZW50QXN0QmxvY2sgPSAoc2NoZW1hLCBub2RlKSA9PiBub2RlLnR5cGUgPT09IDEgJiYgaXNUcmFuc3BhcmVudEVsZW1lbnROYW1lKHNjaGVtYSwgbm9kZS5uYW1lKSAmJiBpc1N0cmluZyhub2RlLmF0dHIodHJhbnNwYXJlbnRCbG9ja0F0dHIpKTtcblxuICAgIGNvbnN0IGJyb3dzZXIkMiA9IGRldGVjdCQyKCkuYnJvd3NlcjtcbiAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBub2RlcyA9PiBmaW5kJDIobm9kZXMsIGlzRWxlbWVudCQ3KTtcbiAgICBjb25zdCBnZXRUYWJsZUNhcHRpb25EZWx0YVkgPSBlbG0gPT4ge1xuICAgICAgaWYgKGJyb3dzZXIkMi5pc0ZpcmVmb3goKSAmJiBuYW1lKGVsbSkgPT09ICd0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0RWxlbWVudChjaGlsZHJlbiQxKGVsbSkpLmZpbHRlcihlbG0gPT4ge1xuICAgICAgICAgIHJldHVybiBuYW1lKGVsbSkgPT09ICdjYXB0aW9uJztcbiAgICAgICAgfSkuYmluZChjYXB0aW9uID0+IHtcbiAgICAgICAgICByZXR1cm4gZmlyc3RFbGVtZW50KG5leHRTaWJsaW5ncyhjYXB0aW9uKSkubWFwKGJvZHkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9keVRvcCA9IGJvZHkuZG9tLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGNvbnN0IGNhcHRpb25Ub3AgPSBjYXB0aW9uLmRvbS5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjb25zdCBjYXB0aW9uSGVpZ2h0ID0gY2FwdGlvbi5kb20ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGJvZHlUb3AgPD0gY2FwdGlvblRvcCA/IC1jYXB0aW9uSGVpZ2h0IDogMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuZ2V0T3IoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0NoaWxkID0gKGVsbSwgY2hpbGQpID0+IGVsbS5jaGlsZHJlbiAmJiBjb250YWlucyQyKGVsbS5jaGlsZHJlbiwgY2hpbGQpO1xuICAgIGNvbnN0IGdldFBvcyA9IChib2R5LCBlbG0sIHJvb3RFbG0pID0+IHtcbiAgICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgICBjb25zdCBkb2MgPSBib2R5Lm93bmVyRG9jdW1lbnQ7XG4gICAgICByb290RWxtID0gcm9vdEVsbSA/IHJvb3RFbG0gOiBib2R5O1xuICAgICAgaWYgKGVsbSkge1xuICAgICAgICBpZiAocm9vdEVsbSA9PT0gYm9keSAmJiBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGdldCQ3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJvZHkpLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBjb25zdCBwb3MgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgeCA9IHBvcy5sZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRMZWZ0O1xuICAgICAgICAgIHkgPSBwb3MudG9wICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wKSAtIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50VG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldFBhcmVudCA9IGVsbTtcbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IHJvb3RFbG0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlICYmICFoYXNDaGlsZChvZmZzZXRQYXJlbnQsIHJvb3RFbG0pKSB7XG4gICAgICAgICAgY29uc3QgY2FzdE9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcbiAgICAgICAgICB4ICs9IGNhc3RPZmZzZXRQYXJlbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgIHkgKz0gY2FzdE9mZnNldFBhcmVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBjYXN0T2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IHJvb3RFbG0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlICYmICFoYXNDaGlsZChvZmZzZXRQYXJlbnQsIHJvb3RFbG0pKSB7XG4gICAgICAgICAgeCAtPSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICAgIHkgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHkgKz0gZ2V0VGFibGVDYXB0aW9uRGVsdGFZKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgU3R5bGVTaGVldExvYWRlciA9IChkb2N1bWVudE9yU2hhZG93Um9vdCwgc2V0dGluZ3MgPSB7fSkgPT4ge1xuICAgICAgbGV0IGlkQ291bnQgPSAwO1xuICAgICAgY29uc3QgbG9hZGVkU3RhdGVzID0ge307XG4gICAgICBjb25zdCBlZG9zID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnRPclNoYWRvd1Jvb3QpO1xuICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRPck93bmVyKGVkb3MpO1xuICAgICAgY29uc3QgX3NldFJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3kgPT4ge1xuICAgICAgICBzZXR0aW5ncy5yZWZlcnJlclBvbGljeSA9IHJlZmVycmVyUG9saWN5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IF9zZXRDb250ZW50Q3NzQ29ycyA9IGNvbnRlbnRDc3NDb3JzID0+IHtcbiAgICAgICAgc2V0dGluZ3MuY29udGVudENzc0NvcnMgPSBjb250ZW50Q3NzQ29ycztcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRTdHlsZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBhcHBlbmQkMShnZXRTdHlsZUNvbnRhaW5lcihlZG9zKSwgZWxlbWVudCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlU3R5bGUgPSBpZCA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlQ29udGFpbmVyID0gZ2V0U3R5bGVDb250YWluZXIoZWRvcyk7XG4gICAgICAgIGRlc2NlbmRhbnQoc3R5bGVDb250YWluZXIsICcjJyArIGlkKS5lYWNoKHJlbW92ZSQ1KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRPckNyZWF0ZVN0YXRlID0gdXJsID0+IGdldCRhKGxvYWRlZFN0YXRlcywgdXJsKS5nZXRPclRodW5rKCgpID0+ICh7XG4gICAgICAgIGlkOiAnbWNlLXUnICsgaWRDb3VudCsrLFxuICAgICAgICBwYXNzZWQ6IFtdLFxuICAgICAgICBmYWlsZWQ6IFtdLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfSkpO1xuICAgICAgY29uc3QgbG9hZCA9IHVybCA9PiBuZXcgUHJvbWlzZSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICBsZXQgbGluaztcbiAgICAgICAgY29uc3QgdXJsV2l0aFN1ZmZpeCA9IFRvb2xzLl9hZGRDYWNoZVN1ZmZpeCh1cmwpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlU3RhdGUodXJsV2l0aFN1ZmZpeCk7XG4gICAgICAgIGxvYWRlZFN0YXRlc1t1cmxXaXRoU3VmZml4XSA9IHN0YXRlO1xuICAgICAgICBzdGF0ZS5jb3VudCsrO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKGNhbGxiYWNrcywgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGNhbGxiYWNrcywgY2FsbCk7XG4gICAgICAgICAgc3RhdGUuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIHN0YXRlLnBhc3NlZCA9IFtdO1xuICAgICAgICAgIHN0YXRlLmZhaWxlZCA9IFtdO1xuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgbGluayA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzZWQgPSAoKSA9PiByZXNvbHZlKHN0YXRlLnBhc3NlZCwgMik7XG4gICAgICAgIGNvbnN0IGZhaWxlZCA9ICgpID0+IHJlc29sdmUoc3RhdGUuZmFpbGVkLCAzKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdGF0ZS5wYXNzZWQucHVzaChzdWNjZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgIHN0YXRlLmZhaWxlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gMikge1xuICAgICAgICAgIHBhc3NlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAzKSB7XG4gICAgICAgICAgZmFpbGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YXR1cyA9IDE7XG4gICAgICAgIGNvbnN0IGxpbmtFbGVtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2xpbmsnLCBkb2MuZG9tKTtcbiAgICAgICAgc2V0QWxsJDEobGlua0VsZW0sIHtcbiAgICAgICAgICByZWw6ICdzdHlsZXNoZWV0JyxcbiAgICAgICAgICB0eXBlOiAndGV4dC9jc3MnLFxuICAgICAgICAgIGlkOiBzdGF0ZS5pZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNvbnRlbnRDc3NDb3JzKSB7XG4gICAgICAgICAgc2V0JDMobGlua0VsZW0sICdjcm9zc09yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgICAgICBzZXQkMyhsaW5rRWxlbSwgJ3JlZmVycmVycG9saWN5Jywgc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBsaW5rRWxlbS5kb207XG4gICAgICAgIGxpbmsub25sb2FkID0gcGFzc2VkO1xuICAgICAgICBsaW5rLm9uZXJyb3IgPSBmYWlsZWQ7XG4gICAgICAgIGFkZFN0eWxlKGxpbmtFbGVtKTtcbiAgICAgICAgc2V0JDMobGlua0VsZW0sICdocmVmJywgdXJsV2l0aFN1ZmZpeCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxvYWRBbGwgPSB1cmxzID0+IHtcbiAgICAgICAgY29uc3QgbG9hZGVkVXJscyA9IFByb21pc2UuYWxsU2V0dGxlZChtYXAkMyh1cmxzLCB1cmwgPT4gbG9hZCh1cmwpLnRoZW4oY29uc3RhbnQodXJsKSkpKTtcbiAgICAgICAgcmV0dXJuIGxvYWRlZFVybHMudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBhcnRpdGlvbiQyKHJlc3VsdHMsIHIgPT4gci5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKTtcbiAgICAgICAgICBpZiAocGFydHMuZmFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFwJDMocGFydHMuZmFpbCwgcmVzdWx0ID0+IHJlc3VsdC5yZWFzb24pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hcCQzKHBhcnRzLnBhc3MsIHJlc3VsdCA9PiByZXN1bHQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5sb2FkID0gdXJsID0+IHtcbiAgICAgICAgY29uc3QgdXJsV2l0aFN1ZmZpeCA9IFRvb2xzLl9hZGRDYWNoZVN1ZmZpeCh1cmwpO1xuICAgICAgICBnZXQkYShsb2FkZWRTdGF0ZXMsIHVybFdpdGhTdWZmaXgpLmVhY2goc3RhdGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gLS1zdGF0ZS5jb3VudDtcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkZWRTdGF0ZXNbdXJsV2l0aFN1ZmZpeF07XG4gICAgICAgICAgICByZW1vdmVTdHlsZShzdGF0ZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmxvYWRBbGwgPSB1cmxzID0+IHtcbiAgICAgICAgZWFjaCRlKHVybHMsIHVybCA9PiB7XG4gICAgICAgICAgdW5sb2FkKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWQsXG4gICAgICAgIGxvYWRBbGwsXG4gICAgICAgIHVubG9hZCxcbiAgICAgICAgdW5sb2FkQWxsLFxuICAgICAgICBfc2V0UmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIF9zZXRDb250ZW50Q3NzQ29yc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlJGQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgY29uc3QgZm9yRWxlbWVudCA9IChyZWZlcmVuY2VFbGVtZW50LCBzZXR0aW5ncykgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gZ2V0Um9vdE5vZGUocmVmZXJlbmNlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJvb3REb20gPSByb290LmRvbTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20obWFwLmdldChyb290RG9tKSkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2wgPSBTdHlsZVNoZWV0TG9hZGVyKHJvb3REb20sIHNldHRpbmdzKTtcbiAgICAgICAgICBtYXAuc2V0KHJvb3REb20sIHNsKTtcbiAgICAgICAgICByZXR1cm4gc2w7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGZvckVsZW1lbnQgfTtcbiAgICB9O1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3JlYXRlJGQoKTtcblxuICAgIGNvbnN0IGlzU3BhbiA9IG5vZGUgPT4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3Bhbic7XG4gICAgY29uc3QgaXNJbmxpbmVDb250ZW50ID0gKG5vZGUsIHJvb3QpID0+IGlzTm9uTnVsbGFibGUobm9kZSkgJiYgKGlzQ29udGVudCQxKG5vZGUsIHJvb3QpIHx8IGlzSW5saW5lJDEoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpKTtcbiAgICBjb25zdCBzdXJyb3VuZGVkQnlJbmxpbmVDb250ZW50ID0gKG5vZGUsIHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IHByZXYgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCByb290KS5wcmV2KGZhbHNlKTtcbiAgICAgIGNvbnN0IG5leHQgPSBuZXcgRG9tVHJlZVdhbGtlcihub2RlLCByb290KS5uZXh0KGZhbHNlKTtcbiAgICAgIGNvbnN0IHByZXZJc0lubGluZSA9IGlzVW5kZWZpbmVkKHByZXYpIHx8IGlzSW5saW5lQ29udGVudChwcmV2LCByb290KTtcbiAgICAgIGNvbnN0IG5leHRJc0lubGluZSA9IGlzVW5kZWZpbmVkKG5leHQpIHx8IGlzSW5saW5lQ29udGVudChuZXh0LCByb290KTtcbiAgICAgIHJldHVybiBwcmV2SXNJbmxpbmUgJiYgbmV4dElzSW5saW5lO1xuICAgIH07XG4gICAgY29uc3QgaXNCb29rbWFya05vZGUkMiA9IG5vZGUgPT4gaXNTcGFuKG5vZGUpICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS10eXBlJykgPT09ICdib29rbWFyayc7XG4gICAgY29uc3QgaXNLZWVwVGV4dE5vZGUgPSAobm9kZSwgcm9vdCkgPT4gaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDAgJiYgc3Vycm91bmRlZEJ5SW5saW5lQ29udGVudChub2RlLCByb290KTtcbiAgICBjb25zdCBpc0tlZXBFbGVtZW50ID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwIDogZmFsc2U7XG4gICAgY29uc3QgaXNEb2N1bWVudCA9IG5vZGUgPT4gaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHx8IGlzRG9jdW1lbnQkMShub2RlKTtcbiAgICBjb25zdCB0cmltTm9kZSA9IChkb20sIG5vZGUsIHJvb3QpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcm9vdCB8fCBub2RlO1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGlzQm9va21hcmtOb2RlJDIobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0cmltTm9kZShkb20sIGNoaWxkcmVuW2ldLCByb290Tm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY3VycmVudENoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBpc0Jvb2ttYXJrTm9kZSQyKGN1cnJlbnRDaGlsZHJlblswXSkpIHtcbiAgICAgICAgICAoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUoY3VycmVudENoaWxkcmVuWzBdLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0RvY3VtZW50KG5vZGUpICYmICFpc0NvbnRlbnQkMShub2RlLCByb290Tm9kZSkgJiYgIWlzS2VlcEVsZW1lbnQobm9kZSkgJiYgIWlzS2VlcFRleHROb2RlKG5vZGUsIHJvb3ROb2RlKSkge1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VNYXAkMyA9IFRvb2xzLm1ha2VNYXA7XG4gICAgY29uc3QgYXR0cnNDaGFyc1JlZ0V4cCA9IC9bJjw+XFxcIlxcdTAwNjBcXHUwMDdFLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRUZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcbiAgICBjb25zdCB0ZXh0Q2hhcnNSZWdFeHAgPSAvWzw+JlxcdTAwN0UtXFx1RDdGRlxcdUUwMDAtXFx1RkZFRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIGNvbnN0IHJhd0NoYXJzUmVnRXhwID0gL1s8PiZcXFwiXFwnXS9nO1xuICAgIGNvbnN0IGVudGl0eVJlZ0V4cCA9IC8mIyhbYS16MC05XSspOz98JihbYS16MC05XSspOy9naTtcbiAgICBjb25zdCBhc2NpaU1hcCA9IHtcbiAgICAgIDEyODogJ1xcdTIwQUMnLFxuICAgICAgMTMwOiAnXFx1MjAxQScsXG4gICAgICAxMzE6ICdcXHUwMTkyJyxcbiAgICAgIDEzMjogJ1xcdTIwMUUnLFxuICAgICAgMTMzOiAnXFx1MjAyNicsXG4gICAgICAxMzQ6ICdcXHUyMDIwJyxcbiAgICAgIDEzNTogJ1xcdTIwMjEnLFxuICAgICAgMTM2OiAnXFx1MDJjNicsXG4gICAgICAxMzc6ICdcXHUyMDMwJyxcbiAgICAgIDEzODogJ1xcdTAxNjAnLFxuICAgICAgMTM5OiAnXFx1MjAzOScsXG4gICAgICAxNDA6ICdcXHUwMTUyJyxcbiAgICAgIDE0MjogJ1xcdTAxN2QnLFxuICAgICAgMTQ1OiAnXFx1MjAxOCcsXG4gICAgICAxNDY6ICdcXHUyMDE5JyxcbiAgICAgIDE0NzogJ1xcdTIwMUMnLFxuICAgICAgMTQ4OiAnXFx1MjAxRCcsXG4gICAgICAxNDk6ICdcXHUyMDIyJyxcbiAgICAgIDE1MDogJ1xcdTIwMTMnLFxuICAgICAgMTUxOiAnXFx1MjAxNCcsXG4gICAgICAxNTI6ICdcXHUwMkRDJyxcbiAgICAgIDE1MzogJ1xcdTIxMjInLFxuICAgICAgMTU0OiAnXFx1MDE2MScsXG4gICAgICAxNTU6ICdcXHUyMDNBJyxcbiAgICAgIDE1NjogJ1xcdTAxNTMnLFxuICAgICAgMTU4OiAnXFx1MDE3ZScsXG4gICAgICAxNTk6ICdcXHUwMTc4J1xuICAgIH07XG4gICAgY29uc3QgYmFzZUVudGl0aWVzID0ge1xuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAnXFwnJzogJyYjMzk7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnYCc6ICcmIzk2OydcbiAgICB9O1xuICAgIGNvbnN0IHJldmVyc2VFbnRpdGllcyA9IHtcbiAgICAgICcmbHQ7JzogJzwnLFxuICAgICAgJyZndDsnOiAnPicsXG4gICAgICAnJmFtcDsnOiAnJicsXG4gICAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAgICcmYXBvczsnOiBgJ2BcbiAgICB9O1xuICAgIGNvbnN0IG5hdGl2ZURlY29kZSA9IHRleHQgPT4ge1xuICAgICAgY29uc3QgZWxtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2RpdicpLmRvbTtcbiAgICAgIGVsbS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGVsbS50ZXh0Q29udGVudCB8fCBlbG0uaW5uZXJUZXh0IHx8IHRleHQ7XG4gICAgfTtcbiAgICBjb25zdCBidWlsZEVudGl0aWVzTG9va3VwID0gKGl0ZW1zLCByYWRpeCkgPT4ge1xuICAgICAgY29uc3QgbG9va3VwID0ge307XG4gICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgY29uc3QgaXRlbUxpc3QgPSBpdGVtcy5zcGxpdCgnLCcpO1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1MaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChpdGVtTGlzdFtpXSwgcmFkaXgpKTtcbiAgICAgICAgICBpZiAoIWJhc2VFbnRpdGllc1tjaHJdKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSAnJicgKyBpdGVtTGlzdFtpICsgMV0gKyAnOyc7XG4gICAgICAgICAgICBsb29rdXBbY2hyXSA9IGVudGl0eTtcbiAgICAgICAgICAgIGxvb2t1cFtlbnRpdHldID0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5hbWVkRW50aXRpZXMgPSBidWlsZEVudGl0aWVzTG9va3VwKCc1MCxuYnNwLDUxLGlleGNsLDUyLGNlbnQsNTMscG91bmQsNTQsY3VycmVuLDU1LHllbiw1NixicnZiYXIsNTcsc2VjdCw1OCx1bWwsNTksY29weSwnICsgJzVhLG9yZGYsNWIsbGFxdW8sNWMsbm90LDVkLHNoeSw1ZSxyZWcsNWYsbWFjciw1ZyxkZWcsNWgscGx1c21uLDVpLHN1cDIsNWosc3VwMyw1ayxhY3V0ZSwnICsgJzVsLG1pY3JvLDVtLHBhcmEsNW4sbWlkZG90LDVvLGNlZGlsLDVwLHN1cDEsNXEsb3JkbSw1cixyYXF1byw1cyxmcmFjMTQsNXQsZnJhYzEyLDV1LGZyYWMzNCwnICsgJzV2LGlxdWVzdCw2MCxBZ3JhdmUsNjEsQWFjdXRlLDYyLEFjaXJjLDYzLEF0aWxkZSw2NCxBdW1sLDY1LEFyaW5nLDY2LEFFbGlnLDY3LENjZWRpbCwnICsgJzY4LEVncmF2ZSw2OSxFYWN1dGUsNmEsRWNpcmMsNmIsRXVtbCw2YyxJZ3JhdmUsNmQsSWFjdXRlLDZlLEljaXJjLDZmLEl1bWwsNmcsRVRILDZoLE50aWxkZSwnICsgJzZpLE9ncmF2ZSw2aixPYWN1dGUsNmssT2NpcmMsNmwsT3RpbGRlLDZtLE91bWwsNm4sdGltZXMsNm8sT3NsYXNoLDZwLFVncmF2ZSw2cSxVYWN1dGUsJyArICc2cixVY2lyYyw2cyxVdW1sLDZ0LFlhY3V0ZSw2dSxUSE9STiw2dixzemxpZyw3MCxhZ3JhdmUsNzEsYWFjdXRlLDcyLGFjaXJjLDczLGF0aWxkZSw3NCxhdW1sLCcgKyAnNzUsYXJpbmcsNzYsYWVsaWcsNzcsY2NlZGlsLDc4LGVncmF2ZSw3OSxlYWN1dGUsN2EsZWNpcmMsN2IsZXVtbCw3YyxpZ3JhdmUsN2QsaWFjdXRlLDdlLGljaXJjLCcgKyAnN2YsaXVtbCw3ZyxldGgsN2gsbnRpbGRlLDdpLG9ncmF2ZSw3aixvYWN1dGUsN2ssb2NpcmMsN2wsb3RpbGRlLDdtLG91bWwsN24sZGl2aWRlLDdvLG9zbGFzaCwnICsgJzdwLHVncmF2ZSw3cSx1YWN1dGUsN3IsdWNpcmMsN3MsdXVtbCw3dCx5YWN1dGUsN3UsdGhvcm4sN3YseXVtbCxjaSxmbm9mLHNoLEFscGhhLHNpLEJldGEsJyArICdzaixHYW1tYSxzayxEZWx0YSxzbCxFcHNpbG9uLHNtLFpldGEsc24sRXRhLHNvLFRoZXRhLHNwLElvdGEsc3EsS2FwcGEsc3IsTGFtYmRhLHNzLE11LCcgKyAnc3QsTnUsc3UsWGksc3YsT21pY3Jvbix0MCxQaSx0MSxSaG8sdDMsU2lnbWEsdDQsVGF1LHQ1LFVwc2lsb24sdDYsUGhpLHQ3LENoaSx0OCxQc2ksJyArICd0OSxPbWVnYSx0aCxhbHBoYSx0aSxiZXRhLHRqLGdhbW1hLHRrLGRlbHRhLHRsLGVwc2lsb24sdG0semV0YSx0bixldGEsdG8sdGhldGEsdHAsaW90YSwnICsgJ3RxLGthcHBhLHRyLGxhbWJkYSx0cyxtdSx0dCxudSx0dSx4aSx0dixvbWljcm9uLHUwLHBpLHUxLHJobyx1MixzaWdtYWYsdTMsc2lnbWEsdTQsdGF1LCcgKyAndTUsdXBzaWxvbix1NixwaGksdTcsY2hpLHU4LHBzaSx1OSxvbWVnYSx1aCx0aGV0YXN5bSx1aSx1cHNpaCx1bSxwaXYsODEyLGJ1bGwsODE2LGhlbGxpcCwnICsgJzgxaSxwcmltZSw4MWosUHJpbWUsODF1LG9saW5lLDgyNCxmcmFzbCw4OG8sd2VpZXJwLDg4aCxpbWFnZSw4OHMscmVhbCw4OTIsdHJhZGUsODlsLGFsZWZzeW0sJyArICc4Y2csbGFyciw4Y2gsdWFyciw4Y2kscmFyciw4Y2osZGFyciw4Y2ssaGFyciw4ZGwsY3JhcnIsOGVnLGxBcnIsOGVoLHVBcnIsOGVpLHJBcnIsOGVqLGRBcnIsJyArICc4ZWssaEFyciw4ZzAsZm9yYWxsLDhnMixwYXJ0LDhnMyxleGlzdCw4ZzUsZW1wdHksOGc3LG5hYmxhLDhnOCxpc2luLDhnOSxub3Rpbiw4Z2IsbmksOGdmLHByb2QsJyArICc4Z2gsc3VtLDhnaSxtaW51cyw4Z24sbG93YXN0LDhncSxyYWRpYyw4Z3QscHJvcCw4Z3UsaW5maW4sOGgwLGFuZyw4aDcsYW5kLDhoOCxvciw4aDksY2FwLDhoYSxjdXAsJyArICc4aGIsaW50LDhoayx0aGVyZTQsOGhzLHNpbSw4aTUsY29uZyw4aTgsYXN5bXAsOGowLG5lLDhqMSxlcXVpdiw4ajQsbGUsOGo1LGdlLDhrMixzdWIsOGszLHN1cCw4azQsJyArICduc3ViLDhrNixzdWJlLDhrNyxzdXBlLDhrbCxvcGx1cyw4a24sb3RpbWVzLDhsNSxwZXJwLDhtNSxzZG90LDhvOCxsY2VpbCw4bzkscmNlaWwsOG9hLGxmbG9vciw4b2IsJyArICdyZmxvb3IsOHA5LGxhbmcsOHBhLHJhbmcsOWVhLGxveiw5ajAsc3BhZGVzLDlqMyxjbHVicyw5ajUsaGVhcnRzLDlqNixkaWFtcyxhaSxPRWxpZyxhaixvZWxpZyxiMCwnICsgJ1NjYXJvbixiMSxzY2Fyb24sYm8sWXVtbCxtNixjaXJjLG1zLHRpbGRlLDgwMixlbnNwLDgwMyxlbXNwLDgwOSx0aGluc3AsODBjLHp3bmosODBkLHp3aiw4MGUsbHJtLCcgKyAnODBmLHJsbSw4MGosbmRhc2gsODBrLG1kYXNoLDgwbyxsc3F1byw4MHAscnNxdW8sODBxLHNicXVvLDgwcyxsZHF1byw4MHQscmRxdW8sODB1LGJkcXVvLDgxMCxkYWdnZXIsJyArICc4MTEsRGFnZ2VyLDgxZyxwZXJtaWwsODFwLGxzYXF1byw4MXEscnNhcXVvLDg1YyxldXJvJywgMzIpO1xuICAgIGNvbnN0IGVuY29kZVJhdyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl0gfHwgY2hyO1xuICAgIH0pO1xuICAgIGNvbnN0IGVuY29kZUFsbFJhdyA9IHRleHQgPT4gKCcnICsgdGV4dCkucmVwbGFjZShyYXdDaGFyc1JlZ0V4cCwgY2hyID0+IHtcbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCBjaHI7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTnVtZXJpYyA9ICh0ZXh0LCBhdHRyKSA9PiB0ZXh0LnJlcGxhY2UoYXR0ciA/IGF0dHJzQ2hhcnNSZWdFeHAgOiB0ZXh0Q2hhcnNSZWdFeHAsIGNociA9PiB7XG4gICAgICBpZiAoY2hyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyAoKGNoci5jaGFyQ29kZUF0KDApIC0gNTUyOTYpICogMTAyNCArIChjaHIuY2hhckNvZGVBdCgxKSAtIDU2MzIwKSArIDY1NTM2KSArICc7JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXSB8fCAnJiMnICsgY2hyLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSk7XG4gICAgY29uc3QgZW5jb2RlTmFtZWQgPSAodGV4dCwgYXR0ciwgZW50aXRpZXMpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVFbnRpdGllcyA9IGVudGl0aWVzIHx8IG5hbWVkRW50aXRpZXM7XG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKGF0dHIgPyBhdHRyc0NoYXJzUmVnRXhwIDogdGV4dENoYXJzUmVnRXhwLCBjaHIgPT4ge1xuICAgICAgICByZXR1cm4gYmFzZUVudGl0aWVzW2Nocl0gfHwgcmVzb2x2ZUVudGl0aWVzW2Nocl0gfHwgY2hyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFbmNvZGVGdW5jID0gKG5hbWUsIGVudGl0aWVzKSA9PiB7XG4gICAgICBjb25zdCBlbnRpdGllc01hcCA9IGJ1aWxkRW50aXRpZXNMb29rdXAoZW50aXRpZXMpIHx8IG5hbWVkRW50aXRpZXM7XG4gICAgICBjb25zdCBlbmNvZGVOYW1lZEFuZE51bWVyaWMgPSAodGV4dCwgYXR0cikgPT4gdGV4dC5yZXBsYWNlKGF0dHIgPyBhdHRyc0NoYXJzUmVnRXhwIDogdGV4dENoYXJzUmVnRXhwLCBjaHIgPT4ge1xuICAgICAgICBpZiAoYmFzZUVudGl0aWVzW2Nocl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlRW50aXRpZXNbY2hyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50aXRpZXNNYXBbY2hyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0aWVzTWFwW2Nocl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuICcmIycgKyAoKGNoci5jaGFyQ29kZUF0KDApIC0gNTUyOTYpICogMTAyNCArIChjaHIuY2hhckNvZGVBdCgxKSAtIDU2MzIwKSArIDY1NTM2KSArICc7JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyYjJyArIGNoci5jaGFyQ29kZUF0KDApICsgJzsnO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmNvZGVDdXN0b21OYW1lZCA9ICh0ZXh0LCBhdHRyKSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVOYW1lZCh0ZXh0LCBhdHRyLCBlbnRpdGllc01hcCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbmFtZU1hcCA9IG1ha2VNYXAkMyhuYW1lLnJlcGxhY2UoL1xcKy9nLCAnLCcpKTtcbiAgICAgIGlmIChuYW1lTWFwLm5hbWVkICYmIG5hbWVNYXAubnVtZXJpYykge1xuICAgICAgICByZXR1cm4gZW5jb2RlTmFtZWRBbmROdW1lcmljO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWVNYXAubmFtZWQpIHtcbiAgICAgICAgaWYgKGVudGl0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZUN1c3RvbU5hbWVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVOYW1lZDtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lTWFwLm51bWVyaWMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWVyaWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlUmF3O1xuICAgIH07XG4gICAgY29uc3QgZGVjb2RlID0gdGV4dCA9PiB0ZXh0LnJlcGxhY2UoZW50aXR5UmVnRXhwLCAoYWxsLCBudW1lcmljKSA9PiB7XG4gICAgICBpZiAobnVtZXJpYykge1xuICAgICAgICBpZiAobnVtZXJpYy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSB7XG4gICAgICAgICAgbnVtZXJpYyA9IHBhcnNlSW50KG51bWVyaWMuc3Vic3RyKDEpLCAxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtZXJpYyA9IHBhcnNlSW50KG51bWVyaWMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZXJpYyA+IDY1NTM1KSB7XG4gICAgICAgICAgbnVtZXJpYyAtPSA2NTUzNjtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiArIChudW1lcmljID4+IDEwKSwgNTYzMjAgKyAobnVtZXJpYyAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNjaWlNYXBbbnVtZXJpY10gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShudW1lcmljKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXZlcnNlRW50aXRpZXNbYWxsXSB8fCBuYW1lZEVudGl0aWVzW2FsbF0gfHwgbmF0aXZlRGVjb2RlKGFsbCk7XG4gICAgfSk7XG4gICAgY29uc3QgRW50aXRpZXMgPSB7XG4gICAgICBlbmNvZGVSYXcsXG4gICAgICBlbmNvZGVBbGxSYXcsXG4gICAgICBlbmNvZGVOdW1lcmljLFxuICAgICAgZW5jb2RlTmFtZWQsXG4gICAgICBnZXRFbmNvZGVGdW5jLFxuICAgICAgZGVjb2RlXG4gICAgfTtcblxuICAgIGNvbnN0IHNwbGl0JDEgPSAoaXRlbXMsIGRlbGltKSA9PiB7XG4gICAgICBpdGVtcyA9IFRvb2xzLnRyaW0oaXRlbXMpO1xuICAgICAgcmV0dXJuIGl0ZW1zID8gaXRlbXMuc3BsaXQoZGVsaW0gfHwgJyAnKSA6IFtdO1xuICAgIH07XG4gICAgY29uc3QgcGF0dGVyblRvUmVnRXhwID0gc3RyID0+IG5ldyBSZWdFeHAoJ14nICsgc3RyLnJlcGxhY2UoLyhbPysqXSkvZywgJy4kMScpICsgJyQnKTtcblxuICAgIGNvbnN0IHBhcnNlQ3VzdG9tRWxlbWVudHNSdWxlcyA9IHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRSZWdFeHAgPSAvXih+KT8oLispJC87XG4gICAgICByZXR1cm4gYmluZCQzKHNwbGl0JDEodmFsdWUsICcsJyksIHJ1bGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gY3VzdG9tRWxlbWVudFJlZ0V4cC5leGVjKHJ1bGUpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IGlubGluZSA9IG1hdGNoZXNbMV0gPT09ICd+JztcbiAgICAgICAgICBjb25zdCBjbG9uZU5hbWUgPSBpbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcbiAgICAgICAgICBjb25zdCBuYW1lID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgaW5saW5lLFxuICAgICAgICAgICAgICBjbG9uZU5hbWUsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldEVsZW1lbnRTZXRzQXNTdHJpbmdzID0gdHlwZSA9PiB7XG4gICAgICBsZXQgZ2xvYmFsQXR0cmlidXRlcywgYmxvY2tDb250ZW50O1xuICAgICAgbGV0IHBocmFzaW5nQ29udGVudCwgZmxvd0NvbnRlbnQ7XG4gICAgICBnbG9iYWxBdHRyaWJ1dGVzID0gJ2lkIGFjY2Vzc2tleSBjbGFzcyBkaXIgbGFuZyBzdHlsZSB0YWJpbmRleCB0aXRsZSByb2xlJztcbiAgICAgIGJsb2NrQ29udGVudCA9ICdhZGRyZXNzIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaHIgbWVudSBvbCBwIHByZSB0YWJsZSB1bCc7XG4gICAgICBwaHJhc2luZ0NvbnRlbnQgPSAnYSBhYmJyIGIgYmRvIGJyIGJ1dHRvbiBjaXRlIGNvZGUgZGVsIGRmbiBlbSBlbWJlZCBpIGlmcmFtZSBpbWcgaW5wdXQgaW5zIGtiZCAnICsgJ2xhYmVsIG1hcCBub3NjcmlwdCBvYmplY3QgcSBzIHNhbXAgc2NyaXB0IHNlbGVjdCBzbWFsbCBzcGFuIHN0cm9uZyBzdWIgc3VwICcgKyAndGV4dGFyZWEgdSB2YXIgI3RleHQgI2NvbW1lbnQnO1xuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRDb250ZW50ID0gJ2EgaW5zIGRlbCBjYW52YXMgbWFwJztcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyArPSAnIGNvbnRlbnRlZGl0YWJsZSBjb250ZXh0bWVudSBkcmFnZ2FibGUgZHJvcHpvbmUgJyArICdoaWRkZW4gc3BlbGxjaGVjayB0cmFuc2xhdGUnO1xuICAgICAgICBibG9ja0NvbnRlbnQgKz0gJyBhcnRpY2xlIGFzaWRlIGRldGFpbHMgZGlhbG9nIGZpZ3VyZSBtYWluIGhlYWRlciBmb290ZXIgaGdyb3VwIHNlY3Rpb24gbmF2ICcgKyB0cmFuc3BhcmVudENvbnRlbnQ7XG4gICAgICAgIHBocmFzaW5nQ29udGVudCArPSAnIGF1ZGlvIGNhbnZhcyBjb21tYW5kIGRhdGFsaXN0IG1hcmsgbWV0ZXIgb3V0cHV0IHBpY3R1cmUgJyArICdwcm9ncmVzcyB0aW1lIHdiciB2aWRlbyBydWJ5IGJkaSBrZXlnZW4nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNS1zdHJpY3QnKSB7XG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMgKz0gJyB4bWw6bGFuZyc7XG4gICAgICAgIGNvbnN0IGh0bWw0UGhyYXNpbmdDb250ZW50ID0gJ2Fjcm9ueW0gYXBwbGV0IGJhc2Vmb250IGJpZyBmb250IHN0cmlrZSB0dCc7XG4gICAgICAgIHBocmFzaW5nQ29udGVudCA9IFtcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgICAgaHRtbDRQaHJhc2luZ0NvbnRlbnRcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIGNvbnN0IGh0bWw0QmxvY2tDb250ZW50ID0gJ2NlbnRlciBkaXIgaXNpbmRleCBub2ZyYW1lcyc7XG4gICAgICAgIGJsb2NrQ29udGVudCA9IFtcbiAgICAgICAgICBibG9ja0NvbnRlbnQsXG4gICAgICAgICAgaHRtbDRCbG9ja0NvbnRlbnRcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIGZsb3dDb250ZW50ID0gW1xuICAgICAgICAgIGJsb2NrQ29udGVudCxcbiAgICAgICAgICBwaHJhc2luZ0NvbnRlbnRcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICB9XG4gICAgICBmbG93Q29udGVudCA9IGZsb3dDb250ZW50IHx8IFtcbiAgICAgICAgYmxvY2tDb250ZW50LFxuICAgICAgICBwaHJhc2luZ0NvbnRlbnRcbiAgICAgIF0uam9pbignICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyxcbiAgICAgICAgYmxvY2tDb250ZW50LFxuICAgICAgICBwaHJhc2luZ0NvbnRlbnQsXG4gICAgICAgIGZsb3dDb250ZW50XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBtYWtlU2NoZW1hID0gdHlwZSA9PiB7XG4gICAgICBjb25zdCB7Z2xvYmFsQXR0cmlidXRlcywgcGhyYXNpbmdDb250ZW50LCBmbG93Q29udGVudH0gPSBnZXRFbGVtZW50U2V0c0FzU3RyaW5ncyh0eXBlKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHt9O1xuICAgICAgY29uc3QgYWRkID0gKG5hbWUsIGF0dHJpYnV0ZXMgPSAnJywgY2hpbGRyZW4gPSAnJykgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZE5hbWVzID0gc3BsaXQkMShjaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3BsaXQkMShuYW1lKTtcbiAgICAgICAgbGV0IG5pID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobmktLSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXNPcmRlciA9IHNwbGl0JDEoW1xuICAgICAgICAgICAgZ2xvYmFsQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgICAgc2NoZW1hW25hbWVzW25pXV0gPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBtYXBUb09iamVjdChhdHRyaWJ1dGVzT3JkZXIsIGNvbnN0YW50KHt9KSksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogbWFwVG9PYmplY3QoY2hpbGROYW1lcywgY29uc3RhbnQoe30pKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRBdHRycyA9IChuYW1lLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3BsaXQkMShuYW1lKTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBzcGxpdCQxKGF0dHJpYnV0ZXMpO1xuICAgICAgICBsZXQgbmkgPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYVtuYW1lc1tuaV1dO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzY2hlbWFJdGVtLmF0dHJpYnV0ZXNbYXR0cnNbaV1dID0ge307XG4gICAgICAgICAgICBzY2hlbWFJdGVtLmF0dHJpYnV0ZXNPcmRlci5wdXNoKGF0dHJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw1LXN0cmljdCcpIHtcbiAgICAgICAgY29uc3QgaHRtbDRQaHJhc2luZ0NvbnRlbnQgPSAnYWNyb255bSBhcHBsZXQgYmFzZWZvbnQgYmlnIGZvbnQgc3RyaWtlIHR0JztcbiAgICAgICAgZWFjaCRlKHNwbGl0JDEoaHRtbDRQaHJhc2luZ0NvbnRlbnQpLCBuYW1lID0+IHtcbiAgICAgICAgICBhZGQobmFtZSwgJycsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBodG1sNEJsb2NrQ29udGVudCA9ICdjZW50ZXIgZGlyIGlzaW5kZXggbm9mcmFtZXMnO1xuICAgICAgICBlYWNoJGUoc3BsaXQkMShodG1sNEJsb2NrQ29udGVudCksIG5hbWUgPT4ge1xuICAgICAgICAgIGFkZChuYW1lLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZCgnaHRtbCcsICdtYW5pZmVzdCcsICdoZWFkIGJvZHknKTtcbiAgICAgIGFkZCgnaGVhZCcsICcnLCAnYmFzZSBjb21tYW5kIGxpbmsgbWV0YSBub3NjcmlwdCBzY3JpcHQgc3R5bGUgdGl0bGUnKTtcbiAgICAgIGFkZCgndGl0bGUgaHIgbm9zY3JpcHQgYnInKTtcbiAgICAgIGFkZCgnYmFzZScsICdocmVmIHRhcmdldCcpO1xuICAgICAgYWRkKCdsaW5rJywgJ2hyZWYgcmVsIG1lZGlhIGhyZWZsYW5nIHR5cGUgc2l6ZXMgaHJlZmxhbmcnKTtcbiAgICAgIGFkZCgnbWV0YScsICduYW1lIGh0dHAtZXF1aXYgY29udGVudCBjaGFyc2V0Jyk7XG4gICAgICBhZGQoJ3N0eWxlJywgJ21lZGlhIHR5cGUgc2NvcGVkJyk7XG4gICAgICBhZGQoJ3NjcmlwdCcsICdzcmMgYXN5bmMgZGVmZXIgdHlwZSBjaGFyc2V0Jyk7XG4gICAgICBhZGQoJ2JvZHknLCAnb25hZnRlcnByaW50IG9uYmVmb3JlcHJpbnQgb25iZWZvcmV1bmxvYWQgb25ibHVyIG9uZXJyb3Igb25mb2N1cyAnICsgJ29uaGFzaGNoYW5nZSBvbmxvYWQgb25tZXNzYWdlIG9ub2ZmbGluZSBvbm9ubGluZSBvbnBhZ2VoaWRlIG9ucGFnZXNob3cgJyArICdvbnBvcHN0YXRlIG9ucmVzaXplIG9uc2Nyb2xsIG9uc3RvcmFnZSBvbnVubG9hZCcsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnZGQgZGl2JywgJycsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnYWRkcmVzcyBkdCBjYXB0aW9uJywgJycsIHR5cGUgPT09ICdodG1sNCcgPyBwaHJhc2luZ0NvbnRlbnQgOiBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2gxIGgyIGgzIGg0IGg1IGg2IHByZSBwIGFiYnIgY29kZSB2YXIgc2FtcCBrYmQgc3ViIHN1cCBpIGIgdSBiZG8gc3BhbiBsZWdlbmQgZW0gc3Ryb25nIHNtYWxsIHMgY2l0ZSBkZm4nLCAnJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgIGFkZCgnYmxvY2txdW90ZScsICdjaXRlJywgZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdvbCcsICdyZXZlcnNlZCBzdGFydCB0eXBlJywgJ2xpJyk7XG4gICAgICBhZGQoJ3VsJywgJycsICdsaScpO1xuICAgICAgYWRkKCdsaScsICd2YWx1ZScsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnZGwnLCAnJywgJ2R0IGRkJyk7XG4gICAgICBhZGQoJ2EnLCAnaHJlZiB0YXJnZXQgcmVsIG1lZGlhIGhyZWZsYW5nIHR5cGUnLCB0eXBlID09PSAnaHRtbDQnID8gcGhyYXNpbmdDb250ZW50IDogZmxvd0NvbnRlbnQpO1xuICAgICAgYWRkKCdxJywgJ2NpdGUnLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgYWRkKCdpbnMgZGVsJywgJ2NpdGUgZGF0ZXRpbWUnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2ltZycsICdzcmMgc2l6ZXMgc3Jjc2V0IGFsdCB1c2VtYXAgaXNtYXAgd2lkdGggaGVpZ2h0Jyk7XG4gICAgICBhZGQoJ2lmcmFtZScsICdzcmMgbmFtZSB3aWR0aCBoZWlnaHQnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2VtYmVkJywgJ3NyYyB0eXBlIHdpZHRoIGhlaWdodCcpO1xuICAgICAgYWRkKCdvYmplY3QnLCAnZGF0YSB0eXBlIHR5cGVtdXN0bWF0Y2ggbmFtZSB1c2VtYXAgZm9ybSB3aWR0aCBoZWlnaHQnLCBbXG4gICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAncGFyYW0nXG4gICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICBhZGQoJ3BhcmFtJywgJ25hbWUgdmFsdWUnKTtcbiAgICAgIGFkZCgnbWFwJywgJ25hbWUnLCBbXG4gICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAnYXJlYSdcbiAgICAgIF0uam9pbignICcpKTtcbiAgICAgIGFkZCgnYXJlYScsICdhbHQgY29vcmRzIHNoYXBlIGhyZWYgdGFyZ2V0IHJlbCBtZWRpYSBocmVmbGFuZyB0eXBlJyk7XG4gICAgICBhZGQoJ3RhYmxlJywgJ2JvcmRlcicsICdjYXB0aW9uIGNvbGdyb3VwIHRoZWFkIHRmb290IHRib2R5IHRyJyArICh0eXBlID09PSAnaHRtbDQnID8gJyBjb2wnIDogJycpKTtcbiAgICAgIGFkZCgnY29sZ3JvdXAnLCAnc3BhbicsICdjb2wnKTtcbiAgICAgIGFkZCgnY29sJywgJ3NwYW4nKTtcbiAgICAgIGFkZCgndGJvZHkgdGhlYWQgdGZvb3QnLCAnJywgJ3RyJyk7XG4gICAgICBhZGQoJ3RyJywgJycsICd0ZCB0aCcpO1xuICAgICAgYWRkKCd0ZCcsICdjb2xzcGFuIHJvd3NwYW4gaGVhZGVycycsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgndGgnLCAnY29sc3BhbiByb3dzcGFuIGhlYWRlcnMgc2NvcGUgYWJicicsIGZsb3dDb250ZW50KTtcbiAgICAgIGFkZCgnZm9ybScsICdhY2NlcHQtY2hhcnNldCBhY3Rpb24gYXV0b2NvbXBsZXRlIGVuY3R5cGUgbWV0aG9kIG5hbWUgbm92YWxpZGF0ZSB0YXJnZXQnLCBmbG93Q29udGVudCk7XG4gICAgICBhZGQoJ2ZpZWxkc2V0JywgJ2Rpc2FibGVkIGZvcm0gbmFtZScsIFtcbiAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICdsZWdlbmQnXG4gICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICBhZGQoJ2xhYmVsJywgJ2Zvcm0gZm9yJywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgIGFkZCgnaW5wdXQnLCAnYWNjZXB0IGFsdCBhdXRvY29tcGxldGUgY2hlY2tlZCBkaXJuYW1lIGRpc2FibGVkIGZvcm0gZm9ybWFjdGlvbiBmb3JtZW5jdHlwZSBmb3JtbWV0aG9kIGZvcm1ub3ZhbGlkYXRlICcgKyAnZm9ybXRhcmdldCBoZWlnaHQgbGlzdCBtYXggbWF4bGVuZ3RoIG1pbiBtdWx0aXBsZSBuYW1lIHBhdHRlcm4gcmVhZG9ubHkgcmVxdWlyZWQgc2l6ZSBzcmMgc3RlcCB0eXBlIHZhbHVlIHdpZHRoJyk7XG4gICAgICBhZGQoJ2J1dHRvbicsICdkaXNhYmxlZCBmb3JtIGZvcm1hY3Rpb24gZm9ybWVuY3R5cGUgZm9ybW1ldGhvZCBmb3Jtbm92YWxpZGF0ZSBmb3JtdGFyZ2V0IG5hbWUgdHlwZSB2YWx1ZScsIHR5cGUgPT09ICdodG1sNCcgPyBmbG93Q29udGVudCA6IHBocmFzaW5nQ29udGVudCk7XG4gICAgICBhZGQoJ3NlbGVjdCcsICdkaXNhYmxlZCBmb3JtIG11bHRpcGxlIG5hbWUgcmVxdWlyZWQgc2l6ZScsICdvcHRpb24gb3B0Z3JvdXAnKTtcbiAgICAgIGFkZCgnb3B0Z3JvdXAnLCAnZGlzYWJsZWQgbGFiZWwnLCAnb3B0aW9uJyk7XG4gICAgICBhZGQoJ29wdGlvbicsICdkaXNhYmxlZCBsYWJlbCBzZWxlY3RlZCB2YWx1ZScpO1xuICAgICAgYWRkKCd0ZXh0YXJlYScsICdjb2xzIGRpcm5hbWUgZGlzYWJsZWQgZm9ybSBtYXhsZW5ndGggbmFtZSByZWFkb25seSByZXF1aXJlZCByb3dzIHdyYXAnKTtcbiAgICAgIGFkZCgnbWVudScsICd0eXBlIGxhYmVsJywgW1xuICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgJ2xpJ1xuICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgYWRkKCdub3NjcmlwdCcsICcnLCBmbG93Q29udGVudCk7XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw0Jykge1xuICAgICAgICBhZGQoJ3dicicpO1xuICAgICAgICBhZGQoJ3J1YnknLCAnJywgW1xuICAgICAgICAgIHBocmFzaW5nQ29udGVudCxcbiAgICAgICAgICAncnQgcnAnXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdmaWdjYXB0aW9uJywgJycsIGZsb3dDb250ZW50KTtcbiAgICAgICAgYWRkKCdtYXJrIHJ0IHJwIHN1bW1hcnkgYmRpJywgJycsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIGFkZCgnY2FudmFzJywgJ3dpZHRoIGhlaWdodCcsIGZsb3dDb250ZW50KTtcbiAgICAgICAgYWRkKCd2aWRlbycsICdzcmMgY3Jvc3NvcmlnaW4gcG9zdGVyIHByZWxvYWQgYXV0b3BsYXkgbWVkaWFncm91cCBsb29wICcgKyAnbXV0ZWQgY29udHJvbHMgd2lkdGggaGVpZ2h0IGJ1ZmZlcmVkJywgW1xuICAgICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAgICd0cmFjayBzb3VyY2UnXG4gICAgICAgIF0uam9pbignICcpKTtcbiAgICAgICAgYWRkKCdhdWRpbycsICdzcmMgY3Jvc3NvcmlnaW4gcHJlbG9hZCBhdXRvcGxheSBtZWRpYWdyb3VwIGxvb3AgbXV0ZWQgY29udHJvbHMgJyArICdidWZmZXJlZCB2b2x1bWUnLCBbXG4gICAgICAgICAgZmxvd0NvbnRlbnQsXG4gICAgICAgICAgJ3RyYWNrIHNvdXJjZSdcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ3BpY3R1cmUnLCAnJywgJ2ltZyBzb3VyY2UnKTtcbiAgICAgICAgYWRkKCdzb3VyY2UnLCAnc3JjIHNyY3NldCB0eXBlIG1lZGlhIHNpemVzJyk7XG4gICAgICAgIGFkZCgndHJhY2snLCAna2luZCBzcmMgc3JjbGFuZyBsYWJlbCBkZWZhdWx0Jyk7XG4gICAgICAgIGFkZCgnZGF0YWxpc3QnLCAnJywgW1xuICAgICAgICAgIHBocmFzaW5nQ29udGVudCxcbiAgICAgICAgICAnb3B0aW9uJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgnYXJ0aWNsZSBzZWN0aW9uIG5hdiBhc2lkZSBtYWluIGhlYWRlciBmb290ZXInLCAnJywgZmxvd0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2hncm91cCcsICcnLCAnaDEgaDIgaDMgaDQgaDUgaDYnKTtcbiAgICAgICAgYWRkKCdmaWd1cmUnLCAnJywgW1xuICAgICAgICAgIGZsb3dDb250ZW50LFxuICAgICAgICAgICdmaWdjYXB0aW9uJ1xuICAgICAgICBdLmpvaW4oJyAnKSk7XG4gICAgICAgIGFkZCgndGltZScsICdkYXRldGltZScsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIGFkZCgnZGlhbG9nJywgJ29wZW4nLCBmbG93Q29udGVudCk7XG4gICAgICAgIGFkZCgnY29tbWFuZCcsICd0eXBlIGxhYmVsIGljb24gZGlzYWJsZWQgY2hlY2tlZCByYWRpb2dyb3VwIGNvbW1hbmQnKTtcbiAgICAgICAgYWRkKCdvdXRwdXQnLCAnZm9yIGZvcm0gbmFtZScsIHBocmFzaW5nQ29udGVudCk7XG4gICAgICAgIGFkZCgncHJvZ3Jlc3MnLCAndmFsdWUgbWF4JywgcGhyYXNpbmdDb250ZW50KTtcbiAgICAgICAgYWRkKCdtZXRlcicsICd2YWx1ZSBtaW4gbWF4IGxvdyBoaWdoIG9wdGltdW0nLCBwaHJhc2luZ0NvbnRlbnQpO1xuICAgICAgICBhZGQoJ2RldGFpbHMnLCAnb3BlbicsIFtcbiAgICAgICAgICBmbG93Q29udGVudCxcbiAgICAgICAgICAnc3VtbWFyeSdcbiAgICAgICAgXS5qb2luKCcgJykpO1xuICAgICAgICBhZGQoJ2tleWdlbicsICdhdXRvZm9jdXMgY2hhbGxlbmdlIGRpc2FibGVkIGZvcm0ga2V5dHlwZSBuYW1lJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAhPT0gJ2h0bWw1LXN0cmljdCcpIHtcbiAgICAgICAgYWRkQXR0cnMoJ3NjcmlwdCcsICdsYW5ndWFnZSB4bWw6c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3N0eWxlJywgJ3htbDpzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygnb2JqZWN0JywgJ2RlY2xhcmUgY2xhc3NpZCBjb2RlIGNvZGViYXNlIGNvZGV0eXBlIGFyY2hpdmUgc3RhbmRieSBhbGlnbiBib3JkZXIgaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygnZW1iZWQnLCAnYWxpZ24gbmFtZSBoc3BhY2UgdnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdwYXJhbScsICd2YWx1ZXR5cGUgdHlwZScpO1xuICAgICAgICBhZGRBdHRycygnYScsICdjaGFyc2V0IG5hbWUgcmV2IHNoYXBlIGNvb3JkcycpO1xuICAgICAgICBhZGRBdHRycygnYnInLCAnY2xlYXInKTtcbiAgICAgICAgYWRkQXR0cnMoJ2FwcGxldCcsICdjb2RlYmFzZSBhcmNoaXZlIGNvZGUgb2JqZWN0IGFsdCBuYW1lIHdpZHRoIGhlaWdodCBhbGlnbiBoc3BhY2UgdnNwYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdpbWcnLCAnbmFtZSBsb25nZGVzYyBhbGlnbiBib3JkZXIgaHNwYWNlIHZzcGFjZScpO1xuICAgICAgICBhZGRBdHRycygnaWZyYW1lJywgJ2xvbmdkZXNjIGZyYW1lYm9yZGVyIG1hcmdpbndpZHRoIG1hcmdpbmhlaWdodCBzY3JvbGxpbmcgYWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ2ZvbnQgYmFzZWZvbnQnLCAnc2l6ZSBjb2xvciBmYWNlJyk7XG4gICAgICAgIGFkZEF0dHJzKCdpbnB1dCcsICd1c2VtYXAgYWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ3NlbGVjdCcpO1xuICAgICAgICBhZGRBdHRycygndGV4dGFyZWEnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2gxIGgyIGgzIGg0IGg1IGg2IGRpdiBwIGxlZ2VuZCBjYXB0aW9uJywgJ2FsaWduJyk7XG4gICAgICAgIGFkZEF0dHJzKCd1bCcsICd0eXBlIGNvbXBhY3QnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2xpJywgJ3R5cGUnKTtcbiAgICAgICAgYWRkQXR0cnMoJ29sIGRsIG1lbnUgZGlyJywgJ2NvbXBhY3QnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3ByZScsICd3aWR0aCB4bWw6c3BhY2UnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2hyJywgJ2FsaWduIG5vc2hhZGUgc2l6ZSB3aWR0aCcpO1xuICAgICAgICBhZGRBdHRycygnaXNpbmRleCcsICdwcm9tcHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RhYmxlJywgJ3N1bW1hcnkgd2lkdGggZnJhbWUgcnVsZXMgY2VsbHNwYWNpbmcgY2VsbHBhZGRpbmcgYWxpZ24gYmdjb2xvcicpO1xuICAgICAgICBhZGRBdHRycygnY29sJywgJ3dpZHRoIGFsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ2NvbGdyb3VwJywgJ3dpZHRoIGFsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RoZWFkJywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24nKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RyJywgJ2FsaWduIGNoYXIgY2hhcm9mZiB2YWxpZ24gYmdjb2xvcicpO1xuICAgICAgICBhZGRBdHRycygndGgnLCAnYXhpcyBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduIG5vd3JhcCBiZ2NvbG9yIHdpZHRoIGhlaWdodCcpO1xuICAgICAgICBhZGRBdHRycygnZm9ybScsICdhY2NlcHQnKTtcbiAgICAgICAgYWRkQXR0cnMoJ3RkJywgJ2FiYnIgYXhpcyBzY29wZSBhbGlnbiBjaGFyIGNoYXJvZmYgdmFsaWduIG5vd3JhcCBiZ2NvbG9yIHdpZHRoIGhlaWdodCcpO1xuICAgICAgICBhZGRBdHRycygndGZvb3QnLCAnYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbicpO1xuICAgICAgICBhZGRBdHRycygndGJvZHknLCAnYWxpZ24gY2hhciBjaGFyb2ZmIHZhbGlnbicpO1xuICAgICAgICBhZGRBdHRycygnYXJlYScsICdub2hyZWYnKTtcbiAgICAgICAgYWRkQXR0cnMoJ2JvZHknLCAnYmFja2dyb3VuZCBiZ2NvbG9yIHRleHQgbGluayB2bGluayBhbGluaycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09ICdodG1sNCcpIHtcbiAgICAgICAgYWRkQXR0cnMoJ2lucHV0IGJ1dHRvbiBzZWxlY3QgdGV4dGFyZWEnLCAnYXV0b2ZvY3VzJyk7XG4gICAgICAgIGFkZEF0dHJzKCdpbnB1dCB0ZXh0YXJlYScsICdwbGFjZWhvbGRlcicpO1xuICAgICAgICBhZGRBdHRycygnYScsICdkb3dubG9hZCcpO1xuICAgICAgICBhZGRBdHRycygnbGluayBzY3JpcHQgaW1nJywgJ2Nyb3Nzb3JpZ2luJyk7XG4gICAgICAgIGFkZEF0dHJzKCdpbWcnLCAnbG9hZGluZycpO1xuICAgICAgICBhZGRBdHRycygnaWZyYW1lJywgJ3NhbmRib3ggc2VhbWxlc3MgYWxsb3cgYWxsb3dmdWxsc2NyZWVuIGxvYWRpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICE9PSAnaHRtbDQnKSB7XG4gICAgICAgIGVhY2gkZShbXG4gICAgICAgICAgc2NoZW1hLnZpZGVvLFxuICAgICAgICAgIHNjaGVtYS5hdWRpb1xuICAgICAgICBdLCBpdGVtID0+IHtcbiAgICAgICAgICBkZWxldGUgaXRlbS5jaGlsZHJlbi5hdWRpbztcbiAgICAgICAgICBkZWxldGUgaXRlbS5jaGlsZHJlbi52aWRlbztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlYWNoJGUoc3BsaXQkMSgnYSBmb3JtIG1ldGVyIHByb2dyZXNzIGRmbicpLCBuYW1lID0+IHtcbiAgICAgICAgaWYgKHNjaGVtYVtuYW1lXSkge1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbbmFtZV0uY2hpbGRyZW5bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHNjaGVtYS5jYXB0aW9uLmNoaWxkcmVuLnRhYmxlO1xuICAgICAgZGVsZXRlIHNjaGVtYS5zY3JpcHQ7XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH07XG5cbiAgICBjb25zdCBwcmVmaXhUb09wZXJhdGlvbiA9IHByZWZpeCA9PiBwcmVmaXggPT09ICctJyA/ICdyZW1vdmUnIDogJ2FkZCc7XG4gICAgY29uc3QgcGFyc2VWYWxpZENoaWxkcmVuUnVsZXMgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBjaGlsZFJ1bGVSZWdFeHAgPSAvXihbK1xcLV0/KShbQS1aYS16MC05X1xcLS5cXHUwMGI3XFx1MDBjMC1cXHUwMGQ2XFx1MDBkOC1cXHUwMGY2XFx1MDBmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwYy1cXHUyMDBkXFx1MjAzZi1cXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXSspXFxbKFteXFxdXSspXSQvO1xuICAgICAgcmV0dXJuIGJpbmQkMyhzcGxpdCQxKHZhbHVlLCAnLCcpLCBydWxlID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNoaWxkUnVsZVJlZ0V4cC5leGVjKHJ1bGUpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcHJlZml4ID8gcHJlZml4VG9PcGVyYXRpb24ocHJlZml4KSA6ICdyZXBsYWNlJztcbiAgICAgICAgICBjb25zdCBuYW1lID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICBjb25zdCB2YWxpZENoaWxkcmVuID0gc3BsaXQkMShtYXRjaGVzWzNdLCAnfCcpO1xuICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHZhbGlkQ2hpbGRyZW5cbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBhcnNlVmFsaWRFbGVtZW50c0F0dHJEYXRhSW50b0VsZW1lbnQgPSAoYXR0ckRhdGEsIHRhcmdldEVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJSdWxlUmVnRXhwID0gL14oWyFcXC1dKT8oXFx3K1tcXFxcOl06XFx3K3xbXj1+PF0rKT8oPzooWz1+PF0pKC4qKSk/JC87XG4gICAgICBjb25zdCBoYXNQYXR0ZXJuc1JlZ0V4cCA9IC9bKj8rXS87XG4gICAgICBjb25zdCB7YXR0cmlidXRlcywgYXR0cmlidXRlc09yZGVyfSA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICByZXR1cm4gZWFjaCRlKHNwbGl0JDEoYXR0ckRhdGEsICd8JyksIHJ1bGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gYXR0clJ1bGVSZWdFeHAuZXhlYyhydWxlKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBjb25zdCBhdHRyID0ge307XG4gICAgICAgICAgY29uc3QgYXR0clR5cGUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbWF0Y2hlc1syXS5yZXBsYWNlKC9bXFxcXDpdOi9nLCAnOicpO1xuICAgICAgICAgIGNvbnN0IGF0dHJQcmVmaXggPSBtYXRjaGVzWzNdO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICBpZiAoYXR0clR5cGUgPT09ICchJykge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVzUmVxdWlyZWQgPSB0YXJnZXRFbGVtZW50LmF0dHJpYnV0ZXNSZXF1aXJlZCB8fCBbXTtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXR0cmlidXRlc1JlcXVpcmVkLnB1c2goYXR0ck5hbWUpO1xuICAgICAgICAgICAgYXR0ci5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyVHlwZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXIuc3BsaWNlKFRvb2xzLmluQXJyYXkoYXR0cmlidXRlc09yZGVyLCBhdHRyTmFtZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0clByZWZpeCkge1xuICAgICAgICAgICAgaWYgKGF0dHJQcmVmaXggPT09ICc9Jykge1xuICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmF0dHJpYnV0ZXNEZWZhdWx0ID0gdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVzRGVmYXVsdCB8fCBbXTtcbiAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVzRGVmYXVsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXR0ci5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0clByZWZpeCA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXR0cmlidXRlc0ZvcmNlZCA9IHRhcmdldEVsZW1lbnQuYXR0cmlidXRlc0ZvcmNlZCB8fCBbXTtcbiAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVzRm9yY2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhdHRyLmZvcmNlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJQcmVmaXggPT09ICc8Jykge1xuICAgICAgICAgICAgICBhdHRyLnZhbGlkVmFsdWVzID0gVG9vbHMubWFrZU1hcCh2YWx1ZSwgJz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc1BhdHRlcm5zUmVnRXhwLnRlc3QoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyUGF0dGVybiA9IGF0dHI7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50LmF0dHJpYnV0ZVBhdHRlcm5zID0gdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVQYXR0ZXJucyB8fCBbXTtcbiAgICAgICAgICAgIGF0dHJQYXR0ZXJuLnBhdHRlcm4gPSBwYXR0ZXJuVG9SZWdFeHAoYXR0ck5hbWUpO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5hdHRyaWJ1dGVQYXR0ZXJucy5wdXNoKGF0dHJQYXR0ZXJuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJOYW1lXSkge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXIucHVzaChhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJOYW1lXSA9IGF0dHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsb25lQXR0cmlidXRlc0ludG8gPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgIGVhY2gkZChmcm9tLmF0dHJpYnV0ZXMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHRvLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICB0by5hdHRyaWJ1dGVzT3JkZXIucHVzaCguLi5mcm9tLmF0dHJpYnV0ZXNPcmRlcik7XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZVZhbGlkRWxlbWVudHNSdWxlcyA9IChnbG9iYWxFbGVtZW50LCB2YWxpZEVsZW1lbnRzKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50UnVsZVJlZ0V4cCA9IC9eKFsjK1xcLV0pPyhbXlxcWyFcXC9dKykoPzpcXC8oW15cXFshXSspKT8oPzooIT8pXFxbKFteXFxdXSspXSk/JC87XG4gICAgICByZXR1cm4gYmluZCQzKHNwbGl0JDEodmFsaWRFbGVtZW50cywgJywnKSwgcnVsZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBlbGVtZW50UnVsZVJlZ0V4cC5leGVjKHJ1bGUpO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgIGNvbnN0IG91dHB1dE5hbWUgPSBtYXRjaGVzWzNdO1xuICAgICAgICAgIGNvbnN0IGF0dHJzUHJlZml4ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICBjb25zdCBhdHRyRGF0YSA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgYXR0cmlidXRlc09yZGVyOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2xvYmFsRWxlbWVudC5lYWNoKGVsID0+IGNsb25lQXR0cmlidXRlc0ludG8oZWwsIGVsZW1lbnQpKTtcbiAgICAgICAgICBpZiAocHJlZml4ID09PSAnIycpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucGFkZEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJzUHJlZml4ID09PSAnIScpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRW1wdHlBdHRycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyRGF0YSkge1xuICAgICAgICAgICAgcGFyc2VWYWxpZEVsZW1lbnRzQXR0ckRhdGFJbnRvRWxlbWVudChhdHRyRGF0YSwgZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXROYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm91dHB1dE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1lbnROYW1lID09PSAnQCcpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxFbGVtZW50LmlzTm9uZSgpKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQgPSBPcHRpb25hbC5zb21lKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW291dHB1dE5hbWUgPyB7XG4gICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBhbGlhc05hbWU6IG91dHB1dE5hbWVcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBtYXBDYWNoZSA9IHt9O1xuICAgIGNvbnN0IG1ha2VNYXAkMiA9IFRvb2xzLm1ha2VNYXAsIGVhY2gkYiA9IFRvb2xzLmVhY2gsIGV4dGVuZCQyID0gVG9vbHMuZXh0ZW5kLCBleHBsb2RlJDIgPSBUb29scy5leHBsb2RlO1xuICAgIGNvbnN0IGNyZWF0ZU1hcCA9IChkZWZhdWx0VmFsdWUsIGV4dGVuZFdpdGggPSB7fSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBtYWtlTWFwJDIoZGVmYXVsdFZhbHVlLCAnICcsIG1ha2VNYXAkMihkZWZhdWx0VmFsdWUudG9VcHBlckNhc2UoKSwgJyAnKSk7XG4gICAgICByZXR1cm4gZXh0ZW5kJDIodmFsdWUsIGV4dGVuZFdpdGgpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzID0gc2NoZW1hID0+IGNyZWF0ZU1hcCgndGQgdGggbGkgZHQgZGQgZmlnY2FwdGlvbiBjYXB0aW9uIGRldGFpbHMgc3VtbWFyeScsIHNjaGVtYS5nZXRUZXh0QmxvY2tFbGVtZW50cygpKTtcbiAgICBjb25zdCBjb21waWxlRWxlbWVudE1hcCA9ICh2YWx1ZSwgbW9kZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB7ICcqJzogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGIodmFsdWUsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5LnRvVXBwZXJDYXNlKCldID0gbW9kZSA9PT0gJ21hcCcgPyBtYWtlTWFwJDIodmFsdWUsIC9bLCBdLykgOiBleHBsb2RlJDIodmFsdWUsIC9bLCBdLyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFNjaGVtYSA9IChzZXR0aW5ncyA9IHt9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IHt9O1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB7fTtcbiAgICAgIGxldCBwYXR0ZXJuRWxlbWVudHMgPSBbXTtcbiAgICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRzTWFwID0ge307XG4gICAgICBjb25zdCBzcGVjaWFsRWxlbWVudHMgPSB7fTtcbiAgICAgIGNvbnN0IGNyZWF0ZUxvb2t1cFRhYmxlID0gKG9wdGlvbiwgZGVmYXVsdFZhbHVlLCBleHRlbmRXaXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2V0dGluZ3Nbb3B0aW9uXTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IG1hcENhY2hlW29wdGlvbl07XG4gICAgICAgICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjcmVhdGVNYXAoZGVmYXVsdFZhbHVlLCBleHRlbmRXaXRoKTtcbiAgICAgICAgICAgIG1hcENhY2hlW29wdGlvbl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYWtlTWFwJDIodmFsdWUsIC9bLCBdLywgbWFrZU1hcCQyKHZhbHVlLnRvVXBwZXJDYXNlKCksIC9bLCBdLykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IChfYSA9IHNldHRpbmdzLnNjaGVtYSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2h0bWw1JztcbiAgICAgIGNvbnN0IHNjaGVtYUl0ZW1zID0gbWFrZVNjaGVtYShzY2hlbWFUeXBlKTtcbiAgICAgIGlmIChzZXR0aW5ncy52ZXJpZnlfaHRtbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2V0dGluZ3MudmFsaWRfZWxlbWVudHMgPSAnKlsqXSc7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZFN0eWxlcyA9IGNvbXBpbGVFbGVtZW50TWFwKHNldHRpbmdzLnZhbGlkX3N0eWxlcyk7XG4gICAgICBjb25zdCBpbnZhbGlkU3R5bGVzID0gY29tcGlsZUVsZW1lbnRNYXAoc2V0dGluZ3MuaW52YWxpZF9zdHlsZXMsICdtYXAnKTtcbiAgICAgIGNvbnN0IHZhbGlkQ2xhc3NlcyA9IGNvbXBpbGVFbGVtZW50TWFwKHNldHRpbmdzLnZhbGlkX2NsYXNzZXMsICdtYXAnKTtcbiAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd3aGl0ZXNwYWNlX2VsZW1lbnRzJywgJ3ByZSBzY3JpcHQgbm9zY3JpcHQgc3R5bGUgdGV4dGFyZWEgdmlkZW8gYXVkaW8gaWZyYW1lIG9iamVjdCBjb2RlJyk7XG4gICAgICBjb25zdCBzZWxmQ2xvc2luZ0VsZW1lbnRzTWFwID0gY3JlYXRlTG9va3VwVGFibGUoJ3NlbGZfY2xvc2luZ19lbGVtZW50cycsICdjb2xncm91cCBkZCBkdCBsaSBvcHRpb24gcCB0ZCB0Zm9vdCB0aCB0aGVhZCB0cicpO1xuICAgICAgY29uc3Qgdm9pZEVsZW1lbnRzTWFwID0gY3JlYXRlTG9va3VwVGFibGUoJ3ZvaWRfZWxlbWVudHMnLCAnYXJlYSBiYXNlIGJhc2Vmb250IGJyIGNvbCBmcmFtZSBociBpbWcgaW5wdXQgaXNpbmRleCBsaW5rICcgKyAnbWV0YSBwYXJhbSBlbWJlZCBzb3VyY2Ugd2JyIHRyYWNrJyk7XG4gICAgICBjb25zdCBib29sQXR0ck1hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdib29sZWFuX2F0dHJpYnV0ZXMnLCAnY2hlY2tlZCBjb21wYWN0IGRlY2xhcmUgZGVmZXIgZGlzYWJsZWQgaXNtYXAgbXVsdGlwbGUgbm9ocmVmIG5vcmVzaXplICcgKyAnbm9zaGFkZSBub3dyYXAgcmVhZG9ubHkgc2VsZWN0ZWQgYXV0b3BsYXkgbG9vcCBjb250cm9scyBhbGxvd2Z1bGxzY3JlZW4nKTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5T3JNb3ZlQ2FyZXRCZWZvcmVPbkVudGVyID0gJ3RkIHRoIGlmcmFtZSB2aWRlbyBhdWRpbyBvYmplY3Qgc2NyaXB0IGNvZGUnO1xuICAgICAgY29uc3Qgbm9uRW1wdHlFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdub25fZW1wdHlfZWxlbWVudHMnLCBub25FbXB0eU9yTW92ZUNhcmV0QmVmb3JlT25FbnRlciArICcgcHJlJywgdm9pZEVsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IG1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdtb3ZlX2NhcmV0X2JlZm9yZV9vbl9lbnRlcl9lbGVtZW50cycsIG5vbkVtcHR5T3JNb3ZlQ2FyZXRCZWZvcmVPbkVudGVyICsgJyB0YWJsZScsIHZvaWRFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCB0ZXh0QmxvY2tFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd0ZXh0X2Jsb2NrX2VsZW1lbnRzJywgJ2gxIGgyIGgzIGg0IGg1IGg2IHAgZGl2IGFkZHJlc3MgcHJlIGZvcm0gJyArICdibG9ja3F1b3RlIGNlbnRlciBkaXIgZmllbGRzZXQgaGVhZGVyIGZvb3RlciBhcnRpY2xlIHNlY3Rpb24gaGdyb3VwIGFzaWRlIG1haW4gbmF2IGZpZ3VyZScpO1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCdibG9ja19lbGVtZW50cycsICdociB0YWJsZSB0Ym9keSB0aGVhZCB0Zm9vdCAnICsgJ3RoIHRyIHRkIGxpIG9sIHVsIGNhcHRpb24gZGwgZHQgZGQgbm9zY3JpcHQgbWVudSBpc2luZGV4IG9wdGlvbiAnICsgJ2RhdGFsaXN0IHNlbGVjdCBvcHRncm91cCBmaWdjYXB0aW9uIGRldGFpbHMgc3VtbWFyeScsIHRleHRCbG9ja0VsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IHRleHRJbmxpbmVFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd0ZXh0X2lubGluZV9lbGVtZW50cycsICdzcGFuIHN0cm9uZyBiIGVtIGkgZm9udCBzIHN0cmlrZSB1IHZhciBjaXRlICcgKyAnZGZuIGNvZGUgbWFyayBxIHN1cCBzdWIgc2FtcCcpO1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRFbGVtZW50c01hcCA9IGNyZWF0ZUxvb2t1cFRhYmxlKCd0cmFuc3BhcmVudF9lbGVtZW50cycsICdhIGlucyBkZWwgY2FudmFzIG1hcCcpO1xuICAgICAgZWFjaCRiKCdzY3JpcHQgbm9zY3JpcHQgaWZyYW1lIG5vZnJhbWVzIG5vZW1iZWQgdGl0bGUgc3R5bGUgdGV4dGFyZWEgeG1wIHBsYWludGV4dCcuc3BsaXQoJyAnKSwgbmFtZSA9PiB7XG4gICAgICAgIHNwZWNpYWxFbGVtZW50c1tuYW1lXSA9IG5ldyBSZWdFeHAoJzwvJyArIG5hbWUgKyAnW14+XSo+JywgJ2dpJyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFkZFZhbGlkRWxlbWVudHMgPSB2YWxpZEVsZW1lbnRzID0+IHtcbiAgICAgICAgY29uc3QgZ2xvYmFsRWxlbWVudCA9IE9wdGlvbmFsLmZyb20oZWxlbWVudHNbJ0AnXSk7XG4gICAgICAgIGNvbnN0IGhhc1BhdHRlcm5zUmVnRXhwID0gL1sqPytdLztcbiAgICAgICAgZWFjaCRlKHBhcnNlVmFsaWRFbGVtZW50c1J1bGVzKGdsb2JhbEVsZW1lbnQsIHZhbGlkRWxlbWVudHMgIT09IG51bGwgJiYgdmFsaWRFbGVtZW50cyAhPT0gdm9pZCAwID8gdmFsaWRFbGVtZW50cyA6ICcnKSwgKHtuYW1lLCBlbGVtZW50LCBhbGlhc05hbWV9KSA9PiB7XG4gICAgICAgICAgaWYgKGFsaWFzTmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudHNbYWxpYXNOYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNQYXR0ZXJuc1JlZ0V4cC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBwYXR0ZXJuRWxlbWVudC5wYXR0ZXJuID0gcGF0dGVyblRvUmVnRXhwKG5hbWUpO1xuICAgICAgICAgICAgcGF0dGVybkVsZW1lbnRzLnB1c2gocGF0dGVybkVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50c1tuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRWYWxpZEVsZW1lbnRzID0gdmFsaWRFbGVtZW50cyA9PiB7XG4gICAgICAgIHBhdHRlcm5FbGVtZW50cyA9IFtdO1xuICAgICAgICBlYWNoJGUoa2V5cyhlbGVtZW50cyksIG5hbWUgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZFZhbGlkRWxlbWVudHModmFsaWRFbGVtZW50cyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQ3VzdG9tRWxlbWVudHMgPSBjdXN0b21FbGVtZW50cyA9PiB7XG4gICAgICAgIGRlbGV0ZSBtYXBDYWNoZS50ZXh0X2Jsb2NrX2VsZW1lbnRzO1xuICAgICAgICBkZWxldGUgbWFwQ2FjaGUuYmxvY2tfZWxlbWVudHM7XG4gICAgICAgIGVhY2gkZShwYXJzZUN1c3RvbUVsZW1lbnRzUnVsZXMoY3VzdG9tRWxlbWVudHMgIT09IG51bGwgJiYgY3VzdG9tRWxlbWVudHMgIT09IHZvaWQgMCA/IGN1c3RvbUVsZW1lbnRzIDogJycpLCAoe2lubGluZSwgbmFtZSwgY2xvbmVOYW1lfSkgPT4ge1xuICAgICAgICAgIGNoaWxkcmVuW25hbWVdID0gY2hpbGRyZW5bY2xvbmVOYW1lXTtcbiAgICAgICAgICBjdXN0b21FbGVtZW50c01hcFtuYW1lXSA9IGNsb25lTmFtZTtcbiAgICAgICAgICBub25FbXB0eUVsZW1lbnRzTWFwW25hbWUudG9VcHBlckNhc2UoKV0gPSB7fTtcbiAgICAgICAgICBub25FbXB0eUVsZW1lbnRzTWFwW25hbWVdID0ge307XG4gICAgICAgICAgaWYgKCFpbmxpbmUpIHtcbiAgICAgICAgICAgIGJsb2NrRWxlbWVudHNNYXBbbmFtZS50b1VwcGVyQ2FzZSgpXSA9IHt9O1xuICAgICAgICAgICAgYmxvY2tFbGVtZW50c01hcFtuYW1lXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICBsZXQgY3VzdG9tUnVsZSA9IGVsZW1lbnRzW2Nsb25lTmFtZV07XG4gICAgICAgICAgICBjdXN0b21SdWxlID0gZXh0ZW5kJDIoe30sIGN1c3RvbVJ1bGUpO1xuICAgICAgICAgICAgZGVsZXRlIGN1c3RvbVJ1bGUucmVtb3ZlRW1wdHlBdHRycztcbiAgICAgICAgICAgIGRlbGV0ZSBjdXN0b21SdWxlLnJlbW92ZUVtcHR5O1xuICAgICAgICAgICAgZWxlbWVudHNbbmFtZV0gPSBjdXN0b21SdWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlYWNoJGQoY2hpbGRyZW4sIChlbGVtZW50LCBlbG1OYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFtjbG9uZU5hbWVdKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuW2VsbU5hbWVdID0gZWxlbWVudCA9IGV4dGVuZCQyKHt9LCBjaGlsZHJlbltlbG1OYW1lXSk7XG4gICAgICAgICAgICAgIGVsZW1lbnRbbmFtZV0gPSBlbGVtZW50W2Nsb25lTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZFZhbGlkQ2hpbGRyZW4gPSB2YWxpZENoaWxkcmVuID0+IHtcbiAgICAgICAgZWFjaCRlKHBhcnNlVmFsaWRDaGlsZHJlblJ1bGVzKHZhbGlkQ2hpbGRyZW4gIT09IG51bGwgJiYgdmFsaWRDaGlsZHJlbiAhPT0gdm9pZCAwID8gdmFsaWRDaGlsZHJlbiA6ICcnKSwgKHtvcGVyYXRpb24sIG5hbWUsIHZhbGlkQ2hpbGRyZW59KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gb3BlcmF0aW9uID09PSAncmVwbGFjZScgPyB7ICcjY29tbWVudCc6IHt9IH0gOiBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICBlYWNoJGUodmFsaWRDaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudFtjaGlsZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnRbY2hpbGRdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBwYXJlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEVsZW1lbnRSdWxlID0gbmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tuYW1lXTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IHBhdHRlcm5FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuRWxlbWVudCA9IHBhdHRlcm5FbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAocGF0dGVybkVsZW1lbnQucGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybkVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgICAgaWYgKCFzZXR0aW5ncy52YWxpZF9lbGVtZW50cykge1xuICAgICAgICBlYWNoJGIoc2NoZW1hSXRlbXMsIChlbGVtZW50LCBuYW1lKSA9PiB7XG4gICAgICAgICAgZWxlbWVudHNbbmFtZV0gPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBlbGVtZW50LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzT3JkZXI6IGVsZW1lbnQuYXR0cmlidXRlc09yZGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGIoc3BsaXQkMSgnc3Ryb25nL2IgZW0vaScpLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHNwbGl0JDEoaXRlbSwgJy8nKTtcbiAgICAgICAgICBlbGVtZW50c1tpdGVtc1sxXV0ub3V0cHV0TmFtZSA9IGl0ZW1zWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCRiKHRleHRJbmxpbmVFbGVtZW50c01hcCwgKF92YWwsIG5hbWUpID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYWRkX2VtcHR5X2Jsb2NrX2lubGluZV9jaGlsZHJlbikge1xuICAgICAgICAgICAgICBlbGVtZW50c1tuYW1lXS5wYWRkSW5FbXB0eUJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzW25hbWVdLnJlbW92ZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGIoc3BsaXQkMSgnb2wgdWwgYmxvY2txdW90ZSBhIHRhYmxlIHRib2R5JyksIG5hbWUgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgZWxlbWVudHNbbmFtZV0ucmVtb3ZlRW1wdHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKCdwIGgxIGgyIGgzIGg0IGg1IGg2IHRoIHRkIHByZSBkaXYgYWRkcmVzcyBjYXB0aW9uIGxpIHN1bW1hcnknKSwgbmFtZSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzW25hbWVdKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tuYW1lXS5wYWRkRW1wdHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkYihzcGxpdCQxKCdzcGFuJyksIG5hbWUgPT4ge1xuICAgICAgICAgIGVsZW1lbnRzW25hbWVdLnJlbW92ZUVtcHR5QXR0cnMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFZhbGlkRWxlbWVudHMoc2V0dGluZ3MudmFsaWRfZWxlbWVudHMpO1xuICAgICAgICBlYWNoJGIoc2NoZW1hSXRlbXMsIChlbGVtZW50LCBuYW1lKSA9PiB7XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZEN1c3RvbUVsZW1lbnRzKHNldHRpbmdzLmN1c3RvbV9lbGVtZW50cyk7XG4gICAgICBhZGRWYWxpZENoaWxkcmVuKHNldHRpbmdzLnZhbGlkX2NoaWxkcmVuKTtcbiAgICAgIGFkZFZhbGlkRWxlbWVudHMoc2V0dGluZ3MuZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHMpO1xuICAgICAgYWRkVmFsaWRDaGlsZHJlbignK29sW3VsfG9sXSwrdWxbdWx8b2xdJyk7XG4gICAgICBlYWNoJGIoe1xuICAgICAgICBkZDogJ2RsJyxcbiAgICAgICAgZHQ6ICdkbCcsXG4gICAgICAgIGxpOiAndWwgb2wnLFxuICAgICAgICB0ZDogJ3RyJyxcbiAgICAgICAgdGg6ICd0cicsXG4gICAgICAgIHRyOiAndGJvZHkgdGhlYWQgdGZvb3QnLFxuICAgICAgICB0Ym9keTogJ3RhYmxlJyxcbiAgICAgICAgdGhlYWQ6ICd0YWJsZScsXG4gICAgICAgIHRmb290OiAndGFibGUnLFxuICAgICAgICBsZWdlbmQ6ICdmaWVsZHNldCcsXG4gICAgICAgIGFyZWE6ICdtYXAnLFxuICAgICAgICBwYXJhbTogJ3ZpZGVvIGF1ZGlvIG9iamVjdCdcbiAgICAgIH0sIChwYXJlbnRzLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50c1tpdGVtXSkge1xuICAgICAgICAgIGVsZW1lbnRzW2l0ZW1dLnBhcmVudHNSZXF1aXJlZCA9IHNwbGl0JDEocGFyZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNldHRpbmdzLmludmFsaWRfZWxlbWVudHMpIHtcbiAgICAgICAgZWFjaCRiKGV4cGxvZGUkMihzZXR0aW5ncy5pbnZhbGlkX2VsZW1lbnRzKSwgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzW2l0ZW1dKSB7XG4gICAgICAgICAgICBkZWxldGUgZWxlbWVudHNbaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2V0RWxlbWVudFJ1bGUoJ3NwYW4nKSkge1xuICAgICAgICBhZGRWYWxpZEVsZW1lbnRzKCdzcGFuWyFkYXRhLW1jZS10eXBlfCpdJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBnZXRWYWxpZFN0eWxlcyA9IGNvbnN0YW50KHZhbGlkU3R5bGVzKTtcbiAgICAgIGNvbnN0IGdldEludmFsaWRTdHlsZXMgPSBjb25zdGFudChpbnZhbGlkU3R5bGVzKTtcbiAgICAgIGNvbnN0IGdldFZhbGlkQ2xhc3NlcyA9IGNvbnN0YW50KHZhbGlkQ2xhc3Nlcyk7XG4gICAgICBjb25zdCBnZXRCb29sQXR0cnMgPSBjb25zdGFudChib29sQXR0ck1hcCk7XG4gICAgICBjb25zdCBnZXRCbG9ja0VsZW1lbnRzID0gY29uc3RhbnQoYmxvY2tFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRUZXh0QmxvY2tFbGVtZW50cyA9IGNvbnN0YW50KHRleHRCbG9ja0VsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldFRleHRJbmxpbmVFbGVtZW50cyA9IGNvbnN0YW50KHRleHRJbmxpbmVFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRWb2lkRWxlbWVudHMgPSBjb25zdGFudChPYmplY3Quc2VhbCh2b2lkRWxlbWVudHNNYXApKTtcbiAgICAgIGNvbnN0IGdldFNlbGZDbG9zaW5nRWxlbWVudHMgPSBjb25zdGFudChzZWxmQ2xvc2luZ0VsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldE5vbkVtcHR5RWxlbWVudHMgPSBjb25zdGFudChub25FbXB0eUVsZW1lbnRzTWFwKTtcbiAgICAgIGNvbnN0IGdldE1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50cyA9IGNvbnN0YW50KG1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50c01hcCk7XG4gICAgICBjb25zdCBnZXRXaGl0ZXNwYWNlRWxlbWVudHMgPSBjb25zdGFudCh3aGl0ZXNwYWNlRWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0VHJhbnNwYXJlbnRFbGVtZW50cyA9IGNvbnN0YW50KHRyYW5zcGFyZW50RWxlbWVudHNNYXApO1xuICAgICAgY29uc3QgZ2V0U3BlY2lhbEVsZW1lbnRzID0gY29uc3RhbnQoT2JqZWN0LnNlYWwoc3BlY2lhbEVsZW1lbnRzKSk7XG4gICAgICBjb25zdCBpc1ZhbGlkQ2hpbGQgPSAobmFtZSwgY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGRyZW5bbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgcmV0dXJuICEhKHBhcmVudCAmJiBwYXJlbnRbY2hpbGQudG9Mb3dlckNhc2UoKV0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAobmFtZSwgYXR0cikgPT4ge1xuICAgICAgICBjb25zdCBydWxlID0gZ2V0RWxlbWVudFJ1bGUobmFtZSk7XG4gICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmF0dHJpYnV0ZXNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdHRyUGF0dGVybnMgPSBydWxlLmF0dHJpYnV0ZVBhdHRlcm5zO1xuICAgICAgICAgICAgaWYgKGF0dHJQYXR0ZXJucykge1xuICAgICAgICAgICAgICBsZXQgaSA9IGF0dHJQYXR0ZXJucy5sZW5ndGg7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0clBhdHRlcm5zW2ldLnBhdHRlcm4udGVzdChhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q3VzdG9tRWxlbWVudHMgPSBjb25zdGFudChjdXN0b21FbGVtZW50c01hcCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBzY2hlbWFUeXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIGdldFZhbGlkU3R5bGVzLFxuICAgICAgICBnZXRWYWxpZENsYXNzZXMsXG4gICAgICAgIGdldEJsb2NrRWxlbWVudHMsXG4gICAgICAgIGdldEludmFsaWRTdHlsZXMsXG4gICAgICAgIGdldFZvaWRFbGVtZW50cyxcbiAgICAgICAgZ2V0VGV4dEJsb2NrRWxlbWVudHMsXG4gICAgICAgIGdldFRleHRJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgZ2V0Qm9vbEF0dHJzLFxuICAgICAgICBnZXRFbGVtZW50UnVsZSxcbiAgICAgICAgZ2V0U2VsZkNsb3NpbmdFbGVtZW50cyxcbiAgICAgICAgZ2V0Tm9uRW1wdHlFbGVtZW50cyxcbiAgICAgICAgZ2V0TW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzLFxuICAgICAgICBnZXRXaGl0ZXNwYWNlRWxlbWVudHMsXG4gICAgICAgIGdldFRyYW5zcGFyZW50RWxlbWVudHMsXG4gICAgICAgIGdldFNwZWNpYWxFbGVtZW50cyxcbiAgICAgICAgaXNWYWxpZENoaWxkLFxuICAgICAgICBpc1ZhbGlkLFxuICAgICAgICBnZXRDdXN0b21FbGVtZW50cyxcbiAgICAgICAgYWRkVmFsaWRFbGVtZW50cyxcbiAgICAgICAgc2V0VmFsaWRFbGVtZW50cyxcbiAgICAgICAgYWRkQ3VzdG9tRWxlbWVudHMsXG4gICAgICAgIGFkZFZhbGlkQ2hpbGRyZW5cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFN0eWxlcyA9IChzZXR0aW5ncyA9IHt9LCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHVybE9yU3RyUmVnRXhwID0gLyg/OnVybCg/Oig/OlxcKFxccypcXFwiKFteXFxcIl0rKVxcXCJcXHMqXFwpKXwoPzpcXChcXHMqXFwnKFteXFwnXSspXFwnXFxzKlxcKSl8KD86XFwoXFxzKihbXilcXHNdKylcXHMqXFwpKSkpfCg/OlxcJyhbXlxcJ10rKVxcJyl8KD86XFxcIihbXlxcXCJdKylcXFwiKS9naTtcbiAgICAgIGNvbnN0IHN0eWxlUmVnRXhwID0gL1xccyooW146XSspOlxccyooW147XSspOz8vZztcbiAgICAgIGNvbnN0IHRyaW1SaWdodFJlZ0V4cCA9IC9cXHMrJC87XG4gICAgICBjb25zdCBlbmNvZGluZ0xvb2t1cCA9IHt9O1xuICAgICAgbGV0IHZhbGlkU3R5bGVzO1xuICAgICAgbGV0IGludmFsaWRTdHlsZXM7XG4gICAgICBjb25zdCBpbnZpc2libGVDaGFyID0gemVyb1dpZHRoO1xuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICB2YWxpZFN0eWxlcyA9IHNjaGVtYS5nZXRWYWxpZFN0eWxlcygpO1xuICAgICAgICBpbnZhbGlkU3R5bGVzID0gc2NoZW1hLmdldEludmFsaWRTdHlsZXMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuY29kaW5nSXRlbXMgPSAoYFxcXFxcIiBcXFxcJyBcXFxcOyBcXFxcOiA7IDogYCArIGludmlzaWJsZUNoYXIpLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kaW5nSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5jb2RpbmdMb29rdXBbZW5jb2RpbmdJdGVtc1tpXV0gPSBpbnZpc2libGVDaGFyICsgaTtcbiAgICAgICAgZW5jb2RpbmdMb29rdXBbaW52aXNpYmxlQ2hhciArIGldID0gZW5jb2RpbmdJdGVtc1tpXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICAgIHBhcnNlOiBjc3MgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHt9O1xuICAgICAgICAgIGxldCBpc0VuY29kZWQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXIgPSBzZXR0aW5ncy51cmxfY29udmVydGVyO1xuICAgICAgICAgIGNvbnN0IHVybENvbnZlcnRlclNjb3BlID0gc2V0dGluZ3MudXJsX2NvbnZlcnRlcl9zY29wZSB8fCBzZWxmO1xuICAgICAgICAgIGNvbnN0IGNvbXByZXNzID0gKHByZWZpeCwgc3VmZml4LCBub0pvaW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHN0eWxlc1twcmVmaXggKyAnLXRvcCcgKyBzdWZmaXhdO1xuICAgICAgICAgICAgaWYgKCF0b3ApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBzdHlsZXNbcHJlZml4ICsgJy1yaWdodCcgKyBzdWZmaXhdO1xuICAgICAgICAgICAgaWYgKCFyaWdodCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBzdHlsZXNbcHJlZml4ICsgJy1ib3R0b20nICsgc3VmZml4XTtcbiAgICAgICAgICAgIGlmICghYm90dG9tKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBzdHlsZXNbcHJlZml4ICsgJy1sZWZ0JyArIHN1ZmZpeF07XG4gICAgICAgICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm94ID0gW1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnRcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgaSA9IGJveC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAoYm94W2ldICE9PSBib3hbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gLTEgJiYgbm9Kb2luKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlc1twcmVmaXggKyBzdWZmaXhdID0gaSA9PT0gLTEgPyBib3hbMF0gOiBib3guam9pbignICcpO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1twcmVmaXggKyAnLXRvcCcgKyBzdWZmaXhdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1twcmVmaXggKyAnLXJpZ2h0JyArIHN1ZmZpeF07XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW3ByZWZpeCArICctYm90dG9tJyArIHN1ZmZpeF07XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW3ByZWZpeCArICctbGVmdCcgKyBzdWZmaXhdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgY2FuQ29tcHJlc3MgPSBrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuaW5kZXhPZignLCcpID4gLTEgPyBbdmFsdWVdIDogdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBpID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSAhPT0gdmFsdWVzWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgY29tcHJlc3MyID0gKHRhcmdldCwgYSwgYiwgYykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYW5Db21wcmVzcyhhKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbkNvbXByZXNzKGIpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FuQ29tcHJlc3MoYykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVzW3RhcmdldF0gPSBzdHlsZXNbYV0gKyAnICcgKyBzdHlsZXNbYl0gKyAnICcgKyBzdHlsZXNbY107XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVzW2FdO1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1tiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXNbY107XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBlbmNvZGUgPSBzdHIgPT4ge1xuICAgICAgICAgICAgaXNFbmNvZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGluZ0xvb2t1cFtzdHJdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZGVjb2RlID0gKHN0ciwga2VlcFNsYXNoZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0VuY29kZWQpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcdUZFRkZbMC05XS9nLCBzdHIgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGluZ0xvb2t1cFtzdHJdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcFNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcXFwoW1xcJ1xcXCI7Ol0pL2csICckMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGRlY29kZVNpbmdsZUhleFNlcXVlbmNlID0gZXNjU2VxID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGVzY1NlcS5zbGljZSgxKSwgMTYpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGRlY29kZUhleFNlcXVlbmNlcyA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXFxcWzAtOWEtZl0rL2dpLCBkZWNvZGVTaW5nbGVIZXhTZXF1ZW5jZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzVXJsID0gKG1hdGNoLCB1cmwsIHVybDIsIHVybDMsIHN0ciwgc3RyMikgPT4ge1xuICAgICAgICAgICAgc3RyID0gc3RyIHx8IHN0cjI7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGRlY29kZShzdHIpO1xuICAgICAgICAgICAgICByZXR1cm4gYCdgICsgc3RyLnJlcGxhY2UoL1xcJy9nLCBgXFxcXCdgKSArIGAnYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGRlY29kZSh1cmwgfHwgdXJsMiB8fCB1cmwzIHx8ICcnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfc2NyaXB0X3VybHMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0VXJsID0gdXJsLnJlcGxhY2UoL1tcXHNcXHJcXG5dKy9nLCAnJyk7XG4gICAgICAgICAgICAgIGlmICgvKGphdmF8dmIpc2NyaXB0Oi9pLnRlc3Qoc2NyaXB0VXJsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFsbG93X3N2Z19kYXRhX3VybHMgJiYgL15kYXRhOmltYWdlXFwvc3ZnL2kudGVzdChzY3JpcHRVcmwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsQ29udmVydGVyKSB7XG4gICAgICAgICAgICAgIHVybCA9IHVybENvbnZlcnRlci5jYWxsKHVybENvbnZlcnRlclNjb3BlLCB1cmwsICdzdHlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJ2AgKyB1cmwucmVwbGFjZSgvXFwnL2csIGBcXFxcJ2ApICsgYCcpYDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKC9bXFx1MDAwMC1cXHUwMDFGXS9nLCAnJyk7XG4gICAgICAgICAgICBjc3MgPSBjc3MucmVwbGFjZSgvXFxcXFtcXFwiXFwnOzpcXHVGRUZGXS9nLCBlbmNvZGUpLnJlcGxhY2UoL1xcXCJbXlxcXCJdK1xcXCJ8XFwnW15cXCddK1xcJy9nLCBzdHIgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1s7Ol0vZywgZW5jb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlcyA9IHN0eWxlUmVnRXhwLmV4ZWMoY3NzKSkge1xuICAgICAgICAgICAgICBzdHlsZVJlZ0V4cC5sYXN0SW5kZXggPSBtYXRjaGVzLmluZGV4ICsgbWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGxldCBuYW1lID0gbWF0Y2hlc1sxXS5yZXBsYWNlKHRyaW1SaWdodFJlZ0V4cCwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG1hdGNoZXNbMl0ucmVwbGFjZSh0cmltUmlnaHRSZWdFeHAsICcnKTtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gZGVjb2RlSGV4U2VxdWVuY2VzKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlSGV4U2VxdWVuY2VzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKGludmlzaWJsZUNoYXIpICE9PSAtMSB8fCBuYW1lLmluZGV4T2YoJ1wiJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscyAmJiAobmFtZSA9PT0gJ2JlaGF2aW9yJyB8fCAvZXhwcmVzc2lvblxccypcXCh8XFwvXFwqfFxcKlxcLy8udGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdmb250LXdlaWdodCcgJiYgdmFsdWUgPT09ICc3MDAnKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdib2xkJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjb2xvcicgfHwgbmFtZSA9PT0gJ2JhY2tncm91bmQtY29sb3InKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSh1cmxPclN0clJlZ0V4cCwgcHJvY2Vzc1VybCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzW25hbWVdID0gaXNFbmNvZGVkID8gZGVjb2RlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wcmVzcygnYm9yZGVyJywgJycsIHRydWUpO1xuICAgICAgICAgICAgY29tcHJlc3MoJ2JvcmRlcicsICctd2lkdGgnKTtcbiAgICAgICAgICAgIGNvbXByZXNzKCdib3JkZXInLCAnLWNvbG9yJyk7XG4gICAgICAgICAgICBjb21wcmVzcygnYm9yZGVyJywgJy1zdHlsZScpO1xuICAgICAgICAgICAgY29tcHJlc3MoJ3BhZGRpbmcnLCAnJyk7XG4gICAgICAgICAgICBjb21wcmVzcygnbWFyZ2luJywgJycpO1xuICAgICAgICAgICAgY29tcHJlc3MyKCdib3JkZXInLCAnYm9yZGVyLXdpZHRoJywgJ2JvcmRlci1zdHlsZScsICdib3JkZXItY29sb3InKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMuYm9yZGVyID09PSAnbWVkaXVtIG5vbmUnKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZXMuYm9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlc1snYm9yZGVyLWltYWdlJ10gPT09ICdub25lJykge1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVzWydib3JkZXItaW1hZ2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplOiAoc3R5bGVzLCBlbGVtZW50TmFtZSkgPT4ge1xuICAgICAgICAgIGxldCBjc3MgPSAnJztcbiAgICAgICAgICBjb25zdCBzZXJpYWxpemVTdHlsZXMgPSAoZWxlbU5hbWUsIHZhbGlkU3R5bGVMaXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZUxpc3QgPSB2YWxpZFN0eWxlTGlzdFtlbGVtTmFtZV07XG4gICAgICAgICAgICBpZiAoc3R5bGVMaXN0KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3R5bGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdHlsZUxpc3RbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBjc3MgKz0gKGNzcy5sZW5ndGggPiAwID8gJyAnIDogJycpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAobmFtZSwgZWxlbU5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghaW52YWxpZFN0eWxlcyB8fCAhZWxlbU5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3R5bGVNYXAgPSBpbnZhbGlkU3R5bGVzWycqJ107XG4gICAgICAgICAgICBpZiAoc3R5bGVNYXAgJiYgc3R5bGVNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVNYXAgPSBpbnZhbGlkU3R5bGVzW2VsZW1OYW1lXTtcbiAgICAgICAgICAgIHJldHVybiAhKHN0eWxlTWFwICYmIHN0eWxlTWFwW25hbWVdKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChlbGVtZW50TmFtZSAmJiB2YWxpZFN0eWxlcykge1xuICAgICAgICAgICAgc2VyaWFsaXplU3R5bGVzKCcqJywgdmFsaWRTdHlsZXMpO1xuICAgICAgICAgICAgc2VyaWFsaXplU3R5bGVzKGVsZW1lbnROYW1lLCB2YWxpZFN0eWxlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhY2gkZChzdHlsZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgaXNWYWxpZChuYW1lLCBlbGVtZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjc3MgKz0gKGNzcy5sZW5ndGggPiAwID8gJyAnIDogJycpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICc7JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjc3M7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVwcmVjYXRlZCA9IHtcbiAgICAgIGtleUxvY2F0aW9uOiB0cnVlLFxuICAgICAgbGF5ZXJYOiB0cnVlLFxuICAgICAgbGF5ZXJZOiB0cnVlLFxuICAgICAgcmV0dXJuVmFsdWU6IHRydWUsXG4gICAgICB3ZWJraXRNb3ZlbWVudFg6IHRydWUsXG4gICAgICB3ZWJraXRNb3ZlbWVudFk6IHRydWUsXG4gICAgICBrZXlJZGVudGlmaWVyOiB0cnVlLFxuICAgICAgbW96UHJlc3N1cmU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGlzTmF0aXZlRXZlbnQgPSBldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEV2ZW50IHx8IGlzRnVuY3Rpb24oZXZlbnQuaW5pdEV2ZW50KTtcbiAgICBjb25zdCBoYXNJc0RlZmF1bHRQcmV2ZW50ZWQgPSBldmVudCA9PiBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPT09IGFsd2F5cyB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPT09IG5ldmVyO1xuICAgIGNvbnN0IG5lZWRzTm9ybWFsaXppbmcgPSBldmVudCA9PiBpc051bGxhYmxlKGV2ZW50LnByZXZlbnREZWZhdWx0KSB8fCBpc05hdGl2ZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBjbG9uZSQzID0gKG9yaWdpbmFsRXZlbnQsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDoge307XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBpZiAoIWhhcyQyKGRlcHJlY2F0ZWQsIG5hbWUpKSB7XG4gICAgICAgICAgZXZlbnRbbmFtZV0gPSBvcmlnaW5hbEV2ZW50W25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZShvcmlnaW5hbEV2ZW50LmNvbXBvc2VkUGF0aCkpIHtcbiAgICAgICAgZXZlbnQuY29tcG9zZWRQYXRoID0gKCkgPT4gb3JpZ2luYWxFdmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZSQzID0gKHR5cGUsIG9yaWdpbmFsRXZlbnQsIGZhbGxiYWNrVGFyZ2V0LCBkYXRhKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBldmVudCA9IGNsb25lJDMob3JpZ2luYWxFdmVudCwgZGF0YSk7XG4gICAgICBldmVudC50eXBlID0gdHlwZTtcbiAgICAgIGlmIChpc051bGxhYmxlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gKF9hID0gZXZlbnQuc3JjRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsbGJhY2tUYXJnZXQ7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNOb3JtYWxpemluZyhvcmlnaW5hbEV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHtcbiAgICAgICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBhbHdheXM7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gYWx3YXlzO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGFsd2F5cztcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFoYXNJc0RlZmF1bHRQcmV2ZW50ZWQoZXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID0gZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9PT0gdHJ1ZSA/IGFsd2F5cyA6IG5ldmVyO1xuICAgICAgICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZXZlbnQuY2FuY2VsQnViYmxlID09PSB0cnVlID8gYWx3YXlzIDogbmV2ZXI7XG4gICAgICAgICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBjb25zdCBldmVudEV4cGFuZG9QcmVmaXggPSAnbWNlLWRhdGEtJztcbiAgICBjb25zdCBtb3VzZUV2ZW50UmUgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay87XG4gICAgY29uc3QgYWRkRXZlbnQgPSAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZSkgPT4ge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRXZlbnQgPSAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZSkgPT4ge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2ssIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgaXNNb3VzZUV2ZW50ID0gZXZlbnQgPT4gaXNOb25OdWxsYWJsZShldmVudCkgJiYgbW91c2VFdmVudFJlLnRlc3QoZXZlbnQudHlwZSk7XG4gICAgY29uc3QgZml4ID0gKG9yaWdpbmFsRXZlbnQsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbm9ybWFsaXplJDMob3JpZ2luYWxFdmVudC50eXBlLCBvcmlnaW5hbEV2ZW50LCBkb2N1bWVudCwgZGF0YSk7XG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KG9yaWdpbmFsRXZlbnQpICYmIGlzVW5kZWZpbmVkKG9yaWdpbmFsRXZlbnQucGFnZVgpICYmICFpc1VuZGVmaW5lZChvcmlnaW5hbEV2ZW50LmNsaWVudFgpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm9keSA9IGV2ZW50RG9jLmJvZHk7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBldmVudDtcbiAgICAgICAgbW91c2VFdmVudC5wYWdlWCA9IG9yaWdpbmFsRXZlbnQuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgICBtb3VzZUV2ZW50LnBhZ2VZID0gb3JpZ2luYWxFdmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmRPblJlYWR5ID0gKHdpbiwgY2FsbGJhY2ssIGV2ZW50VXRpbHMpID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudCwgZXZlbnQgPSB7IHR5cGU6ICdyZWFkeScgfTtcbiAgICAgIGlmIChldmVudFV0aWxzLmRvbUxvYWRlZCkge1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRG9jUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkb2MucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBkb2MucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyAmJiBkb2MuYm9keTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWFkeUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHJlbW92ZUV2ZW50KHdpbiwgJ0RPTUNvbnRlbnRMb2FkZWQnLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICByZW1vdmVFdmVudCh3aW4sICdsb2FkJywgcmVhZHlIYW5kbGVyKTtcbiAgICAgICAgaWYgKCFldmVudFV0aWxzLmRvbUxvYWRlZCkge1xuICAgICAgICAgIGV2ZW50VXRpbHMuZG9tTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgd2luID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBpZiAoaXNEb2NSZWFkeSgpKSB7XG4gICAgICAgIHJlYWR5SGFuZGxlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkRXZlbnQod2luLCAnRE9NQ29udGVudExvYWRlZCcsIHJlYWR5SGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoIWV2ZW50VXRpbHMuZG9tTG9hZGVkKSB7XG4gICAgICAgIGFkZEV2ZW50KHdpbiwgJ2xvYWQnLCByZWFkeUhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY2xhc3MgRXZlbnRVdGlscyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kb21Mb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIHRoaXMuZXhwYW5kbyA9IGV2ZW50RXhwYW5kb1ByZWZpeCArICgrbmV3IERhdGUoKSkudG9TdHJpbmcoMzIpO1xuICAgICAgICB0aGlzLmhhc0ZvY3VzSW4gPSAnb25mb2N1c2luJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfVxuICAgICAgYmluZCh0YXJnZXQsIG5hbWVzLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBjYWxsYmFja0xpc3Q7XG4gICAgICAgIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgICAgICAgY29uc3QgZGVmYXVsdE5hdGl2ZUhhbmRsZXIgPSBldnQgPT4ge1xuICAgICAgICAgIHNlbGYuZXhlY3V0ZUhhbmRsZXJzKGZpeChldnQgfHwgd2luLmV2ZW50KSwgaWQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRhcmdldCB8fCBpc1RleHQkYSh0YXJnZXQpIHx8IGlzQ29tbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKCF0YXJnZXRbc2VsZi5leHBhbmRvXSkge1xuICAgICAgICAgIGlkID0gc2VsZi5jb3VudCsrO1xuICAgICAgICAgIHRhcmdldFtzZWxmLmV4cGFuZG9dID0gaWQ7XG4gICAgICAgICAgc2VsZi5ldmVudHNbaWRdID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSB0YXJnZXRbc2VsZi5leHBhbmRvXTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSA9IHNjb3BlIHx8IHRhcmdldDtcbiAgICAgICAgY29uc3QgbmFtZXNMaXN0ID0gbmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgICAgbGV0IGkgPSBuYW1lc0xpc3QubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgbGV0IG5hbWUgPSBuYW1lc0xpc3RbaV07XG4gICAgICAgICAgbGV0IG5hdGl2ZUhhbmRsZXIgPSBkZWZhdWx0TmF0aXZlSGFuZGxlcjtcbiAgICAgICAgICBsZXQgY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCBmYWtlTmFtZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnRE9NQ29udGVudExvYWRlZCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSAncmVhZHknO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5kb21Mb2FkZWQgJiYgbmFtZSA9PT0gJ3JlYWR5JyAmJiB0YXJnZXQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSwgZml4KHsgdHlwZTogbmFtZSB9KSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLmhhc0ZvY3VzSW4gJiYgKG5hbWUgPT09ICdmb2N1c2luJyB8fCBuYW1lID09PSAnZm9jdXNvdXQnKSkge1xuICAgICAgICAgICAgY2FwdHVyZSA9IHRydWU7XG4gICAgICAgICAgICBmYWtlTmFtZSA9IG5hbWUgPT09ICdmb2N1c2luJyA/ICdmb2N1cycgOiAnYmx1cic7XG4gICAgICAgICAgICBuYXRpdmVIYW5kbGVyID0gZXZ0ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBmaXgoZXZ0IHx8IHdpbi5ldmVudCk7XG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBldmVudC50eXBlID09PSAnZm9jdXMnID8gJ2ZvY3VzaW4nIDogJ2ZvY3Vzb3V0JztcbiAgICAgICAgICAgICAgc2VsZi5leGVjdXRlSGFuZGxlcnMoZXZlbnQsIGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrTGlzdCA9IHNlbGYuZXZlbnRzW2lkXVtuYW1lXTtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrTGlzdCkge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNbaWRdW25hbWVdID0gY2FsbGJhY2tMaXN0ID0gW3tcbiAgICAgICAgICAgICAgICBmdW5jOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBzY29wZVxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGNhbGxiYWNrTGlzdC5mYWtlTmFtZSA9IGZha2VOYW1lO1xuICAgICAgICAgICAgY2FsbGJhY2tMaXN0LmNhcHR1cmUgPSBjYXB0dXJlO1xuICAgICAgICAgICAgY2FsbGJhY2tMaXN0Lm5hdGl2ZUhhbmRsZXIgPSBuYXRpdmVIYW5kbGVyO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWFkeScpIHtcbiAgICAgICAgICAgICAgYmluZE9uUmVhZHkodGFyZ2V0LCBuYXRpdmVIYW5kbGVyLCBzZWxmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZEV2ZW50KHRhcmdldCwgZmFrZU5hbWUgfHwgbmFtZSwgbmF0aXZlSGFuZGxlciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVhZHknICYmIHNlbGYuZG9tTG9hZGVkKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGZpeCh7IHR5cGU6IG5hbWUgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bmM6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNjb3BlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSBjYWxsYmFja0xpc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICB9XG4gICAgICB1bmJpbmQodGFyZ2V0LCBuYW1lcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNUZXh0JGEodGFyZ2V0KSB8fCBpc0NvbW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGFyZ2V0W3RoaXMuZXhwYW5kb107XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGxldCBldmVudE1hcCA9IHRoaXMuZXZlbnRzW2lkXTtcbiAgICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzTGlzdCA9IG5hbWVzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBsZXQgaSA9IG5hbWVzTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc0xpc3RbaV07XG4gICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTGlzdCA9IGV2ZW50TWFwW25hbWVdO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tMaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2kgPSBjYWxsYmFja0xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGNpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrTGlzdFtjaV0uZnVuYyA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYXRpdmVIYW5kbGVyID0gY2FsbGJhY2tMaXN0Lm5hdGl2ZUhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFrZU5hbWUgPSBjYWxsYmFja0xpc3QuZmFrZU5hbWUsIGNhcHR1cmUgPSBjYWxsYmFja0xpc3QuY2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDYWxsYmFja0xpc3QgPSBjYWxsYmFja0xpc3Quc2xpY2UoMCwgY2kpLmNvbmNhdChjYWxsYmFja0xpc3Quc2xpY2UoY2kgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tMaXN0Lm5hdGl2ZUhhbmRsZXIgPSBuYXRpdmVIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrTGlzdC5mYWtlTmFtZSA9IGZha2VOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrTGlzdC5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudE1hcFtuYW1lXSA9IG5ld0NhbGxiYWNrTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrIHx8IGNhbGxiYWNrTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudE1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRhcmdldCwgY2FsbGJhY2tMaXN0LmZha2VOYW1lIHx8IG5hbWUsIGNhbGxiYWNrTGlzdC5uYXRpdmVIYW5kbGVyLCBjYWxsYmFja0xpc3QuY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhY2gkZChldmVudE1hcCwgKGNhbGxiYWNrTGlzdCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICByZW1vdmVFdmVudCh0YXJnZXQsIGNhbGxiYWNrTGlzdC5mYWtlTmFtZSB8fCBuYW1lLCBjYWxsYmFja0xpc3QubmF0aXZlSGFuZGxlciwgY2FsbGJhY2tMaXN0LmNhcHR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudE1hcCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRNYXApIHtcbiAgICAgICAgICAgIGlmIChoYXMkMihldmVudE1hcCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tpZF07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbdGhpcy5leHBhbmRvXTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGFyZ2V0W3RoaXMuZXhwYW5kb10gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZpcmUodGFyZ2V0LCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKHRhcmdldCwgbmFtZSwgYXJncyk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaCh0YXJnZXQsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNUZXh0JGEodGFyZ2V0KSB8fCBpc0NvbW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZml4KHtcbiAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9LCBhcmdzKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IGlkID0gdGFyZ2V0W3RoaXMuZXhwYW5kb107XG4gICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWN1dGVIYW5kbGVycyhldmVudCwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSB8fCB0YXJnZXQub3duZXJEb2N1bWVudCB8fCB0YXJnZXQuZGVmYXVsdFZpZXcgfHwgdGFyZ2V0LnBhcmVudFdpbmRvdztcbiAgICAgICAgfSB3aGlsZSAodGFyZ2V0ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjbGVhbih0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgaXNUZXh0JGEodGFyZ2V0KSB8fCBpc0NvbW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRbdGhpcy5leHBhbmRvXSkge1xuICAgICAgICAgIHRoaXMudW5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICB0aGlzLnVuYmluZCh0YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgICAgICAgbGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3RoaXMuZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgdGhpcy51bmJpbmQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgfVxuICAgICAgY2FuY2VsKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBleGVjdXRlSGFuZGxlcnMoZXZ0LCBpZCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmV2ZW50c1tpZF07XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTGlzdCA9IGNvbnRhaW5lciAmJiBjb250YWluZXJbZXZ0LnR5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tMaXN0KSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjYWxsYmFja0xpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5mdW5jLmNhbGwoY2FsbGJhY2suc2NvcGUsIGV2dCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2dC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRVdGlscy5FdmVudCA9IG5ldyBFdmVudFV0aWxzKCk7XG5cbiAgICBjb25zdCBlYWNoJGEgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IGdyZXAgPSBUb29scy5ncmVwO1xuICAgIGNvbnN0IGludGVybmFsU3R5bGVOYW1lID0gJ2RhdGEtbWNlLXN0eWxlJztcbiAgICBjb25zdCBudW1lcmljYWxDc3NNYXAgPSBUb29scy5tYWtlTWFwKCdmaWxsLW9wYWNpdHkgZm9udC13ZWlnaHQgbGluZS1oZWlnaHQgb3BhY2l0eSBvcnBoYW5zIHdpZG93cyB6LWluZGV4IHpvb20nLCAnICcpO1xuICAgIGNvbnN0IGxlZ2FjeVNldEF0dHJpYnV0ZSA9IChlbG0sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoaXNOdWxsYWJsZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJlbW92ZSRhKGVsbSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXQkMyhlbG0sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNhbWVsQ2FzZVRvSHlwaGVucyA9IG5hbWUgPT4gbmFtZS5yZXBsYWNlKC9bQS1aXS9nLCB2ID0+ICctJyArIHYudG9Mb3dlckNhc2UoKSk7XG4gICAgY29uc3QgZmluZE5vZGVJbmRleCA9IChub2RlLCBub3JtYWxpemVkKSA9PiB7XG4gICAgICBsZXQgaWR4ID0gMDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGZvciAobGV0IGxhc3ROb2RlVHlwZSA9IG5vZGUubm9kZVR5cGUsIHRlbXBOb2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7IHRlbXBOb2RlOyB0ZW1wTm9kZSA9IHRlbXBOb2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gdGVtcE5vZGUubm9kZVR5cGU7XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgJiYgaXNUZXh0JGEodGVtcE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IGxhc3ROb2RlVHlwZSB8fCAhdGVtcE5vZGUuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgIGxhc3ROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlSW50ZXJuYWxTdHlsZUF0dHIgPSAoc3R5bGVzLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZ2V0JDkoZWxtLCAnc3R5bGUnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzLnNlcmlhbGl6ZShzdHlsZXMucGFyc2UocmF3VmFsdWUpLCBuYW1lKGVsbSkpO1xuICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKGVsbSwgaW50ZXJuYWxTdHlsZU5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnZlcnRTdHlsZVRvU3RyaW5nID0gKGNzc1ZhbHVlLCBjc3NOYW1lKSA9PiB7XG4gICAgICBpZiAoaXNOdW1iZXIoY3NzVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBoYXMkMihudW1lcmljYWxDc3NNYXAsIGNzc05hbWUpID8gY3NzVmFsdWUgKyAnJyA6IGNzc1ZhbHVlICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjc3NWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5U3R5bGUkMSA9ICgkZWxtLCBjc3NOYW1lLCBjc3NWYWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBjYW1lbENhc2VUb0h5cGhlbnMoY3NzTmFtZSk7XG4gICAgICBpZiAoaXNOdWxsYWJsZShjc3NWYWx1ZSkgfHwgY3NzVmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJlbW92ZSQ2KCRlbG0sIG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldCQyKCRlbG0sIG5vcm1hbGl6ZWROYW1lLCBjb252ZXJ0U3R5bGVUb1N0cmluZyhjc3NWYWx1ZSwgbm9ybWFsaXplZE5hbWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwQXR0ckhvb2tzID0gKHN0eWxlcywgc2V0dGluZ3MsIGdldENvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGtlZXBWYWx1ZXMgPSBzZXR0aW5ncy5rZWVwX3ZhbHVlcztcbiAgICAgIGNvbnN0IGtlZXBVcmxIb29rID0ge1xuICAgICAgICBzZXQ6IChlbG0sIHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3VnYXJFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHNldHRpbmdzLnVybF9jb252ZXJ0ZXIpICYmIGlzTm9uTnVsbGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXIuY2FsbChzZXR0aW5ncy51cmxfY29udmVydGVyX3Njb3BlIHx8IGdldENvbnRleHQoKSwgU3RyaW5nKHZhbHVlKSwgbmFtZSwgZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZShzdWdhckVsbSwgaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgbGVnYWN5U2V0QXR0cmlidXRlKHN1Z2FyRWxtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogKGVsbSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICByZXR1cm4gZ2V0JDkoc3VnYXJFbG0sICdkYXRhLW1jZS0nICsgbmFtZSkgfHwgZ2V0JDkoc3VnYXJFbG0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYXR0ckhvb2tzID0ge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHNldDogKGVsbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICAgIGlmIChrZWVwVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZShzdWdhckVsbSwgaW50ZXJuYWxTdHlsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZSRhKHN1Z2FyRWxtLCAnc3R5bGUnKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc2V0QWxsKHN1Z2FyRWxtLCBzdHlsZXMucGFyc2UodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogZWxtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2FyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0JDkoc3VnYXJFbG0sIGludGVybmFsU3R5bGVOYW1lKSB8fCBnZXQkOShzdWdhckVsbSwgJ3N0eWxlJyk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzLnNlcmlhbGl6ZShzdHlsZXMucGFyc2UodmFsdWUpLCBuYW1lKHN1Z2FyRWxtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtlZXBWYWx1ZXMpIHtcbiAgICAgICAgYXR0ckhvb2tzLmhyZWYgPSBhdHRySG9va3Muc3JjID0ga2VlcFVybEhvb2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0ckhvb2tzO1xuICAgIH07XG4gICAgY29uc3QgRE9NVXRpbHMgPSAoZG9jLCBzZXR0aW5ncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBhZGRlZFN0eWxlcyA9IHt9O1xuICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgY29uc3QgZmlsZXMgPSB7fTtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGNvbnN0IHN0ZE1vZGUgPSB0cnVlO1xuICAgICAgY29uc3QgYm94TW9kZWwgPSB0cnVlO1xuICAgICAgY29uc3Qgc3R5bGVTaGVldExvYWRlciA9IGluc3RhbmNlLmZvckVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jKSwge1xuICAgICAgICBjb250ZW50Q3NzQ29yczogc2V0dGluZ3MuY29udGVudENzc0NvcnMsXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBzZXR0aW5ncy5yZWZlcnJlclBvbGljeVxuICAgICAgfSk7XG4gICAgICBjb25zdCBib3VuZEV2ZW50cyA9IFtdO1xuICAgICAgY29uc3Qgc2NoZW1hID0gc2V0dGluZ3Muc2NoZW1hID8gc2V0dGluZ3Muc2NoZW1hIDogU2NoZW1hKHt9KTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IFN0eWxlcyh7XG4gICAgICAgIHVybF9jb252ZXJ0ZXI6IHNldHRpbmdzLnVybF9jb252ZXJ0ZXIsXG4gICAgICAgIHVybF9jb252ZXJ0ZXJfc2NvcGU6IHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGVcbiAgICAgIH0sIHNldHRpbmdzLnNjaGVtYSk7XG4gICAgICBjb25zdCBldmVudHMgPSBzZXR0aW5ncy5vd25FdmVudHMgPyBuZXcgRXZlbnRVdGlscygpIDogRXZlbnRVdGlscy5FdmVudDtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHNNYXAgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3QgaXNCbG9jayA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFzJDIoYmxvY2tFbGVtZW50c01hcCwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIChoYXMkMihibG9ja0VsZW1lbnRzTWFwLCBub2RlLm5vZGVOYW1lKSB8fCBpc1RyYW5zcGFyZW50QmxvY2soc2NoZW1hLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXQgPSBlbG0gPT4gZWxtICYmIGRvYyAmJiBpc1N0cmluZyhlbG0pID8gZG9jLmdldEVsZW1lbnRCeUlkKGVsbSkgOiBlbG07XG4gICAgICBjb25zdCBfZ2V0ID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQoZWxtKTtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodmFsdWUpID8gU3VnYXJFbGVtZW50LmZyb21Eb20odmFsdWUpIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdHRyaWIgPSAoZWxtLCBuYW1lLCBkZWZhdWx0VmFsID0gJycpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBjb25zdCAkZWxtID0gX2dldChlbG0pO1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZSgkZWxtKSAmJiBpc0VsZW1lbnQkNygkZWxtKSkge1xuICAgICAgICAgIGNvbnN0IGhvb2sgPSBhdHRySG9va3NbbmFtZV07XG4gICAgICAgICAgaWYgKGhvb2sgJiYgaG9vay5nZXQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaG9vay5nZXQoJGVsbS5kb20sIG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldCQ5KCRlbG0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOb25OdWxsYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWw7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0QXR0cmlicyA9IGVsbSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBnZXQoZWxtKTtcbiAgICAgICAgcmV0dXJuIGlzTnVsbGFibGUobm9kZSkgPyBbXSA6IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRBdHRyaWIgPSAoZWxtLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHtcbiAgICAgICAgICBpZiAoaXNFbGVtZW50JDYoZSkpIHtcbiAgICAgICAgICAgIGNvbnN0ICRlbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBnZXQkOSgkZWxtLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBhdHRySG9va3NbbmFtZV07XG4gICAgICAgICAgICBpZiAoaG9vayAmJiBob29rLnNldCkge1xuICAgICAgICAgICAgICBob29rLnNldCgkZWxtLmRvbSwgdmFsLCBuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxlZ2FjeVNldEF0dHJpYnV0ZSgkZWxtLCBuYW1lLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsVmFsdWUgIT09IHZhbCAmJiBzZXR0aW5ncy5vblNldEF0dHJpYikge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5vblNldEF0dHJpYih7XG4gICAgICAgICAgICAgICAgYXR0ckVsbTogJGVsbS5kb20sXG4gICAgICAgICAgICAgICAgYXR0ck5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0clZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbG9uZSA9IChub2RlLCBkZWVwKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlLmNsb25lTm9kZShkZWVwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRSb290ID0gKCkgPT4gc2V0dGluZ3Mucm9vdF9lbGVtZW50IHx8IGRvYy5ib2R5O1xuICAgICAgY29uc3QgZ2V0Vmlld1BvcnQgPSBhcmdXaW4gPT4ge1xuICAgICAgICBjb25zdCB2cCA9IGdldEJvdW5kcyhhcmdXaW4pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHZwLngsXG4gICAgICAgICAgeTogdnAueSxcbiAgICAgICAgICB3OiB2cC53aWR0aCxcbiAgICAgICAgICBoOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRQb3MkMSA9IChlbG0sIHJvb3RFbG0pID0+IGdldFBvcyhkb2MuYm9keSwgZ2V0KGVsbSksIHJvb3RFbG0pO1xuICAgICAgY29uc3Qgc2V0U3R5bGUgPSAoZWxtLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHtcbiAgICAgICAgICBjb25zdCAkZWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZSk7XG4gICAgICAgICAgYXBwbHlTdHlsZSQxKCRlbG0sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXBkYXRlX3N0eWxlcykge1xuICAgICAgICAgICAgdXBkYXRlSW50ZXJuYWxTdHlsZUF0dHIoc3R5bGVzLCAkZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldFN0eWxlcyA9IChlbG0sIHN0eWxlc0FyZykgPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHtcbiAgICAgICAgICBjb25zdCAkZWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZSk7XG4gICAgICAgICAgZWFjaCRkKHN0eWxlc0FyZywgKHYsIG4pID0+IHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUkMSgkZWxtLCBuLCB2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXBkYXRlX3N0eWxlcykge1xuICAgICAgICAgICAgdXBkYXRlSW50ZXJuYWxTdHlsZUF0dHIoc3R5bGVzLCAkZWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFN0eWxlID0gKGVsbSwgbmFtZSwgY29tcHV0ZWQpID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IGdldChlbG0pO1xuICAgICAgICBpZiAoaXNOdWxsYWJsZSgkZWxtKSB8fCAhaXNFbGVtZW50JDYoJGVsbSkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgIHJldHVybiBnZXQkNyhTdWdhckVsZW1lbnQuZnJvbURvbSgkZWxtKSwgY2FtZWxDYXNlVG9IeXBoZW5zKG5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8tKFxcRCkvZywgKGEsIGIpID0+IGIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnY3NzRmxvYXQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJGVsbS5zdHlsZSA/ICRlbG0uc3R5bGVbbmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRTaXplID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IGdldChlbG0pO1xuICAgICAgICBpZiAoISRlbG0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdzogMCxcbiAgICAgICAgICAgIGg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB3ID0gZ2V0U3R5bGUoJGVsbSwgJ3dpZHRoJyk7XG4gICAgICAgIGxldCBoID0gZ2V0U3R5bGUoJGVsbSwgJ2hlaWdodCcpO1xuICAgICAgICBpZiAoIXcgfHwgdy5pbmRleE9mKCdweCcpID09PSAtMSkge1xuICAgICAgICAgIHcgPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoIHx8IGguaW5kZXhPZigncHgnKSA9PT0gLTEpIHtcbiAgICAgICAgICBoID0gJzAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdzogcGFyc2VJbnQodywgMTApIHx8ICRlbG0ub2Zmc2V0V2lkdGggfHwgJGVsbS5jbGllbnRXaWR0aCxcbiAgICAgICAgICBoOiBwYXJzZUludChoLCAxMCkgfHwgJGVsbS5vZmZzZXRIZWlnaHQgfHwgJGVsbS5jbGllbnRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRSZWN0ID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IGdldChlbG0pO1xuICAgICAgICBjb25zdCBwb3MgPSBnZXRQb3MkMSgkZWxtKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUoJGVsbSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgeTogcG9zLnksXG4gICAgICAgICAgdzogc2l6ZS53LFxuICAgICAgICAgIGg6IHNpemUuaFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzID0gKGVsbSwgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxtcyA9IGlzQXJyYXkkMShlbG0pID8gZWxtIDogW2VsbV07XG4gICAgICAgIHJldHVybiBleGlzdHMoZWxtcywgZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZSksIHNlbGVjdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UGFyZW50cyA9IChlbG0sIHNlbGVjdG9yLCByb290LCBjb2xsZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbm9kZSA9IGdldChlbG0pO1xuICAgICAgICBjb2xsZWN0ID0gY29sbGVjdCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlZFJvb3QgPSByb290IHx8IChnZXRSb290KCkubm9kZU5hbWUgIT09ICdCT0RZJyA/IGdldFJvb3QoKS5wYXJlbnROb2RlIDogbnVsbCk7XG4gICAgICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBpc0VsZW1lbnQkNjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JWYWwgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbm9kZSA9PiBpcyhub2RlLCBzZWxlY3RvclZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IHJlc29sdmVkUm9vdCB8fCBpc051bGxhYmxlKG5vZGUubm9kZVR5cGUpIHx8IGlzRG9jdW1lbnQkMShub2RlKSB8fCBpc0RvY3VtZW50RnJhZ21lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoY29sbGVjdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3QgPyByZXN1bHQgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFBhcmVudCA9IChub2RlLCBzZWxlY3Rvciwgcm9vdCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gZ2V0UGFyZW50cyhub2RlLCBzZWxlY3Rvciwgcm9vdCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gcGFyZW50cyAmJiBwYXJlbnRzLmxlbmd0aCA+IDAgPyBwYXJlbnRzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBfZmluZFNpYiA9IChub2RlLCBzZWxlY3RvciwgbmFtZSkgPT4ge1xuICAgICAgICBsZXQgZnVuYyA9IHNlbGVjdG9yO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGlmIChpc1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBub2RlID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzKG5vZGUsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IHRlbXBOb2RlID0gbm9kZVtuYW1lXTsgdGVtcE5vZGU7IHRlbXBOb2RlID0gdGVtcE5vZGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpICYmIGZ1bmModGVtcE5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0TmV4dCA9IChub2RlLCBzZWxlY3RvcikgPT4gX2ZpbmRTaWIobm9kZSwgc2VsZWN0b3IsICduZXh0U2libGluZycpO1xuICAgICAgY29uc3QgZ2V0UHJldiA9IChub2RlLCBzZWxlY3RvcikgPT4gX2ZpbmRTaWIobm9kZSwgc2VsZWN0b3IsICdwcmV2aW91c1NpYmxpbmcnKTtcbiAgICAgIGNvbnN0IGlzUGFyZW50Tm9kZSA9IG5vZGUgPT4gaXNGdW5jdGlvbihub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpO1xuICAgICAgY29uc3Qgc2VsZWN0ID0gKHNlbGVjdG9yLCBzY29wZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBlbG0gPSAoX2IgPSAoX2EgPSBnZXQoc2NvcGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzZXR0aW5ncy5yb290X2VsZW1lbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRvYztcbiAgICAgICAgcmV0dXJuIGlzUGFyZW50Tm9kZShlbG0pID8gZnJvbShlbG0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpIDogW107XG4gICAgICB9O1xuICAgICAgY29uc3QgcnVuID0gZnVuY3Rpb24gKGVsbSwgZnVuYywgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHNjb3BlICE9PSBudWxsICYmIHNjb3BlICE9PSB2b2lkIDAgPyBzY29wZSA6IHRoaXM7XG4gICAgICAgIGlmIChpc0FycmF5JDEoZWxtKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGVhY2gkYShlbG0sIChlLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0KGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnVuYy5jYWxsKGNvbnRleHQsIG5vZGUsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBnZXQoZWxtKTtcbiAgICAgICAgICByZXR1cm4gIW5vZGUgPyBmYWxzZSA6IGZ1bmMuY2FsbChjb250ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldEF0dHJpYnMgPSAoZWxtLCBhdHRycykgPT4ge1xuICAgICAgICBydW4oZWxtLCAkZWxtID0+IHtcbiAgICAgICAgICBlYWNoJGQoYXR0cnMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgc2V0QXR0cmliKCRlbG0sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0SFRNTCA9IChlbG0sIGh0bWwpID0+IHtcbiAgICAgICAgcnVuKGVsbSwgZSA9PiB7XG4gICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgIHNldCQxKCRlbG0sIGh0bWwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGQgPSAocGFyZW50RWxtLCBuYW1lLCBhdHRycywgaHRtbCwgY3JlYXRlKSA9PiBydW4ocGFyZW50RWxtLCBwYXJlbnRFbG0gPT4ge1xuICAgICAgICBjb25zdCBuZXdFbG0gPSBpc1N0cmluZyhuYW1lKSA/IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDogbmFtZTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYXR0cnMpKSB7XG4gICAgICAgICAgc2V0QXR0cmlicyhuZXdFbG0sIGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgIGlmICghaXNTdHJpbmcoaHRtbCkgJiYgaHRtbC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgbmV3RWxtLmFwcGVuZENoaWxkKGh0bWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoaHRtbCkpIHtcbiAgICAgICAgICAgIHNldEhUTUwobmV3RWxtLCBodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjcmVhdGUgPyBwYXJlbnRFbG0uYXBwZW5kQ2hpbGQobmV3RWxtKSA6IG5ld0VsbTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY3JlYXRlID0gKG5hbWUsIGF0dHJzLCBodG1sKSA9PiBhZGQoZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSksIG5hbWUsIGF0dHJzLCBodG1sLCB0cnVlKTtcbiAgICAgIGNvbnN0IGRlY29kZSA9IEVudGl0aWVzLmRlY29kZTtcbiAgICAgIGNvbnN0IGVuY29kZSA9IEVudGl0aWVzLmVuY29kZUFsbFJhdztcbiAgICAgIGNvbnN0IGNyZWF0ZUhUTUwgPSAobmFtZSwgYXR0cnMsIGh0bWwgPSAnJykgPT4ge1xuICAgICAgICBsZXQgb3V0SHRtbCA9ICc8JyArIG5hbWU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGhhc05vbk51bGxhYmxlS2V5KGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBvdXRIdG1sICs9ICcgJyArIGtleSArICc9XCInICsgZW5jb2RlKGF0dHJzW2tleV0pICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRW1wdHkkMyhodG1sKSAmJiBoYXMkMihzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCksIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG91dEh0bWwgKyAnIC8+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3V0SHRtbCArICc+JyArIGh0bWwgKyAnPC8nICsgbmFtZSArICc+JztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUZyYWdtZW50ID0gaHRtbCA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3QgZnJhZyA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmUgPSAobm9kZSwga2VlcENoaWxkcmVuKSA9PiB7XG4gICAgICAgIHJldHVybiBydW4obm9kZSwgbiA9PiB7XG4gICAgICAgICAgY29uc3QgJG5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShuKTtcbiAgICAgICAgICBpZiAoa2VlcENoaWxkcmVuKSB7XG4gICAgICAgICAgICBlYWNoJGUoY2hpbGRyZW4kMSgkbm9kZSksIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzVGV4dCRiKGNoaWxkKSAmJiBjaGlsZC5kb20ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlJDUoY2hpbGQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJlZm9yZSQzKCRub2RlLCBjaGlsZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmUkNSgkbm9kZSk7XG4gICAgICAgICAgcmV0dXJuICRub2RlLmRvbTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlQWxsQXR0cmlicyA9IGUgPT4gcnVuKGUsIGUgPT4ge1xuICAgICAgICBjb25zdCBhdHRycyA9IGUuYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHJzLml0ZW0oaSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBhcnNlU3R5bGUgPSBjc3NUZXh0ID0+IHN0eWxlcy5wYXJzZShjc3NUZXh0KTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZVN0eWxlID0gKHN0eWxlc0FyZywgbmFtZSkgPT4gc3R5bGVzLnNlcmlhbGl6ZShzdHlsZXNBcmcsIG5hbWUpO1xuICAgICAgY29uc3QgYWRkU3R5bGUgPSBjc3NUZXh0ID0+IHtcbiAgICAgICAgaWYgKHNlbGYgIT09IERPTVV0aWxzLkRPTSAmJiBkb2MgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgaWYgKGFkZGVkU3R5bGVzW2Nzc1RleHRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkU3R5bGVzW2Nzc1RleHRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3R5bGVFbG0gPSBkb2MuZ2V0RWxlbWVudEJ5SWQoJ21jZURlZmF1bHRTdHlsZXMnKTtcbiAgICAgICAgaWYgKCFzdHlsZUVsbSkge1xuICAgICAgICAgIHN0eWxlRWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgc3R5bGVFbG0uaWQgPSAnbWNlRGVmYXVsdFN0eWxlcyc7XG4gICAgICAgICAgc3R5bGVFbG0udHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgY29uc3QgaGVhZCA9IGRvYy5oZWFkO1xuICAgICAgICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxtLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlRWxtLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICBzdHlsZUVsbS5zdHlsZVNoZWV0LmNzc1RleHQgKz0gY3NzVGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZUVsbS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZENTUyA9IHVybHMgPT4ge1xuICAgICAgICBpZiAoIXVybHMpIHtcbiAgICAgICAgICB1cmxzID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWFjaCRlKHVybHMuc3BsaXQoJywnKSwgdXJsID0+IHtcbiAgICAgICAgICBmaWxlc1t1cmxdID0gdHJ1ZTtcbiAgICAgICAgICBzdHlsZVNoZWV0TG9hZGVyLmxvYWQodXJsKS5jYXRjaChub29wKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9nZ2xlQ2xhc3MgPSAoZWxtLCBjbHMsIHN0YXRlKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihlKSkge1xuICAgICAgICAgICAgY29uc3QgJGVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNscy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZWFjaCRlKGNsYXNzZXMsIGMgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHN0YXRlID8gYWRkJDIgOiByZW1vdmUkNztcbiAgICAgICAgICAgICAgICBmbigkZWxtLCBjKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUkMSgkZWxtLCBjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGRDbGFzcyA9IChlbG0sIGNscykgPT4ge1xuICAgICAgICB0b2dnbGVDbGFzcyhlbG0sIGNscywgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlQ2xhc3MgPSAoZWxtLCBjbHMpID0+IHtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWxtLCBjbHMsIGZhbHNlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBoYXNDbGFzcyA9IChlbG0sIGNscykgPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gX2dldChlbG0pO1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gY2xzLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKCRlbG0pICYmIGZvcmFsbChjbGFzc2VzLCBjID0+IGhhcygkZWxtLCBjKSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvdyA9IGVsbSA9PiB7XG4gICAgICAgIHJ1bihlbG0sIGUgPT4gcmVtb3ZlJDYoU3VnYXJFbGVtZW50LmZyb21Eb20oZSksICdkaXNwbGF5JykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhpZGUgPSBlbG0gPT4ge1xuICAgICAgICBydW4oZWxtLCBlID0+IHNldCQyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGUpLCAnZGlzcGxheScsICdub25lJykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzSGlkZGVuID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgJGVsbSA9IF9nZXQoZWxtKTtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoJGVsbSkgJiYgaXMkMihnZXRSYXcoJGVsbSwgJ2Rpc3BsYXknKSwgJ25vbmUnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmlxdWVJZCA9IHByZWZpeCA9PiAoIXByZWZpeCA/ICdtY2VfJyA6IHByZWZpeCkgKyBjb3VudGVyKys7XG4gICAgICBjb25zdCBnZXRPdXRlckhUTUwgPSBlbG0gPT4ge1xuICAgICAgICBjb25zdCAkZWxtID0gX2dldChlbG0pO1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZSgkZWxtKSkge1xuICAgICAgICAgIHJldHVybiBpc0VsZW1lbnQkNigkZWxtLmRvbSkgPyAkZWxtLmRvbS5vdXRlckhUTUwgOiBnZXRPdXRlcigkZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRPdXRlckhUTUwgPSAoZWxtLCBodG1sKSA9PiB7XG4gICAgICAgIHJ1bihlbG0sICRlbG0gPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNigkZWxtKSkge1xuICAgICAgICAgICAgJGVsbS5vdXRlckhUTUwgPSBodG1sO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaW5zZXJ0QWZ0ZXIgPSAobm9kZSwgcmVmZXJlbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSBnZXQocmVmZXJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHJ1bihub2RlLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSByZWZlcmVuY2VOb2RlID09PSBudWxsIHx8IHJlZmVyZW5jZU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IHJlZmVyZW5jZU5vZGUgPT09IG51bGwgfHwgcmVmZXJlbmNlTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlID0gKG5ld0VsbSwgb2xkRWxtLCBrZWVwQ2hpbGRyZW4pID0+IHJ1bihvbGRFbG0sIGVsbSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVwbGFjZWUgPSBpc0FycmF5JDEob2xkRWxtKSA/IG5ld0VsbS5jbG9uZU5vZGUodHJ1ZSkgOiBuZXdFbG07XG4gICAgICAgIGlmIChrZWVwQ2hpbGRyZW4pIHtcbiAgICAgICAgICBlYWNoJGEoZ3JlcChlbG0uY2hpbGROb2RlcyksIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmVwbGFjZWUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gZWxtLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlQ2hpbGQocmVwbGFjZWUsIGVsbSk7XG4gICAgICAgIHJldHVybiBlbG07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmFtZSA9IChlbG0sIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKGVsbS5ub2RlTmFtZSAhPT0gbmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgY29uc3QgbmV3RWxtID0gY3JlYXRlKG5hbWUpO1xuICAgICAgICAgIGVhY2gkYShnZXRBdHRyaWJzKGVsbSksIGF0dHJOb2RlID0+IHtcbiAgICAgICAgICAgIHNldEF0dHJpYihuZXdFbG0sIGF0dHJOb2RlLm5vZGVOYW1lLCBnZXRBdHRyaWIoZWxtLCBhdHRyTm9kZS5ub2RlTmFtZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcGxhY2UobmV3RWxtLCBlbG0sIHRydWUpO1xuICAgICAgICAgIHJldHVybiBuZXdFbG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRDb21tb25BbmNlc3RvciA9IChhLCBiKSA9PiB7XG4gICAgICAgIGxldCBwcyA9IGE7XG4gICAgICAgIHdoaWxlIChwcykge1xuICAgICAgICAgIGxldCBwZSA9IGI7XG4gICAgICAgICAgd2hpbGUgKHBlICYmIHBzICE9PSBwZSkge1xuICAgICAgICAgICAgcGUgPSBwZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHMgPT09IHBlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHMgPSBwcy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHMgJiYgYS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGEub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNOb25FbXB0eUVsZW1lbnQgPSBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgaXNOYW1lZEFuY2hvciA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnICYmICFnZXRBdHRyaWIobm9kZSwgJ2hyZWYnKSAmJiBnZXRBdHRyaWIobm9kZSwgJ2lkJyk7XG4gICAgICAgICAgaWYgKGdldEF0dHJpYihub2RlLCAnbmFtZScpIHx8IGdldEF0dHJpYihub2RlLCAnZGF0YS1tY2UtYm9va21hcmsnKSB8fCBpc05hbWVkQW5jaG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRW1wdHkgPSAobm9kZSwgZWxlbWVudHMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgbGV0IGJyQ291bnQgPSAwO1xuICAgICAgICBpZiAoaXNOb25FbXB0eUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihmaXJzdENoaWxkLCBub2RlKTtcbiAgICAgICAgICBjb25zdCB3aGl0ZXNwYWNlRWxlbWVudHMgPSBzY2hlbWEgPyBzY2hlbWEuZ2V0V2hpdGVzcGFjZUVsZW1lbnRzKCkgOiB7fTtcbiAgICAgICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gZWxlbWVudHMgfHwgKHNjaGVtYSA/IHNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCkgOiBudWxsKTtcbiAgICAgICAgICBsZXQgdGVtcE5vZGUgPSBmaXJzdENoaWxkO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQkNih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgYm9ndXNWYWwgPSB0ZW1wTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJyk7XG4gICAgICAgICAgICAgIGlmIChib2d1c1ZhbCkge1xuICAgICAgICAgICAgICAgIHRlbXBOb2RlID0gd2Fsa2VyLm5leHQoYm9ndXNWYWwgPT09ICdhbGwnKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGVtcE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG5vbkVtcHR5RWxlbWVudHMgJiYgbm9uRW1wdHlFbGVtZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgICBickNvdW50Kys7XG4gICAgICAgICAgICAgICAgICB0ZW1wTm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc05vbkVtcHR5RWxlbWVudCh0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbW1lbnQodGVtcE5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1RleHQkYSh0ZW1wTm9kZSkgJiYgIWlzV2hpdGVzcGFjZVRleHQodGVtcE5vZGUuZGF0YSkgJiYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVad3NwKSB8fCAhaXNad3NwKHRlbXBOb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpICYmIHRlbXBOb2RlLnBhcmVudE5vZGUgJiYgd2hpdGVzcGFjZUVsZW1lbnRzW3RlbXBOb2RlLnBhcmVudE5vZGUubm9kZU5hbWVdICYmIGlzV2hpdGVzcGFjZVRleHQodGVtcE5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcE5vZGUgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJDb3VudCA8PSAxO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVJuZyA9ICgpID0+IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3BsaXQgPSAocGFyZW50RWxtLCBzcGxpdEVsbSwgcmVwbGFjZW1lbnRFbG0pID0+IHtcbiAgICAgICAgbGV0IHJhbmdlID0gY3JlYXRlUm5nKCk7XG4gICAgICAgIGxldCBiZWZvcmVGcmFnbWVudDtcbiAgICAgICAgbGV0IGFmdGVyRnJhZ21lbnQ7XG4gICAgICAgIGlmIChwYXJlbnRFbG0gJiYgc3BsaXRFbG0gJiYgcGFyZW50RWxtLnBhcmVudE5vZGUgJiYgc3BsaXRFbG0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnRFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChwYXJlbnROb2RlLCBmaW5kTm9kZUluZGV4KHBhcmVudEVsbSkpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChzcGxpdEVsbS5wYXJlbnROb2RlLCBmaW5kTm9kZUluZGV4KHNwbGl0RWxtKSk7XG4gICAgICAgICAgYmVmb3JlRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICByYW5nZSA9IGNyZWF0ZVJuZygpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHNwbGl0RWxtLnBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgoc3BsaXRFbG0pICsgMSk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKHBhcmVudE5vZGUsIGZpbmROb2RlSW5kZXgocGFyZW50RWxtKSArIDEpO1xuICAgICAgICAgIGFmdGVyRnJhZ21lbnQgPSByYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmltTm9kZShzZWxmLCBiZWZvcmVGcmFnbWVudCksIHBhcmVudEVsbSk7XG4gICAgICAgICAgaWYgKHJlcGxhY2VtZW50RWxtKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShyZXBsYWNlbWVudEVsbSwgcGFyZW50RWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3BsaXRFbG0sIHBhcmVudEVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyaW1Ob2RlKHNlbGYsIGFmdGVyRnJhZ21lbnQpLCBwYXJlbnRFbG0pO1xuICAgICAgICAgIHJlbW92ZShwYXJlbnRFbG0pO1xuICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudEVsbSB8fCBzcGxpdEVsbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYmluZCA9ICh0YXJnZXQsIG5hbWUsIGZ1bmMsIHNjb3BlKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5JDEodGFyZ2V0KSkge1xuICAgICAgICAgIGxldCBpID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJ2W2ldID0gYmluZCh0YXJnZXRbaV0sIG5hbWUsIGZ1bmMsIHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsZWN0ICYmICh0YXJnZXQgPT09IGRvYyB8fCB0YXJnZXQgPT09IHdpbikpIHtcbiAgICAgICAgICAgIGJvdW5kRXZlbnRzLnB1c2goW1xuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgIHNjb3BlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5iaW5kKHRhcmdldCwgbmFtZSwgZnVuYywgc2NvcGUgfHwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB1bmJpbmQgPSAodGFyZ2V0LCBuYW1lLCBmdW5jKSA9PiB7XG4gICAgICAgIGlmIChpc0FycmF5JDEodGFyZ2V0KSkge1xuICAgICAgICAgIGxldCBpID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJ2W2ldID0gdW5iaW5kKHRhcmdldFtpXSwgbmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYm91bmRFdmVudHMubGVuZ3RoID4gMCAmJiAodGFyZ2V0ID09PSBkb2MgfHwgdGFyZ2V0ID09PSB3aW4pKSB7XG4gICAgICAgICAgICBsZXQgaSA9IGJvdW5kRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgW2JvdW5kVGFyZ2V0LCBib3VuZE5hbWUsIGJvdW5kRnVuY10gPSBib3VuZEV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gYm91bmRUYXJnZXQgJiYgKCFuYW1lIHx8IG5hbWUgPT09IGJvdW5kTmFtZSkgJiYgKCFmdW5jIHx8IGZ1bmMgPT09IGJvdW5kRnVuYykpIHtcbiAgICAgICAgICAgICAgICBldmVudHMudW5iaW5kKGJvdW5kVGFyZ2V0LCBib3VuZE5hbWUsIGJvdW5kRnVuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy51bmJpbmQodGFyZ2V0LCBuYW1lLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gKHRhcmdldCwgbmFtZSwgZXZ0KSA9PiBldmVudHMuZGlzcGF0Y2godGFyZ2V0LCBuYW1lLCBldnQpO1xuICAgICAgY29uc3QgZmlyZSA9ICh0YXJnZXQsIG5hbWUsIGV2dCkgPT4gZXZlbnRzLmRpc3BhdGNoKHRhcmdldCwgbmFtZSwgZXZ0KTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZSA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSAmJiBpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1jb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICBpZiAoY29udGVudEVkaXRhYmxlICYmIGNvbnRlbnRFZGl0YWJsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgIT09ICdpbmhlcml0JyA/IG5vZGUuY29udGVudEVkaXRhYmxlIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVBhcmVudCA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gZ2V0Um9vdCgpO1xuICAgICAgICBsZXQgc3RhdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCB0ZW1wTm9kZSA9IG5vZGU7IHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSByb290OyB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IGdldENvbnRlbnRFZGl0YWJsZSh0ZW1wTm9kZSk7XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBzY29wZSA9IGlzRWxlbWVudCQ2KG5vZGUpID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShzY29wZSkgJiYgaXNFZGl0YWJsZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHNjb3BlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGJvdW5kRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgaSA9IGJvdW5kRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBbYm91bmRUYXJnZXQsIGJvdW5kTmFtZSwgYm91bmRGdW5jXSA9IGJvdW5kRXZlbnRzW2ldO1xuICAgICAgICAgICAgZXZlbnRzLnVuYmluZChib3VuZFRhcmdldCwgYm91bmROYW1lLCBib3VuZEZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlYWNoJGQoZmlsZXMsIChfLCB1cmwpID0+IHtcbiAgICAgICAgICBzdHlsZVNoZWV0TG9hZGVyLnVubG9hZCh1cmwpO1xuICAgICAgICAgIGRlbGV0ZSBmaWxlc1t1cmxdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc0NoaWxkT2YgPSAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBwYXJlbnQgfHwgcGFyZW50LmNvbnRhaW5zKG5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGR1bXBSbmcgPSByID0+ICdzdGFydENvbnRhaW5lcjogJyArIHIuc3RhcnRDb250YWluZXIubm9kZU5hbWUgKyAnLCBzdGFydE9mZnNldDogJyArIHIuc3RhcnRPZmZzZXQgKyAnLCBlbmRDb250YWluZXI6ICcgKyByLmVuZENvbnRhaW5lci5ub2RlTmFtZSArICcsIGVuZE9mZnNldDogJyArIHIuZW5kT2Zmc2V0O1xuICAgICAgY29uc3Qgc2VsZiA9IHtcbiAgICAgICAgZG9jLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgd2luLFxuICAgICAgICBmaWxlcyxcbiAgICAgICAgc3RkTW9kZSxcbiAgICAgICAgYm94TW9kZWwsXG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZXIsXG4gICAgICAgIGJvdW5kRXZlbnRzLFxuICAgICAgICBzdHlsZXMsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpc0Jsb2NrOiBpc0Jsb2NrLFxuICAgICAgICByb290OiBudWxsLFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgZ2V0Um9vdCxcbiAgICAgICAgZ2V0Vmlld1BvcnQsXG4gICAgICAgIGdldFJlY3QsXG4gICAgICAgIGdldFNpemUsXG4gICAgICAgIGdldFBhcmVudCxcbiAgICAgICAgZ2V0UGFyZW50czogZ2V0UGFyZW50cyxcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXROZXh0LFxuICAgICAgICBnZXRQcmV2LFxuICAgICAgICBzZWxlY3QsXG4gICAgICAgIGlzLFxuICAgICAgICBhZGQsXG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY3JlYXRlSFRNTCxcbiAgICAgICAgY3JlYXRlRnJhZ21lbnQsXG4gICAgICAgIHJlbW92ZSxcbiAgICAgICAgc2V0U3R5bGUsXG4gICAgICAgIGdldFN0eWxlOiBnZXRTdHlsZSxcbiAgICAgICAgc2V0U3R5bGVzLFxuICAgICAgICByZW1vdmVBbGxBdHRyaWJzLFxuICAgICAgICBzZXRBdHRyaWIsXG4gICAgICAgIHNldEF0dHJpYnMsXG4gICAgICAgIGdldEF0dHJpYixcbiAgICAgICAgZ2V0UG9zOiBnZXRQb3MkMSxcbiAgICAgICAgcGFyc2VTdHlsZSxcbiAgICAgICAgc2VyaWFsaXplU3R5bGUsXG4gICAgICAgIGFkZFN0eWxlLFxuICAgICAgICBsb2FkQ1NTLFxuICAgICAgICBhZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3MsXG4gICAgICAgIGhhc0NsYXNzLFxuICAgICAgICB0b2dnbGVDbGFzcyxcbiAgICAgICAgc2hvdyxcbiAgICAgICAgaGlkZSxcbiAgICAgICAgaXNIaWRkZW4sXG4gICAgICAgIHVuaXF1ZUlkLFxuICAgICAgICBzZXRIVE1MLFxuICAgICAgICBnZXRPdXRlckhUTUwsXG4gICAgICAgIHNldE91dGVySFRNTCxcbiAgICAgICAgZGVjb2RlLFxuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGluc2VydEFmdGVyLFxuICAgICAgICByZXBsYWNlLFxuICAgICAgICByZW5hbWUsXG4gICAgICAgIGZpbmRDb21tb25BbmNlc3RvcixcbiAgICAgICAgcnVuLFxuICAgICAgICBnZXRBdHRyaWJzLFxuICAgICAgICBpc0VtcHR5LFxuICAgICAgICBjcmVhdGVSbmcsXG4gICAgICAgIG5vZGVJbmRleDogZmluZE5vZGVJbmRleCxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIHVuYmluZDogdW5iaW5kLFxuICAgICAgICBmaXJlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0Q29udGVudEVkaXRhYmxlLFxuICAgICAgICBnZXRDb250ZW50RWRpdGFibGVQYXJlbnQsXG4gICAgICAgIGlzRWRpdGFibGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIGlzQ2hpbGRPZixcbiAgICAgICAgZHVtcFJuZ1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGF0dHJIb29rcyA9IHNldHVwQXR0ckhvb2tzKHN0eWxlcywgc2V0dGluZ3MsIGNvbnN0YW50KHNlbGYpKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgRE9NVXRpbHMuRE9NID0gRE9NVXRpbHMoZG9jdW1lbnQpO1xuICAgIERPTVV0aWxzLm5vZGVJbmRleCA9IGZpbmROb2RlSW5kZXg7XG5cbiAgICBjb25zdCBET00kYiA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBRVUVVRUQgPSAwO1xuICAgIGNvbnN0IExPQURJTkcgPSAxO1xuICAgIGNvbnN0IExPQURFRCA9IDI7XG4gICAgY29uc3QgRkFJTEVEID0gMztcbiAgICBjbGFzcyBTY3JpcHRMb2FkZXIge1xuICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMucXVldWVMb2FkZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIF9zZXRSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlZmVycmVyUG9saWN5ID0gcmVmZXJyZXJQb2xpY3k7XG4gICAgICB9XG4gICAgICBsb2FkU2NyaXB0KHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvbSA9IERPTSRiO1xuICAgICAgICAgIGxldCBlbG07XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUoaWQpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICBlbG0ub25lcnJvciA9IGVsbS5vbmxvYWQgPSBlbG0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KCdGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICcgKyB1cmwpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgaWQgPSBkb20udW5pcXVlSWQoKTtcbiAgICAgICAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICBlbG0uaWQgPSBpZDtcbiAgICAgICAgICBlbG0udHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgIGVsbS5zcmMgPSBUb29scy5fYWRkQ2FjaGVTdWZmaXgodXJsKTtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZlcnJlclBvbGljeSkge1xuICAgICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sICdyZWZlcnJlcnBvbGljeScsIHRoaXMuc2V0dGluZ3MucmVmZXJyZXJQb2xpY3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbG0ub25sb2FkID0gZG9uZTtcbiAgICAgICAgICBlbG0ub25lcnJvciA9IGVycm9yO1xuICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKGVsbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXNEb25lKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdXJsXSA9PT0gTE9BREVEO1xuICAgICAgfVxuICAgICAgbWFya0RvbmUodXJsKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzW3VybF0gPSBMT0FERUQ7XG4gICAgICB9XG4gICAgICBhZGQodXJsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLnF1ZXVlLnB1c2godXJsKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzZWxmLnN0YXRlc1t1cmxdO1xuICAgICAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBRVUVVRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpZiAoIXNlbGYuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzW3VybF0pIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0TG9hZGVkQ2FsbGJhY2tzW3VybF0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXS5wdXNoKHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2FkKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQodXJsKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSh1cmwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RhdGVzW3VybF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjcmlwdExvYWRlZENhbGxiYWNrc1t1cmxdO1xuICAgICAgfVxuICAgICAgbG9hZFF1ZXVlKCkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNjcmlwdHMocXVldWUpO1xuICAgICAgfVxuICAgICAgbG9hZFNjcmlwdHMoc2NyaXB0cykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhlY0NhbGxiYWNrcyA9IChuYW1lLCB1cmwpID0+IHtcbiAgICAgICAgICBnZXQkYShzZWxmLnNjcmlwdExvYWRlZENhbGxiYWNrcywgdXJsKS5lYWNoKGNhbGxiYWNrcyA9PiB7XG4gICAgICAgICAgICBlYWNoJGUoY2FsbGJhY2tzLCBjYWxsYmFjayA9PiBjYWxsYmFja1tuYW1lXSh1cmwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5zY3JpcHRMb2FkZWRDYWxsYmFja3NbdXJsXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc1Jlc3VsdHMgPSByZXN1bHRzID0+IHtcbiAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IGZpbHRlciQ1KHJlc3VsdHMsIHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICAgICAgICBpZiAoZmFpbHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGJpbmQkMyhmYWlsdXJlcywgKHtyZWFzb259KSA9PiBpc0FycmF5JDEocmVhc29uKSA/IHJlYXNvbiA6IFtyZWFzb25dKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxvYWQgPSB1cmxzID0+IFByb21pc2UuYWxsU2V0dGxlZChtYXAkMyh1cmxzLCB1cmwgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLnN0YXRlc1t1cmxdID09PSBMT0FERUQpIHtcbiAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJ3Jlc29sdmUnLCB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZXNbdXJsXSA9PT0gRkFJTEVEKSB7XG4gICAgICAgICAgICBleGVjQ2FsbGJhY2tzKCdyZWplY3QnLCB1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHVybCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBMT0FESU5HO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZFNjcmlwdCh1cmwpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLnN0YXRlc1t1cmxdID0gTE9BREVEO1xuICAgICAgICAgICAgICBleGVjQ2FsbGJhY2tzKCdyZXNvbHZlJywgdXJsKTtcbiAgICAgICAgICAgICAgY29uc3QgcXVldWUgPSBzZWxmLnF1ZXVlO1xuICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYucXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZChxdWV1ZSkudGhlbihwcm9jZXNzUmVzdWx0cyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgIHNlbGYuc3RhdGVzW3VybF0gPSBGQUlMRUQ7XG4gICAgICAgICAgICAgIGV4ZWNDYWxsYmFja3MoJ3JlamVjdCcsIHVybCk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh1cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NRdWV1ZSA9IHVybHMgPT4ge1xuICAgICAgICAgIHNlbGYubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGxvYWQodXJscykudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICAgIHNlbGYubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbmV4dFF1ZXVlZEl0ZW0gPSBzZWxmLnF1ZXVlTG9hZGVkQ2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICBPcHRpb25hbC5mcm9tKG5leHRRdWV1ZWRJdGVtKS5lYWNoKGNhbGwpO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bmlxdWVTY3JpcHRzID0gc3RyaW5nQXJyYXkoc2NyaXB0cyk7XG4gICAgICAgIGlmIChzZWxmLmxvYWRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5xdWV1ZUxvYWRlZENhbGxiYWNrcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKHVuaXF1ZVNjcmlwdHMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzUXVldWUodW5pcXVlU2NyaXB0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlciA9IG5ldyBTY3JpcHRMb2FkZXIoKTtcblxuICAgIGNvbnN0IENlbGwgPSBpbml0aWFsID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWw7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXQgPSB2ID0+IHtcbiAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBpc0R1cGxpY2F0ZWQgPSAoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgcmV0dXJuIGZpcnN0SW5kZXggIT09IC0xICYmIGl0ZW1zLmluZGV4T2YoaXRlbSwgZmlyc3RJbmRleCArIDEpID4gZmlyc3RJbmRleDtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmF3ID0gc3RyID0+IGlzT2JqZWN0KHN0cikgJiYgaGFzJDIoc3RyLCAncmF3Jyk7XG4gICAgY29uc3QgaXNUb2tlbmlzZWQgPSBzdHIgPT4gaXNBcnJheSQxKHN0cikgJiYgc3RyLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IGN1cnJlbnRDb2RlID0gQ2VsbCgnZW4nKTtcbiAgICBjb25zdCBnZXRMYW5ndWFnZURhdGEgPSAoKSA9PiBnZXQkYShkYXRhLCBjdXJyZW50Q29kZS5nZXQoKSk7XG4gICAgY29uc3QgZ2V0RGF0YSQxID0gKCkgPT4gbWFwJDIoZGF0YSwgdmFsdWUgPT4gKHsgLi4udmFsdWUgfSkpO1xuICAgIGNvbnN0IHNldENvZGUgPSBuZXdDb2RlID0+IHtcbiAgICAgIGlmIChuZXdDb2RlKSB7XG4gICAgICAgIGN1cnJlbnRDb2RlLnNldChuZXdDb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldENvZGUgPSAoKSA9PiBjdXJyZW50Q29kZS5nZXQoKTtcbiAgICBjb25zdCBhZGQkMSA9IChjb2RlLCBpdGVtcykgPT4ge1xuICAgICAgbGV0IGxhbmdEYXRhID0gZGF0YVtjb2RlXTtcbiAgICAgIGlmICghbGFuZ0RhdGEpIHtcbiAgICAgICAgZGF0YVtjb2RlXSA9IGxhbmdEYXRhID0ge307XG4gICAgICB9XG4gICAgICBjb25zdCBsY05hbWVzID0gbWFwJDMoa2V5cyhpdGVtcyksIG5hbWUgPT4gbmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGVhY2gkZChpdGVtcywgKHRyYW5zbGF0aW9uLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxjTmFtZSAhPT0gbmFtZSAmJiBpc0R1cGxpY2F0ZWQobGNOYW1lcywgbGNOYW1lKSkge1xuICAgICAgICAgIGlmICghaGFzJDIoaXRlbXMsIGxjTmFtZSkpIHtcbiAgICAgICAgICAgIGxhbmdEYXRhW2xjTmFtZV0gPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFuZ0RhdGFbbmFtZV0gPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYW5nRGF0YVtsY05hbWVdID0gdHJhbnNsYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNsYXRlID0gdGV4dCA9PiB7XG4gICAgICBjb25zdCBsYW5nRGF0YSA9IGdldExhbmd1YWdlRGF0YSgpLmdldE9yKHt9KTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gb2JqID0+IHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWlzRW1wdHkob2JqKSA/ICcnICsgb2JqIDogJyc7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNFbXB0eSA9IHRleHQgPT4gdGV4dCA9PT0gJycgfHwgdGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBnZXRMYW5nRGF0YSA9IHRleHQgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0U3RyID0gdG9TdHJpbmcodGV4dCk7XG4gICAgICAgIHJldHVybiBoYXMkMihsYW5nRGF0YSwgdGV4dFN0cikgPyB0b1N0cmluZyhsYW5nRGF0YVt0ZXh0U3RyXSkgOiBnZXQkYShsYW5nRGF0YSwgdGV4dFN0ci50b0xvd2VyQ2FzZSgpKS5tYXAodG9TdHJpbmcpLmdldE9yKHRleHRTdHIpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUNvbnRleHQgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL3tjb250ZXh0Olxcdyt9JC8sICcnKTtcbiAgICAgIGlmIChpc0VtcHR5KHRleHQpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1Jhdyh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcodGV4dC5yYXcpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVG9rZW5pc2VkKHRleHQpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHN1YnN0aXR1ZWQgPSBnZXRMYW5nRGF0YSh0ZXh0WzBdKS5yZXBsYWNlKC9cXHsoWzAtOV0rKVxcfS9nLCAoJDEsICQyKSA9PiBoYXMkMih2YWx1ZXMsICQyKSA/IHRvU3RyaW5nKHZhbHVlc1skMl0pIDogJDEpO1xuICAgICAgICByZXR1cm4gcmVtb3ZlQ29udGV4dChzdWJzdGl0dWVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVDb250ZXh0KGdldExhbmdEYXRhKHRleHQpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUnRsJDEgPSAoKSA9PiBnZXRMYW5ndWFnZURhdGEoKS5iaW5kKGl0ZW1zID0+IGdldCRhKGl0ZW1zLCAnX2RpcicpKS5leGlzdHMoZGlyID0+IGRpciA9PT0gJ3J0bCcpO1xuICAgIGNvbnN0IGhhc0NvZGUgPSBjb2RlID0+IGhhcyQyKGRhdGEsIGNvZGUpO1xuICAgIGNvbnN0IEkxOG4gPSB7XG4gICAgICBnZXREYXRhOiBnZXREYXRhJDEsXG4gICAgICBzZXRDb2RlLFxuICAgICAgZ2V0Q29kZSxcbiAgICAgIGFkZDogYWRkJDEsXG4gICAgICB0cmFuc2xhdGUsXG4gICAgICBpc1J0bDogaXNSdGwkMSxcbiAgICAgIGhhc0NvZGVcbiAgICB9O1xuXG4gICAgY29uc3QgQWRkT25NYW5hZ2VyID0gKCkgPT4ge1xuICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgIGNvbnN0IHVybHMgPSB7fTtcbiAgICAgIGNvbnN0IGxvb2t1cCA9IHt9O1xuICAgICAgY29uc3QgX2xpc3RlbmVycyA9IFtdO1xuICAgICAgY29uc3QgcnVuTGlzdGVuZXJzID0gKG5hbWUsIHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRMaXN0ZW5lcnMgPSBmaWx0ZXIkNShfbGlzdGVuZXJzLCBsaXN0ZW5lciA9PiBsaXN0ZW5lci5uYW1lID09PSBuYW1lICYmIGxpc3RlbmVyLnN0YXRlID09PSBzdGF0ZSk7XG4gICAgICAgIGVhY2gkZShtYXRjaGVkTGlzdGVuZXJzLCBsaXN0ZW5lciA9PiBsaXN0ZW5lci5yZXNvbHZlKCkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzTG9hZGVkID0gbmFtZSA9PiBoYXMkMih1cmxzLCBuYW1lKTtcbiAgICAgIGNvbnN0IGlzQWRkZWQgPSBuYW1lID0+IGhhcyQyKGxvb2t1cCwgbmFtZSk7XG4gICAgICBjb25zdCBnZXQgPSBuYW1lID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFtuYW1lXSkge1xuICAgICAgICAgIHJldHVybiBsb29rdXBbbmFtZV0uaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkTGFuZ3VhZ2VQYWNrID0gKG5hbWUsIGxhbmd1YWdlcykgPT4ge1xuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IEkxOG4uZ2V0Q29kZSgpO1xuICAgICAgICBjb25zdCB3cmFwcGVkTGFuZ3VhZ2VzID0gJywnICsgKGxhbmd1YWdlcyB8fCAnJykgKyAnLCc7XG4gICAgICAgIGlmICghbGFuZ3VhZ2UgfHwgbGFuZ3VhZ2VzICYmIHdyYXBwZWRMYW5ndWFnZXMuaW5kZXhPZignLCcgKyBsYW5ndWFnZSArICcsJykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFNjcmlwdExvYWRlci5TY3JpcHRMb2FkZXIuYWRkKHVybHNbbmFtZV0gKyAnL2xhbmdzLycgKyBsYW5ndWFnZSArICcuanMnKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXF1aXJlTGFuZ1BhY2sgPSAobmFtZSwgbGFuZ3VhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChBZGRPbk1hbmFnZXIubGFuZ3VhZ2VMb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChpc0xvYWRlZChuYW1lKSkge1xuICAgICAgICAgICAgbG9hZExhbmd1YWdlUGFjayhuYW1lLCBsYW5ndWFnZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YWl0Rm9yKG5hbWUsICdsb2FkZWQnKS50aGVuKCgpID0+IGxvYWRMYW5ndWFnZVBhY2sobmFtZSwgbGFuZ3VhZ2VzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkID0gKGlkLCBhZGRPbikgPT4ge1xuICAgICAgICBpdGVtcy5wdXNoKGFkZE9uKTtcbiAgICAgICAgbG9va3VwW2lkXSA9IHsgaW5zdGFuY2U6IGFkZE9uIH07XG4gICAgICAgIHJ1bkxpc3RlbmVycyhpZCwgJ2FkZGVkJyk7XG4gICAgICAgIHJldHVybiBhZGRPbjtcbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmUgPSBuYW1lID0+IHtcbiAgICAgICAgZGVsZXRlIHVybHNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBsb29rdXBbbmFtZV07XG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlVXJsID0gKGJhc2VVcmwsIGRlcCkgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcoZGVwKSkge1xuICAgICAgICAgIHJldHVybiBpc1N0cmluZyhiYXNlVXJsKSA/IHtcbiAgICAgICAgICAgIHByZWZpeDogJycsXG4gICAgICAgICAgICByZXNvdXJjZTogZGVwLFxuICAgICAgICAgICAgc3VmZml4OiAnJ1xuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBwcmVmaXg6IGJhc2VVcmwucHJlZml4LFxuICAgICAgICAgICAgcmVzb3VyY2U6IGRlcCxcbiAgICAgICAgICAgIHN1ZmZpeDogYmFzZVVybC5zdWZmaXhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkID0gKG5hbWUsIGFkZE9uVXJsKSA9PiB7XG4gICAgICAgIGlmICh1cmxzW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cmxTdHJpbmcgPSBpc1N0cmluZyhhZGRPblVybCkgPyBhZGRPblVybCA6IGFkZE9uVXJsLnByZWZpeCArIGFkZE9uVXJsLnJlc291cmNlICsgYWRkT25Vcmwuc3VmZml4O1xuICAgICAgICBpZiAodXJsU3RyaW5nLmluZGV4T2YoJy8nKSAhPT0gMCAmJiB1cmxTdHJpbmcuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgICAgICAgdXJsU3RyaW5nID0gQWRkT25NYW5hZ2VyLmJhc2VVUkwgKyAnLycgKyB1cmxTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdXJsc1tuYW1lXSA9IHVybFN0cmluZy5zdWJzdHJpbmcoMCwgdXJsU3RyaW5nLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgIHJ1bkxpc3RlbmVycyhuYW1lLCAnbG9hZGVkJyk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobG9va3VwW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlci5hZGQodXJsU3RyaW5nKS50aGVuKGRvbmUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgd2FpdEZvciA9IChuYW1lLCBzdGF0ZSA9ICdhZGRlZCcpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnYWRkZWQnICYmIGlzQWRkZWQobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdsb2FkZWQnICYmIGlzTG9hZGVkKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIF9saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICByZXNvbHZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICB1cmxzLFxuICAgICAgICBsb29rdXAsXG4gICAgICAgIGdldCxcbiAgICAgICAgcmVxdWlyZUxhbmdQYWNrLFxuICAgICAgICBhZGQsXG4gICAgICAgIHJlbW92ZSxcbiAgICAgICAgY3JlYXRlVXJsLFxuICAgICAgICBsb2FkLFxuICAgICAgICB3YWl0Rm9yXG4gICAgICB9O1xuICAgIH07XG4gICAgQWRkT25NYW5hZ2VyLmxhbmd1YWdlTG9hZCA9IHRydWU7XG4gICAgQWRkT25NYW5hZ2VyLmJhc2VVUkwgPSAnJztcbiAgICBBZGRPbk1hbmFnZXIuUGx1Z2luTWFuYWdlciA9IEFkZE9uTWFuYWdlcigpO1xuICAgIEFkZE9uTWFuYWdlci5UaGVtZU1hbmFnZXIgPSBBZGRPbk1hbmFnZXIoKTtcbiAgICBBZGRPbk1hbmFnZXIuTW9kZWxNYW5hZ2VyID0gQWRkT25NYW5hZ2VyKCk7XG5cbiAgICBjb25zdCBzaW5nbGV0b24gPSBkb1Jldm9rZSA9PiB7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gQ2VsbChPcHRpb25hbC5ub25lKCkpO1xuICAgICAgY29uc3QgcmV2b2tlID0gKCkgPT4gc3ViamVjdC5nZXQoKS5lYWNoKGRvUmV2b2tlKTtcbiAgICAgIGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICAgICAgICByZXZva2UoKTtcbiAgICAgICAgc3ViamVjdC5zZXQoT3B0aW9uYWwubm9uZSgpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1NldCA9ICgpID0+IHN1YmplY3QuZ2V0KCkuaXNTb21lKCk7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiBzdWJqZWN0LmdldCgpO1xuICAgICAgY29uc3Qgc2V0ID0gcyA9PiB7XG4gICAgICAgIHJldm9rZSgpO1xuICAgICAgICBzdWJqZWN0LnNldChPcHRpb25hbC5zb21lKHMpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGVhcixcbiAgICAgICAgaXNTZXQsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVwZWF0YWJsZSA9IGRlbGF5ID0+IHtcbiAgICAgIGNvbnN0IGludGVydmFsSWQgPSBDZWxsKE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgICBjb25zdCByZXZva2UgPSAoKSA9PiBpbnRlcnZhbElkLmdldCgpLmVhY2goaWQgPT4gY2xlYXJJbnRlcnZhbChpZCkpO1xuICAgICAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgICAgIHJldm9rZSgpO1xuICAgICAgICBpbnRlcnZhbElkLnNldChPcHRpb25hbC5ub25lKCkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzU2V0ID0gKCkgPT4gaW50ZXJ2YWxJZC5nZXQoKS5pc1NvbWUoKTtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IGludGVydmFsSWQuZ2V0KCk7XG4gICAgICBjb25zdCBzZXQgPSBmdW5jdGlvblRvUmVwZWF0ID0+IHtcbiAgICAgICAgcmV2b2tlKCk7XG4gICAgICAgIGludGVydmFsSWQuc2V0KE9wdGlvbmFsLnNvbWUoc2V0SW50ZXJ2YWwoZnVuY3Rpb25Ub1JlcGVhdCwgZGVsYXkpKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIGlzU2V0LFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHZhbHVlJDIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gc2luZ2xldG9uKG5vb3ApO1xuICAgICAgY29uc3Qgb24gPSBmID0+IHN1YmplY3QuZ2V0KCkuZWFjaChmKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN1YmplY3QsXG4gICAgICAgIG9uXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBmaXJzdCQxID0gKGZuLCByYXRlKSA9PiB7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSwgcmF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWwsXG4gICAgICAgIHRocm90dGxlXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbGFzdCQxID0gKGZuLCByYXRlKSA9PiB7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTnVsbCh0aW1lcikpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9LCByYXRlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWwsXG4gICAgICAgIHRocm90dGxlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBhbm5vdGF0aW9uID0gY29uc3RhbnQoJ21jZS1hbm5vdGF0aW9uJyk7XG4gICAgY29uc3QgZGF0YUFubm90YXRpb24gPSBjb25zdGFudCgnZGF0YS1tY2UtYW5ub3RhdGlvbicpO1xuICAgIGNvbnN0IGRhdGFBbm5vdGF0aW9uSWQgPSBjb25zdGFudCgnZGF0YS1tY2UtYW5ub3RhdGlvbi11aWQnKTtcbiAgICBjb25zdCBkYXRhQW5ub3RhdGlvbkFjdGl2ZSA9IGNvbnN0YW50KCdkYXRhLW1jZS1hbm5vdGF0aW9uLWFjdGl2ZScpO1xuICAgIGNvbnN0IGRhdGFBbm5vdGF0aW9uQ2xhc3NlcyA9IGNvbnN0YW50KCdkYXRhLW1jZS1hbm5vdGF0aW9uLWNsYXNzZXMnKTtcbiAgICBjb25zdCBkYXRhQW5ub3RhdGlvbkF0dHJpYnV0ZXMgPSBjb25zdGFudCgnZGF0YS1tY2UtYW5ub3RhdGlvbi1hdHRycycpO1xuXG4gICAgY29uc3QgaXNSb290JDEgPSByb290ID0+IG5vZGUgPT4gZXEobm9kZSwgcm9vdCk7XG4gICAgY29uc3QgaWRlbnRpZnkgPSAoZWRpdG9yLCBhbm5vdGF0aW9uTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gYW5ub3RhdGlvbk5hbWUuZm9sZCgoKSA9PiAnLicgKyBhbm5vdGF0aW9uKCksIGFuID0+IGBbJHsgZGF0YUFubm90YXRpb24oKSB9PVwiJHsgYW4gfVwiXWApO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBjaGlsZCQxKHN0YXJ0LCBybmcuc3RhcnRPZmZzZXQpLmdldE9yKHN0YXJ0KTtcbiAgICAgIGNvbnN0IGNsb3Nlc3QgPSBjbG9zZXN0JDMobmV3U3RhcnQsIHNlbGVjdG9yLCBpc1Jvb3QkMShyb290KSk7XG4gICAgICByZXR1cm4gY2xvc2VzdC5iaW5kKGMgPT4gZ2V0T3B0KGMsIGAkeyBkYXRhQW5ub3RhdGlvbklkKCkgfWApLmJpbmQodWlkID0+IGdldE9wdChjLCBgJHsgZGF0YUFubm90YXRpb24oKSB9YCkubWFwKG5hbWUgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGZpbmRNYXJrZXJzKGVkaXRvciwgdWlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1aWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBlbGVtZW50c1xuICAgICAgICB9O1xuICAgICAgfSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQW5ub3RhdGlvbiA9IGVsZW0gPT4gaXNFbGVtZW50JDcoZWxlbSkgJiYgaGFzKGVsZW0sIGFubm90YXRpb24oKSk7XG4gICAgY29uc3QgaXNCb2d1c0VsZW1lbnQgPSAoZWxlbSwgcm9vdCkgPT4gaGFzJDEoZWxlbSwgJ2RhdGEtbWNlLWJvZ3VzJykgfHwgYW5jZXN0b3IkMihlbGVtLCAnW2RhdGEtbWNlLWJvZ3VzPVwiYWxsXCJdJywgaXNSb290JDEocm9vdCkpO1xuICAgIGNvbnN0IGZpbmRNYXJrZXJzID0gKGVkaXRvciwgdWlkKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBkZXNjZW5kYW50cyQxID0gZGVzY2VuZGFudHMoYm9keSwgYFskeyBkYXRhQW5ub3RhdGlvbklkKCkgfT1cIiR7IHVpZCB9XCJdYCk7XG4gICAgICByZXR1cm4gZmlsdGVyJDUoZGVzY2VuZGFudHMkMSwgZGVzY2VuZGFudCA9PiAhaXNCb2d1c0VsZW1lbnQoZGVzY2VuZGFudCwgYm9keSkpO1xuICAgIH07XG4gICAgY29uc3QgZmluZEFsbCA9IChlZGl0b3IsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IG1hcmtlcnMgPSBkZXNjZW5kYW50cyhib2R5LCBgWyR7IGRhdGFBbm5vdGF0aW9uKCkgfT1cIiR7IG5hbWUgfVwiXWApO1xuICAgICAgY29uc3QgZGlyZWN0b3J5ID0ge307XG4gICAgICBlYWNoJGUobWFya2VycywgbSA9PiB7XG4gICAgICAgIGlmICghaXNCb2d1c0VsZW1lbnQobSwgYm9keSkpIHtcbiAgICAgICAgICBjb25zdCB1aWQgPSBnZXQkOShtLCBkYXRhQW5ub3RhdGlvbklkKCkpO1xuICAgICAgICAgIGNvbnN0IG5vZGVzQWxyZWFkeSA9IGdldCRhKGRpcmVjdG9yeSwgdWlkKS5nZXRPcihbXSk7XG4gICAgICAgICAgZGlyZWN0b3J5W3VpZF0gPSBub2Rlc0FscmVhZHkuY29uY2F0KFttXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRpcmVjdG9yeTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkeCA9IChlZGl0b3IsIHJlZ2lzdHJ5KSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VDYWxsYmFja3MgPSBDZWxsKHt9KTtcbiAgICAgIGNvbnN0IGluaXREYXRhID0gKCkgPT4gKHtcbiAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgcHJldmlvdXM6IHZhbHVlJDIoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCB3aXRoQ2FsbGJhY2tzID0gKG5hbWUsIGYpID0+IHtcbiAgICAgICAgdXBkYXRlQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4ge1xuICAgICAgICAgIGYoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwZGF0ZUNhbGxiYWNrcyA9IChuYW1lLCBmKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFwID0gY2hhbmdlQ2FsbGJhY2tzLmdldCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0JGEoY2FsbGJhY2tNYXAsIG5hbWUpLmdldE9yVGh1bmsoaW5pdERhdGEpO1xuICAgICAgICBjb25zdCBvdXRwdXREYXRhID0gZihkYXRhKTtcbiAgICAgICAgY2FsbGJhY2tNYXBbbmFtZV0gPSBvdXRwdXREYXRhO1xuICAgICAgICBjaGFuZ2VDYWxsYmFja3Muc2V0KGNhbGxiYWNrTWFwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlQ2FsbGJhY2tzID0gKG5hbWUsIHVpZCwgZWxlbWVudHMpID0+IHtcbiAgICAgICAgd2l0aENhbGxiYWNrcyhuYW1lLCBkYXRhID0+IHtcbiAgICAgICAgICBlYWNoJGUoZGF0YS5saXN0ZW5lcnMsIGYgPT4gZih0cnVlLCBuYW1lLCB7XG4gICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICBub2RlczogbWFwJDMoZWxlbWVudHMsIGVsZW0gPT4gZWxlbS5kb20pXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJlTm9Bbm5vdGF0aW9uID0gbmFtZSA9PiB7XG4gICAgICAgIHdpdGhDYWxsYmFja3MobmFtZSwgZGF0YSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGRhdGEubGlzdGVuZXJzLCBmID0+IGYoZmFsc2UsIG5hbWUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9nZ2xlQWN0aXZlQXR0ciA9ICh1aWQsIHN0YXRlKSA9PiB7XG4gICAgICAgIGVhY2gkZShmaW5kTWFya2VycyhlZGl0b3IsIHVpZCksIGVsZW0gPT4ge1xuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgc2V0JDMoZWxlbSwgZGF0YUFubm90YXRpb25BY3RpdmUoKSwgJ3RydWUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlJGEoZWxlbSwgZGF0YUFubm90YXRpb25BY3RpdmUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvbk5vZGVDaGFuZ2UgPSBsYXN0JDEoKCkgPT4ge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHNvcnQocmVnaXN0cnkuZ2V0TmFtZXMoKSk7XG4gICAgICAgIGVhY2gkZShhbm5vdGF0aW9ucywgbmFtZSA9PiB7XG4gICAgICAgICAgdXBkYXRlQ2FsbGJhY2tzKG5hbWUsIGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGRhdGEucHJldmlvdXMuZ2V0KCk7XG4gICAgICAgICAgICBpZGVudGlmeShlZGl0b3IsIE9wdGlvbmFsLnNvbWUobmFtZSkpLmZvbGQoKCkgPT4ge1xuICAgICAgICAgICAgICBwcmV2LmVhY2godWlkID0+IHtcbiAgICAgICAgICAgICAgICBmaXJlTm9Bbm5vdGF0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgIGRhdGEucHJldmlvdXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVBY3RpdmVBdHRyKHVpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sICh7dWlkLCBuYW1lLCBlbGVtZW50c30pID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpcyQyKHByZXYsIHVpZCkpIHtcbiAgICAgICAgICAgICAgICBwcmV2LmVhY2godWlkID0+IHRvZ2dsZUFjdGl2ZUF0dHIodWlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGZpcmVDYWxsYmFja3MobmFtZSwgdWlkLCBlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgZGF0YS5wcmV2aW91cy5zZXQodWlkKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVBY3RpdmVBdHRyKHVpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGRhdGEucHJldmlvdXMsXG4gICAgICAgICAgICAgIGxpc3RlbmVyczogZGF0YS5saXN0ZW5lcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMzApO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIG9uTm9kZUNoYW5nZS5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBvbk5vZGVDaGFuZ2UudGhyb3R0bGUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWRkTGlzdGVuZXIgPSAobmFtZSwgZikgPT4ge1xuICAgICAgICB1cGRhdGVDYWxsYmFja3MobmFtZSwgZGF0YSA9PiAoe1xuICAgICAgICAgIHByZXZpb3VzOiBkYXRhLnByZXZpb3VzLFxuICAgICAgICAgIGxpc3RlbmVyczogZGF0YS5saXN0ZW5lcnMuY29uY2F0KFtmXSlcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7IGFkZExpc3RlbmVyIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJHcgPSAoZWRpdG9yLCByZWdpc3RyeSkgPT4ge1xuICAgICAgY29uc3QgZGF0YUFubm90YXRpb24kMSA9IGRhdGFBbm5vdGF0aW9uKCk7XG4gICAgICBjb25zdCBpZGVudGlmeVBhcnNlck5vZGUgPSBub2RlID0+IE9wdGlvbmFsLmZyb20obm9kZS5hdHRyKGRhdGFBbm5vdGF0aW9uJDEpKS5iaW5kKHJlZ2lzdHJ5Lmxvb2t1cCk7XG4gICAgICBjb25zdCByZW1vdmVEaXJlY3RBbm5vdGF0aW9uID0gbm9kZSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIG5vZGUuYXR0cihkYXRhQW5ub3RhdGlvbklkKCksIG51bGwpO1xuICAgICAgICBub2RlLmF0dHIoZGF0YUFubm90YXRpb24oKSwgbnVsbCk7XG4gICAgICAgIG5vZGUuYXR0cihkYXRhQW5ub3RhdGlvbkFjdGl2ZSgpLCBudWxsKTtcbiAgICAgICAgY29uc3QgY3VzdG9tQXR0ck5hbWVzID0gT3B0aW9uYWwuZnJvbShub2RlLmF0dHIoZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCkpKS5tYXAobmFtZXMgPT4gbmFtZXMuc3BsaXQoJywnKSkuZ2V0T3IoW10pO1xuICAgICAgICBjb25zdCBjdXN0b21DbGFzc2VzID0gT3B0aW9uYWwuZnJvbShub2RlLmF0dHIoZGF0YUFubm90YXRpb25DbGFzc2VzKCkpKS5tYXAobmFtZXMgPT4gbmFtZXMuc3BsaXQoJywnKSkuZ2V0T3IoW10pO1xuICAgICAgICBlYWNoJGUoY3VzdG9tQXR0ck5hbWVzLCBuYW1lID0+IG5vZGUuYXR0cihuYW1lLCBudWxsKSk7XG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IChfYiA9IChfYSA9IG5vZGUuYXR0cignY2xhc3MnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCcgJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBjb25zdCBuZXdDbGFzc0xpc3QgPSBkaWZmZXJlbmNlKGNsYXNzTGlzdCwgW2Fubm90YXRpb24oKV0uY29uY2F0KGN1c3RvbUNsYXNzZXMpKTtcbiAgICAgICAgbm9kZS5hdHRyKCdjbGFzcycsIG5ld0NsYXNzTGlzdC5sZW5ndGggPiAwID8gbmV3Q2xhc3NMaXN0LmpvaW4oJyAnKSA6IG51bGwpO1xuICAgICAgICBub2RlLmF0dHIoZGF0YUFubm90YXRpb25DbGFzc2VzKCksIG51bGwpO1xuICAgICAgICBub2RlLmF0dHIoZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCksIG51bGwpO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5zZXJpYWxpemVyLmFkZFRlbXBBdHRyKGRhdGFBbm5vdGF0aW9uQWN0aXZlKCkpO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkQXR0cmlidXRlRmlsdGVyKGRhdGFBbm5vdGF0aW9uJDEsIG5vZGVzID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgaWRlbnRpZnlQYXJzZXJOb2RlKG5vZGUpLmVhY2goc2V0dGluZ3MgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBlcnNpc3RlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09ICdzcGFuJykge1xuICAgICAgICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRGlyZWN0QW5ub3RhdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlJGMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgc2V0dGluZ3MpID0+IHtcbiAgICAgICAgYW5ub3RhdGlvbnNbbmFtZV0gPSB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvb2t1cCA9IG5hbWUgPT4gZ2V0JGEoYW5ub3RhdGlvbnMsIG5hbWUpLm1hcChhID0+IGEuc2V0dGluZ3MpO1xuICAgICAgY29uc3QgZ2V0TmFtZXMgPSAoKSA9PiBrZXlzKGFubm90YXRpb25zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBsb29rdXAsXG4gICAgICAgIGdldE5hbWVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgdW5pcXVlID0gMDtcbiAgICBjb25zdCBnZW5lcmF0ZSQxID0gcHJlZml4ID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgdGltZSA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMCk7XG4gICAgICB1bmlxdWUrKztcbiAgICAgIHJldHVybiBwcmVmaXggKyAnXycgKyByYW5kb20gKyB1bmlxdWUgKyBTdHJpbmcodGltZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZCA9IChlbGVtZW50LCBjbGFzc2VzKSA9PiB7XG4gICAgICBlYWNoJGUoY2xhc3NlcywgeCA9PiB7XG4gICAgICAgIGFkZCQyKGVsZW1lbnQsIHgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUkNCA9IChlbGVtZW50LCBjbGFzc2VzKSA9PiB7XG4gICAgICBlYWNoJGUoY2xhc3NlcywgeCA9PiB7XG4gICAgICAgIHJlbW92ZSQ3KGVsZW1lbnQsIHgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNsb25lJDIgPSAob3JpZ2luYWwsIGlzRGVlcCkgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20ob3JpZ2luYWwuZG9tLmNsb25lTm9kZShpc0RlZXApKTtcbiAgICBjb25zdCBzaGFsbG93JDEgPSBvcmlnaW5hbCA9PiBjbG9uZSQyKG9yaWdpbmFsLCBmYWxzZSk7XG4gICAgY29uc3QgZGVlcCQxID0gb3JpZ2luYWwgPT4gY2xvbmUkMihvcmlnaW5hbCwgdHJ1ZSk7XG4gICAgY29uc3Qgc2hhbGxvd0FzID0gKG9yaWdpbmFsLCB0YWcpID0+IHtcbiAgICAgIGNvbnN0IG51ID0gU3VnYXJFbGVtZW50LmZyb21UYWcodGFnKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjbG9uZSQ0KG9yaWdpbmFsKTtcbiAgICAgIHNldEFsbCQxKG51LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBudTtcbiAgICB9O1xuICAgIGNvbnN0IG11dGF0ZSA9IChvcmlnaW5hbCwgdGFnKSA9PiB7XG4gICAgICBjb25zdCBudSA9IHNoYWxsb3dBcyhvcmlnaW5hbCwgdGFnKTtcbiAgICAgIGFmdGVyJDQob3JpZ2luYWwsIG51KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW4kMShvcmlnaW5hbCk7XG4gICAgICBhcHBlbmQobnUsIGNoaWxkcmVuKTtcbiAgICAgIHJlbW92ZSQ1KG9yaWdpbmFsKTtcbiAgICAgIHJldHVybiBudTtcbiAgICB9O1xuXG4gICAgY29uc3QgVGV4dFdhbGtlciA9IChzdGFydE5vZGUsIHJvb3ROb2RlLCBpc0JvdW5kYXJ5ID0gbmV2ZXIpID0+IHtcbiAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHN0YXJ0Tm9kZSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3Qgd2FsayA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbmV4dCA9IHdhbGtlcltkaXJlY3Rpb25dKCk7XG4gICAgICAgIH0gd2hpbGUgKG5leHQgJiYgIWlzVGV4dCRhKG5leHQpICYmICFpc0JvdW5kYXJ5KG5leHQpKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20obmV4dCkuZmlsdGVyKGlzVGV4dCRhKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiAoKSA9PiBPcHRpb25hbC5mcm9tKHdhbGtlci5jdXJyZW50KCkpLmZpbHRlcihpc1RleHQkYSksXG4gICAgICAgIG5leHQ6ICgpID0+IHdhbGsoJ25leHQnKSxcbiAgICAgICAgcHJldjogKCkgPT4gd2FsaygncHJldicpLFxuICAgICAgICBwcmV2MjogKCkgPT4gd2FsaygncHJldjInKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgVGV4dFNlZWtlciA9IChkb20sIGlzQm91bmRhcnkpID0+IHtcbiAgICAgIGNvbnN0IGlzQmxvY2tCb3VuZGFyeSA9IGlzQm91bmRhcnkgPyBpc0JvdW5kYXJ5IDogbm9kZSA9PiBkb20uaXNCbG9jayhub2RlKSB8fCBpc0JyJDYobm9kZSkgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKG5vZGUpO1xuICAgICAgY29uc3Qgd2FsayA9IChub2RlLCBvZmZzZXQsIHdhbGtlciwgcHJvY2VzcykgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBwcm9jZXNzKG5vZGUsIG9mZnNldCwgbm9kZS5kYXRhKTtcbiAgICAgICAgICBpZiAobmV3T2Zmc2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgICBjb250YWluZXI6IG5vZGUsXG4gICAgICAgICAgICAgIG9mZnNldDogbmV3T2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhbGtlcigpLmJpbmQobmV4dCA9PiB3YWxrKG5leHQuY29udGFpbmVyLCBuZXh0Lm9mZnNldCwgd2Fsa2VyLCBwcm9jZXNzKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYmFja3dhcmRzID0gKG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdCkgPT4ge1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBUZXh0V2Fsa2VyKG5vZGUsIHJvb3QgIT09IG51bGwgJiYgcm9vdCAhPT0gdm9pZCAwID8gcm9vdCA6IGRvbS5nZXRSb290KCksIGlzQmxvY2tCb3VuZGFyeSk7XG4gICAgICAgIHJldHVybiB3YWxrKG5vZGUsIG9mZnNldCwgKCkgPT4gd2Fsa2VyLnByZXYoKS5tYXAocHJldiA9PiAoe1xuICAgICAgICAgIGNvbnRhaW5lcjogcHJldixcbiAgICAgICAgICBvZmZzZXQ6IHByZXYubGVuZ3RoXG4gICAgICAgIH0pKSwgcHJvY2VzcykuZ2V0T3JOdWxsKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yd2FyZHMgPSAobm9kZSwgb2Zmc2V0LCBwcm9jZXNzLCByb290KSA9PiB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IFRleHRXYWxrZXIobm9kZSwgcm9vdCAhPT0gbnVsbCAmJiByb290ICE9PSB2b2lkIDAgPyByb290IDogZG9tLmdldFJvb3QoKSwgaXNCbG9ja0JvdW5kYXJ5KTtcbiAgICAgICAgcmV0dXJuIHdhbGsobm9kZSwgb2Zmc2V0LCAoKSA9PiB3YWxrZXIubmV4dCgpLm1hcChuZXh0ID0+ICh7XG4gICAgICAgICAgY29udGFpbmVyOiBuZXh0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9KSksIHByb2Nlc3MpLmdldE9yTnVsbCgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2t3YXJkcyxcbiAgICAgICAgZm9yd2FyZHNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJvdW5kJDIgPSBNYXRoLnJvdW5kO1xuICAgIGNvbnN0IGNsb25lJDEgPSByZWN0ID0+IHtcbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJvdW5kJDIocmVjdC5sZWZ0KSxcbiAgICAgICAgdG9wOiByb3VuZCQyKHJlY3QudG9wKSxcbiAgICAgICAgYm90dG9tOiByb3VuZCQyKHJlY3QuYm90dG9tKSxcbiAgICAgICAgcmlnaHQ6IHJvdW5kJDIocmVjdC5yaWdodCksXG4gICAgICAgIHdpZHRoOiByb3VuZCQyKHJlY3Qud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IHJvdW5kJDIocmVjdC5oZWlnaHQpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29sbGFwc2UgPSAocmVjdCwgdG9TdGFydCkgPT4ge1xuICAgICAgcmVjdCA9IGNsb25lJDEocmVjdCk7XG4gICAgICBpZiAodG9TdGFydCkge1xuICAgICAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aDtcbiAgICAgICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdDtcbiAgICAgIH1cbiAgICAgIHJlY3Qud2lkdGggPSAwO1xuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCBpc0VxdWFsID0gKHJlY3QxLCByZWN0MikgPT4gcmVjdDEubGVmdCA9PT0gcmVjdDIubGVmdCAmJiByZWN0MS50b3AgPT09IHJlY3QyLnRvcCAmJiByZWN0MS5ib3R0b20gPT09IHJlY3QyLmJvdHRvbSAmJiByZWN0MS5yaWdodCA9PT0gcmVjdDIucmlnaHQ7XG4gICAgY29uc3QgaXNWYWxpZE92ZXJmbG93ID0gKG92ZXJmbG93WSwgcmVjdDEsIHJlY3QyKSA9PiBvdmVyZmxvd1kgPj0gMCAmJiBvdmVyZmxvd1kgPD0gTWF0aC5taW4ocmVjdDEuaGVpZ2h0LCByZWN0Mi5oZWlnaHQpIC8gMjtcbiAgICBjb25zdCBpc0Fib3ZlJDEgPSAocmVjdDEsIHJlY3QyKSA9PiB7XG4gICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gTWF0aC5taW4ocmVjdDIuaGVpZ2h0IC8gMiwgcmVjdDEuaGVpZ2h0IC8gMik7XG4gICAgICBpZiAocmVjdDEuYm90dG9tIC0gaGFsZkhlaWdodCA8IHJlY3QyLnRvcCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0MS50b3AgPiByZWN0Mi5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzVmFsaWRPdmVyZmxvdyhyZWN0Mi50b3AgLSByZWN0MS5ib3R0b20sIHJlY3QxLCByZWN0Mik7XG4gICAgfTtcbiAgICBjb25zdCBpc0JlbG93JDEgPSAocmVjdDEsIHJlY3QyKSA9PiB7XG4gICAgICBpZiAocmVjdDEudG9wID4gcmVjdDIuYm90dG9tKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3QxLmJvdHRvbSA8IHJlY3QyLnRvcCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNWYWxpZE92ZXJmbG93KHJlY3QyLmJvdHRvbSAtIHJlY3QxLnRvcCwgcmVjdDEsIHJlY3QyKTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRhaW5zWFkgPSAocmVjdCwgY2xpZW50WCwgY2xpZW50WSkgPT4gY2xpZW50WCA+PSByZWN0LmxlZnQgJiYgY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGNsaWVudFkgPj0gcmVjdC50b3AgJiYgY2xpZW50WSA8PSByZWN0LmJvdHRvbTtcbiAgICBjb25zdCBib3VuZGluZ0NsaWVudFJlY3RGcm9tUmVjdHMgPSByZWN0cyA9PiB7XG4gICAgICByZXR1cm4gZm9sZGwocmVjdHMsIChhY2MsIHJlY3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYy5mb2xkKCgpID0+IE9wdGlvbmFsLnNvbWUocmVjdCksIHByZXZSZWN0ID0+IHtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4ocmVjdC5sZWZ0LCBwcmV2UmVjdC5sZWZ0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcHJldlJlY3QudG9wKTtcbiAgICAgICAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHJlY3QucmlnaHQsIHByZXZSZWN0LnJpZ2h0KTtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChyZWN0LmJvdHRvbSwgcHJldlJlY3QuYm90dG9tKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBPcHRpb25hbC5ub25lKCkpO1xuICAgIH07XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RFZGdlRnJvbVhZID0gKHJlY3QsIHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGN4ID0gTWF0aC5tYXgoTWF0aC5taW4oeCwgcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCksIHJlY3QubGVmdCk7XG4gICAgICBjb25zdCBjeSA9IE1hdGgubWF4KE1hdGgubWluKHksIHJlY3QudG9wICsgcmVjdC5oZWlnaHQpLCByZWN0LnRvcCk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4IC0gY3gpICogKHggLSBjeCkgKyAoeSAtIGN5KSAqICh5IC0gY3kpKTtcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJsYXBZID0gKHIxLCByMikgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocjEuYm90dG9tLCByMi5ib3R0b20pIC0gTWF0aC5tYXgocjEudG9wLCByMi50b3ApKTtcblxuICAgIGNvbnN0IGNsYW1wJDIgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcblxuICAgIGNvbnN0IGdldFNlbGVjdGVkTm9kZSA9IHJhbmdlID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICBpZiAoc3RhcnRDb250YWluZXIgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJiBzdGFydENvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkgJiYgcmFuZ2UuZW5kT2Zmc2V0ID09PSBzdGFydE9mZnNldCArIDEpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbc3RhcnRPZmZzZXRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBnZXROb2RlJDEgPSAoY29udGFpbmVyLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpICYmIGNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgICAgICBjb25zdCBzYWZlT2Zmc2V0ID0gY2xhbXAkMihvZmZzZXQsIDAsIGNoaWxkTm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVzW3NhZmVPZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldE5vZGVVbnNhZmUgPSAoY29udGFpbmVyLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChvZmZzZXQgPCAwICYmIGlzRWxlbWVudCQ2KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldE5vZGUkMShjb250YWluZXIsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGV4dGVuZGluZ0NoYXJzID0gbmV3IFJlZ0V4cCgnW1xcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA0ODgtXFx1MDQ4OVxcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxLVxcdTA1YzJcXHUwNWM0LVxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhJyArICdcXHUwNjRiLVxcdTA2NWZcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlNy1cXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMCcgKyAnXFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhlMy1cXHUwOTAyXFx1MDkzYVxcdTA5M2MnICsgJ1xcdTA5NDEtXFx1MDk0OFxcdTA5NGRcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTItXFx1MDllMycgKyAnXFx1MGEwMS1cXHUwYTAyXFx1MGEzY1xcdTBhNDEtXFx1MGE0MlxcdTBhNDctXFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwLVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgyXFx1MGFiYycgKyAnXFx1MGFjMS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM4XFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTcnICsgJ1xcdTBiNjItXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMwMFxcdTBjM2UtXFx1MGM0MFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTUtXFx1MGM1NicgKyAnXFx1MGM2Mi1cXHUwYzYzXFx1MGM4MVxcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjLVxcdTBjY2RcXHUwY2Q1LVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwZDAxXFx1MGQzZVxcdTBkNDEtXFx1MGQ0NCcgKyAnXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZGNhXFx1MGRjZlxcdTBkZDItXFx1MGRkNFxcdTBkZDZcXHUwZGRmXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlYjFcXHUwZWI0LVxcdTBlYjknICsgJ1xcdTBlYmItXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBmMTgtXFx1MGYxOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNzEtXFx1MGY3ZVxcdTBmODAtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5NycgKyAnXFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzktXFx1MTAzYVxcdTEwM2QtXFx1MTAzZVxcdTEwNTgtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NCcgKyAnXFx1MTA4MlxcdTEwODUtXFx1MTA4NlxcdTEwOGRcXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1Mi1cXHUxNzUzXFx1MTc3Mi1cXHUxNzczXFx1MTdiNC1cXHUxN2I1JyArICdcXHUxN2I3LVxcdTE3YmRcXHUxN2M2XFx1MTdjOS1cXHUxN2QzXFx1MTdkZFxcdTE4MGItXFx1MTgwZFxcdTE4YTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3LVxcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExNy1cXHUxYTE4JyArICdcXHUxYTFiXFx1MWE1NlxcdTFhNTgtXFx1MWE1ZVxcdTFhNjBcXHUxYTYyXFx1MWE2NS1cXHUxYTZjXFx1MWE3My1cXHUxYTdjXFx1MWE3ZlxcdTFhYjAtXFx1MWFiZFxcdTFBQkVcXHUxYjAwLVxcdTFiMDNcXHUxYjM0JyArICdcXHUxYjM2LVxcdTFiM2FcXHUxYjNjXFx1MWI0MlxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MVxcdTFiYTItXFx1MWJhNVxcdTFiYTgtXFx1MWJhOVxcdTFiYWItXFx1MWJhZFxcdTFiZTZcXHUxYmU4LVxcdTFiZTknICsgJ1xcdTFiZWRcXHUxYmVmLVxcdTFiZjFcXHUxYzJjLVxcdTFjMzNcXHUxYzM2LVxcdTFjMzdcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZTBcXHUxY2UyLVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjgtXFx1MWNmOScgKyAnXFx1MWRjMC1cXHUxZGY1XFx1MWRmYy1cXHUxZGZmXFx1MjAwYy1cXHUyMDBkXFx1MjBkMC1cXHUyMGRjXFx1MjBERC1cXHUyMEUwXFx1MjBlMVxcdTIwRTItXFx1MjBFNFxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMScgKyAnXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZFxcdTMwMmUtXFx1MzAyZlxcdTMwOTktXFx1MzA5YVxcdWE2NmZcXHVBNjcwLVxcdUE2NzJcXHVhNjc0LVxcdWE2N2RcXHVhNjllLVxcdWE2OWZcXHVhNmYwLVxcdWE2ZjEnICsgJ1xcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjUtXFx1YTgyNlxcdWE4YzRcXHVhOGUwLVxcdWE4ZjFcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTFcXHVhOTgwLVxcdWE5ODJcXHVhOWIzXFx1YTliNi1cXHVhOWI5XFx1YTliYycgKyAnXFx1YTllNVxcdWFhMjktXFx1YWEyZVxcdWFhMzEtXFx1YWEzMlxcdWFhMzUtXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE3Y1xcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3LVxcdWFhYjhcXHVhYWJlLVxcdWFhYmZcXHVhYWMxJyArICdcXHVhYWVjLVxcdWFhZWRcXHVhYWY2XFx1YWJlNVxcdWFiZThcXHVhYmVkXFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZmOWUtXFx1ZmY5Zl0nKTtcbiAgICBjb25zdCBpc0V4dGVuZGluZ0NoYXIgPSBjaCA9PiBpc1N0cmluZyhjaCkgJiYgY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCk7XG5cbiAgICBjb25zdCBvciA9ICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4geCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldKHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGFuZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICByZXR1cm4geCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghYXJnc1tpXSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzRWxlbWVudCQ0ID0gaXNFbGVtZW50JDY7XG4gICAgY29uc3QgaXNDYXJldENhbmRpZGF0ZSQyID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzQmxvY2skMSA9IG1hdGNoU3R5bGVWYWx1ZXMoJ2Rpc3BsYXknLCAnYmxvY2sgdGFibGUnKTtcbiAgICBjb25zdCBpc0Zsb2F0ZWQgPSBtYXRjaFN0eWxlVmFsdWVzKCdmbG9hdCcsICdsZWZ0IHJpZ2h0Jyk7XG4gICAgY29uc3QgaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZSA9IGFuZChpc0VsZW1lbnQkNCwgaXNDYXJldENhbmRpZGF0ZSQyLCBub3QoaXNGbG9hdGVkKSk7XG4gICAgY29uc3QgaXNOb3RQcmUgPSBub3QobWF0Y2hTdHlsZVZhbHVlcygnd2hpdGUtc3BhY2UnLCAncHJlIHByZS1saW5lIHByZS13cmFwJykpO1xuICAgIGNvbnN0IGlzVGV4dCQ3ID0gaXNUZXh0JGE7XG4gICAgY29uc3QgaXNCciQzID0gaXNCciQ2O1xuICAgIGNvbnN0IG5vZGVJbmRleCQxID0gRE9NVXRpbHMubm9kZUluZGV4O1xuICAgIGNvbnN0IHJlc29sdmVJbmRleCQxID0gZ2V0Tm9kZVVuc2FmZTtcbiAgICBjb25zdCBjcmVhdGVSYW5nZSQxID0gZG9jID0+IGRvYyA/IGRvYy5jcmVhdGVSYW5nZSgpIDogRE9NVXRpbHMuRE9NLmNyZWF0ZVJuZygpO1xuICAgIGNvbnN0IGlzV2hpdGVTcGFjZSQxID0gY2hyID0+IGlzU3RyaW5nKGNocikgJiYgL1tcXHJcXG5cXHQgXS8udGVzdChjaHIpO1xuICAgIGNvbnN0IGlzUmFuZ2UgPSBybmcgPT4gISFybmcuc2V0U3RhcnQgJiYgISFybmcuc2V0RW5kO1xuICAgIGNvbnN0IGlzSGlkZGVuV2hpdGVTcGFjZVJhbmdlID0gcmFuZ2UgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBvZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgIGlmIChpc1doaXRlU3BhY2UkMShyYW5nZS50b1N0cmluZygpKSAmJiBpc05vdFByZShjb250YWluZXIucGFyZW50Tm9kZSkgJiYgaXNUZXh0JGEoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gY29udGFpbmVyLmRhdGE7XG4gICAgICAgIGlmIChpc1doaXRlU3BhY2UkMSh0ZXh0W29mZnNldCAtIDFdKSB8fCBpc1doaXRlU3BhY2UkMSh0ZXh0W29mZnNldCArIDFdKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBnZXRCckNsaWVudFJlY3QgPSBick5vZGUgPT4ge1xuICAgICAgY29uc3QgZG9jID0gYnJOb2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCBybmcgPSBjcmVhdGVSYW5nZSQxKGRvYyk7XG4gICAgICBjb25zdCBuYnNwJDEgPSBkb2MuY3JlYXRlVGV4dE5vZGUobmJzcCk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYnJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuYnNwJDEsIGJyTm9kZSk7XG4gICAgICBybmcuc2V0U3RhcnQobmJzcCQxLCAwKTtcbiAgICAgIHJuZy5zZXRFbmQobmJzcCQxLCAxKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBjbG9uZSQxKHJuZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5ic3AkMSk7XG4gICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvdW5kaW5nQ2xpZW50UmVjdFdlYktpdFRleHQgPSBybmcgPT4ge1xuICAgICAgY29uc3Qgc2MgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBlYyA9IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCBzbyA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgIGNvbnN0IGVvID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGlmIChzYyA9PT0gZWMgJiYgaXNUZXh0JGEoZWMpICYmIHNvID09PSAwICYmIGVvID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG5ld1JuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICAgIG5ld1JuZy5zZXRFbmRBZnRlcihlYyk7XG4gICAgICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShuZXdSbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1plcm9SZWN0ID0gciA9PiByLmxlZnQgPT09IDAgJiYgci5yaWdodCA9PT0gMCAmJiByLnRvcCA9PT0gMCAmJiByLmJvdHRvbSA9PT0gMDtcbiAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QkMSA9IGl0ZW0gPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IGNsaWVudFJlY3Q7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGl0ZW0uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNsaWVudFJlY3QgPSBjbG9uZSQxKGNsaWVudFJlY3RzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFJlY3QgPSBjbG9uZSQxKGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1JhbmdlKGl0ZW0pICYmIGlzQnIkMyhpdGVtKSAmJiBpc1plcm9SZWN0KGNsaWVudFJlY3QpKSB7XG4gICAgICAgIHJldHVybiBnZXRCckNsaWVudFJlY3QoaXRlbSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNaZXJvUmVjdChjbGllbnRSZWN0KSAmJiBpc1JhbmdlKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiAoX2EgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3RXZWJLaXRUZXh0KGl0ZW0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnRSZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCBjb2xsYXBzZUFuZEluZmxhdGVXaWR0aCA9IChjbGllbnRSZWN0LCB0b1N0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBuZXdDbGllbnRSZWN0ID0gY29sbGFwc2UoY2xpZW50UmVjdCwgdG9TdGFydCk7XG4gICAgICBuZXdDbGllbnRSZWN0LndpZHRoID0gMTtcbiAgICAgIG5ld0NsaWVudFJlY3QucmlnaHQgPSBuZXdDbGllbnRSZWN0LmxlZnQgKyAxO1xuICAgICAgcmV0dXJuIG5ld0NsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDYXJldFBvc2l0aW9uQ2xpZW50UmVjdHMgPSBjYXJldFBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gW107XG4gICAgICBjb25zdCBhZGRVbmlxdWVBbmRWYWxpZFJlY3QgPSBjbGllbnRSZWN0ID0+IHtcbiAgICAgICAgaWYgKGNsaWVudFJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKGlzRXF1YWwoY2xpZW50UmVjdCwgY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlY3RzLnB1c2goY2xpZW50UmVjdCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQ2hhcmFjdGVyT2Zmc2V0ID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gY3JlYXRlUmFuZ2UkMShjb250YWluZXIub3duZXJEb2N1bWVudCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaXNFeHRlbmRpbmdDaGFyKGNvbnRhaW5lci5kYXRhW29mZnNldF0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0V4dGVuZGluZ0NoYXIoY29udGFpbmVyLmRhdGFbb2Zmc2V0IC0gMV0pKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGlmICghaXNIaWRkZW5XaGl0ZVNwYWNlUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgICAgICAgIGFkZFVuaXF1ZUFuZFZhbGlkUmVjdChjb2xsYXBzZUFuZEluZmxhdGVXaWR0aChnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShyYW5nZSksIGZhbHNlKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChjb250YWluZXIsIG9mZnNldCAtIDEpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgaWYgKCFpc0hpZGRlbldoaXRlU3BhY2VSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgIGFkZFVuaXF1ZUFuZFZhbGlkUmVjdChjb2xsYXBzZUFuZEluZmxhdGVXaWR0aChnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShyYW5nZSksIGZhbHNlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgaWYgKCFpc0hpZGRlbldoaXRlU3BhY2VSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgIGFkZFVuaXF1ZUFuZFZhbGlkUmVjdChjb2xsYXBzZUFuZEluZmxhdGVXaWR0aChnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShyYW5nZSksIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjYXJldFBvc2l0aW9uLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gY2FyZXRQb3NpdGlvbi5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkNyhjb250YWluZXIpKSB7XG4gICAgICAgIGFkZENoYXJhY3Rlck9mZnNldChjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBjbGllbnRSZWN0cztcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNChjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChjYXJldFBvc2l0aW9uLmlzQXRFbmQoKSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXNvbHZlSW5kZXgkMShjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGlzVGV4dCQ3KG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRDaGFyYWN0ZXJPZmZzZXQobm9kZSwgbm9kZS5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudENhcmV0Q2FuZGlkYXRlKG5vZGUpICYmICFpc0JyJDMobm9kZSkpIHtcbiAgICAgICAgICAgIGFkZFVuaXF1ZUFuZFZhbGlkUmVjdChjb2xsYXBzZUFuZEluZmxhdGVXaWR0aChnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShub2RlKSwgZmFsc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHJlc29sdmVJbmRleCQxKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaXNUZXh0JDcobm9kZSkpIHtcbiAgICAgICAgICAgIGFkZENoYXJhY3Rlck9mZnNldChub2RlLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50Q2FyZXRDYW5kaWRhdGUobm9kZSkgJiYgY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCkpIHtcbiAgICAgICAgICAgIGFkZFVuaXF1ZUFuZFZhbGlkUmVjdChjb2xsYXBzZUFuZEluZmxhdGVXaWR0aChnZXRCb3VuZGluZ0NsaWVudFJlY3QkMShub2RlKSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IHJlc29sdmVJbmRleCQxKGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCksIGNhcmV0UG9zaXRpb24ub2Zmc2V0KCkgLSAxKTtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShiZWZvcmVOb2RlKSAmJiAhaXNCciQzKGJlZm9yZU5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayQxKGJlZm9yZU5vZGUpIHx8IGlzQmxvY2skMShub2RlKSB8fCAhaXNWYWxpZEVsZW1lbnRDYXJldENhbmRpZGF0ZShub2RlKSkge1xuICAgICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEoYmVmb3JlTm9kZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudENhcmV0Q2FuZGlkYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICBhZGRVbmlxdWVBbmRWYWxpZFJlY3QoY29sbGFwc2VBbmRJbmZsYXRlV2lkdGgoZ2V0Qm91bmRpbmdDbGllbnRSZWN0JDEobm9kZSksIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGllbnRSZWN0cztcbiAgICB9O1xuICAgIGNvbnN0IENhcmV0UG9zaXRpb24gPSAoY29udGFpbmVyLCBvZmZzZXQsIGNsaWVudFJlY3RzKSA9PiB7XG4gICAgICBjb25zdCBpc0F0U3RhcnQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc1RleHQkNyhjb250YWluZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0ID09PSAwO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQXRFbmQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc1RleHQkNyhjb250YWluZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCA+PSBjb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldCA+PSBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgY29uc3QgdG9SYW5nZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBjcmVhdGVSYW5nZSQxKGNvbnRhaW5lci5vd25lckRvY3VtZW50KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q2xpZW50UmVjdHMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghY2xpZW50UmVjdHMpIHtcbiAgICAgICAgICBjbGllbnRSZWN0cyA9IGdldENhcmV0UG9zaXRpb25DbGllbnRSZWN0cyhDYXJldFBvc2l0aW9uKGNvbnRhaW5lciwgb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9ICgpID0+IGdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbiAgICAgIGNvbnN0IGlzRXF1YWwgPSBjYXJldFBvc2l0aW9uID0+IGNhcmV0UG9zaXRpb24gJiYgY29udGFpbmVyID09PSBjYXJldFBvc2l0aW9uLmNvbnRhaW5lcigpICYmIG9mZnNldCA9PT0gY2FyZXRQb3NpdGlvbi5vZmZzZXQoKTtcbiAgICAgIGNvbnN0IGdldE5vZGUgPSBiZWZvcmUgPT4gcmVzb2x2ZUluZGV4JDEoY29udGFpbmVyLCBiZWZvcmUgPyBvZmZzZXQgLSAxIDogb2Zmc2V0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5lcjogY29uc3RhbnQoY29udGFpbmVyKSxcbiAgICAgICAgb2Zmc2V0OiBjb25zdGFudChvZmZzZXQpLFxuICAgICAgICB0b1JhbmdlLFxuICAgICAgICBnZXRDbGllbnRSZWN0cyxcbiAgICAgICAgaXNWaXNpYmxlLFxuICAgICAgICBpc0F0U3RhcnQsXG4gICAgICAgIGlzQXRFbmQsXG4gICAgICAgIGlzRXF1YWwsXG4gICAgICAgIGdldE5vZGVcbiAgICAgIH07XG4gICAgfTtcbiAgICBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0ID0gcmFuZ2UgPT4gQ2FyZXRQb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kID0gcmFuZ2UgPT4gQ2FyZXRQb3NpdGlvbihyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgQ2FyZXRQb3NpdGlvbi5hZnRlciA9IG5vZGUgPT4gQ2FyZXRQb3NpdGlvbihub2RlLnBhcmVudE5vZGUsIG5vZGVJbmRleCQxKG5vZGUpICsgMSk7XG4gICAgQ2FyZXRQb3NpdGlvbi5iZWZvcmUgPSBub2RlID0+IENhcmV0UG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBub2RlSW5kZXgkMShub2RlKSk7XG4gICAgQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlID0gKHBvczEsIHBvczIpID0+IGxpZnQyKGhlYWQocG9zMi5nZXRDbGllbnRSZWN0cygpKSwgbGFzdCQzKHBvczEuZ2V0Q2xpZW50UmVjdHMoKSksIGlzQWJvdmUkMSkuZ2V0T3IoZmFsc2UpO1xuICAgIENhcmV0UG9zaXRpb24uaXNCZWxvdyA9IChwb3MxLCBwb3MyKSA9PiBsaWZ0MihsYXN0JDMocG9zMi5nZXRDbGllbnRSZWN0cygpKSwgaGVhZChwb3MxLmdldENsaWVudFJlY3RzKCkpLCBpc0JlbG93JDEpLmdldE9yKGZhbHNlKTtcbiAgICBDYXJldFBvc2l0aW9uLmlzQXRTdGFydCA9IHBvcyA9PiBwb3MgPyBwb3MuaXNBdFN0YXJ0KCkgOiBmYWxzZTtcbiAgICBDYXJldFBvc2l0aW9uLmlzQXRFbmQgPSBwb3MgPT4gcG9zID8gcG9zLmlzQXRFbmQoKSA6IGZhbHNlO1xuICAgIENhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24gPSBwb3MgPT4gcG9zID8gaXNUZXh0JGEocG9zLmNvbnRhaW5lcigpKSA6IGZhbHNlO1xuICAgIENhcmV0UG9zaXRpb24uaXNFbGVtZW50UG9zaXRpb24gPSBwb3MgPT4gIUNhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zKTtcblxuICAgIGNvbnN0IHRyaW1FbXB0eVRleHROb2RlJDEgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0Tm9kZSA9IChkb20sIHJuZywgbm9kZSkgPT4ge1xuICAgICAgcm5nLmluc2VydE5vZGUobm9kZSk7XG4gICAgICB0cmltRW1wdHlUZXh0Tm9kZSQxKGRvbSwgbm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgdHJpbUVtcHR5VGV4dE5vZGUkMShkb20sIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0RnJhZ21lbnQgPSAoZG9tLCBybmcsIGZyYWcpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBPcHRpb25hbC5mcm9tKGZyYWcuZmlyc3RDaGlsZCk7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBPcHRpb25hbC5mcm9tKGZyYWcubGFzdENoaWxkKTtcbiAgICAgIHJuZy5pbnNlcnROb2RlKGZyYWcpO1xuICAgICAgZmlyc3RDaGlsZC5lYWNoKGNoaWxkID0+IHRyaW1FbXB0eVRleHROb2RlJDEoZG9tLCBjaGlsZC5wcmV2aW91c1NpYmxpbmcpKTtcbiAgICAgIGxhc3RDaGlsZC5lYWNoKGNoaWxkID0+IHRyaW1FbXB0eVRleHROb2RlJDEoZG9tLCBjaGlsZC5uZXh0U2libGluZykpO1xuICAgIH07XG4gICAgY29uc3QgcmFuZ2VJbnNlcnROb2RlID0gKGRvbSwgcm5nLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpKSB7XG4gICAgICAgIGluc2VydEZyYWdtZW50KGRvbSwgcm5nLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydE5vZGUoZG9tLCBybmcsIG5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc1RleHQkNiA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IGlzQm9ndXMgPSBpc0JvZ3VzJDI7XG4gICAgY29uc3Qgbm9kZUluZGV4ID0gRE9NVXRpbHMubm9kZUluZGV4O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXJlbnQgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAoaXNCb2d1cyhwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZFBhcmVudChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2hpbGROb2RlcyA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWR1Y2Uobm9kZS5jaGlsZE5vZGVzLCAocmVzdWx0LCBub2RlKSA9PiB7XG4gICAgICAgIGlmIChpc0JvZ3VzKG5vZGUpICYmIG5vZGUubm9kZU5hbWUgIT09ICdCUicpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGdldENoaWxkTm9kZXMobm9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVkVGV4dE9mZnNldCA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGxldCB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAodGVtcE5vZGUgPSB0ZW1wTm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgaWYgKCFpc1RleHQkNih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gdGVtcE5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG4gICAgY29uc3QgZXF1YWwgPSBhID0+IGIgPT4gYSA9PT0gYjtcbiAgICBjb25zdCBub3JtYWxpemVkTm9kZUluZGV4ID0gbm9kZSA9PiB7XG4gICAgICBsZXQgbm9kZXMsIGluZGV4O1xuICAgICAgbm9kZXMgPSBnZXRDaGlsZE5vZGVzKG5vcm1hbGl6ZWRQYXJlbnQobm9kZSkpO1xuICAgICAgaW5kZXggPSBmaW5kSW5kZXgkMShub2RlcywgZXF1YWwobm9kZSksIG5vZGUpO1xuICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgICAgY29uc3QgbnVtVGV4dEZyYWdtZW50cyA9IHJlZHVjZShub2RlcywgKHJlc3VsdCwgbm9kZSwgaSkgPT4ge1xuICAgICAgICBpZiAoaXNUZXh0JDYobm9kZSkgJiYgaXNUZXh0JDYobm9kZXNbaSAtIDFdKSkge1xuICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCAwKTtcbiAgICAgIG5vZGVzID0gZmlsdGVyJDMobm9kZXMsIG1hdGNoTm9kZU5hbWVzKFtub2RlLm5vZGVOYW1lXSkpO1xuICAgICAgaW5kZXggPSBmaW5kSW5kZXgkMShub2RlcywgZXF1YWwobm9kZSksIG5vZGUpO1xuICAgICAgcmV0dXJuIGluZGV4IC0gbnVtVGV4dEZyYWdtZW50cztcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBhdGhJdGVtID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNUZXh0JDYobm9kZSkgPyAndGV4dCgpJyA6IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBuYW1lICsgJ1snICsgbm9ybWFsaXplZE5vZGVJbmRleChub2RlKSArICddJztcbiAgICB9O1xuICAgIGNvbnN0IHBhcmVudHNVbnRpbCQxID0gKHJvb3QsIG5vZGUsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgdGVtcE5vZGUgPSBub2RlLnBhcmVudE5vZGU7IHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSByb290OyB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSAmJiBwcmVkaWNhdGUodGVtcE5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50cy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlJGIgPSAocm9vdCwgY2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgbGV0IHBhdGggPSBbXTtcbiAgICAgIGxldCBjb250YWluZXIgPSBjYXJldFBvc2l0aW9uLmNvbnRhaW5lcigpO1xuICAgICAgbGV0IG9mZnNldCA9IGNhcmV0UG9zaXRpb24ub2Zmc2V0KCk7XG4gICAgICBsZXQgb3V0cHV0T2Zmc2V0O1xuICAgICAgaWYgKGlzVGV4dCQ2KGNvbnRhaW5lcikpIHtcbiAgICAgICAgb3V0cHV0T2Zmc2V0ID0gbm9ybWFsaXplZFRleHRPZmZzZXQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGNvbnRhaW5lci5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAob2Zmc2V0ID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgb3V0cHV0T2Zmc2V0ID0gJ2FmdGVyJztcbiAgICAgICAgICBvZmZzZXQgPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0T2Zmc2V0ID0gJ2JlZm9yZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyID0gY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKGNyZWF0ZVBhdGhJdGVtKGNvbnRhaW5lcikpO1xuICAgICAgbGV0IHBhcmVudHMgPSBwYXJlbnRzVW50aWwkMShyb290LCBjb250YWluZXIpO1xuICAgICAgcGFyZW50cyA9IGZpbHRlciQzKHBhcmVudHMsIG5vdChpc0JvZ3VzJDIpKTtcbiAgICAgIHBhdGggPSBwYXRoLmNvbmNhdChtYXAkMShwYXJlbnRzLCBub2RlID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGhJdGVtKG5vZGUpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpLmpvaW4oJy8nKSArICcsJyArIG91dHB1dE9mZnNldDtcbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVQYXRoSXRlbSA9IChub2RlLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IG5vZGVzID0gZ2V0Q2hpbGROb2Rlcyhub2RlKTtcbiAgICAgIG5vZGVzID0gZmlsdGVyJDMobm9kZXMsIChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gIWlzVGV4dCQ2KG5vZGUpIHx8ICFpc1RleHQkNihub2Rlc1tpbmRleCAtIDFdKTtcbiAgICAgIH0pO1xuICAgICAgbm9kZXMgPSBmaWx0ZXIkMyhub2RlcywgbWF0Y2hOb2RlTmFtZXMoW25hbWVdKSk7XG4gICAgICByZXR1cm4gbm9kZXNbaW5kZXhdO1xuICAgIH07XG4gICAgY29uc3QgZmluZFRleHRQb3NpdGlvbiA9IChjb250YWluZXIsIG9mZnNldCkgPT4ge1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXI7XG4gICAgICBsZXQgdGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChpc1RleHQkNihub2RlKSkge1xuICAgICAgICBjb25zdCBkYXRhTGVuID0gbm9kZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+PSB0YXJnZXRPZmZzZXQgJiYgb2Zmc2V0IDw9IHRhcmdldE9mZnNldCArIGRhdGFMZW4pIHtcbiAgICAgICAgICBjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgIG9mZnNldCA9IG9mZnNldCAtIHRhcmdldE9mZnNldDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVGV4dCQ2KG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkYXRhTGVuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE9mZnNldCArPSBkYXRhTGVuO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkNihjb250YWluZXIpICYmIG9mZnNldCA+IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQgPSBjb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCk7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlJDEgPSAocm9vdCwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCBwYXRocyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0gOiAnYmVmb3JlJztcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJlZHVjZShwYXRocywgKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvKFtcXHdcXC1cXChcXCldKylcXFsoWzAtOV0rKVxcXS8uZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICd0ZXh0KCknKSB7XG4gICAgICAgICAgbWF0Y2hbMV0gPSAnI3RleHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlUGF0aEl0ZW0ocmVzdWx0LCBtYXRjaFsxXSwgcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICB9LCByb290KTtcbiAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1RleHQkNihjb250YWluZXIpICYmIGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGxldCBub2RlT2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgbm9kZU9mZnNldCA9IG5vZGVJbmRleChjb250YWluZXIpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlT2Zmc2V0ID0gbm9kZUluZGV4KGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24oY29udGFpbmVyLnBhcmVudE5vZGUsIG5vZGVPZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRUZXh0UG9zaXRpb24oY29udGFpbmVyLCBwYXJzZUludChvZmZzZXQsIDEwKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYjtcbiAgICBjb25zdCBnZXROb3JtYWxpemVkVGV4dE9mZnNldCQxID0gKHRyaW0sIGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBsZXQgdHJpbW1lZE9mZnNldCA9IHRyaW0oY29udGFpbmVyLmRhdGEuc2xpY2UoMCwgb2Zmc2V0KSkubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgbm9kZSA9IGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7IG5vZGUgJiYgaXNUZXh0JGEobm9kZSk7IG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgICB0cmltbWVkT2Zmc2V0ICs9IHRyaW0obm9kZS5kYXRhKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJpbW1lZE9mZnNldDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBvaW50ID0gKGRvbSwgdHJpbSwgbm9ybWFsaXplZCwgcm5nLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0ID8gcm5nLnN0YXJ0T2Zmc2V0IDogcm5nLmVuZE9mZnNldDtcbiAgICAgIGNvbnN0IHBvaW50ID0gW107XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIHBvaW50LnB1c2gobm9ybWFsaXplZCA/IGdldE5vcm1hbGl6ZWRUZXh0T2Zmc2V0JDEodHJpbSwgY29udGFpbmVyLCBvZmZzZXQpIDogb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhZnRlciA9IDA7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKG9mZnNldCA+PSBjaGlsZE5vZGVzLmxlbmd0aCAmJiBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGFmdGVyID0gMTtcbiAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBjaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50LnB1c2goZG9tLm5vZGVJbmRleChjaGlsZE5vZGVzW29mZnNldF0sIG5vcm1hbGl6ZWQpICsgYWZ0ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgbm9kZSA9IGNvbnRhaW5lcjsgbm9kZSAmJiBub2RlICE9PSByb290OyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBvaW50LnB1c2goZG9tLm5vZGVJbmRleChub2RlLCBub3JtYWxpemVkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRMb2NhdGlvbiA9ICh0cmltLCBzZWxlY3Rpb24sIG5vcm1hbGl6ZWQsIHJuZykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gc2VsZWN0aW9uLmRvbTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0UG9pbnQoZG9tLCB0cmltLCBub3JtYWxpemVkLCBybmcsIHRydWUpO1xuICAgICAgY29uc3QgZm9yd2FyZCA9IHNlbGVjdGlvbi5pc0ZvcndhcmQoKTtcbiAgICAgIGNvbnN0IGZha2VDYXJldCA9IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyQmxvY2socm5nKSA/IHsgaXNGYWtlQ2FyZXQ6IHRydWUgfSA6IHt9O1xuICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBlbmQgPSBnZXRQb2ludChkb20sIHRyaW0sIG5vcm1hbGl6ZWQsIHJuZywgZmFsc2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBmb3J3YXJkLFxuICAgICAgICAgIC4uLmZha2VDYXJldFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBmb3J3YXJkLFxuICAgICAgICAgIC4uLmZha2VDYXJldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZEluZGV4ID0gKGRvbSwgbmFtZSwgZWxlbWVudCkgPT4ge1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIFRvb2xzLmVhY2goZG9tLnNlbGVjdChuYW1lKSwgbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtYm9ndXMnKSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlRW5kUG9pbnQkMSA9IChybmcsIHN0YXJ0KSA9PiB7XG4gICAgICBsZXQgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0ID8gcm5nLnN0YXJ0T2Zmc2V0IDogcm5nLmVuZE9mZnNldDtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpICYmIGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1RSJykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgIGNvbnRhaW5lciA9IGNoaWxkTm9kZXNbTWF0aC5taW4oc3RhcnQgPyBvZmZzZXQgOiBvZmZzZXQgLSAxLCBjaGlsZE5vZGVzLmxlbmd0aCAtIDEpXTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ID8gMCA6IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplVGFibGVDZWxsU2VsZWN0aW9uID0gcm5nID0+IHtcbiAgICAgIG1vdmVFbmRQb2ludCQxKHJuZywgdHJ1ZSk7XG4gICAgICBtb3ZlRW5kUG9pbnQkMShybmcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kU2libGluZyA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICBub2RlID0gZ2V0Tm9kZSQxKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDkobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXIkMihub2RlKSkge1xuICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgaXNDYXJldENvbnRhaW5lckJsb2NrJDEobm9kZSkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDkoc2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlRmFsc2UkOShzaWJsaW5nKSkge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgZmluZEFkamFjZW50Q29udGVudEVkaXRhYmxlRmFsc2VFbG0gPSBybmcgPT4ge1xuICAgICAgcmV0dXJuIGZpbmRTaWJsaW5nKHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KSB8fCBmaW5kU2libGluZyhybmcuZW5kQ29udGFpbmVyLCBybmcuZW5kT2Zmc2V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldE9mZnNldEJvb2ttYXJrID0gKHRyaW0sIG5vcm1hbGl6ZWQsIHNlbGVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lNRycgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ5KGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChzZWxlY3Rpb24uZG9tLCBuYW1lLCBlbGVtZW50KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2libGluZyA9IGZpbmRBZGphY2VudENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKHJuZyk7XG4gICAgICBpZiAoc2libGluZykge1xuICAgICAgICBjb25zdCBuYW1lID0gc2libGluZy50YWdOYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChzZWxlY3Rpb24uZG9tLCBuYW1lLCBzaWJsaW5nKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHRyaW0sIHNlbGVjdGlvbiwgbm9ybWFsaXplZCwgcm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENhcmV0Qm9va21hcmsgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNyZWF0ZSRiKHNlbGVjdGlvbi5kb20uZ2V0Um9vdCgpLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpLFxuICAgICAgICBlbmQ6IGNyZWF0ZSRiKHNlbGVjdGlvbi5kb20uZ2V0Um9vdCgpLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpKSxcbiAgICAgICAgZm9yd2FyZDogc2VsZWN0aW9uLmlzRm9yd2FyZCgpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmFuZ2VCb29rbWFyayA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBybmc6IHNlbGVjdGlvbi5nZXRSbmcoKSxcbiAgICAgICAgZm9yd2FyZDogc2VsZWN0aW9uLmlzRm9yd2FyZCgpXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQm9va21hcmtTcGFuID0gKGRvbSwgaWQsIGZpbGxlZCkgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnLFxuICAgICAgICBpZCxcbiAgICAgICAgJ3N0eWxlJzogJ292ZXJmbG93OmhpZGRlbjtsaW5lLWhlaWdodDowcHgnXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZpbGxlZCA/IGRvbS5jcmVhdGUoJ3NwYW4nLCBhcmdzLCAnJiN4RkVGRjsnKSA6IGRvbS5jcmVhdGUoJ3NwYW4nLCBhcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBlcnNpc3RlbnRCb29rbWFyayA9IChzZWxlY3Rpb24sIGZpbGxlZCkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gc2VsZWN0aW9uLmRvbTtcbiAgICAgIGxldCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBpZCA9IGRvbS51bmlxdWVJZCgpO1xuICAgICAgY29uc3QgY29sbGFwc2VkID0gc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICAgICAgY29uc3QgZm9yd2FyZCA9IHNlbGVjdGlvbi5pc0ZvcndhcmQoKTtcbiAgICAgIGlmIChuYW1lID09PSAnSU1HJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXg6IGZpbmRJbmRleChkb20sIG5hbWUsIGVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBybmcyID0gbm9ybWFsaXplVGFibGVDZWxsU2VsZWN0aW9uKHJuZy5jbG9uZVJhbmdlKCkpO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgcm5nMi5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IGVuZEJvb2ttYXJrTm9kZSA9IGNyZWF0ZUJvb2ttYXJrU3Bhbihkb20sIGlkICsgJ19lbmQnLCBmaWxsZWQpO1xuICAgICAgICByYW5nZUluc2VydE5vZGUoZG9tLCBybmcyLCBlbmRCb29rbWFya05vZGUpO1xuICAgICAgfVxuICAgICAgcm5nID0gbm9ybWFsaXplVGFibGVDZWxsU2VsZWN0aW9uKHJuZyk7XG4gICAgICBybmcuY29sbGFwc2UodHJ1ZSk7XG4gICAgICBjb25zdCBzdGFydEJvb2ttYXJrTm9kZSA9IGNyZWF0ZUJvb2ttYXJrU3Bhbihkb20sIGlkICsgJ19zdGFydCcsIGZpbGxlZCk7XG4gICAgICByYW5nZUluc2VydE5vZGUoZG9tLCBybmcsIHN0YXJ0Qm9va21hcmtOb2RlKTtcbiAgICAgIHNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayh7XG4gICAgICAgIGlkLFxuICAgICAgICBrZWVwOiB0cnVlLFxuICAgICAgICBmb3J3YXJkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICBmb3J3YXJkXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Qm9va21hcmskMiA9IChzZWxlY3Rpb24sIHR5cGUsIG5vcm1hbGl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGdldE9mZnNldEJvb2ttYXJrKHRyaW0kMSwgbm9ybWFsaXplZCwgc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRCb29rbWFyayhzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZUJvb2ttYXJrKHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0UGVyc2lzdGVudEJvb2ttYXJrKHNlbGVjdGlvbiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0VW5kb0Jvb2ttYXJrID0gY3VycnkoZ2V0T2Zmc2V0Qm9va21hcmssIGlkZW50aXR5LCB0cnVlKTtcblxuICAgIGNvbnN0IHZhbHVlJDEgPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBhcHBseUhlbHBlciA9IGZuID0+IGZuKHZhbHVlKTtcbiAgICAgIGNvbnN0IGNvbnN0SGVscGVyID0gY29uc3RhbnQodmFsdWUpO1xuICAgICAgY29uc3Qgb3V0cHV0SGVscGVyID0gKCkgPT4gb3V0cHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICB0YWc6IHRydWUsXG4gICAgICAgIGlubmVyOiB2YWx1ZSxcbiAgICAgICAgZm9sZDogKF9vbkVycm9yLCBvblZhbHVlKSA9PiBvblZhbHVlKHZhbHVlKSxcbiAgICAgICAgaXNWYWx1ZTogYWx3YXlzLFxuICAgICAgICBpc0Vycm9yOiBuZXZlcixcbiAgICAgICAgbWFwOiBtYXBwZXIgPT4gUmVzdWx0LnZhbHVlKG1hcHBlcih2YWx1ZSkpLFxuICAgICAgICBtYXBFcnJvcjogb3V0cHV0SGVscGVyLFxuICAgICAgICBiaW5kOiBhcHBseUhlbHBlcixcbiAgICAgICAgZXhpc3RzOiBhcHBseUhlbHBlcixcbiAgICAgICAgZm9yYWxsOiBhcHBseUhlbHBlcixcbiAgICAgICAgZ2V0T3I6IGNvbnN0SGVscGVyLFxuICAgICAgICBvcjogb3V0cHV0SGVscGVyLFxuICAgICAgICBnZXRPclRodW5rOiBjb25zdEhlbHBlcixcbiAgICAgICAgb3JUaHVuazogb3V0cHV0SGVscGVyLFxuICAgICAgICBnZXRPckRpZTogY29uc3RIZWxwZXIsXG4gICAgICAgIGVhY2g6IGZuID0+IHtcbiAgICAgICAgICBmbih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT3B0aW9uYWw6ICgpID0+IE9wdGlvbmFsLnNvbWUodmFsdWUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIGNvbnN0IGVycm9yID0gZXJyb3IgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0SGVscGVyID0gKCkgPT4gb3V0cHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICB0YWc6IGZhbHNlLFxuICAgICAgICBpbm5lcjogZXJyb3IsXG4gICAgICAgIGZvbGQ6IChvbkVycm9yLCBfb25WYWx1ZSkgPT4gb25FcnJvcihlcnJvciksXG4gICAgICAgIGlzVmFsdWU6IG5ldmVyLFxuICAgICAgICBpc0Vycm9yOiBhbHdheXMsXG4gICAgICAgIG1hcDogb3V0cHV0SGVscGVyLFxuICAgICAgICBtYXBFcnJvcjogbWFwcGVyID0+IFJlc3VsdC5lcnJvcihtYXBwZXIoZXJyb3IpKSxcbiAgICAgICAgYmluZDogb3V0cHV0SGVscGVyLFxuICAgICAgICBleGlzdHM6IG5ldmVyLFxuICAgICAgICBmb3JhbGw6IGFsd2F5cyxcbiAgICAgICAgZ2V0T3I6IGlkZW50aXR5LFxuICAgICAgICBvcjogaWRlbnRpdHksXG4gICAgICAgIGdldE9yVGh1bms6IGFwcGx5JDEsXG4gICAgICAgIG9yVGh1bms6IGFwcGx5JDEsXG4gICAgICAgIGdldE9yRGllOiBkaWUoU3RyaW5nKGVycm9yKSksXG4gICAgICAgIGVhY2g6IG5vb3AsXG4gICAgICAgIHRvT3B0aW9uYWw6IE9wdGlvbmFsLm5vbmVcbiAgICAgIH07XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgY29uc3QgZnJvbU9wdGlvbiA9IChvcHRpb25hbCwgZXJyKSA9PiBvcHRpb25hbC5mb2xkKCgpID0+IGVycm9yKGVyciksIHZhbHVlJDEpO1xuICAgIGNvbnN0IFJlc3VsdCA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSQxLFxuICAgICAgZXJyb3IsXG4gICAgICBmcm9tT3B0aW9uXG4gICAgfTtcblxuICAgIGNvbnN0IGdlbmVyYXRlID0gY2FzZXMgPT4ge1xuICAgICAgaWYgKCFpc0FycmF5JDEoY2FzZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FzZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGNhc2UnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9ycyA9IFtdO1xuICAgICAgY29uc3QgYWR0ID0ge307XG4gICAgICBlYWNoJGUoY2FzZXMsIChhY2FzZSwgY291bnQpID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyQxID0ga2V5cyhhY2FzZSk7XG4gICAgICAgIGlmIChrZXlzJDEubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmUgYW5kIG9ubHkgb25lIG5hbWUgcGVyIGNhc2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBrZXlzJDFbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWNhc2Vba2V5XTtcbiAgICAgICAgaWYgKGFkdFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZSBrZXkgZGV0ZWN0ZWQ6JyArIGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2F0YScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBoYXZlIGEgY2FzZSBuYW1lZCBjYXRhIChzb3JyeSknKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2FzZSBhcmd1bWVudHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKGtleSk7XG4gICAgICAgIGFkdFtrZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCBhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYXJnTGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBjYXNlICcgKyBrZXkgKyAnLiBFeHBlY3RlZCAnICsgdmFsdWUubGVuZ3RoICsgJyAoJyArIHZhbHVlICsgJyksIGdvdCAnICsgYXJnTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBicmFuY2hlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBicmFuY2hLZXlzID0ga2V5cyhicmFuY2hlcyk7XG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3JzLmxlbmd0aCAhPT0gYnJhbmNoS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHRvIG1hdGNoLiBFeHBlY3RlZDogJyArIGNvbnN0cnVjdG9ycy5qb2luKCcsJykgKyAnXFxuQWN0dWFsOiAnICsgYnJhbmNoS2V5cy5qb2luKCcsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxsUmVxZCA9IGZvcmFsbChjb25zdHJ1Y3RvcnMsIHJlcUtleSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250YWlucyQyKGJyYW5jaEtleXMsIHJlcUtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYWxsUmVxZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbGwgYnJhbmNoZXMgd2VyZSBzcGVjaWZpZWQgd2hlbiB1c2luZyBtYXRjaC4gU3BlY2lmaWVkOiAnICsgYnJhbmNoS2V5cy5qb2luKCcsICcpICsgJ1xcblJlcXVpcmVkOiAnICsgY29uc3RydWN0b3JzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaGVzW2tleV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9sZDogKC4uLmZvbGRBcmdzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChmb2xkQXJncy5sZW5ndGggIT09IGNhc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmb2xkLiBFeHBlY3RlZCAnICsgY2FzZXMubGVuZ3RoICsgJywgZ290ICcgKyBmb2xkQXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGZvbGRBcmdzW2NvdW50XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGxvZzogbGFiZWwgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsYWJlbCwge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9ycyxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoga2V5LFxuICAgICAgICAgICAgICAgIHBhcmFtczogYXJnc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWR0O1xuICAgIH07XG4gICAgY29uc3QgQWR0ID0geyBnZW5lcmF0ZSB9O1xuXG4gICAgQWR0LmdlbmVyYXRlKFtcbiAgICAgIHtcbiAgICAgICAgYm90aEVycm9yczogW1xuICAgICAgICAgICdlcnJvcjEnLFxuICAgICAgICAgICdlcnJvcjInXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGZpcnN0RXJyb3I6IFtcbiAgICAgICAgICAnZXJyb3IxJyxcbiAgICAgICAgICAndmFsdWUyJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZWNvbmRFcnJvcjogW1xuICAgICAgICAgICd2YWx1ZTEnLFxuICAgICAgICAgICdlcnJvcjInXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvdGhWYWx1ZXM6IFtcbiAgICAgICAgICAndmFsdWUxJyxcbiAgICAgICAgICAndmFsdWUyJ1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSk7XG4gICAgY29uc3QgcGFydGl0aW9uJDEgPSByZXN1bHRzID0+IHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICBlYWNoJGUocmVzdWx0cywgcmVzdWx0ID0+IHtcbiAgICAgICAgcmVzdWx0LmZvbGQoZXJyID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICB9LCB2YWx1ZSA9PiB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICB2YWx1ZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGlzSW5saW5lUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVybi50eXBlID09PSAnaW5saW5lLWNvbW1hbmQnIHx8IHBhdHRlcm4udHlwZSA9PT0gJ2lubGluZS1mb3JtYXQnO1xuICAgIGNvbnN0IGlzQmxvY2tQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuLnR5cGUgPT09ICdibG9jay1jb21tYW5kJyB8fCBwYXR0ZXJuLnR5cGUgPT09ICdibG9jay1mb3JtYXQnO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVBhdHRlcm4gPSBwYXR0ZXJuID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IG1lc3NhZ2UgPT4gUmVzdWx0LmVycm9yKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfSk7XG4gICAgICBjb25zdCBmb3JtYXRPckNtZCA9IChuYW1lLCBvbkZvcm1hdCwgb25Db21tYW5kKSA9PiB7XG4gICAgICAgIGlmIChwYXR0ZXJuLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IGZvcm1hdHM7XG4gICAgICAgICAgaWYgKGlzQXJyYXkkMShwYXR0ZXJuLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIGlmICghZm9yYWxsKHBhdHRlcm4uZm9ybWF0LCBpc1N0cmluZykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycihuYW1lICsgJyBwYXR0ZXJuIGhhcyBub24tc3RyaW5nIGl0ZW1zIGluIHRoZSBgZm9ybWF0YCBhcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0cyA9IHBhdHRlcm4uZm9ybWF0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybi5mb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXRzID0gW3BhdHRlcm4uZm9ybWF0XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVycihuYW1lICsgJyBwYXR0ZXJuIGhhcyBub24tc3RyaW5nIGBmb3JtYXRgIHBhcmFtZXRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKG9uRm9ybWF0KGZvcm1hdHMpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuLmNtZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuLmNtZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIobmFtZSArICcgcGF0dGVybiBoYXMgbm9uLXN0cmluZyBgY21kYCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShvbkNvbW1hbmQocGF0dGVybi5jbWQsIHBhdHRlcm4udmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXJyKG5hbWUgKyAnIHBhdHRlcm4gaXMgbWlzc2luZyBib3RoIGBmb3JtYXRgIGFuZCBgY21kYCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoIWlzT2JqZWN0KHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBlcnIoJ1JhdyBwYXR0ZXJuIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybi5zdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIGVycignUmF3IHBhdHRlcm4gaXMgbWlzc2luZyBgc3RhcnRgIHBhcmFtZXRlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm4uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuLmVuZCkpIHtcbiAgICAgICAgICByZXR1cm4gZXJyKCdJbmxpbmUgcGF0dGVybiBoYXMgbm9uLXN0cmluZyBgZW5kYCBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5zdGFydC5sZW5ndGggPT09IDAgJiYgcGF0dGVybi5lbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVycignSW5saW5lIHBhdHRlcm4gaGFzIGVtcHR5IGBzdGFydGAgYW5kIGBlbmRgIHBhcmFtZXRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBwYXR0ZXJuLnN0YXJ0O1xuICAgICAgICBsZXQgZW5kID0gcGF0dGVybi5lbmQ7XG4gICAgICAgIGlmIChlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0T3JDbWQoJ0lubGluZScsIGZvcm1hdCA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdpbmxpbmUtZm9ybWF0JyxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZm9ybWF0XG4gICAgICAgIH0pLCAoY21kLCB2YWx1ZSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnaW5saW5lLWNvbW1hbmQnLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBjbWQsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChwYXR0ZXJuLnJlcGxhY2VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuLnJlcGxhY2VtZW50KSkge1xuICAgICAgICAgIHJldHVybiBlcnIoJ1JlcGxhY2VtZW50IHBhdHRlcm4gaGFzIG5vbi1zdHJpbmcgYHJlcGxhY2VtZW50YCBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5zdGFydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZXJyKCdSZXBsYWNlbWVudCBwYXR0ZXJuIGhhcyBlbXB0eSBgc3RhcnRgIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUoe1xuICAgICAgICAgIHR5cGU6ICdpbmxpbmUtY29tbWFuZCcsXG4gICAgICAgICAgc3RhcnQ6ICcnLFxuICAgICAgICAgIGVuZDogcGF0dGVybi5zdGFydCxcbiAgICAgICAgICBjbWQ6ICdtY2VJbnNlcnRDb250ZW50JyxcbiAgICAgICAgICB2YWx1ZTogcGF0dGVybi5yZXBsYWNlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnN0YXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlcnIoJ0Jsb2NrIHBhdHRlcm4gaGFzIGVtcHR5IGBzdGFydGAgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE9yQ21kKCdCbG9jaycsIGZvcm1hdHMgPT4gKHtcbiAgICAgICAgICB0eXBlOiAnYmxvY2stZm9ybWF0JyxcbiAgICAgICAgICBzdGFydDogcGF0dGVybi5zdGFydCxcbiAgICAgICAgICBmb3JtYXQ6IGZvcm1hdHNbMF1cbiAgICAgICAgfSksIChjb21tYW5kLCBjb21tYW5kVmFsdWUpID0+ICh7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrLWNvbW1hbmQnLFxuICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuLnN0YXJ0LFxuICAgICAgICAgIGNtZDogY29tbWFuZCxcbiAgICAgICAgICB2YWx1ZTogY29tbWFuZFZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEJsb2NrUGF0dGVybnMgPSBwYXR0ZXJucyA9PiBmaWx0ZXIkNShwYXR0ZXJucywgaXNCbG9ja1BhdHRlcm4pO1xuICAgIGNvbnN0IGdldElubGluZVBhdHRlcm5zID0gcGF0dGVybnMgPT4gZmlsdGVyJDUocGF0dGVybnMsIGlzSW5saW5lUGF0dGVybik7XG4gICAgY29uc3QgY3JlYXRlUGF0dGVyblNldCA9IChwYXR0ZXJucywgZHluYW1pY1BhdHRlcm5zTG9va3VwKSA9PiAoe1xuICAgICAgaW5saW5lUGF0dGVybnM6IGdldElubGluZVBhdHRlcm5zKHBhdHRlcm5zKSxcbiAgICAgIGJsb2NrUGF0dGVybnM6IGdldEJsb2NrUGF0dGVybnMocGF0dGVybnMpLFxuICAgICAgZHluYW1pY1BhdHRlcm5zTG9va3VwXG4gICAgfSk7XG4gICAgY29uc3QgZnJvbVJhd1BhdHRlcm5zID0gcGF0dGVybnMgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnRpdGlvbiQxKG1hcCQzKHBhdHRlcm5zLCBub3JtYWxpemVQYXR0ZXJuKSk7XG4gICAgICBlYWNoJGUobm9ybWFsaXplZC5lcnJvcnMsIGVyciA9PiBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlLCBlcnIucGF0dGVybikpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQudmFsdWVzO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVJhd1BhdHRlcm5zTG9va3VwID0gbG9va3VwRm4gPT4ge1xuICAgICAgcmV0dXJuIGN0eCA9PiB7XG4gICAgICAgIGNvbnN0IHJhd1BhdHRlcm5zID0gbG9va3VwRm4oY3R4KTtcbiAgICAgICAgcmV0dXJuIGZyb21SYXdQYXR0ZXJucyhyYXdQYXR0ZXJucyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBkZXZpY2VEZXRlY3Rpb24kMSA9IGRldGVjdCQyKCkuZGV2aWNlVHlwZTtcbiAgICBjb25zdCBpc1RvdWNoID0gZGV2aWNlRGV0ZWN0aW9uJDEuaXNUb3VjaCgpO1xuICAgIGNvbnN0IERPTSRhID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGdldEhhc2ggPSB2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLmluZGV4T2YoJz0nKSA+IDAgPyB2YWx1ZS5zcGxpdCgvWzssXSg/IVtePTssXSooPzpbOyxdfCQpKS8pIDogdmFsdWUuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBmb2xkbChpdGVtcywgKG91dHB1dCwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBpdGVtLnNwbGl0KCc9Jyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyclswXTtcbiAgICAgICAgY29uc3QgdmFsID0gYXJyLmxlbmd0aCA+IDEgPyBhcnJbMV0gOiBrZXk7XG4gICAgICAgIG91dHB1dFt0cmltJDMoa2V5KV0gPSB0cmltJDModmFsKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUmVnRXhwID0geCA9PiBpcyQ0KHgsIFJlZ0V4cCk7XG4gICAgY29uc3Qgb3B0aW9uID0gbmFtZSA9PiBlZGl0b3IgPT4gZWRpdG9yLm9wdGlvbnMuZ2V0KG5hbWUpO1xuICAgIGNvbnN0IHN0cmluZ09yT2JqZWN0UHJvY2Vzc29yID0gdmFsdWUgPT4gaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCBib2R5T3B0aW9uUHJvY2Vzc29yID0gKGVkaXRvciwgZGVmYXVsdFZhbHVlID0gJycpID0+IHZhbHVlID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gaXNTdHJpbmcodmFsdWUpO1xuICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCc9JykgIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgYm9keU9iaiA9IGdldEhhc2godmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0JGEoYm9keU9iaiwgZWRpdG9yLmlkKS5nZXRPcihkZWZhdWx0VmFsdWUpLFxuICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBzdHJpbmcuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByZWdpc3Rlck9wdGlvbiA9IGVkaXRvci5vcHRpb25zLnJlZ2lzdGVyO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lkJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuaWRcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NlbGVjdG9yJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3RhcmdldCcsIHsgcHJvY2Vzc29yOiAnb2JqZWN0JyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzdWZmaXgnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY2FjaGVfc3VmZml4JywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Jhc2VfdXJsJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3JlZmVycmVyX3BvbGljeScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2xhbmd1YWdlX2xvYWQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmxpbmUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWZyYW1lX2F0dHJzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdvYmplY3QnLFxuICAgICAgICBkZWZhdWx0OiB7fVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZG9jdHlwZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJzwhRE9DVFlQRSBodG1sPidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2RvY3VtZW50X2Jhc2VfdXJsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuZG9jdW1lbnRCYXNlVXJsXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdib2R5X2lkJywge1xuICAgICAgICBwcm9jZXNzb3I6IGJvZHlPcHRpb25Qcm9jZXNzb3IoZWRpdG9yLCAndGlueW1jZScpLFxuICAgICAgICBkZWZhdWx0OiAndGlueW1jZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2JvZHlfY2xhc3MnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogYm9keU9wdGlvblByb2Nlc3NvcihlZGl0b3IpLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udGVudF9zZWN1cml0eV9wb2xpY3knLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdicl9pbl9wcmUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9jaycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBpc1N0cmluZyh2YWx1ZSkgJiYgaXNOb3RFbXB0eSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiAncCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvcmNlZF9yb290X2Jsb2NrX2F0dHJzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdvYmplY3QnLFxuICAgICAgICBkZWZhdWx0OiB7fVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbmV3bGluZV9iZWhhdmlvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBjb250YWlucyQyKFtcbiAgICAgICAgICAgICdibG9jaycsXG4gICAgICAgICAgICAnbGluZWJyZWFrJyxcbiAgICAgICAgICAgICdpbnZlcnQnLFxuICAgICAgICAgICAgJ2RlZmF1bHQnXG4gICAgICAgICAgXSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB2YWxpZCA/IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgb25lIG9mOiBibG9jaywgbGluZWJyZWFrLCBpbnZlcnQgb3IgZGVmYXVsdC4nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdicl9uZXdsaW5lX3NlbGVjdG9yJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnLm1jZS10b2MgaDIsZmlnY2FwdGlvbixjYXB0aW9uJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbm9fbmV3bGluZV9zZWxlY3RvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2tlZXBfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZW5kX2NvbnRhaW5lcl9vbl9lbXB0eV9ibG9jaycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGJvb2xlYW4gb3IgYSBzdHJpbmcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2Jsb2NrcXVvdGUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdmb250X3NpemVfc3R5bGVfdmFsdWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAneHgtc21hbGwseC1zbWFsbCxzbWFsbCxtZWRpdW0sbGFyZ2UseC1sYXJnZSx4eC1sYXJnZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAneHgtc21hbGwsc21hbGwsbWVkaXVtLGxhcmdlLHgtbGFyZ2UseHgtbGFyZ2UsMzAwJSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfc2l6ZV9jbGFzc2VzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYXV0b21hdGljX3VwbG9hZHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfcmV1c2VfZmlsZW5hbWUnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3JlcGxhY2VfYmxvYl91cmlzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaWNvbnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpY29uc191cmwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfdXBsb2FkX3VybCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc191cGxvYWRfYmFzZV9wYXRoJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW1hZ2VzX3VwbG9hZF9jcmVkZW50aWFscycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbWFnZXNfdXBsb2FkX2hhbmRsZXInLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdsYW5ndWFnZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ2VuJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignbGFuZ3VhZ2VfdXJsJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZW50aXR5X2VuY29kaW5nJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnbmFtZWQnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnRfYmVmb3JlJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAncCxoMSxoMixoMyxoNCxoNSxoNixibG9ja3F1b3RlLGRpdix0aXRsZSxzdHlsZSxwcmUsc2NyaXB0LHRkLHRoLHVsLG9sLGxpLGRsLGR0LGRkLGFyZWEsdGFibGUsdGhlYWQsJyArICd0Zm9vdCx0Ym9keSx0cixzZWN0aW9uLGRldGFpbHMsc3VtbWFyeSxhcnRpY2xlLGhncm91cCxhc2lkZSxmaWd1cmUsZmlnY2FwdGlvbixvcHRpb24sb3B0Z3JvdXAsZGF0YWxpc3QnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmRlbnRfYWZ0ZXInLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdwLGgxLGgyLGgzLGg0LGg1LGg2LGJsb2NrcXVvdGUsZGl2LHRpdGxlLHN0eWxlLHByZSxzY3JpcHQsdGQsdGgsdWwsb2wsbGksZGwsZHQsZGQsYXJlYSx0YWJsZSx0aGVhZCwnICsgJ3Rmb290LHRib2R5LHRyLHNlY3Rpb24sZGV0YWlscyxzdW1tYXJ5LGFydGljbGUsaGdyb3VwLGFzaWRlLGZpZ3VyZSxmaWdjYXB0aW9uLG9wdGlvbixvcHRncm91cCxkYXRhbGlzdCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudF91c2VfbWFyZ2luJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2luZGVudGF0aW9uJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnNDBweCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2NvbnRlbnRfY3NzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcnJheU9mKHZhbHVlLCBpc1N0cmluZyk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcCQzKHZhbHVlLnNwbGl0KCcsJyksIHRyaW0kMyksXG4gICAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGZhbHNlLCBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBpc0lubGluZShlZGl0b3IpID8gW10gOiBbJ2RlZmF1bHQnXVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udGVudF9zdHlsZScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb250ZW50X2Nzc19jb3JzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZvbnRfY3NzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FycmF5T2YodmFsdWUsIGlzU3RyaW5nKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gaXNBcnJheSQxKHZhbHVlKSA/IHZhbHVlIDogbWFwJDModmFsdWUuc3BsaXQoJywnKSwgdHJpbSQzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogW11cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lubGluZV9ib3VuZGFyaWVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW5saW5lX2JvdW5kYXJpZXNfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdhW2hyZWZdLGNvZGUsc3Bhbi5tY2UtYW5ub3RhdGlvbidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ29iamVjdF9yZXNpemluZycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBpc0Jvb2xlYW4odmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgZGV2aWNlRGV0ZWN0aW9uJDEuaXNpUGhvbmUoKSB8fCBkZXZpY2VEZXRlY3Rpb24kMS5pc2lQYWQoKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IHRydWUgPyAndGFibGUsaW1nLGZpZ3VyZS5pbWFnZSxkaXYsdmlkZW8saWZyYW1lJyA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgYm9vbGVhbiBvciBhIHN0cmluZydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiAhaXNUb3VjaFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVzaXplX2ltZ19wcm9wb3J0aW9uYWwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdldmVudF9yb290JywgeyBwcm9jZXNzb3I6ICdvYmplY3QnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3NlcnZpY2VfbWVzc2FnZScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0aGVtZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB2YWx1ZSA9PT0gZmFsc2UgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpLFxuICAgICAgICBkZWZhdWx0OiAnc2lsdmVyJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndGhlbWVfdXJsJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Zvcm1hdHMnLCB7IHByb2Nlc3NvcjogJ29iamVjdCcgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9ybWF0X2VtcHR5X2xpbmVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2Zvcm1hdF9ub25lZGl0YWJsZV9zZWxlY3RvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ByZXZpZXdfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbHVlID09PSBmYWxzZSB8fCBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT09IGZhbHNlID8gJycgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgZmFsc2Ugb3IgYSBzdHJpbmcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXdlaWdodCBmb250LXN0eWxlIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXRyYW5zZm9ybSBjb2xvciBiYWNrZ3JvdW5kLWNvbG9yIGJvcmRlciBib3JkZXItcmFkaXVzIG91dGxpbmUgdGV4dC1zaGFkb3cnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjdXN0b21fdWlfc2VsZWN0b3InLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdoaWRkZW5faW5wdXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzdWJtaXRfcGF0Y2gnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdlbmNvZGluZycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhZGRfZm9ybV9zdWJtaXRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2FkZF91bmxvYWRfdHJpZ2dlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2N1c3RvbV91bmRvX3JlZG9fbGV2ZWxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiAwXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkaXNhYmxlX25vZGVjaGFuZ2UnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVhZG9ubHknLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZWRpdGFibGVfcm9vdCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3BsdWdpbnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZ1tdJyxcbiAgICAgICAgZGVmYXVsdDogW11cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2V4dGVybmFsX3BsdWdpbnMnLCB7IHByb2Nlc3NvcjogJ29iamVjdCcgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZm9yY2VkX3BsdWdpbnMnLCB7IHByb2Nlc3NvcjogJ3N0cmluZ1tdJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdtb2RlbCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogZWRpdG9yLmhhc1BsdWdpbigncnRjJykgPyAncGx1Z2luJyA6ICdkb20nXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdtb2RlbF91cmwnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYmxvY2tfdW5zdXBwb3J0ZWRfZHJvcCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Zpc3VhbCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Zpc3VhbF90YWJsZV9jbGFzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ21jZS1pdGVtLXRhYmxlJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmlzdWFsX2FuY2hvcl9jbGFzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ21jZS1pdGVtLWFuY2hvcidcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2lmcmFtZV9hcmlhX3RleHQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdSaWNoIFRleHQgQXJlYS4gUHJlc3MgQUxULTAgZm9yIGhlbHAuJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignc2V0dXAnLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbml0X2luc3RhbmNlX2NhbGxiYWNrJywgeyBwcm9jZXNzb3I6ICdmdW5jdGlvbicgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndXJsX2NvbnZlcnRlcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnZnVuY3Rpb24nLFxuICAgICAgICBkZWZhdWx0OiBlZGl0b3IuY29udmVydFVSTFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndXJsX2NvbnZlcnRlcl9zY29wZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnb2JqZWN0JyxcbiAgICAgICAgZGVmYXVsdDogZWRpdG9yXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd1cmxjb252ZXJ0ZXJfY2FsbGJhY2snLCB7IHByb2Nlc3NvcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd19jb25kaXRpb25hbF9jb21tZW50cycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd19odG1sX2RhdGFfdXJscycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd19zdmdfZGF0YV91cmxzJywgeyBwcm9jZXNzb3I6ICdib29sZWFuJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd19odG1sX2luX25hbWVkX2FuY2hvcicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd19zY3JpcHRfdXJscycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhbGxvd191bnNhZmVfbGlua190YXJnZXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY29udmVydF9mb250c190b19zcGFucycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ZpeF9saXN0X2VsZW1lbnRzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3ByZXNlcnZlX2NkYXRhJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3JlbW92ZV90cmFpbGluZ19icnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYWRfZW1wdHlfd2l0aF9icicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbmxpbmVfc3R5bGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZWxlbWVudF9mb3JtYXQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdodG1sJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZW50aXRpZXMnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignc2NoZW1hJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnaHRtbDUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdjb252ZXJ0X3VybHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdyZWxhdGl2ZV91cmxzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncmVtb3ZlX3NjcmlwdF9ob3N0Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignY3VzdG9tX2VsZW1lbnRzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2V4dGVuZGVkX3ZhbGlkX2VsZW1lbnRzJywgeyBwcm9jZXNzb3I6ICdzdHJpbmcnIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ludmFsaWRfZWxlbWVudHMnLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignaW52YWxpZF9zdHlsZXMnLCB7IHByb2Nlc3Nvcjogc3RyaW5nT3JPYmplY3RQcm9jZXNzb3IgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfY2hpbGRyZW4nLCB7IHByb2Nlc3NvcjogJ3N0cmluZycgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmFsaWRfY2xhc3NlcycsIHsgcHJvY2Vzc29yOiBzdHJpbmdPck9iamVjdFByb2Nlc3NvciB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd2YWxpZF9lbGVtZW50cycsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd2YWxpZF9zdHlsZXMnLCB7IHByb2Nlc3Nvcjogc3RyaW5nT3JPYmplY3RQcm9jZXNzb3IgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndmVyaWZ5X2h0bWwnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhdXRvX2ZvY3VzJywgeyBwcm9jZXNzb3I6IHZhbHVlID0+IGlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZSA9PT0gdHJ1ZSB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdicm93c2VyX3NwZWxsY2hlY2snLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncHJvdGVjdCcsIHsgcHJvY2Vzc29yOiAnYXJyYXknIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2ltYWdlc19maWxlX3R5cGVzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnanBlZyxqcGcsanBlLGpmaSxqaWYsamZpZixwbmcsZ2lmLGJtcCx3ZWJwJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZGVwcmVjYXRpb25fd2FybmluZ3MnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdhMTF5X2FkdmFuY2VkX29wdGlvbnMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignYXBpX2tleScsIHsgcHJvY2Vzc29yOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9ibG9ja19kcm9wJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX2RhdGFfaW1hZ2VzJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfcHJlcHJvY2VzcycsIHsgcHJvY2Vzc29yOiAnZnVuY3Rpb24nIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX3Bvc3Rwcm9jZXNzJywgeyBwcm9jZXNzb3I6ICdmdW5jdGlvbicgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfd2Via2l0X3N0eWxlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdwYXN0ZV9yZW1vdmVfc3R5bGVzX2lmX3dlYmtpdCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX21lcmdlX2Zvcm1hdHMnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdzbWFydF9wYXN0ZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3Bhc3RlX2FzX3RleHQnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigncGFzdGVfdGFiX3NwYWNlcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogNFxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbigndGV4dF9wYXR0ZXJucycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlPZih2YWx1ZSwgaXNPYmplY3QpIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSB2YWx1ZSA9PT0gZmFsc2UgPyBbXSA6IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGZyb21SYXdQYXR0ZXJucyhwYXR0ZXJucyksXG4gICAgICAgICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdNdXN0IGJlIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgZmFsc2UuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyonLFxuICAgICAgICAgICAgZW5kOiAnKicsXG4gICAgICAgICAgICBmb3JtYXQ6ICdpdGFsaWMnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyoqJyxcbiAgICAgICAgICAgIGVuZDogJyoqJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2JvbGQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyMnLFxuICAgICAgICAgICAgZm9ybWF0OiAnaDEnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2gyJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMnLFxuICAgICAgICAgICAgZm9ybWF0OiAnaDMnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyMjIyMnLFxuICAgICAgICAgICAgZm9ybWF0OiAnaDQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJyMjIyMjJyxcbiAgICAgICAgICAgIGZvcm1hdDogJ2g1J1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhcnQ6ICcjIyMjIyMnLFxuICAgICAgICAgICAgZm9ybWF0OiAnaDYnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGFydDogJzEuICcsXG4gICAgICAgICAgICBjbWQ6ICdJbnNlcnRPcmRlcmVkTGlzdCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnKiAnLFxuICAgICAgICAgICAgY21kOiAnSW5zZXJ0VW5vcmRlcmVkTGlzdCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiAnLSAnLFxuICAgICAgICAgICAgY21kOiAnSW5zZXJ0VW5vcmRlcmVkTGlzdCdcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ3RleHRfcGF0dGVybnNfbG9va3VwJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmcm9tUmF3UGF0dGVybnNMb29rdXAodmFsdWUpLFxuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhIHNpbmdsZSBmdW5jdGlvbidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0OiBfY3R4ID0+IFtdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdub25lZGl0YWJsZV9jbGFzcycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogJ21jZU5vbkVkaXRhYmxlJ1xuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZWRpdGFibGVfY2xhc3MnLCB7XG4gICAgICAgIHByb2Nlc3NvcjogJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6ICdtY2VFZGl0YWJsZSdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ25vbmVkaXRhYmxlX3JlZ2V4cCcsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlPZih2YWx1ZSwgaXNSZWdFeHApKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBbdmFsdWVdLFxuICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBhIFJlZ0V4cCBvciBhbiBhcnJheSBvZiBSZWdFeHAuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6IFtdXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd0YWJsZV90YWJfbmF2aWdhdGlvbicsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2hpZ2hsaWdodF9vbl9mb2N1cycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCd4c3Nfc2FuaXRpemF0aW9uJywge1xuICAgICAgICBwcm9jZXNzb3I6ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWdpc3Rlck9wdGlvbignZGV0YWlsc19pbml0aWFsX3N0YXRlJywge1xuICAgICAgICBwcm9jZXNzb3I6IHZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IGNvbnRhaW5zJDIoW1xuICAgICAgICAgICAgJ2luaGVyaXRlZCcsXG4gICAgICAgICAgICAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgICdleHBhbmRlZCdcbiAgICAgICAgICBdLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbGlkID8ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB2YWxpZFxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiAnTXVzdCBiZSBvbmUgb2Y6IGluaGVyaXRlZCwgY29sbGFwc2VkLCBvciBleHBhbmRlZC4nXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdDogJ2luaGVyaXRlZCdcbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJPcHRpb24oJ2RldGFpbHNfc2VyaWFsaXplZF9zdGF0ZScsIHtcbiAgICAgICAgcHJvY2Vzc29yOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBjb250YWlucyQyKFtcbiAgICAgICAgICAgICdpbmhlcml0ZWQnLFxuICAgICAgICAgICAgJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICAnZXhwYW5kZWQnXG4gICAgICAgICAgXSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB2YWxpZCA/IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgYmUgb25lIG9mOiBpbmhlcml0ZWQsIGNvbGxhcHNlZCwgb3IgZXhwYW5kZWQuJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHQ6ICdpbmhlcml0ZWQnXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCdpbml0X2NvbnRlbnRfc3luYycsIHtcbiAgICAgICAgcHJvY2Vzc29yOiAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyT3B0aW9uKCduZXdkb2N1bWVudF9jb250ZW50Jywge1xuICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ1NjcmlwdHNMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgIHJlZ2lzdGVyT3B0aW9uKCdkaXJlY3Rpb25hbGl0eScsIHtcbiAgICAgICAgICBwcm9jZXNzb3I6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IEkxOG4uaXNSdGwoKSA/ICdydGwnIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZWdpc3Rlck9wdGlvbigncGxhY2Vob2xkZXInLCB7XG4gICAgICAgICAgcHJvY2Vzc29yOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiBET00kYS5nZXRBdHRyaWIoZWRpdG9yLmdldEVsZW1lbnQoKSwgJ3BsYWNlaG9sZGVyJylcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldElmcmFtZUF0dHJzID0gb3B0aW9uKCdpZnJhbWVfYXR0cnMnKTtcbiAgICBjb25zdCBnZXREb2NUeXBlID0gb3B0aW9uKCdkb2N0eXBlJyk7XG4gICAgY29uc3QgZ2V0RG9jdW1lbnRCYXNlVXJsID0gb3B0aW9uKCdkb2N1bWVudF9iYXNlX3VybCcpO1xuICAgIGNvbnN0IGdldEJvZHlJZCA9IG9wdGlvbignYm9keV9pZCcpO1xuICAgIGNvbnN0IGdldEJvZHlDbGFzcyA9IG9wdGlvbignYm9keV9jbGFzcycpO1xuICAgIGNvbnN0IGdldENvbnRlbnRTZWN1cml0eVBvbGljeSA9IG9wdGlvbignY29udGVudF9zZWN1cml0eV9wb2xpY3knKTtcbiAgICBjb25zdCBzaG91bGRQdXRCckluUHJlJDEgPSBvcHRpb24oJ2JyX2luX3ByZScpO1xuICAgIGNvbnN0IGdldEZvcmNlZFJvb3RCbG9jayA9IG9wdGlvbignZm9yY2VkX3Jvb3RfYmxvY2snKTtcbiAgICBjb25zdCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyA9IG9wdGlvbignZm9yY2VkX3Jvb3RfYmxvY2tfYXR0cnMnKTtcbiAgICBjb25zdCBnZXROZXdsaW5lQmVoYXZpb3IgPSBvcHRpb24oJ25ld2xpbmVfYmVoYXZpb3InKTtcbiAgICBjb25zdCBnZXRCck5ld0xpbmVTZWxlY3RvciA9IG9wdGlvbignYnJfbmV3bGluZV9zZWxlY3RvcicpO1xuICAgIGNvbnN0IGdldE5vTmV3TGluZVNlbGVjdG9yID0gb3B0aW9uKCdub19uZXdsaW5lX3NlbGVjdG9yJyk7XG4gICAgY29uc3Qgc2hvdWxkS2VlcFN0eWxlcyA9IG9wdGlvbigna2VlcF9zdHlsZXMnKTtcbiAgICBjb25zdCBzaG91bGRFbmRDb250YWluZXJPbkVtcHR5QmxvY2sgPSBvcHRpb24oJ2VuZF9jb250YWluZXJfb25fZW1wdHlfYmxvY2snKTtcbiAgICBjb25zdCBpc0F1dG9tYXRpY1VwbG9hZHNFbmFibGVkID0gb3B0aW9uKCdhdXRvbWF0aWNfdXBsb2FkcycpO1xuICAgIGNvbnN0IHNob3VsZFJldXNlRmlsZU5hbWUgPSBvcHRpb24oJ2ltYWdlc19yZXVzZV9maWxlbmFtZScpO1xuICAgIGNvbnN0IHNob3VsZFJlcGxhY2VCbG9iVXJpcyA9IG9wdGlvbignaW1hZ2VzX3JlcGxhY2VfYmxvYl91cmlzJyk7XG4gICAgY29uc3QgZ2V0SWNvblBhY2tOYW1lID0gb3B0aW9uKCdpY29ucycpO1xuICAgIGNvbnN0IGdldEljb25zVXJsID0gb3B0aW9uKCdpY29uc191cmwnKTtcbiAgICBjb25zdCBnZXRJbWFnZVVwbG9hZFVybCA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF91cmwnKTtcbiAgICBjb25zdCBnZXRJbWFnZVVwbG9hZEJhc2VQYXRoID0gb3B0aW9uKCdpbWFnZXNfdXBsb2FkX2Jhc2VfcGF0aCcpO1xuICAgIGNvbnN0IGdldEltYWdlc1VwbG9hZENyZWRlbnRpYWxzID0gb3B0aW9uKCdpbWFnZXNfdXBsb2FkX2NyZWRlbnRpYWxzJyk7XG4gICAgY29uc3QgZ2V0SW1hZ2VzVXBsb2FkSGFuZGxlciA9IG9wdGlvbignaW1hZ2VzX3VwbG9hZF9oYW5kbGVyJyk7XG4gICAgY29uc3Qgc2hvdWxkVXNlQ29udGVudENzc0NvcnMgPSBvcHRpb24oJ2NvbnRlbnRfY3NzX2NvcnMnKTtcbiAgICBjb25zdCBnZXRSZWZlcnJlclBvbGljeSA9IG9wdGlvbigncmVmZXJyZXJfcG9saWN5Jyk7XG4gICAgY29uc3QgZ2V0TGFuZ3VhZ2VDb2RlID0gb3B0aW9uKCdsYW5ndWFnZScpO1xuICAgIGNvbnN0IGdldExhbmd1YWdlVXJsID0gb3B0aW9uKCdsYW5ndWFnZV91cmwnKTtcbiAgICBjb25zdCBzaG91bGRJbmRlbnRVc2VNYXJnaW4gPSBvcHRpb24oJ2luZGVudF91c2VfbWFyZ2luJyk7XG4gICAgY29uc3QgZ2V0SW5kZW50YXRpb24gPSBvcHRpb24oJ2luZGVudGF0aW9uJyk7XG4gICAgY29uc3QgZ2V0Q29udGVudENzcyA9IG9wdGlvbignY29udGVudF9jc3MnKTtcbiAgICBjb25zdCBnZXRDb250ZW50U3R5bGUgPSBvcHRpb24oJ2NvbnRlbnRfc3R5bGUnKTtcbiAgICBjb25zdCBnZXRGb250Q3NzID0gb3B0aW9uKCdmb250X2NzcycpO1xuICAgIGNvbnN0IGdldERpcmVjdGlvbmFsaXR5ID0gb3B0aW9uKCdkaXJlY3Rpb25hbGl0eScpO1xuICAgIGNvbnN0IGdldElubGluZUJvdW5kYXJ5U2VsZWN0b3IgPSBvcHRpb24oJ2lubGluZV9ib3VuZGFyaWVzX3NlbGVjdG9yJyk7XG4gICAgY29uc3QgZ2V0T2JqZWN0UmVzaXppbmcgPSBvcHRpb24oJ29iamVjdF9yZXNpemluZycpO1xuICAgIGNvbnN0IGdldFJlc2l6ZUltZ1Byb3BvcnRpb25hbCA9IG9wdGlvbigncmVzaXplX2ltZ19wcm9wb3J0aW9uYWwnKTtcbiAgICBjb25zdCBnZXRQbGFjZWhvbGRlciA9IG9wdGlvbigncGxhY2Vob2xkZXInKTtcbiAgICBjb25zdCBnZXRFdmVudFJvb3QgPSBvcHRpb24oJ2V2ZW50X3Jvb3QnKTtcbiAgICBjb25zdCBnZXRTZXJ2aWNlTWVzc2FnZSA9IG9wdGlvbignc2VydmljZV9tZXNzYWdlJyk7XG4gICAgY29uc3QgZ2V0VGhlbWUgPSBvcHRpb24oJ3RoZW1lJyk7XG4gICAgY29uc3QgZ2V0VGhlbWVVcmwgPSBvcHRpb24oJ3RoZW1lX3VybCcpO1xuICAgIGNvbnN0IGdldE1vZGVsID0gb3B0aW9uKCdtb2RlbCcpO1xuICAgIGNvbnN0IGdldE1vZGVsVXJsID0gb3B0aW9uKCdtb2RlbF91cmwnKTtcbiAgICBjb25zdCBpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkID0gb3B0aW9uKCdpbmxpbmVfYm91bmRhcmllcycpO1xuICAgIGNvbnN0IGdldEZvcm1hdHMgPSBvcHRpb24oJ2Zvcm1hdHMnKTtcbiAgICBjb25zdCBnZXRQcmV2aWV3U3R5bGVzID0gb3B0aW9uKCdwcmV2aWV3X3N0eWxlcycpO1xuICAgIGNvbnN0IGNhbkZvcm1hdEVtcHR5TGluZXMgPSBvcHRpb24oJ2Zvcm1hdF9lbXB0eV9saW5lcycpO1xuICAgIGNvbnN0IGdldEZvcm1hdE5vbmVkaXRhYmxlU2VsZWN0b3IgPSBvcHRpb24oJ2Zvcm1hdF9ub25lZGl0YWJsZV9zZWxlY3RvcicpO1xuICAgIGNvbnN0IGdldEN1c3RvbVVpU2VsZWN0b3IgPSBvcHRpb24oJ2N1c3RvbV91aV9zZWxlY3RvcicpO1xuICAgIGNvbnN0IGlzSW5saW5lID0gb3B0aW9uKCdpbmxpbmUnKTtcbiAgICBjb25zdCBoYXNIaWRkZW5JbnB1dCA9IG9wdGlvbignaGlkZGVuX2lucHV0Jyk7XG4gICAgY29uc3Qgc2hvdWxkUGF0Y2hTdWJtaXQgPSBvcHRpb24oJ3N1Ym1pdF9wYXRjaCcpO1xuICAgIGNvbnN0IHNob3VsZEFkZEZvcm1TdWJtaXRUcmlnZ2VyID0gb3B0aW9uKCdhZGRfZm9ybV9zdWJtaXRfdHJpZ2dlcicpO1xuICAgIGNvbnN0IHNob3VsZEFkZFVubG9hZFRyaWdnZXIgPSBvcHRpb24oJ2FkZF91bmxvYWRfdHJpZ2dlcicpO1xuICAgIGNvbnN0IGdldEN1c3RvbVVuZG9SZWRvTGV2ZWxzID0gb3B0aW9uKCdjdXN0b21fdW5kb19yZWRvX2xldmVscycpO1xuICAgIGNvbnN0IHNob3VsZERpc2FibGVOb2RlQ2hhbmdlID0gb3B0aW9uKCdkaXNhYmxlX25vZGVjaGFuZ2UnKTtcbiAgICBjb25zdCBpc1JlYWRPbmx5JDEgPSBvcHRpb24oJ3JlYWRvbmx5Jyk7XG4gICAgY29uc3QgaGFzRWRpdGFibGVSb290JDEgPSBvcHRpb24oJ2VkaXRhYmxlX3Jvb3QnKTtcbiAgICBjb25zdCBoYXNDb250ZW50Q3NzQ29ycyA9IG9wdGlvbignY29udGVudF9jc3NfY29ycycpO1xuICAgIGNvbnN0IGdldFBsdWdpbnMgPSBvcHRpb24oJ3BsdWdpbnMnKTtcbiAgICBjb25zdCBnZXRFeHRlcm5hbFBsdWdpbnMkMSA9IG9wdGlvbignZXh0ZXJuYWxfcGx1Z2lucycpO1xuICAgIGNvbnN0IHNob3VsZEJsb2NrVW5zdXBwb3J0ZWREcm9wID0gb3B0aW9uKCdibG9ja191bnN1cHBvcnRlZF9kcm9wJyk7XG4gICAgY29uc3QgaXNWaXN1YWxBaWRzRW5hYmxlZCA9IG9wdGlvbigndmlzdWFsJyk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQWlkc1RhYmxlQ2xhc3MgPSBvcHRpb24oJ3Zpc3VhbF90YWJsZV9jbGFzcycpO1xuICAgIGNvbnN0IGdldFZpc3VhbEFpZHNBbmNob3JDbGFzcyA9IG9wdGlvbigndmlzdWFsX2FuY2hvcl9jbGFzcycpO1xuICAgIGNvbnN0IGdldElmcmFtZUFyaWFUZXh0ID0gb3B0aW9uKCdpZnJhbWVfYXJpYV90ZXh0Jyk7XG4gICAgY29uc3QgZ2V0U2V0dXBDYWxsYmFjayA9IG9wdGlvbignc2V0dXAnKTtcbiAgICBjb25zdCBnZXRJbml0SW5zdGFuY2VDYWxsYmFjayA9IG9wdGlvbignaW5pdF9pbnN0YW5jZV9jYWxsYmFjaycpO1xuICAgIGNvbnN0IGdldFVybENvbnZlcnRlckNhbGxiYWNrID0gb3B0aW9uKCd1cmxjb252ZXJ0ZXJfY2FsbGJhY2snKTtcbiAgICBjb25zdCBnZXRBdXRvRm9jdXMgPSBvcHRpb24oJ2F1dG9fZm9jdXMnKTtcbiAgICBjb25zdCBzaG91bGRCcm93c2VyU3BlbGxjaGVjayA9IG9wdGlvbignYnJvd3Nlcl9zcGVsbGNoZWNrJyk7XG4gICAgY29uc3QgZ2V0UHJvdGVjdCA9IG9wdGlvbigncHJvdGVjdCcpO1xuICAgIGNvbnN0IHNob3VsZFBhc3RlQmxvY2tEcm9wID0gb3B0aW9uKCdwYXN0ZV9ibG9ja19kcm9wJyk7XG4gICAgY29uc3Qgc2hvdWxkUGFzdGVEYXRhSW1hZ2VzID0gb3B0aW9uKCdwYXN0ZV9kYXRhX2ltYWdlcycpO1xuICAgIGNvbnN0IGdldFBhc3RlUHJlUHJvY2VzcyA9IG9wdGlvbigncGFzdGVfcHJlcHJvY2VzcycpO1xuICAgIGNvbnN0IGdldFBhc3RlUG9zdFByb2Nlc3MgPSBvcHRpb24oJ3Bhc3RlX3Bvc3Rwcm9jZXNzJyk7XG4gICAgY29uc3QgZ2V0TmV3RG9jdW1lbnRDb250ZW50ID0gb3B0aW9uKCduZXdkb2N1bWVudF9jb250ZW50Jyk7XG4gICAgY29uc3QgZ2V0UGFzdGVXZWJraXRTdHlsZXMgPSBvcHRpb24oJ3Bhc3RlX3dlYmtpdF9zdHlsZXMnKTtcbiAgICBjb25zdCBzaG91bGRQYXN0ZVJlbW92ZVdlYktpdFN0eWxlcyA9IG9wdGlvbigncGFzdGVfcmVtb3ZlX3N0eWxlc19pZl93ZWJraXQnKTtcbiAgICBjb25zdCBzaG91bGRQYXN0ZU1lcmdlRm9ybWF0cyA9IG9wdGlvbigncGFzdGVfbWVyZ2VfZm9ybWF0cycpO1xuICAgIGNvbnN0IGlzU21hcnRQYXN0ZUVuYWJsZWQgPSBvcHRpb24oJ3NtYXJ0X3Bhc3RlJyk7XG4gICAgY29uc3QgaXNQYXN0ZUFzVGV4dEVuYWJsZWQgPSBvcHRpb24oJ3Bhc3RlX2FzX3RleHQnKTtcbiAgICBjb25zdCBnZXRQYXN0ZVRhYlNwYWNlcyA9IG9wdGlvbigncGFzdGVfdGFiX3NwYWNlcycpO1xuICAgIGNvbnN0IHNob3VsZEFsbG93SHRtbERhdGFVcmxzID0gb3B0aW9uKCdhbGxvd19odG1sX2RhdGFfdXJscycpO1xuICAgIGNvbnN0IGdldFRleHRQYXR0ZXJucyA9IG9wdGlvbigndGV4dF9wYXR0ZXJucycpO1xuICAgIGNvbnN0IGdldFRleHRQYXR0ZXJuc0xvb2t1cCA9IG9wdGlvbigndGV4dF9wYXR0ZXJuc19sb29rdXAnKTtcbiAgICBjb25zdCBnZXROb25FZGl0YWJsZUNsYXNzID0gb3B0aW9uKCdub25lZGl0YWJsZV9jbGFzcycpO1xuICAgIGNvbnN0IGdldEVkaXRhYmxlQ2xhc3MgPSBvcHRpb24oJ2VkaXRhYmxlX2NsYXNzJyk7XG4gICAgY29uc3QgZ2V0Tm9uRWRpdGFibGVSZWdFeHBzID0gb3B0aW9uKCdub25lZGl0YWJsZV9yZWdleHAnKTtcbiAgICBjb25zdCBzaG91bGRQcmVzZXJ2ZUNEYXRhID0gb3B0aW9uKCdwcmVzZXJ2ZV9jZGF0YScpO1xuICAgIGNvbnN0IHNob3VsZEhpZ2hsaWdodE9uRm9jdXMgPSBvcHRpb24oJ2hpZ2hsaWdodF9vbl9mb2N1cycpO1xuICAgIGNvbnN0IHNob3VsZFNhbml0aXplWHNzID0gb3B0aW9uKCd4c3Nfc2FuaXRpemF0aW9uJyk7XG4gICAgY29uc3Qgc2hvdWxkVXNlRG9jdW1lbnRXcml0ZSA9IG9wdGlvbignaW5pdF9jb250ZW50X3N5bmMnKTtcbiAgICBjb25zdCBoYXNUZXh0UGF0dGVybnNMb29rdXAgPSBlZGl0b3IgPT4gZWRpdG9yLm9wdGlvbnMuaXNTZXQoJ3RleHRfcGF0dGVybnNfbG9va3VwJyk7XG4gICAgY29uc3QgZ2V0Rm9udFN0eWxlVmFsdWVzID0gZWRpdG9yID0+IFRvb2xzLmV4cGxvZGUoZWRpdG9yLm9wdGlvbnMuZ2V0KCdmb250X3NpemVfc3R5bGVfdmFsdWVzJykpO1xuICAgIGNvbnN0IGdldEZvbnRTaXplQ2xhc3NlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnZm9udF9zaXplX2NsYXNzZXMnKSk7XG4gICAgY29uc3QgaXNFbmNvZGluZ1htbCA9IGVkaXRvciA9PiBlZGl0b3Iub3B0aW9ucy5nZXQoJ2VuY29kaW5nJykgPT09ICd4bWwnO1xuICAgIGNvbnN0IGdldEFsbG93ZWRJbWFnZUZpbGVUeXBlcyA9IGVkaXRvciA9PiBUb29scy5leHBsb2RlKGVkaXRvci5vcHRpb25zLmdldCgnaW1hZ2VzX2ZpbGVfdHlwZXMnKSk7XG4gICAgY29uc3QgaGFzVGFibGVUYWJOYXZpZ2F0aW9uID0gb3B0aW9uKCd0YWJsZV90YWJfbmF2aWdhdGlvbicpO1xuICAgIGNvbnN0IGdldERldGFpbHNJbml0aWFsU3RhdGUgPSBvcHRpb24oJ2RldGFpbHNfaW5pdGlhbF9zdGF0ZScpO1xuICAgIGNvbnN0IGdldERldGFpbHNTZXJpYWxpemVkU3RhdGUgPSBvcHRpb24oJ2RldGFpbHNfc2VyaWFsaXplZF9zdGF0ZScpO1xuXG4gICAgY29uc3QgaXNFbGVtZW50JDMgPSBpc0VsZW1lbnQkNjtcbiAgICBjb25zdCBpc1RleHQkNSA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IHJlbW92ZU5vZGUkMSA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmltQ291bnQgPSB0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IHRyaW1tZWRUZXh0ID0gdHJpbSQxKHRleHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY291bnQ6IHRleHQubGVuZ3RoIC0gdHJpbW1lZFRleHQubGVuZ3RoLFxuICAgICAgICB0ZXh0OiB0cmltbWVkVGV4dFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVp3c3BDaGFycyA9IGNhcmV0Q29udGFpbmVyID0+IHtcbiAgICAgIGxldCBpZHg7XG4gICAgICB3aGlsZSAoKGlkeCA9IGNhcmV0Q29udGFpbmVyLmRhdGEubGFzdEluZGV4T2YoWldTUCQxKSkgIT09IC0xKSB7XG4gICAgICAgIGNhcmV0Q29udGFpbmVyLmRlbGV0ZURhdGEoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVVuY2hhbmdlZCA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICByZW1vdmUkMyhjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlVGV4dEFuZFJlcG9zaXRpb24gPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4ge1xuICAgICAgY29uc3QgYmVmb3JlID0gdHJpbUNvdW50KGNhcmV0Q29udGFpbmVyLmRhdGEuc3Vic3RyKDAsIHBvcy5vZmZzZXQoKSkpO1xuICAgICAgY29uc3QgYWZ0ZXIgPSB0cmltQ291bnQoY2FyZXRDb250YWluZXIuZGF0YS5zdWJzdHIocG9zLm9mZnNldCgpKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYmVmb3JlLnRleHQgKyBhZnRlci50ZXh0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWxldGVad3NwQ2hhcnMoY2FyZXRDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zLm9mZnNldCgpIC0gYmVmb3JlLmNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50QW5kUmVwb3NpdGlvbiA9IChjYXJldENvbnRhaW5lciwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBpbmRleE9mJDEoZnJvbShwYXJlbnROb2RlLmNoaWxkTm9kZXMpLCBjYXJldENvbnRhaW5lcikubWFwKGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgcG9zLm9mZnNldCgpID8gQ2FyZXRQb3NpdGlvbihwYXJlbnROb2RlLCBwb3Mub2Zmc2V0KCkgLSAxKSA6IHBvcztcbiAgICAgIH0pLmdldE9yKHBvcyk7XG4gICAgICByZW1vdmUkMyhjYXJldENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbmV3UG9zaXRpb247XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVUZXh0Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gaXNUZXh0JDUoY2FyZXRDb250YWluZXIpICYmIHBvcy5jb250YWluZXIoKSA9PT0gY2FyZXRDb250YWluZXIgPyByZW1vdmVUZXh0QW5kUmVwb3NpdGlvbihjYXJldENvbnRhaW5lciwgcG9zKSA6IHJlbW92ZVVuY2hhbmdlZChjYXJldENvbnRhaW5lciwgcG9zKTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50Q2FyZXRDb250YWluZXIgPSAoY2FyZXRDb250YWluZXIsIHBvcykgPT4gcG9zLmNvbnRhaW5lcigpID09PSBjYXJldENvbnRhaW5lci5wYXJlbnROb2RlID8gcmVtb3ZlRWxlbWVudEFuZFJlcG9zaXRpb24oY2FyZXRDb250YWluZXIsIHBvcykgOiByZW1vdmVVbmNoYW5nZWQoY2FyZXRDb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlQW5kUmVwb3NpdGlvbiA9IChjb250YWluZXIsIHBvcykgPT4gQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpID8gcmVtb3ZlVGV4dENhcmV0Q29udGFpbmVyKGNvbnRhaW5lciwgcG9zKSA6IHJlbW92ZUVsZW1lbnRDYXJldENvbnRhaW5lcihjb250YWluZXIsIHBvcyk7XG4gICAgY29uc3QgcmVtb3ZlJDMgPSBjYXJldENvbnRhaW5lck5vZGUgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQzKGNhcmV0Q29udGFpbmVyTm9kZSkgJiYgaXNDYXJldENvbnRhaW5lciQyKGNhcmV0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQoY2FyZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkNShjYXJldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgIGRlbGV0ZVp3c3BDaGFycyhjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgICBpZiAoY2FyZXRDb250YWluZXJOb2RlLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTm9kZSQxKGNhcmV0Q29udGFpbmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ4ID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRiO1xuICAgIGNvbnN0IGlzTWVkaWEkMSA9IGlzTWVkaWEkMjtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbCQxID0gaXNUYWJsZUNlbGwkMztcbiAgICBjb25zdCBpbmxpbmVGYWtlQ2FyZXRTZWxlY3RvciA9ICcqW2NvbnRlbnRFZGl0YWJsZT1mYWxzZV0sdmlkZW8sYXVkaW8sZW1iZWQsb2JqZWN0JztcbiAgICBjb25zdCBnZXRBYnNvbHV0ZUNsaWVudFJlY3QgPSAocm9vdCwgZWxlbWVudCwgYmVmb3JlKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRSZWN0ID0gY29sbGFwc2UoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmVmb3JlKTtcbiAgICAgIGxldCBzY3JvbGxYO1xuICAgICAgbGV0IHNjcm9sbFk7XG4gICAgICBpZiAocm9vdC50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgY29uc3QgZG9jRWxtID0gcm9vdC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2Nyb2xsWCA9IHJvb3Quc2Nyb2xsTGVmdCB8fCBkb2NFbG0uc2Nyb2xsTGVmdDtcbiAgICAgICAgc2Nyb2xsWSA9IHJvb3Quc2Nyb2xsVG9wIHx8IGRvY0VsbS5zY3JvbGxUb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByb290UmVjdCA9IHJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNjcm9sbFggPSByb290LnNjcm9sbExlZnQgLSByb290UmVjdC5sZWZ0O1xuICAgICAgICBzY3JvbGxZID0gcm9vdC5zY3JvbGxUb3AgLSByb290UmVjdC50b3A7XG4gICAgICB9XG4gICAgICBjbGllbnRSZWN0LmxlZnQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gc2Nyb2xsWDtcbiAgICAgIGNsaWVudFJlY3QudG9wICs9IHNjcm9sbFk7XG4gICAgICBjbGllbnRSZWN0LmJvdHRvbSArPSBzY3JvbGxZO1xuICAgICAgY2xpZW50UmVjdC53aWR0aCA9IDE7XG4gICAgICBsZXQgbWFyZ2luID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICBpZiAobWFyZ2luID4gMCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbWFyZ2luICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlY3QubGVmdCArPSBtYXJnaW47XG4gICAgICAgIGNsaWVudFJlY3QucmlnaHQgKz0gbWFyZ2luO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW5saW5lQ2FyZXRDb250YWluZXJzID0gcm9vdCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZmFrZUNhcmV0VGFyZ2V0Tm9kZXMgPSBkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShyb290KSwgaW5saW5lRmFrZUNhcmV0U2VsZWN0b3IpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWtlQ2FyZXRUYXJnZXROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gZmFrZUNhcmV0VGFyZ2V0Tm9kZXNbaV0uZG9tO1xuICAgICAgICBsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lciQxKHNpYmxpbmcpKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHNpYmxpbmcuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIChfYSA9IHNpYmxpbmcucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmRlbGV0ZURhdGEoZGF0YS5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShzaWJsaW5nKSkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBzaWJsaW5nLmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAoX2IgPSBzaWJsaW5nLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRmFrZUNhcmV0ID0gKGVkaXRvciwgcm9vdCwgaXNCbG9jaywgaGFzRm9jdXMpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RWaXN1YWxDYXJldCA9IHZhbHVlJDIoKTtcbiAgICAgIGxldCBjdXJzb3JJbnRlcnZhbDtcbiAgICAgIGxldCBjYXJldENvbnRhaW5lck5vZGU7XG4gICAgICBjb25zdCBjYXJldEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2hvdyA9IChiZWZvcmUsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IHJuZztcbiAgICAgICAgaGlkZSgpO1xuICAgICAgICBpZiAoaXNUYWJsZUNlbGwkMShlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jsb2NrKGVsZW1lbnQpKSB7XG4gICAgICAgICAgY29uc3QgY2FyZXRDb250YWluZXIgPSBpbnNlcnRCbG9jayhjYXJldEJsb2NrLCBlbGVtZW50LCBiZWZvcmUpO1xuICAgICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRBYnNvbHV0ZUNsaWVudFJlY3Qocm9vdCwgZWxlbWVudCwgYmVmb3JlKTtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoY2FyZXRDb250YWluZXIsICd0b3AnLCBjbGllbnRSZWN0LnRvcCk7XG4gICAgICAgICAgY2FyZXRDb250YWluZXJOb2RlID0gY2FyZXRDb250YWluZXI7XG4gICAgICAgICAgY29uc3QgY2FyZXQgPSBkb20uY3JlYXRlKCdkaXYnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnbWNlLXZpc3VhbC1jYXJldCcsXG4gICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY2FyZXQsIHsgLi4uY2xpZW50UmVjdCB9KTtcbiAgICAgICAgICBkb20uYWRkKHJvb3QsIGNhcmV0KTtcbiAgICAgICAgICBsYXN0VmlzdWFsQ2FyZXQuc2V0KHtcbiAgICAgICAgICAgIGNhcmV0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjYXJldCwgJ21jZS12aXN1YWwtY2FyZXQtYmVmb3JlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0QmxpbmsoKTtcbiAgICAgICAgICBybmcgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQoY2FyZXRDb250YWluZXIsIDApO1xuICAgICAgICAgIHJuZy5zZXRFbmQoY2FyZXRDb250YWluZXIsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZSA9IGluc2VydElubGluZSQxKGVsZW1lbnQsIGJlZm9yZSk7XG4gICAgICAgICAgcm5nID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgaWYgKGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KGNhcmV0Q29udGFpbmVyTm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjYXJldENvbnRhaW5lck5vZGUsIDApO1xuICAgICAgICAgICAgcm5nLnNldEVuZChjYXJldENvbnRhaW5lck5vZGUsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQoY2FyZXRDb250YWluZXJOb2RlLCAxKTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY2FyZXRDb250YWluZXJOb2RlLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhpZGUgPSAoKSA9PiB7XG4gICAgICAgIHRyaW1JbmxpbmVDYXJldENvbnRhaW5lcnMocm9vdCk7XG4gICAgICAgIGlmIChjYXJldENvbnRhaW5lck5vZGUpIHtcbiAgICAgICAgICByZW1vdmUkMyhjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgICAgIGNhcmV0Q29udGFpbmVyTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFZpc3VhbENhcmV0Lm9uKGNhcmV0U3RhdGUgPT4ge1xuICAgICAgICAgIGRvbS5yZW1vdmUoY2FyZXRTdGF0ZS5jYXJldCk7XG4gICAgICAgICAgbGFzdFZpc3VhbENhcmV0LmNsZWFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3Vyc29ySW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnNvckludGVydmFsKTtcbiAgICAgICAgICBjdXJzb3JJbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0YXJ0QmxpbmsgPSAoKSA9PiB7XG4gICAgICAgIGN1cnNvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGxhc3RWaXN1YWxDYXJldC5vbihjYXJldFN0YXRlID0+IHtcbiAgICAgICAgICAgIGlmIChoYXNGb2N1cygpKSB7XG4gICAgICAgICAgICAgIGRvbS50b2dnbGVDbGFzcyhjYXJldFN0YXRlLmNhcmV0LCAnbWNlLXZpc3VhbC1jYXJldC1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjYXJldFN0YXRlLmNhcmV0LCAnbWNlLXZpc3VhbC1jYXJldC1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgICBsYXN0VmlzdWFsQ2FyZXQub24oY2FyZXRTdGF0ZSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGdldEFic29sdXRlQ2xpZW50UmVjdChyb290LCBjYXJldFN0YXRlLmVsZW1lbnQsIGNhcmV0U3RhdGUuYmVmb3JlKTtcbiAgICAgICAgICBkb20uc2V0U3R5bGVzKGNhcmV0U3RhdGUuY2FyZXQsIHsgLi4uY2xpZW50UmVjdCB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IGNsZWFySW50ZXJ2YWwoY3Vyc29ySW50ZXJ2YWwpO1xuICAgICAgY29uc3QgZ2V0Q3NzID0gKCkgPT4gJy5tY2UtdmlzdWFsLWNhcmV0IHsnICsgJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsnICsgJ2JhY2tncm91bmQtY29sb3I6IGJsYWNrOycgKyAnYmFja2dyb3VuZC1jb2xvcjogY3VycmVudGNvbG9yOycgKyAnfScgKyAnLm1jZS12aXN1YWwtY2FyZXQtaGlkZGVuIHsnICsgJ2Rpc3BsYXk6IG5vbmU7JyArICd9JyArICcqW2RhdGEtbWNlLWNhcmV0XSB7JyArICdwb3NpdGlvbjogYWJzb2x1dGU7JyArICdsZWZ0OiAtMTAwMHB4OycgKyAncmlnaHQ6IGF1dG87JyArICd0b3A6IDA7JyArICdtYXJnaW46IDA7JyArICdwYWRkaW5nOiAwOycgKyAnfSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG93LFxuICAgICAgICBoaWRlLFxuICAgICAgICBnZXRDc3MsXG4gICAgICAgIHJlcG9zaXRpb24sXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpc0Zha2VDYXJldFRhYmxlQnJvd3NlciA9ICgpID0+IEVudi5icm93c2VyLmlzRmlyZWZveCgpO1xuICAgIGNvbnN0IGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0ID0gbm9kZSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDgobm9kZSkgfHwgaXNNZWRpYSQxKG5vZGUpO1xuICAgIGNvbnN0IGlzRmFrZUNhcmV0VGFyZ2V0ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBpc1RhcmdldCA9IGlzSW5saW5lRmFrZUNhcmV0VGFyZ2V0KG5vZGUpIHx8IGlzVGFibGUkMihub2RlKSAmJiBpc0Zha2VDYXJldFRhYmxlQnJvd3NlcigpO1xuICAgICAgcmV0dXJuIGlzVGFyZ2V0ICYmIHBhcmVudEVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpLmV4aXN0cyhpc0VkaXRhYmxlJDMpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMSA9IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNyA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYjtcbiAgICBjb25zdCBpc01lZGlhID0gaXNNZWRpYSQyO1xuICAgIGNvbnN0IGlzQmxvY2tMaWtlID0gbWF0Y2hTdHlsZVZhbHVlcygnZGlzcGxheScsICdibG9jayB0YWJsZSB0YWJsZS1jZWxsIHRhYmxlLWNhcHRpb24gbGlzdC1pdGVtJyk7XG4gICAgY29uc3QgaXNDYXJldENvbnRhaW5lciA9IGlzQ2FyZXRDb250YWluZXIkMjtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyQmxvY2sgPSBpc0NhcmV0Q29udGFpbmVyQmxvY2skMTtcbiAgICBjb25zdCBpc0VsZW1lbnQkMiA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzVGV4dCQ0ID0gaXNUZXh0JGE7XG4gICAgY29uc3QgaXNDYXJldENhbmRpZGF0ZSQxID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzRm9yd2FyZHMgPSBkaXJlY3Rpb24gPT4gZGlyZWN0aW9uID4gMDtcbiAgICBjb25zdCBpc0JhY2t3YXJkcyA9IGRpcmVjdGlvbiA9PiBkaXJlY3Rpb24gPCAwO1xuICAgIGNvbnN0IHNraXBDYXJldENvbnRhaW5lcnMgPSAod2Fsaywgc2hhbGxvdykgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSA9IHdhbGsoc2hhbGxvdykpIHtcbiAgICAgICAgaWYgKCFpc0NhcmV0Q29udGFpbmVyQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTm9kZSA9IChub2RlLCBkaXJlY3Rpb24sIHByZWRpY2F0ZUZuLCByb290Tm9kZSwgc2hhbGxvdykgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdE5vZGUpO1xuICAgICAgY29uc3QgaXNDZWZPckNhcmV0Q29udGFpbmVyID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXJCbG9jayhub2RlKTtcbiAgICAgIGxldCB0ZW1wTm9kZTtcbiAgICAgIGlmIChpc0JhY2t3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChpc0NlZk9yQ2FyZXRDb250YWluZXIpIHtcbiAgICAgICAgICB0ZW1wTm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLnByZXYuYmluZCh3YWxrZXIpLCB0cnVlKTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4odGVtcE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0ZW1wTm9kZSA9IHNraXBDYXJldENvbnRhaW5lcnMod2Fsa2VyLnByZXYuYmluZCh3YWxrZXIpLCBzaGFsbG93KSkge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVGbih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ZvcndhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQ2VmT3JDYXJldENvbnRhaW5lcikge1xuICAgICAgICAgIHRlbXBOb2RlID0gc2tpcENhcmV0Q29udGFpbmVycyh3YWxrZXIubmV4dC5iaW5kKHdhbGtlciksIHRydWUpO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVGbih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRlbXBOb2RlID0gc2tpcENhcmV0Q29udGFpbmVycyh3YWxrZXIubmV4dC5iaW5kKHdhbGtlciksIHNoYWxsb3cpKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZUZuKHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBOb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBnZXRFZGl0aW5nSG9zdCA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgaXNDRVRydWUgPSBub2RlID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQxKG5vZGUuZG9tKTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IG5vZGUgPT4gbm9kZS5kb20gPT09IHJvb3ROb2RlO1xuICAgICAgcmV0dXJuIGFuY2VzdG9yJDQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIGlzQ0VUcnVlLCBpc1Jvb3QpLm1hcChlbG0gPT4gZWxtLmRvbSkuZ2V0T3Iocm9vdE5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2skMyA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgaWYgKGlzQmxvY2tMaWtlKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaXNJblNhbWVCbG9jayA9IChjYXJldFBvc2l0aW9uMSwgY2FyZXRQb3NpdGlvbjIsIHJvb3ROb2RlKSA9PiBnZXRQYXJlbnRCbG9jayQzKGNhcmV0UG9zaXRpb24xLmNvbnRhaW5lcigpLCByb290Tm9kZSkgPT09IGdldFBhcmVudEJsb2NrJDMoY2FyZXRQb3NpdGlvbjIuY29udGFpbmVyKCksIHJvb3ROb2RlKTtcbiAgICBjb25zdCBnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0ID0gKHJlbGF0aXZlT2Zmc2V0LCBjYXJldFBvc2l0aW9uKSA9PiB7XG4gICAgICBpZiAoIWNhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXJldFBvc2l0aW9uLm9mZnNldCgpO1xuICAgICAgaWYgKCFpc0VsZW1lbnQkMihjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXQgKyByZWxhdGl2ZU9mZnNldF0pO1xuICAgIH07XG4gICAgY29uc3QgYmVmb3JlQWZ0ZXIgPSAoYmVmb3JlLCBub2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb2MgPSAoX2EgPSBub2RlLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50O1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgaXNOb2Rlc0luU2FtZUJsb2NrID0gKHJvb3QsIG5vZGUxLCBub2RlMikgPT4gZ2V0UGFyZW50QmxvY2skMyhub2RlMSwgcm9vdCkgPT09IGdldFBhcmVudEJsb2NrJDMobm9kZTIsIHJvb3QpO1xuICAgIGNvbnN0IGxlYW4gPSAobGVmdCwgcm9vdCwgbm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZ05hbWUgPSBsZWZ0ID8gJ3ByZXZpb3VzU2libGluZycgOiAnbmV4dFNpYmxpbmcnO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSAmJiB0ZW1wTm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBsZXQgc2libGluZyA9IHRlbXBOb2RlW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgaWYgKHNpYmxpbmcgJiYgaXNDYXJldENvbnRhaW5lcihzaWJsaW5nKSkge1xuICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nW3NpYmxpbmdOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KHNpYmxpbmcpIHx8IGlzTWVkaWEoc2libGluZykpIHtcbiAgICAgICAgICBpZiAoaXNOb2Rlc0luU2FtZUJsb2NrKHJvb3QsIHNpYmxpbmcsIHRlbXBOb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlJDEoc2libGluZykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZSQyID0gY3VycnkoYmVmb3JlQWZ0ZXIsIHRydWUpO1xuICAgIGNvbnN0IGFmdGVyJDIgPSBjdXJyeShiZWZvcmVBZnRlciwgZmFsc2UpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVJhbmdlID0gKGRpcmVjdGlvbiwgcm9vdCwgcmFuZ2UpID0+IHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgY29uc3QgbGVhbkxlZnQgPSBjdXJyeShsZWFuLCB0cnVlLCByb290KTtcbiAgICAgIGNvbnN0IGxlYW5SaWdodCA9IGN1cnJ5KGxlYW4sIGZhbHNlLCByb290KTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICBpZiAoaXNDYXJldENvbnRhaW5lckJsb2NrJDEoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBibG9jayA9IGlzVGV4dCQ0KGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBibG9jay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWNhcmV0Jyk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2JlZm9yZScpIHtcbiAgICAgICAgICBub2RlID0gYmxvY2submV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlJDIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgIG5vZGUgPSBibG9jay5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhZnRlciQyKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgbm9kZSA9IGxlYW5MZWZ0KGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aENhcmV0Q29udGFpbmVyJDEoY29udGFpbmVyKSAmJiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuUmlnaHQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydHNXaXRoQ2FyZXRDb250YWluZXIkMShjb250YWluZXIpICYmIG9mZnNldCA8PSAxKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBsZWFuTGVmdChjb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSBjb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlID0gbGVhblJpZ2h0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWZvcmUkMihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBub2RlID0gbGVhbkxlZnQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFmdGVyJDIobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UmVsYXRpdmVDZWZFbG0gPSAoZm9yd2FyZCwgY2FyZXRQb3NpdGlvbikgPT4gZ2V0Q2hpbGROb2RlQXRSZWxhdGl2ZU9mZnNldChmb3J3YXJkID8gMCA6IC0xLCBjYXJldFBvc2l0aW9uKS5maWx0ZXIoaXNDb250ZW50RWRpdGFibGVGYWxzZSQ3KTtcbiAgICBjb25zdCBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludCA9IChkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZShkaXJlY3Rpb24sIHJvb3QsIHJhbmdlKTtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IC0xID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChub3JtYWxpemVkUmFuZ2UpIDogQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQobm9ybWFsaXplZFJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUG9zaXRpb24gPSBwb3MgPT4gT3B0aW9uYWwuZnJvbShwb3MuZ2V0Tm9kZSgpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IGdldEVsZW1lbnRGcm9tUHJldlBvc2l0aW9uID0gcG9zID0+IE9wdGlvbmFsLmZyb20ocG9zLmdldE5vZGUodHJ1ZSkpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiA9ICh3YWxrRm4sIGNhcmV0UG9zaXRpb24pID0+IHtcbiAgICAgIGxldCBwb3MgPSBjYXJldFBvc2l0aW9uO1xuICAgICAgd2hpbGUgKHBvcyA9IHdhbGtGbihwb3MpKSB7XG4gICAgICAgIGlmIChwb3MuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgY29uc3QgaXNNb3ZlSW5zaWRlU2FtZUJsb2NrID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCBpblNhbWVCbG9jayA9IGlzSW5TYW1lQmxvY2soZnJvbSwgdG8pO1xuICAgICAgaWYgKCFpblNhbWVCbG9jayAmJiBpc0JyJDYoZnJvbS5nZXROb2RlKCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluU2FtZUJsb2NrO1xuICAgIH07XG5cbiAgICB2YXIgSERpcmVjdGlvbjtcbiAgICAoZnVuY3Rpb24gKEhEaXJlY3Rpb24pIHtcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnQmFja3dhcmRzJ10gPSAtMV0gPSAnQmFja3dhcmRzJztcbiAgICAgIEhEaXJlY3Rpb25bSERpcmVjdGlvblsnRm9yd2FyZHMnXSA9IDFdID0gJ0ZvcndhcmRzJztcbiAgICB9KEhEaXJlY3Rpb24gfHwgKEhEaXJlY3Rpb24gPSB7fSkpKTtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDYgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgaXNUZXh0JDMgPSBpc1RleHQkYTtcbiAgICBjb25zdCBpc0VsZW1lbnQkMSA9IGlzRWxlbWVudCQ2O1xuICAgIGNvbnN0IGlzQnIkMiA9IGlzQnIkNjtcbiAgICBjb25zdCBpc0NhcmV0Q2FuZGlkYXRlID0gaXNDYXJldENhbmRpZGF0ZSQzO1xuICAgIGNvbnN0IGlzQXRvbWljID0gaXNBdG9taWMkMTtcbiAgICBjb25zdCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUgPSBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMTtcbiAgICBjb25zdCBnZXRQYXJlbnRzJDMgPSAobm9kZSwgcm9vdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSAmJiB0ZW1wTm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBwYXJlbnRzLnB1c2godGVtcE5vZGUpO1xuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9O1xuICAgIGNvbnN0IG5vZGVBdEluZGV4ID0gKGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENhcmV0Q2FuZGlkYXRlUG9zaXRpb24gPSAoZGlyZWN0aW9uLCBub2RlKSA9PiB7XG4gICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChpc0NhcmV0Q2FuZGlkYXRlKG5vZGUucHJldmlvdXNTaWJsaW5nKSAmJiAhaXNUZXh0JDMobm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHQkMyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKG5vZGUsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShub2RlLm5leHRTaWJsaW5nKSAmJiAhaXNUZXh0JDMobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JDMobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgaWYgKGlzQnIkMihub2RlKSkge1xuICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVGb3J3YXJkRnJvbUJyID0gKHJvb3QsIG5leHROb2RlKSA9PiB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICYmIGlzQ2FyZXRDYW5kaWRhdGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChpc1RleHQkMyhuZXh0U2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0U2libGluZywgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSksIHJvb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb24kMSA9IChkaXJlY3Rpb24sIHN0YXJ0UG9zLCByb290KSA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBuZXh0Tm9kZTtcbiAgICAgIGxldCBpbm5lck5vZGU7XG4gICAgICBsZXQgY2FyZXRQb3NpdGlvbjtcbiAgICAgIGlmICghaXNFbGVtZW50JDEocm9vdCkgfHwgIXN0YXJ0UG9zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0UG9zLmlzRXF1YWwoQ2FyZXRQb3NpdGlvbi5hZnRlcihyb290KSkgJiYgcm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdC5sYXN0Q2hpbGQpO1xuICAgICAgICBpZiAoaXNCYWNrd2FyZHMoZGlyZWN0aW9uKSAmJiBpc0NhcmV0Q2FuZGlkYXRlKHJvb3QubGFzdENoaWxkKSAmJiBpc0VsZW1lbnQkMShyb290Lmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gaXNCciQyKHJvb3QubGFzdENoaWxkKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHJvb3QubGFzdENoaWxkKSA6IGNhcmV0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcmV0UG9zaXRpb24gPSBzdGFydFBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhcmV0UG9zaXRpb24uY29udGFpbmVyKCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gY2FyZXRQb3NpdGlvbi5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkMyhjb250YWluZXIpKSB7XG4gICAgICAgIGlmIChpc0JhY2t3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIC0tb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIG9mZnNldCA8IGNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsICsrb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgIG5leHROb2RlID0gbm9kZUF0SW5kZXgoY29udGFpbmVyLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghaXNBdG9taWMobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGlubmVyTm9kZSA9IGZpbmROb2RlKG5leHROb2RlLCBkaXJlY3Rpb24sIGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZSwgbmV4dE5vZGUpO1xuICAgICAgICAgICAgICBpZiAoaW5uZXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCQzKGlubmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKGlubmVyTm9kZSwgaW5uZXJOb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYWZ0ZXIoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQzKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgbmV4dE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24uYmVmb3JlKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9yd2FyZHMoZGlyZWN0aW9uKSAmJiBvZmZzZXQgPCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGVBdEluZGV4KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChpc0JyJDIobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb3ZlRm9yd2FyZEZyb21Ccihyb290LCBuZXh0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQXRvbWljKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICBpbm5lck5vZGUgPSBmaW5kTm9kZShuZXh0Tm9kZSwgZGlyZWN0aW9uLCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUsIG5leHROb2RlKTtcbiAgICAgICAgICAgICAgaWYgKGlubmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMyhpbm5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihpbm5lck5vZGUsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVGV4dCQzKG5leHROb2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihuZXh0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXh0Tm9kZSA/IG5leHROb2RlIDogY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAmJiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pICYmIGNhcmV0UG9zaXRpb24uaXNBdEVuZCgpIHx8IGlzQmFja3dhcmRzKGRpcmVjdGlvbikgJiYgY2FyZXRQb3NpdGlvbi5pc0F0U3RhcnQoKSkpIHtcbiAgICAgICAgbm9kZSA9IGZpbmROb2RlKG5vZGUsIGRpcmVjdGlvbiwgYWx3YXlzLCByb290LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzRWRpdGFibGVDYXJldENhbmRpZGF0ZShub2RlLCByb290KSkge1xuICAgICAgICAgIHJldHVybiBnZXRDYXJldENhbmRpZGF0ZVBvc2l0aW9uKGRpcmVjdGlvbiwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHROb2RlID0gbm9kZSA/IGZpbmROb2RlKG5vZGUsIGRpcmVjdGlvbiwgaXNFZGl0YWJsZUNhcmV0Q2FuZGlkYXRlLCByb290KSA6IG5vZGU7XG4gICAgICBjb25zdCByb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0gPSBsYXN0JDIoZmlsdGVyJDUoZ2V0UGFyZW50cyQzKGNvbnRhaW5lciwgcm9vdCksIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNikpO1xuICAgICAgaWYgKHJvb3RDb250ZW50RWRpdGFibGVGYWxzZUVsbSAmJiAoIW5leHROb2RlIHx8ICFyb290Q29udGVudEVkaXRhYmxlRmFsc2VFbG0uY29udGFpbnMobmV4dE5vZGUpKSkge1xuICAgICAgICBpZiAoaXNGb3J3YXJkcyhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uYWZ0ZXIocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUocm9vdENvbnRlbnRFZGl0YWJsZUZhbHNlRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2FyZXRDYW5kaWRhdGVQb3NpdGlvbihkaXJlY3Rpb24sIG5leHROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgQ2FyZXRXYWxrZXIgPSByb290ID0+ICh7XG4gICAgICBuZXh0OiBjYXJldFBvc2l0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmRDYXJldFBvc2l0aW9uJDEoSERpcmVjdGlvbi5Gb3J3YXJkcywgY2FyZXRQb3NpdGlvbiwgcm9vdCk7XG4gICAgICB9LFxuICAgICAgcHJldjogY2FyZXRQb3NpdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiBmaW5kQ2FyZXRQb3NpdGlvbiQxKEhEaXJlY3Rpb24uQmFja3dhcmRzLCBjYXJldFBvc2l0aW9uLCByb290KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHdhbGtUb1Bvc2l0aW9uSW4gPSAoZm9yd2FyZCwgcm9vdCwgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uYmVmb3JlKHN0YXJ0KSA6IENhcmV0UG9zaXRpb24uYWZ0ZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCBhZnRlckVsZW1lbnQgPSBub2RlID0+IGlzQnIkNihub2RlKSA/IENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpIDogQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICBjb25zdCBpc0JlZm9yZU9yU3RhcnQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uLm9mZnNldCgpID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQ2FyZXRDYW5kaWRhdGUkMyhwb3NpdGlvbi5nZXROb2RlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNBZnRlck9yRW5kID0gcG9zaXRpb24gPT4ge1xuICAgICAgaWYgKENhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvc2l0aW9uLmNvbnRhaW5lcigpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24ub2Zmc2V0KCkgPT09IGNvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0NhcmV0Q2FuZGlkYXRlJDMocG9zaXRpb24uZ2V0Tm9kZSh0cnVlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUFmdGVyU2FtZUVsZW1lbnQgPSAoZnJvbSwgdG8pID0+ICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKGZyb20pICYmICFDYXJldFBvc2l0aW9uLmlzVGV4dFBvc2l0aW9uKHRvKSAmJiBmcm9tLmdldE5vZGUoKSA9PT0gdG8uZ2V0Tm9kZSh0cnVlKTtcbiAgICBjb25zdCBpc0F0QnIgPSBwb3NpdGlvbiA9PiAhQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3NpdGlvbikgJiYgaXNCciQ2KHBvc2l0aW9uLmdldE5vZGUoKSk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFBvc2l0aW9uID0gKGZvcndhcmQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gIWlzQmVmb3JlQWZ0ZXJTYW1lRWxlbWVudChmcm9tLCB0bykgJiYgIWlzQXRCcihmcm9tKSAmJiBpc0FmdGVyT3JFbmQoZnJvbSkgJiYgaXNCZWZvcmVPclN0YXJ0KHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNCZWZvcmVBZnRlclNhbWVFbGVtZW50KHRvLCBmcm9tKSAmJiBpc0JlZm9yZU9yU3RhcnQoZnJvbSkgJiYgaXNBZnRlck9yRW5kKHRvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZyb21Qb3NpdGlvbiA9IChmb3J3YXJkLCByb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3QpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZm9yd2FyZCA/IHdhbGtlci5uZXh0KHBvcykgOiB3YWxrZXIucHJldihwb3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IG5hdmlnYXRlID0gKGZvcndhcmQsIHJvb3QsIGZyb20pID0+IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290LCBmcm9tKS5iaW5kKHRvID0+IHtcbiAgICAgIGlmIChpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KSAmJiBzaG91bGRTa2lwUG9zaXRpb24oZm9yd2FyZCwgZnJvbSwgdG8pKSB7XG4gICAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdCwgdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUodG8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlSWdub3JlID0gKGZvcndhcmQsIHJvb3QsIGZyb20sIGlnbm9yZUZpbHRlcikgPT4gbmF2aWdhdGUoZm9yd2FyZCwgcm9vdCwgZnJvbSkuYmluZChwb3MgPT4gaWdub3JlRmlsdGVyKHBvcykgPyBuYXZpZ2F0ZUlnbm9yZShmb3J3YXJkLCByb290LCBwb3MsIGlnbm9yZUZpbHRlcikgOiBPcHRpb25hbC5zb21lKHBvcykpO1xuICAgIGNvbnN0IHBvc2l0aW9uSW4gPSAoZm9yd2FyZCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gZm9yd2FyZCA/IGVsZW1lbnQuZmlyc3RDaGlsZCA6IGVsZW1lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGlzVGV4dCRhKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihzdGFydE5vZGUsIGZvcndhcmQgPyAwIDogc3RhcnROb2RlLmRhdGEubGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0Tm9kZSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoc3RhcnROb2RlKSA6IGFmdGVyRWxlbWVudChzdGFydE5vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gd2Fsa1RvUG9zaXRpb25Jbihmb3J3YXJkLCBlbGVtZW50LCBzdGFydE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbmV4dFBvc2l0aW9uID0gY3VycnkoZnJvbVBvc2l0aW9uLCB0cnVlKTtcbiAgICBjb25zdCBwcmV2UG9zaXRpb24gPSBjdXJyeShmcm9tUG9zaXRpb24sIGZhbHNlKTtcbiAgICBjb25zdCBmaXJzdFBvc2l0aW9uSW4gPSBjdXJyeShwb3NpdGlvbkluLCB0cnVlKTtcbiAgICBjb25zdCBsYXN0UG9zaXRpb25JbiA9IGN1cnJ5KHBvc2l0aW9uSW4sIGZhbHNlKTtcblxuICAgIGNvbnN0IENBUkVUX0lEID0gJ19tY2VfY2FyZXQnO1xuICAgIGNvbnN0IGlzQ2FyZXROb2RlID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmlkID09PSBDQVJFVF9JRDtcbiAgICBjb25zdCBnZXRQYXJlbnRDYXJldENvbnRhaW5lciA9IChib2R5LCBub2RlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlICE9PSBib2R5KSB7XG4gICAgICAgIGlmIChpc0NhcmV0Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzU3RyaW5nUGF0aEJvb2ttYXJrID0gYm9va21hcmsgPT4gaXNTdHJpbmcoYm9va21hcmsuc3RhcnQpO1xuICAgIGNvbnN0IGlzUmFuZ2VCb29rbWFyayA9IGJvb2ttYXJrID0+IGhhcyQyKGJvb2ttYXJrLCAncm5nJyk7XG4gICAgY29uc3QgaXNJZEJvb2ttYXJrID0gYm9va21hcmsgPT4gaGFzJDIoYm9va21hcmssICdpZCcpO1xuICAgIGNvbnN0IGlzSW5kZXhCb29rbWFyayA9IGJvb2ttYXJrID0+IGhhcyQyKGJvb2ttYXJrLCAnbmFtZScpO1xuICAgIGNvbnN0IGlzUGF0aEJvb2ttYXJrID0gYm9va21hcmsgPT4gVG9vbHMuaXNBcnJheShib29rbWFyay5zdGFydCk7XG5cbiAgICBjb25zdCBpc0ZvcndhcmRCb29rbWFyayA9IGJvb2ttYXJrID0+ICFpc0luZGV4Qm9va21hcmsoYm9va21hcmspICYmIGlzQm9vbGVhbihib29rbWFyay5mb3J3YXJkKSA/IGJvb2ttYXJrLmZvcndhcmQgOiB0cnVlO1xuICAgIGNvbnN0IGFkZEJvZ3VzID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpICYmIGRvbS5pc0Jsb2NrKG5vZGUpICYmICFub2RlLmlubmVySFRNTCkge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCIgLz4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlQ2FyZXRQb3NpdGlvbkJvb2ttYXJrID0gKGRvbSwgYm9va21hcmspID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gT3B0aW9uYWwuZnJvbShyZXNvbHZlJDEoZG9tLmdldFJvb3QoKSwgYm9va21hcmsuc3RhcnQpKTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IE9wdGlvbmFsLmZyb20ocmVzb2x2ZSQxKGRvbS5nZXRSb290KCksIGJvb2ttYXJrLmVuZCkpO1xuICAgICAgcmV0dXJuIGxpZnQyKHN0YXJ0UG9zLCBlbmRQb3MsIChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydC5jb250YWluZXIoKSwgc3RhcnQub2Zmc2V0KCkpO1xuICAgICAgICByYW5nZS5zZXRFbmQoZW5kLmNvbnRhaW5lcigpLCBlbmQub2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRad3NwID0gKG5vZGUsIHJuZykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZG9jID0gKF9hID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudDtcbiAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKFpXU1AkMSk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgIHJuZy5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICBybmcuc2V0RW5kKHRleHROb2RlLCAwKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkkMSA9IG5vZGUgPT4gIW5vZGUuaGFzQ2hpbGROb2RlcygpO1xuICAgIGNvbnN0IHRyeUZpbmRSYW5nZVBvc2l0aW9uID0gKG5vZGUsIHJuZykgPT4gbGFzdFBvc2l0aW9uSW4obm9kZSkuZm9sZChuZXZlciwgcG9zID0+IHtcbiAgICAgIHJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICBybmcuc2V0RW5kKHBvcy5jb250YWluZXIoKSwgcG9zLm9mZnNldCgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhZEVtcHR5Q2FyZXRDb250YWluZXIgPSAocm9vdCwgbm9kZSwgcm5nKSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQxKG5vZGUpICYmIGdldFBhcmVudENhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUpKSB7XG4gICAgICAgIGluc2VydFp3c3Aobm9kZSwgcm5nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRFbmRQb2ludCA9IChkb20sIHN0YXJ0LCBib29rbWFyaywgcm5nKSA9PiB7XG4gICAgICBjb25zdCBwb2ludCA9IGJvb2ttYXJrW3N0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnXTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIGxldCBub2RlID0gcm9vdDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHBvaW50WzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9pbnQubGVuZ3RoIC0gMTsgbm9kZSAmJiBpID49IDE7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgIGlmIChwYWRFbXB0eUNhcmV0Q29udGFpbmVyKHJvb3QsIG5vZGUsIHJuZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9pbnRbaV0gPiBjaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAocGFkRW1wdHlDYXJldENvbnRhaW5lcihyb290LCBub2RlLCBybmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeUZpbmRSYW5nZVBvc2l0aW9uKG5vZGUsIHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBjaGlsZHJlbltwb2ludFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ocG9pbnRbMF0sIG5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKHBvaW50WzBdLCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybmcuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZFRleHROb2RlID0gbm9kZSA9PiBpc1RleHQkYShub2RlKSAmJiBub2RlLmRhdGEubGVuZ3RoID4gMDtcbiAgICBjb25zdCByZXN0b3JlRW5kUG9pbnQgPSAoZG9tLCBzdWZmaXgsIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXIgPSBkb20uZ2V0KGJvb2ttYXJrLmlkICsgJ18nICsgc3VmZml4KTtcbiAgICAgIGNvbnN0IG1hcmtlclBhcmVudCA9IG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5wYXJlbnROb2RlO1xuICAgICAgY29uc3Qga2VlcCA9IGJvb2ttYXJrLmtlZXA7XG4gICAgICBpZiAobWFya2VyICYmIG1hcmtlclBhcmVudCkge1xuICAgICAgICBsZXQgY29udGFpbmVyO1xuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAoc3VmZml4ID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXJQYXJlbnQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXJrZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IG1hcmtlci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkVGV4dE5vZGUobWFya2VyLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRUZXh0Tm9kZShtYXJrZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyUGFyZW50O1xuICAgICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcikgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG1hcmtlclBhcmVudDtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbS5ub2RlSW5kZXgobWFya2VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hcmtlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRUZXh0Tm9kZShtYXJrZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBvZmZzZXQgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gbWFya2VyUGFyZW50O1xuICAgICAgICAgICAgICBvZmZzZXQgPSBkb20ubm9kZUluZGV4KG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXJrZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgVG9vbHMuZWFjaChUb29scy5ncmVwKG1hcmtlci5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLnJlcGxhY2UoL1xcdUZFRkYvZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBvdGhlck1hcmtlcjtcbiAgICAgICAgICB3aGlsZSAob3RoZXJNYXJrZXIgPSBkb20uZ2V0KGJvb2ttYXJrLmlkICsgJ18nICsgc3VmZml4KSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShvdGhlck1hcmtlciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RleHQkYShuZXh0KSAmJiBpc1RleHQkYShwcmV2KSAmJiAhRW52LmJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwcmV2LmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcHJldi5hcHBlbmREYXRhKG5leHQuZGF0YSk7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKG5leHQpO1xuICAgICAgICAgICAgY29udGFpbmVyID0gcHJldjtcbiAgICAgICAgICAgIG9mZnNldCA9IGlkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVQYXRocyA9IChkb20sIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIGlmIChzZXRFbmRQb2ludChkb20sIHRydWUsIGJvb2ttYXJrLCByYW5nZSkgJiYgc2V0RW5kUG9pbnQoZG9tLCBmYWxzZSwgYm9va21hcmssIHJhbmdlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgZm9yd2FyZDogaXNGb3J3YXJkQm9va21hcmsoYm9va21hcmspXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVJZCA9IChkb20sIGJvb2ttYXJrKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFBvcyA9IHJlc3RvcmVFbmRQb2ludChkb20sICdzdGFydCcsIGJvb2ttYXJrKTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IHJlc3RvcmVFbmRQb2ludChkb20sICdlbmQnLCBib29rbWFyayk7XG4gICAgICByZXR1cm4gbGlmdDIoc3RhcnRQb3MsIGVuZFBvcy5vcihzdGFydFBvcyksIChzcG9zLCBlcG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChhZGRCb2d1cyhkb20sIHNwb3MuY29udGFpbmVyKCkpLCBzcG9zLm9mZnNldCgpKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKGFkZEJvZ3VzKGRvbSwgZXBvcy5jb250YWluZXIoKSksIGVwb3Mub2Zmc2V0KCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlSW5kZXggPSAoZG9tLCBib29rbWFyaykgPT4gT3B0aW9uYWwuZnJvbShkb20uc2VsZWN0KGJvb2ttYXJrLm5hbWUpW2Jvb2ttYXJrLmluZGV4XSkubWFwKGVsbSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZWxtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlLFxuICAgICAgICBmb3J3YXJkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoc2VsZWN0aW9uLCBib29rbWFyaykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gc2VsZWN0aW9uLmRvbTtcbiAgICAgIGlmIChib29rbWFyaykge1xuICAgICAgICBpZiAoaXNQYXRoQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVQYXRocyhkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ1BhdGhCb29rbWFyayhib29rbWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZUNhcmV0UG9zaXRpb25Cb29rbWFyayhkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0lkQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVJZChkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0luZGV4Qm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVJbmRleChkb20sIGJvb2ttYXJrKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1JhbmdlQm9va21hcmsoYm9va21hcmspKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgcmFuZ2U6IGJvb2ttYXJrLnJuZyxcbiAgICAgICAgICAgIGZvcndhcmQ6IGlzRm9yd2FyZEJvb2ttYXJrKGJvb2ttYXJrKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRCb29rbWFyayQxID0gKHNlbGVjdGlvbiwgdHlwZSwgbm9ybWFsaXplZCkgPT4ge1xuICAgICAgcmV0dXJuIGdldEJvb2ttYXJrJDIoc2VsZWN0aW9uLCB0eXBlLCBub3JtYWxpemVkKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb0Jvb2ttYXJrID0gKHNlbGVjdGlvbiwgYm9va21hcmspID0+IHtcbiAgICAgIHJlc29sdmUoc2VsZWN0aW9uLCBib29rbWFyaykuZWFjaCgoe3JhbmdlLCBmb3J3YXJkfSkgPT4ge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNCb29rbWFya05vZGUkMSA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUudGFnTmFtZSA9PT0gJ1NQQU4nICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS10eXBlJykgPT09ICdib29rbWFyayc7XG4gICAgfTtcblxuICAgIGNvbnN0IGlzID0gZXhwZWN0ZWQgPT4gYWN0dWFsID0+IGV4cGVjdGVkID09PSBhY3R1YWw7XG4gICAgY29uc3QgaXNOYnNwID0gaXMobmJzcCk7XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlID0gY2hyID0+IGNociAhPT0gJycgJiYgJyBcXGZcXG5cXHJcXHRcXHgwQicuaW5kZXhPZihjaHIpICE9PSAtMTtcbiAgICBjb25zdCBpc0NvbnRlbnQgPSBjaHIgPT4gIWlzV2hpdGVTcGFjZShjaHIpICYmICFpc05ic3AoY2hyKSAmJiAhaXNad3NwJDIoY2hyKTtcblxuICAgIGNvbnN0IGhleENvbG91ciA9IHZhbHVlID0+ICh7IHZhbHVlOiBub3JtYWxpemVIZXgodmFsdWUpIH0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZUhleCA9IGhleCA9PiByZW1vdmVMZWFkaW5nKGhleCwgJyMnKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHRvSGV4ID0gY29tcG9uZW50ID0+IHtcbiAgICAgIGNvbnN0IGhleCA9IGNvbXBvbmVudC50b1N0cmluZygxNik7XG4gICAgICByZXR1cm4gKGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXgpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tUmdiYSA9IHJnYmFDb2xvdXIgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0hleChyZ2JhQ29sb3VyLnJlZCkgKyB0b0hleChyZ2JhQ29sb3VyLmdyZWVuKSArIHRvSGV4KHJnYmFDb2xvdXIuYmx1ZSk7XG4gICAgICByZXR1cm4gaGV4Q29sb3VyKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmdiUmVnZXggPSAvXlxccypyZ2JcXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXClcXHMqJC9pO1xuICAgIGNvbnN0IHJnYmFSZWdleCA9IC9eXFxzKnJnYmFcXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccypcXClcXHMqJC9pO1xuICAgIGNvbnN0IHJnYmFDb2xvdXIgPSAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpID0+ICh7XG4gICAgICByZWQsXG4gICAgICBncmVlbixcbiAgICAgIGJsdWUsXG4gICAgICBhbHBoYVxuICAgIH0pO1xuICAgIGNvbnN0IGZyb21TdHJpbmdWYWx1ZXMgPSAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUludChyZWQsIDEwKTtcbiAgICAgIGNvbnN0IGcgPSBwYXJzZUludChncmVlbiwgMTApO1xuICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGJsdWUsIDEwKTtcbiAgICAgIGNvbnN0IGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcbiAgICAgIHJldHVybiByZ2JhQ29sb3VyKHIsIGcsIGIsIGEpO1xuICAgIH07XG4gICAgY29uc3QgZnJvbVN0cmluZyA9IHJnYmFTdHJpbmcgPT4ge1xuICAgICAgaWYgKHJnYmFTdHJpbmcgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocmdiYUNvbG91cigwLCAwLCAwLCAwKSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZ2JNYXRjaCA9IHJnYlJlZ2V4LmV4ZWMocmdiYVN0cmluZyk7XG4gICAgICBpZiAocmdiTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZnJvbVN0cmluZ1ZhbHVlcyhyZ2JNYXRjaFsxXSwgcmdiTWF0Y2hbMl0sIHJnYk1hdGNoWzNdLCAnMScpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJnYmFNYXRjaCA9IHJnYmFSZWdleC5leGVjKHJnYmFTdHJpbmcpO1xuICAgICAgaWYgKHJnYmFNYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShmcm9tU3RyaW5nVmFsdWVzKHJnYmFNYXRjaFsxXSwgcmdiYU1hdGNoWzJdLCByZ2JhTWF0Y2hbM10sIHJnYmFNYXRjaFs0XSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmdiYVRvSGV4U3RyaW5nID0gY29sb3IgPT4gZnJvbVN0cmluZyhjb2xvcikubWFwKGZyb21SZ2JhKS5tYXAoaCA9PiAnIycgKyBoLnZhbHVlKS5nZXRPcihjb2xvcik7XG5cbiAgICBjb25zdCBnZXRSYW5nZXMkMSA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgcmFuZ2VzLnB1c2goc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWROb2RlcyA9IHJhbmdlcyA9PiB7XG4gICAgICByZXR1cm4gYmluZCQzKHJhbmdlcywgcmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZ2V0U2VsZWN0ZWROb2RlKHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIG5vZGUgPyBbU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSldIDogW107XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIHJldHVybiBnZXRSYW5nZXMkMShzZWxlY3Rpb24pLmxlbmd0aCA+IDE7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENlbGxzRnJvbVJhbmdlcyA9IHJhbmdlcyA9PiBmaWx0ZXIkNShnZXRTZWxlY3RlZE5vZGVzKHJhbmdlcyksIGlzVGFibGVDZWxsJDIpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnQgPSBlbG0gPT4gZGVzY2VuZGFudHMoZWxtLCAndGRbZGF0YS1tY2Utc2VsZWN0ZWRdLHRoW2RhdGEtbWNlLXNlbGVjdGVkXScpO1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVsZW1lbnRPclJhbmdlcyA9IChyYW5nZXMsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCA/IHNlbGVjdGVkQ2VsbHMgOiBnZXRDZWxsc0Zyb21SYW5nZXMocmFuZ2VzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENlbGxzRnJvbUVkaXRvciA9IGVkaXRvciA9PiBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMoZ2V0UmFuZ2VzJDEoZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKSksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0VGFibGUgPSAoY2VsbCwgaXNSb290KSA9PiBhbmNlc3RvciQzKGNlbGwsICd0YWJsZScsIGlzUm9vdCk7XG5cbiAgICBjb25zdCBnZXRTdGFydE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3Qgc2MgPSBybmcuc3RhcnRDb250YWluZXIsIHNvID0gcm5nLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKGlzVGV4dCRhKHNjKSkge1xuICAgICAgICByZXR1cm4gc28gPT09IDAgPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHNjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShzYy5jaGlsZE5vZGVzW3NvXSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEVuZE5vZGUgPSBybmcgPT4ge1xuICAgICAgY29uc3QgZWMgPSBybmcuZW5kQ29udGFpbmVyLCBlbyA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBpZiAoaXNUZXh0JGEoZWMpKSB7XG4gICAgICAgIHJldHVybiBlbyA9PT0gZWMuZGF0YS5sZW5ndGggPyBPcHRpb25hbC5zb21lKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVjKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShlYy5jaGlsZE5vZGVzW2VvIC0gMV0pLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaXJzdENoaWxkcmVuID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gZmlyc3RDaGlsZChub2RlKS5mb2xkKGNvbnN0YW50KFtub2RlXSksIGNoaWxkID0+IHtcbiAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0Rmlyc3RDaGlsZHJlbihjaGlsZCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRMYXN0Q2hpbGRyZW4gPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBsYXN0Q2hpbGQobm9kZSkuZm9sZChjb25zdGFudChbbm9kZV0pLCBjaGlsZCA9PiB7XG4gICAgICAgIGlmIChuYW1lKGNoaWxkKSA9PT0gJ2JyJykge1xuICAgICAgICAgIHJldHVybiBwcmV2U2libGluZyhjaGlsZCkubWFwKHNpYmxpbmcgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0TGFzdENoaWxkcmVuKHNpYmxpbmcpKTtcbiAgICAgICAgICB9KS5nZXRPcihbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXS5jb25jYXQoZ2V0TGFzdENoaWxkcmVuKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaGFzQWxsQ29udGVudHNTZWxlY3RlZCA9IChlbG0sIHJuZykgPT4ge1xuICAgICAgcmV0dXJuIGxpZnQyKGdldFN0YXJ0Tm9kZShybmcpLCBnZXRFbmROb2RlKHJuZyksIChzdGFydE5vZGUsIGVuZE5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kJDIoZ2V0Rmlyc3RDaGlsZHJlbihlbG0pLCBjdXJyeShlcSwgc3RhcnROb2RlKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZpbmQkMihnZXRMYXN0Q2hpbGRyZW4oZWxtKSwgY3VycnkoZXEsIGVuZE5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmlzU29tZSgpICYmIGVuZC5pc1NvbWUoKTtcbiAgICAgIH0pLmdldE9yKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVFbmRQb2ludCA9IChkb20sIHJuZywgbm9kZSwgc3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBub2RlO1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIobm9kZSwgcm9vdCk7XG4gICAgICBjb25zdCBtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXAgPSBmaWx0ZXIkNChkb20uc2NoZW1hLmdldE1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50cygpLCAoXywgbmFtZSkgPT4gIWNvbnRhaW5zJDIoW1xuICAgICAgICAndGQnLFxuICAgICAgICAndGgnLFxuICAgICAgICAndGFibGUnXG4gICAgICBdLCBuYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpc1RleHQkYShjdXJyZW50Tm9kZSkgJiYgVG9vbHMudHJpbShjdXJyZW50Tm9kZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChjdXJyZW50Tm9kZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoY3VycmVudE5vZGUsIGN1cnJlbnROb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXBbY3VycmVudE5vZGUubm9kZU5hbWVdKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgICAgcm5nLnNldEVuZEJlZm9yZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBybmcuc2V0RW5kQWZ0ZXIoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKGN1cnJlbnROb2RlID0gc3RhcnQgPyB3YWxrZXIubmV4dCgpIDogd2Fsa2VyLnByZXYoKSk7XG4gICAgICBpZiAocm9vdC5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIHJuZy5zZXRTdGFydChyb290LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybmcuc2V0RW5kKHJvb3QsIHJvb3QuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNBbnlSYW5nZXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgc2VsID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHNlbCkgJiYgc2VsLnJhbmdlQ291bnQgPiAwO1xuICAgIH07XG4gICAgY29uc3QgcnVuT25SYW5nZXMgPSAoZWRpdG9yLCBleGVjdXRvcikgPT4ge1xuICAgICAgY29uc3QgZmFrZVNlbGVjdGlvbk5vZGVzID0gZ2V0Q2VsbHNGcm9tRWRpdG9yKGVkaXRvcik7XG4gICAgICBpZiAoZmFrZVNlbGVjdGlvbk5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWFjaCRlKGZha2VTZWxlY3Rpb25Ob2RlcywgZWxlbSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGVsZW0uZG9tO1xuICAgICAgICAgIGNvbnN0IGZha2VOb2RlUm5nID0gZWRpdG9yLmRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBmYWtlTm9kZVJuZy5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgICBmYWtlTm9kZVJuZy5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgICAgICBleGVjdXRvcihmYWtlTm9kZVJuZywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY3V0b3IoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlc2VydmUgPSAoc2VsZWN0aW9uLCBmaWxsQm9va21hcmssIGV4ZWN1dG9yKSA9PiB7XG4gICAgICBjb25zdCBib29rbWFyayA9IGdldFBlcnNpc3RlbnRCb29rbWFyayhzZWxlY3Rpb24sIGZpbGxCb29rbWFyayk7XG4gICAgICBleGVjdXRvcihib29rbWFyayk7XG4gICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgIH07XG5cbiAgICBjb25zdCBpc05vZGUgPSBub2RlID0+IGlzTnVtYmVyKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5ub2RlVHlwZSk7XG4gICAgY29uc3QgaXNFbGVtZW50Tm9kZSQxID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlKSAmJiAhaXNDYXJldE5vZGUobm9kZSkgJiYgIWlzQm9ndXMkMihub2RlKTtcbiAgICBjb25zdCBpc0VsZW1lbnREaXJlY3RseVNlbGVjdGVkID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudE5vZGUkMShub2RlKSAmJiAhL14oVER8VEgpJC8udGVzdChub2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEF0dHIgPSBkb20uZ2V0QXR0cmliKG5vZGUsICdkYXRhLW1jZS1zZWxlY3RlZCcpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHNlbGVjdGVkQXR0ciwgMTApO1xuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0VkaXRhYmxlJDIgPSBlbG0gPT4gZWxtLmlzQ29udGVudEVkaXRhYmxlID09PSB0cnVlO1xuICAgIGNvbnN0IHByZXNlcnZlU2VsZWN0aW9uID0gKGVkaXRvciwgYWN0aW9uLCBzaG91bGRNb3ZlU3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHtzZWxlY3Rpb24sIGRvbX0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24gPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZEJlZm9yZU5vZGVOb25lZGl0YWJsZSA9IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24pO1xuICAgICAgcHJlc2VydmUoc2VsZWN0aW9uLCB0cnVlLCAoKSA9PiB7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBpc0JlZm9yZU5vZGVTdGlsbE5vbmVkaXRhYmxlID0gaXNTZWxlY3RlZEJlZm9yZU5vZGVOb25lZGl0YWJsZSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoc2VsZWN0ZWROb2RlQmVmb3JlQWN0aW9uKTtcbiAgICAgIGlmIChpc0JlZm9yZU5vZGVTdGlsbE5vbmVkaXRhYmxlICYmIGRvbS5pc0NoaWxkT2Yoc2VsZWN0ZWROb2RlQmVmb3JlQWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpKSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChzZWxlY3RlZE5vZGVCZWZvcmVBY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRNb3ZlU3RhcnQoc2VsZWN0aW9uLmdldFN0YXJ0KCkpKSB7XG4gICAgICAgIG1vdmVTdGFydFRvTmVhcmVzdFRleHQoZG9tLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZVN0YXJ0VG9OZWFyZXN0VGV4dCA9IChkb20sIHNlbGVjdGlvbikgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHtzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChpc0VsZW1lbnREaXJlY3RseVNlbGVjdGVkKGRvbSwgc2VsZWN0ZWROb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDYoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gc3RhcnRDb250YWluZXIuY2hpbGROb2RlcztcbiAgICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgIGxldCB3YWxrZXI7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG5vZGVzW3N0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydE5vZGUsIChfYSA9IGRvbS5nZXRQYXJlbnQoc3RhcnROb2RlLCBkb20uaXNCbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHN0YXJ0Tm9kZSwgKF9iID0gZG9tLmdldFBhcmVudChzdGFydE5vZGUsIGRvbS5pc0Jsb2NrKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcm9vdCk7XG4gICAgICAgICAgd2Fsa2VyLm5leHQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHdhbGtlci5jdXJyZW50KCk7IG5vZGU7IG5vZGUgPSB3YWxrZXIubmV4dCgpKSB7XG4gICAgICAgICAgaWYgKGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCRhKG5vZGUpICYmICFpc1doaXRlU3BhY2VOb2RlJDEobm9kZSkpIHtcbiAgICAgICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldE5vbldoaXRlU3BhY2VTaWJsaW5nID0gKG5vZGUsIG5leHQsIGluYykgPT4ge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dE5hbWUgPSBuZXh0ID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnO1xuICAgICAgICBmb3IgKG5vZGUgPSBpbmMgPyBub2RlIDogbm9kZVtuZXh0TmFtZV07IG5vZGU7IG5vZGUgPSBub2RlW25leHROYW1lXSkge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSB8fCAhaXNXaGl0ZVNwYWNlTm9kZSQxKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBpc1RleHRCbG9jayQxID0gKHNjaGVtYSwgbm9kZSkgPT4gISFzY2hlbWEuZ2V0VGV4dEJsb2NrRWxlbWVudHMoKVtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGlzVHJhbnNwYXJlbnRCbG9jayhzY2hlbWEsIG5vZGUpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSAoZWQsIHBhcmVudCwgY2hpbGQpID0+IHtcbiAgICAgIHJldHVybiBlZC5zY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgIH07XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlTm9kZSQxID0gKG5vZGUsIGFsbG93U3BhY2VzID0gZmFsc2UpID0+IHtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKG5vZGUpICYmIGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbGxvd1NwYWNlcyA/IG5vZGUuZGF0YS5yZXBsYWNlKC8gL2csICdcXHhBMCcpIDogbm9kZS5kYXRhO1xuICAgICAgICByZXR1cm4gaXNXaGl0ZXNwYWNlVGV4dChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlUZXh0Tm9kZSQxID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBpc1RleHQkYShub2RlKSAmJiBub2RlLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGlzV3JhcE5vbmVkaXRhYmxlVGFyZ2V0ID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgYmFzZURhdGFTZWxlY3RvciA9ICdbZGF0YS1tY2UtY2VmLXdyYXBwYWJsZV0nO1xuICAgICAgY29uc3QgZm9ybWF0Tm9uZWRpdGFibGVTZWxlY3RvciA9IGdldEZvcm1hdE5vbmVkaXRhYmxlU2VsZWN0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gaXNFbXB0eSQzKGZvcm1hdE5vbmVkaXRhYmxlU2VsZWN0b3IpID8gYmFzZURhdGFTZWxlY3RvciA6IGAkeyBiYXNlRGF0YVNlbGVjdG9yIH0sJHsgZm9ybWF0Tm9uZWRpdGFibGVTZWxlY3RvciB9YDtcbiAgICAgIHJldHVybiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgICBjb25zdCBpc1dyYXBwYWJsZU5vbmVkaXRhYmxlID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIHJldHVybiBpc0VsZW1lbnROb2RlJDEobm9kZSkgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZShub2RlKSA9PT0gJ2ZhbHNlJyAmJiBpc1dyYXBOb25lZGl0YWJsZVRhcmdldChlZGl0b3IsIG5vZGUpICYmIGRvbS5zZWxlY3QoJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJywgbm9kZSkubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgcmVwbGFjZVZhcnMgPSAodmFsdWUsIHZhcnMpID0+IHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUodmFycyk7XG4gICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbGFibGUodmFycykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8lKFxcdyspL2csIChzdHIsIG5hbWUpID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFyc1tuYW1lXSB8fCBzdHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgY29uc3QgaXNFcSQ1ID0gKHN0cjEsIHN0cjIpID0+IHtcbiAgICAgIHN0cjEgPSBzdHIxIHx8ICcnO1xuICAgICAgc3RyMiA9IHN0cjIgfHwgJyc7XG4gICAgICBzdHIxID0gJycgKyAoc3RyMS5ub2RlTmFtZSB8fCBzdHIxKTtcbiAgICAgIHN0cjIgPSAnJyArIChzdHIyLm5vZGVOYW1lIHx8IHN0cjIpO1xuICAgICAgcmV0dXJuIHN0cjEudG9Mb3dlckNhc2UoKSA9PT0gc3RyMi50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplU3R5bGVWYWx1ZSA9ICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgaWYgKGlzTnVsbGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN0clZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicgfHwgbmFtZSA9PT0gJ2JhY2tncm91bmRDb2xvcicpIHtcbiAgICAgICAgICBzdHJWYWx1ZSA9IHJnYmFUb0hleFN0cmluZyhzdHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmb250V2VpZ2h0JyAmJiB2YWx1ZSA9PT0gNzAwKSB7XG4gICAgICAgICAgc3RyVmFsdWUgPSAnYm9sZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdmb250RmFtaWx5Jykge1xuICAgICAgICAgIHN0clZhbHVlID0gc3RyVmFsdWUucmVwbGFjZSgvW1xcJ1xcXCJdL2csICcnKS5yZXBsYWNlKC8sXFxzKy9nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFN0eWxlID0gKGRvbSwgbm9kZSwgbmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc3R5bGUgPSBkb20uZ2V0U3R5bGUobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU3R5bGVWYWx1ZShzdHlsZSwgbmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRUZXh0RGVjb3JhdGlvbiA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGxldCBkZWNvcmF0aW9uO1xuICAgICAgZG9tLmdldFBhcmVudChub2RlLCBuID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG4pKSB7XG4gICAgICAgICAgZGVjb3JhdGlvbiA9IGRvbS5nZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuICEhZGVjb3JhdGlvbiAmJiBkZWNvcmF0aW9uICE9PSAnbm9uZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZWNvcmF0aW9uO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50cyQyID0gKGRvbSwgbm9kZSwgc2VsZWN0b3IpID0+IHtcbiAgICAgIHJldHVybiBkb20uZ2V0UGFyZW50cyhub2RlLCBzZWxlY3RvciwgZG9tLmdldFJvb3QoKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0Zvcm1hdFByZWRpY2F0ZSA9IChlZGl0b3IsIGZvcm1hdE5hbWUsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KGZvcm1hdE5hbWUpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoZm9ybWF0cykgJiYgZXhpc3RzKGZvcm1hdHMsIHByZWRpY2F0ZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1ZhcmlhYmxlRm9ybWF0TmFtZSA9IChlZGl0b3IsIGZvcm1hdE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGhhc1ZhcmlhYmxlVmFsdWVzID0gZm9ybWF0ID0+IHtcbiAgICAgICAgY29uc3QgaXNWYXJpYWJsZVZhbHVlID0gdmFsID0+IGlzRnVuY3Rpb24odmFsKSB8fCB2YWwubGVuZ3RoID4gMSAmJiB2YWwuY2hhckF0KDApID09PSAnJSc7XG4gICAgICAgIHJldHVybiBleGlzdHMoW1xuICAgICAgICAgICdzdHlsZXMnLFxuICAgICAgICAgICdhdHRyaWJ1dGVzJ1xuICAgICAgICBdLCBrZXkgPT4gZ2V0JGEoZm9ybWF0LCBrZXkpLmV4aXN0cyhmaWVsZCA9PiB7XG4gICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBpc0FycmF5JDEoZmllbGQpID8gZmllbGQgOiB2YWx1ZXMoZmllbGQpO1xuICAgICAgICAgIHJldHVybiBleGlzdHMoZmllbGRWYWx1ZXMsIGlzVmFyaWFibGVWYWx1ZSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaXNGb3JtYXRQcmVkaWNhdGUoZWRpdG9yLCBmb3JtYXROYW1lLCBoYXNWYXJpYWJsZVZhbHVlcyk7XG4gICAgfTtcbiAgICBjb25zdCBhcmVTaW1pbGFyRm9ybWF0cyA9IChlZGl0b3IsIGZvcm1hdE5hbWUsIG90aGVyRm9ybWF0TmFtZSkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRLZXlzID0gW1xuICAgICAgICAnaW5saW5lJyxcbiAgICAgICAgJ2Jsb2NrJyxcbiAgICAgICAgJ3NlbGVjdG9yJyxcbiAgICAgICAgJ2F0dHJpYnV0ZXMnLFxuICAgICAgICAnc3R5bGVzJyxcbiAgICAgICAgJ2NsYXNzZXMnXG4gICAgICBdO1xuICAgICAgY29uc3QgZmlsdGVyT2JqID0gZm9ybWF0ID0+IGZpbHRlciQ0KGZvcm1hdCwgKF8sIGtleSkgPT4gZXhpc3RzKHZhbGlkS2V5cywgdmFsaWRLZXkgPT4gdmFsaWRLZXkgPT09IGtleSkpO1xuICAgICAgcmV0dXJuIGlzRm9ybWF0UHJlZGljYXRlKGVkaXRvciwgZm9ybWF0TmFtZSwgZm10MSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRm10MSA9IGZpbHRlck9iaihmbXQxKTtcbiAgICAgICAgcmV0dXJuIGlzRm9ybWF0UHJlZGljYXRlKGVkaXRvciwgb3RoZXJGb3JtYXROYW1lLCBmbXQyID0+IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZEZtdDIgPSBmaWx0ZXJPYmooZm10Mik7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsJDEoZmlsdGVyZWRGbXQxLCBmaWx0ZXJlZEZtdDIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNCbG9ja0Zvcm1hdCA9IGZvcm1hdCA9PiBoYXNOb25OdWxsYWJsZUtleShmb3JtYXQsICdibG9jaycpO1xuICAgIGNvbnN0IGlzV3JhcHBpbmdCbG9ja0Zvcm1hdCA9IGZvcm1hdCA9PiBpc0Jsb2NrRm9ybWF0KGZvcm1hdCkgJiYgZm9ybWF0LndyYXBwZXIgPT09IHRydWU7XG4gICAgY29uc3QgaXNOb25XcmFwcGluZ0Jsb2NrRm9ybWF0ID0gZm9ybWF0ID0+IGlzQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBmb3JtYXQud3JhcHBlciAhPT0gdHJ1ZTtcbiAgICBjb25zdCBpc1NlbGVjdG9yRm9ybWF0ID0gZm9ybWF0ID0+IGhhc05vbk51bGxhYmxlS2V5KGZvcm1hdCwgJ3NlbGVjdG9yJyk7XG4gICAgY29uc3QgaXNJbmxpbmVGb3JtYXQgPSBmb3JtYXQgPT4gaGFzTm9uTnVsbGFibGVLZXkoZm9ybWF0LCAnaW5saW5lJyk7XG4gICAgY29uc3QgaXNNaXhlZEZvcm1hdCA9IGZvcm1hdCA9PiBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBpcyQyKGdldCRhKGZvcm1hdCwgJ21peGVkJyksIHRydWUpO1xuICAgIGNvbnN0IHNob3VsZEV4cGFuZFRvU2VsZWN0b3IgPSBmb3JtYXQgPT4gaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5leHBhbmQgIT09IGZhbHNlICYmICFpc0lubGluZUZvcm1hdChmb3JtYXQpO1xuXG4gICAgY29uc3QgaXNCb29rbWFya05vZGUgPSBpc0Jvb2ttYXJrTm9kZSQxO1xuICAgIGNvbnN0IGdldFBhcmVudHMkMSA9IGdldFBhcmVudHMkMjtcbiAgICBjb25zdCBpc1doaXRlU3BhY2VOb2RlID0gaXNXaGl0ZVNwYWNlTm9kZSQxO1xuICAgIGNvbnN0IGlzVGV4dEJsb2NrID0gaXNUZXh0QmxvY2skMTtcbiAgICBjb25zdCBpc0JvZ3VzQnIgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBpc0JyJDYobm9kZSkgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgJiYgIW5vZGUubmV4dFNpYmxpbmc7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGFyZW50Q29udGVudEVkaXRhYmxlID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IG5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihwYXJlbnQpICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgPT09ICdmYWxzZScgPyBwYXJlbnQgOiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVGV4dCA9IChzdGFydCwgbm9kZSwgb2Zmc2V0LCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0ciA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShzdHIuY2hhckF0KGkgLSAxKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUoc3RyLmNoYXJBdChpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgY29uc3QgZmluZFNwYWNlID0gKHN0YXJ0LCBub2RlLCBvZmZzZXQpID0+IHdhbGtUZXh0KHN0YXJ0LCBub2RlLCBvZmZzZXQsIGMgPT4gaXNOYnNwKGMpIHx8IGlzV2hpdGVTcGFjZShjKSk7XG4gICAgY29uc3QgZmluZENvbnRlbnQgPSAoc3RhcnQsIG5vZGUsIG9mZnNldCkgPT4gd2Fsa1RleHQoc3RhcnQsIG5vZGUsIG9mZnNldCwgaXNDb250ZW50KTtcbiAgICBjb25zdCBmaW5kV29yZEVuZFBvaW50ID0gKGRvbSwgYm9keSwgY29udGFpbmVyLCBvZmZzZXQsIHN0YXJ0LCBpbmNsdWRlVHJhaWxpbmdTcGFjZXMpID0+IHtcbiAgICAgIGxldCBsYXN0VGV4dE5vZGU7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBkb20uaXNCbG9jaykgfHwgYm9keTtcbiAgICAgIGNvbnN0IHdhbGsgPSAoY29udGFpbmVyLCBvZmZzZXQsIHByZWQpID0+IHtcbiAgICAgICAgY29uc3QgdGV4dFNlZWtlciA9IFRleHRTZWVrZXIoZG9tKTtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gc3RhcnQgPyB0ZXh0U2Vla2VyLmJhY2t3YXJkcyA6IHRleHRTZWVrZXIuZm9yd2FyZHM7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHdhbGtlcihjb250YWluZXIsIG9mZnNldCwgKHRleHQsIHRleHRPZmZzZXQpID0+IHtcbiAgICAgICAgICBpZiAoaXNCb29rbWFya05vZGUodGV4dC5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0VGV4dE5vZGUgPSB0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHByZWQoc3RhcnQsIHRleHQsIHRleHRPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcm9vdE5vZGUpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzcGFjZVJlc3VsdCA9IHdhbGsoY29udGFpbmVyLCBvZmZzZXQsIGZpbmRTcGFjZSk7XG4gICAgICByZXR1cm4gc3BhY2VSZXN1bHQuYmluZChyZXN1bHQgPT4gaW5jbHVkZVRyYWlsaW5nU3BhY2VzID8gd2FsayhyZXN1bHQuY29udGFpbmVyLCByZXN1bHQub2Zmc2V0ICsgKHN0YXJ0ID8gLTEgOiAwKSwgZmluZENvbnRlbnQpIDogT3B0aW9uYWwuc29tZShyZXN1bHQpKS5vclRodW5rKCgpID0+IGxhc3RUZXh0Tm9kZSA/IE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICBjb250YWluZXI6IGxhc3RUZXh0Tm9kZSxcbiAgICAgICAgb2Zmc2V0OiBzdGFydCA/IDAgOiBsYXN0VGV4dE5vZGUubGVuZ3RoXG4gICAgICB9KSA6IE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kU2VsZWN0b3JFbmRQb2ludCA9IChkb20sIGZvcm1hdExpc3QsIHJuZywgY29udGFpbmVyLCBzaWJsaW5nTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZyA9IGNvbnRhaW5lcltzaWJsaW5nTmFtZV07XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSAmJiBpc0VtcHR5JDMoY29udGFpbmVyLmRhdGEpICYmIHNpYmxpbmcpIHtcbiAgICAgICAgY29udGFpbmVyID0gc2libGluZztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzJDEoZG9tLCBjb250YWluZXIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZm9ybWF0TGlzdC5sZW5ndGg7IHkrKykge1xuICAgICAgICAgIGNvbnN0IGN1ckZvcm1hdCA9IGZvcm1hdExpc3RbeV07XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY3VyRm9ybWF0LmNvbGxhcHNlZCkgJiYgY3VyRm9ybWF0LmNvbGxhcHNlZCAhPT0gcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NlbGVjdG9yRm9ybWF0KGN1ckZvcm1hdCkgJiYgZG9tLmlzKHBhcmVudHNbaV0sIGN1ckZvcm1hdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRCbG9ja0VuZFBvaW50ID0gKGRvbSwgZm9ybWF0TGlzdCwgY29udGFpbmVyLCBzaWJsaW5nTmFtZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXI7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdExpc3RbMF07XG4gICAgICBpZiAoaXNCbG9ja0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5vZGUgPSBmb3JtYXQud3JhcHBlciA/IG51bGwgOiBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZm9ybWF0LmJsb2NrLCByb290KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjb25zdCBzY29wZVJvb3QgPSAoX2EgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgJ0xJLFRELFRIJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvb3Q7XG4gICAgICAgIG5vZGUgPSBkb20uZ2V0UGFyZW50KGlzVGV4dCRhKGNvbnRhaW5lcikgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lciwgbm9kZSA9PiBub2RlICE9PSByb290ICYmIGlzVGV4dEJsb2NrKGRvbS5zY2hlbWEsIG5vZGUpLCBzY29wZVJvb3QpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgJiYgaXNCbG9ja0Zvcm1hdChmb3JtYXQpICYmIGZvcm1hdC53cmFwcGVyKSB7XG4gICAgICAgIG5vZGUgPSBnZXRQYXJlbnRzJDEoZG9tLCBub2RlLCAndWwsb2wnKS5yZXZlcnNlKClbMF0gfHwgbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gY29udGFpbmVyO1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlW3NpYmxpbmdOYW1lXSAmJiAhZG9tLmlzQmxvY2sobm9kZVtzaWJsaW5nTmFtZV0pKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVbc2libGluZ05hbWVdO1xuICAgICAgICAgIGlmIChpc0VxJDUobm9kZSwgJ2JyJykpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgfHwgY29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgaXNBdEJsb2NrQm91bmRhcnkkMSA9IChkb20sIHJvb3QsIGNvbnRhaW5lciwgc2libGluZ05hbWUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY29udGFpbmVyW3NpYmxpbmdOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQgPT09IHJvb3QgfHwgaXNOdWxsYWJsZShwYXJlbnQpIHx8IGRvbS5pc0Jsb2NrKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdEJsb2NrQm91bmRhcnkkMShkb20sIHJvb3QsIHBhcmVudCwgc2libGluZ05hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhcmVudENvbnRhaW5lciA9IChkb20sIGZvcm1hdExpc3QsIGNvbnRhaW5lciwgb2Zmc2V0LCBzdGFydCkgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHNpYmxpbmdOYW1lID0gc3RhcnQgPyAncHJldmlvdXNTaWJsaW5nJyA6ICduZXh0U2libGluZyc7XG4gICAgICBjb25zdCByb290ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpICYmICFpc1doaXRlU3BhY2VOb2RlKGNvbnRhaW5lcikpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID8gb2Zmc2V0ID4gMCA6IG9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXRMaXN0WzBdLmJsb2NrX2V4cGFuZCAmJiBkb20uaXNCbG9jayhwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzaWJsaW5nID0gcGFyZW50W3NpYmxpbmdOYW1lXTsgc2libGluZzsgc2libGluZyA9IHNpYmxpbmdbc2libGluZ05hbWVdKSB7XG4gICAgICAgICAgY29uc3QgYWxsb3dTcGFjZXMgPSBpc1RleHQkYShzaWJsaW5nKSAmJiAhaXNBdEJsb2NrQm91bmRhcnkkMShkb20sIHJvb3QsIHNpYmxpbmcsIHNpYmxpbmdOYW1lKTtcbiAgICAgICAgICBpZiAoIWlzQm9va21hcmtOb2RlKHNpYmxpbmcpICYmICFpc0JvZ3VzQnIoc2libGluZykgJiYgIWlzV2hpdGVTcGFjZU5vZGUoc2libGluZywgYWxsb3dTcGFjZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50ID09PSByb290IHx8IHBhcmVudC5wYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgY29udGFpbmVyID0gcGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGlzU2VsZk9yUGFyZW50Qm9va21hcmsgPSBjb250YWluZXIgPT4gaXNCb29rbWFya05vZGUoY29udGFpbmVyLnBhcmVudE5vZGUpIHx8IGlzQm9va21hcmtOb2RlKGNvbnRhaW5lcik7XG4gICAgY29uc3QgZXhwYW5kUm5nID0gKGRvbSwgcm5nLCBmb3JtYXRMaXN0LCBpbmNsdWRlVHJhaWxpbmdTcGFjZSA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQge3N0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFswXTtcbiAgICAgIGlmIChpc0VsZW1lbnQkNihzdGFydENvbnRhaW5lcikgJiYgc3RhcnRDb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZ2V0Tm9kZSQxKHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIGlmIChpc1RleHQkYShzdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihlbmRDb250YWluZXIpICYmIGVuZENvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgZW5kQ29udGFpbmVyID0gZ2V0Tm9kZSQxKGVuZENvbnRhaW5lciwgcm5nLmNvbGxhcHNlZCA/IGVuZE9mZnNldCA6IGVuZE9mZnNldCAtIDEpO1xuICAgICAgICBpZiAoaXNUZXh0JGEoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgIGVuZE9mZnNldCA9IGVuZENvbnRhaW5lci5kYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kUGFyZW50Q29udGVudEVkaXRhYmxlKGRvbSwgc3RhcnRDb250YWluZXIpO1xuICAgICAgZW5kQ29udGFpbmVyID0gZmluZFBhcmVudENvbnRlbnRFZGl0YWJsZShkb20sIGVuZENvbnRhaW5lcik7XG4gICAgICBpZiAoaXNTZWxmT3JQYXJlbnRCb29rbWFyayhzdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBpc0Jvb2ttYXJrTm9kZShzdGFydENvbnRhaW5lcikgPyBzdGFydENvbnRhaW5lciA6IHN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcgfHwgc3RhcnRDb250YWluZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5uZXh0U2libGluZyB8fCBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JGEoc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSBybmcuY29sbGFwc2VkID8gc3RhcnRDb250YWluZXIubGVuZ3RoIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZk9yUGFyZW50Qm9va21hcmsoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICBlbmRDb250YWluZXIgPSBpc0Jvb2ttYXJrTm9kZShlbmRDb250YWluZXIpID8gZW5kQ29udGFpbmVyIDogZW5kQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLm5leHRTaWJsaW5nIHx8IGVuZENvbnRhaW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmRDb250YWluZXIucHJldmlvdXNTaWJsaW5nIHx8IGVuZENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0JGEoZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgIGVuZE9mZnNldCA9IHJuZy5jb2xsYXBzZWQgPyAwIDogZW5kQ29udGFpbmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGZpbmRXb3JkRW5kUG9pbnQoZG9tLCBkb20uZ2V0Um9vdCgpLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHRydWUsIGluY2x1ZGVUcmFpbGluZ1NwYWNlKTtcbiAgICAgICAgc3RhcnRQb2ludC5lYWNoKCh7Y29udGFpbmVyLCBvZmZzZXR9KSA9PiB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmRQb2ludCA9IGZpbmRXb3JkRW5kUG9pbnQoZG9tLCBkb20uZ2V0Um9vdCgpLCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UsIGluY2x1ZGVUcmFpbGluZ1NwYWNlKTtcbiAgICAgICAgZW5kUG9pbnQuZWFjaCgoe2NvbnRhaW5lciwgb2Zmc2V0fSkgPT4ge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgZm9ybWF0LmJsb2NrX2V4cGFuZCkge1xuICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgKCFpc1RleHQkYShzdGFydENvbnRhaW5lcikgfHwgc3RhcnRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kUGFyZW50Q29udGFpbmVyKGRvbSwgZm9ybWF0TGlzdCwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgKCFpc1RleHQkYShlbmRDb250YWluZXIpIHx8IGVuZE9mZnNldCA9PT0gZW5kQ29udGFpbmVyLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gZmluZFNlbGVjdG9yRW5kUG9pbnQoZG9tLCBmb3JtYXRMaXN0LCBybmcsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRTZWxlY3RvckVuZFBvaW50KGRvbSwgZm9ybWF0TGlzdCwgcm5nLCBlbmRDb250YWluZXIsICduZXh0U2libGluZycpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSB8fCBpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIgPSBmaW5kQmxvY2tFbmRQb2ludChkb20sIGZvcm1hdExpc3QsIHN0YXJ0Q29udGFpbmVyLCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRCbG9ja0VuZFBvaW50KGRvbSwgZm9ybWF0TGlzdCwgZW5kQ29udGFpbmVyLCAnbmV4dFNpYmxpbmcnKTtcbiAgICAgICAgaWYgKGlzQmxvY2tGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGlmICghZG9tLmlzQmxvY2soc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRvbS5pc0Jsb2NrKGVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGZpbmRQYXJlbnRDb250YWluZXIoZG9tLCBmb3JtYXRMaXN0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KHN0YXJ0Q29udGFpbmVyKSAmJiBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gZG9tLm5vZGVJbmRleChzdGFydENvbnRhaW5lcik7XG4gICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihlbmRDb250YWluZXIpICYmIGVuZENvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVuZE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoZW5kQ29udGFpbmVyKSArIDE7XG4gICAgICAgIGVuZENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRDb250YWluZXIsXG4gICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRDb250YWluZXIsXG4gICAgICAgIGVuZE9mZnNldFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd2FsayQzID0gKGRvbSwgcm5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBzdGFydENvbnRhaW5lciA9IGdldE5vZGUkMShybmcuc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRDb250YWluZXIgPSBnZXROb2RlJDEocm5nLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0IC0gMSk7XG4gICAgICBjb25zdCBleGNsdWRlID0gbm9kZXMgPT4ge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGZpcnN0Tm9kZSkgJiYgZmlyc3ROb2RlID09PSBzdGFydENvbnRhaW5lciAmJiBzdGFydE9mZnNldCA+PSBmaXJzdE5vZGUuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBub2Rlcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCAmJiBub2Rlcy5sZW5ndGggPiAwICYmIGxhc3ROb2RlID09PSBlbmRDb250YWluZXIgJiYgaXNUZXh0JGEobGFzdE5vZGUpKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKG5vZGVzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBjb25zdCBjb2xsZWN0U2libGluZ3MgPSAobm9kZSwgbmFtZSwgZW5kTm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKDsgbm9kZSAmJiBub2RlICE9PSBlbmROb2RlOyBub2RlID0gbm9kZVtuYW1lXSkge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRFbmRQb2ludCA9IChub2RlLCByb290KSA9PiBkb20uZ2V0UGFyZW50KG5vZGUsIG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlID09PSByb290LCByb290KTtcbiAgICAgIGNvbnN0IHdhbGtCb3VuZGFyeSA9IChzdGFydE5vZGUsIGVuZE5vZGUsIG5leHQpID0+IHtcbiAgICAgICAgY29uc3Qgc2libGluZ05hbWUgPSBuZXh0ID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7IG5vZGUgJiYgbm9kZSAhPT0gZW5kTm9kZTsgbm9kZSA9IHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbGxlY3RTaWJsaW5ncyhub2RlID09PSBzdGFydE5vZGUgPyBub2RlIDogbm9kZVtzaWJsaW5nTmFtZV0sIHNpYmxpbmdOYW1lKTtcbiAgICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgc2libGluZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXhjbHVkZShzaWJsaW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhleGNsdWRlKFtzdGFydENvbnRhaW5lcl0pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gKF9hID0gZG9tLmZpbmRDb21tb25BbmNlc3RvcihzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9tLmdldFJvb3QoKTtcbiAgICAgIGlmIChkb20uaXNDaGlsZE9mKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiB3YWxrQm91bmRhcnkoc3RhcnRDb250YWluZXIsIGFuY2VzdG9yLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb20uaXNDaGlsZE9mKGVuZENvbnRhaW5lciwgc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiB3YWxrQm91bmRhcnkoZW5kQ29udGFpbmVyLCBhbmNlc3Rvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBvaW50ID0gZmluZEVuZFBvaW50KHN0YXJ0Q29udGFpbmVyLCBhbmNlc3RvcikgfHwgc3RhcnRDb250YWluZXI7XG4gICAgICBjb25zdCBlbmRQb2ludCA9IGZpbmRFbmRQb2ludChlbmRDb250YWluZXIsIGFuY2VzdG9yKSB8fCBlbmRDb250YWluZXI7XG4gICAgICB3YWxrQm91bmRhcnkoc3RhcnRDb250YWluZXIsIHN0YXJ0UG9pbnQsIHRydWUpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSBjb2xsZWN0U2libGluZ3Moc3RhcnRQb2ludCA9PT0gc3RhcnRDb250YWluZXIgPyBzdGFydFBvaW50IDogc3RhcnRQb2ludC5uZXh0U2libGluZywgJ25leHRTaWJsaW5nJywgZW5kUG9pbnQgPT09IGVuZENvbnRhaW5lciA/IGVuZFBvaW50Lm5leHRTaWJsaW5nIDogZW5kUG9pbnQpO1xuICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhleGNsdWRlKHNpYmxpbmdzKSk7XG4gICAgICB9XG4gICAgICB3YWxrQm91bmRhcnkoZW5kQ29udGFpbmVyLCBlbmRQb2ludCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbGlkQmxvY2tzID0gW1xuICAgICAgJ3ByZVtjbGFzcyo9bGFuZ3VhZ2UtXVtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScsXG4gICAgICAnZmlndXJlLmltYWdlJyxcbiAgICAgICdkaXZbZGF0YS1lcGhveC1lbWJlZC1pcmldJyxcbiAgICAgICdkaXYudGlueS1wYWdlZW1iZWQnLFxuICAgICAgJ2Rpdi5tY2UtdG9jJyxcbiAgICAgICdkaXZbZGF0YS1tY2UtdG9jXSdcbiAgICBdO1xuICAgIGNvbnN0IGlzWmVyb1dpZHRoID0gZWxlbSA9PiBpc1RleHQkYihlbGVtKSAmJiBnZXQkMyhlbGVtKSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoZWRpdG9yLCBlbGVtLCB3cmFwTmFtZSwgbm9kZU5hbWUpID0+IHBhcmVudChlbGVtKS5mb2xkKCgpID0+ICdza2lwcGluZycsIHBhcmVudCA9PiB7XG4gICAgICBpZiAobm9kZU5hbWUgPT09ICdicicgfHwgaXNaZXJvV2lkdGgoZWxlbSkpIHtcbiAgICAgICAgcmV0dXJuICd2YWxpZCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQW5ub3RhdGlvbihlbGVtKSkge1xuICAgICAgICByZXR1cm4gJ2V4aXN0aW5nJztcbiAgICAgIH0gZWxzZSBpZiAoaXNDYXJldE5vZGUoZWxlbS5kb20pKSB7XG4gICAgICAgIHJldHVybiAnY2FyZXQnO1xuICAgICAgfSBlbHNlIGlmIChleGlzdHModmFsaWRCbG9ja3MsIHNlbGVjdG9yID0+IGlzJDEoZWxlbSwgc2VsZWN0b3IpKSkge1xuICAgICAgICByZXR1cm4gJ3ZhbGlkLWJsb2NrJztcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWQoZWRpdG9yLCB3cmFwTmFtZSwgbm9kZU5hbWUpIHx8ICFpc1ZhbGlkKGVkaXRvciwgbmFtZShwYXJlbnQpLCB3cmFwTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuICdpbnZhbGlkLWNoaWxkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndmFsaWQnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgYXBwbHlXb3JkR3JhYiA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgY29uc3QgciA9IGV4cGFuZFJuZyhlZGl0b3IuZG9tLCBybmcsIFt7IGlubGluZTogJ3NwYW4nIH1dKTtcbiAgICAgIHJuZy5zZXRTdGFydChyLnN0YXJ0Q29udGFpbmVyLCByLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHJuZy5zZXRFbmQoci5lbmRDb250YWluZXIsIHIuZW5kT2Zmc2V0KTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAoZWxlbSwgbWFzdGVyVUlkLCBkYXRhLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGRpcmVjdEFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHt1aWQgPSBtYXN0ZXJVSWQsIC4uLm90aGVyRGF0YX0gPSBkYXRhO1xuICAgICAgYWRkJDIoZWxlbSwgYW5ub3RhdGlvbigpKTtcbiAgICAgIHNldCQzKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbklkKCkgfWAsIHVpZCk7XG4gICAgICBzZXQkMyhlbGVtLCBgJHsgZGF0YUFubm90YXRpb24oKSB9YCwgYW5ub3RhdGlvbk5hbWUpO1xuICAgICAgY29uc3Qge2F0dHJpYnV0ZXMgPSB7fSwgY2xhc3NlcyA9IFtdfSA9IGRlY29yYXRlKHVpZCwgb3RoZXJEYXRhKTtcbiAgICAgIHNldEFsbCQxKGVsZW0sIGF0dHJpYnV0ZXMpO1xuICAgICAgYWRkKGVsZW0sIGNsYXNzZXMpO1xuICAgICAgaWYgKGRpcmVjdEFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKGNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldCQzKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkNsYXNzZXMoKSB9YCwgY2xhc3Nlcy5qb2luKCcsJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0ga2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXQkMyhlbGVtLCBgJHsgZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCkgfWAsIGF0dHJpYnV0ZU5hbWVzLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZURpcmVjdEFubm90YXRpb24gPSBlbGVtID0+IHtcbiAgICAgIHJlbW92ZSQ3KGVsZW0sIGFubm90YXRpb24oKSk7XG4gICAgICByZW1vdmUkYShlbGVtLCBgJHsgZGF0YUFubm90YXRpb25JZCgpIH1gKTtcbiAgICAgIHJlbW92ZSRhKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbigpIH1gKTtcbiAgICAgIHJlbW92ZSRhKGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkFjdGl2ZSgpIH1gKTtcbiAgICAgIGNvbnN0IGN1c3RvbUF0dHJOYW1lcyA9IGdldE9wdChlbGVtLCBgJHsgZGF0YUFubm90YXRpb25BdHRyaWJ1dGVzKCkgfWApLm1hcChuYW1lcyA9PiBuYW1lcy5zcGxpdCgnLCcpKS5nZXRPcihbXSk7XG4gICAgICBjb25zdCBjdXN0b21DbGFzc2VzID0gZ2V0T3B0KGVsZW0sIGAkeyBkYXRhQW5ub3RhdGlvbkNsYXNzZXMoKSB9YCkubWFwKG5hbWVzID0+IG5hbWVzLnNwbGl0KCcsJykpLmdldE9yKFtdKTtcbiAgICAgIGVhY2gkZShjdXN0b21BdHRyTmFtZXMsIG5hbWUgPT4gcmVtb3ZlJGEoZWxlbSwgbmFtZSkpO1xuICAgICAgcmVtb3ZlJDQoZWxlbSwgY3VzdG9tQ2xhc3Nlcyk7XG4gICAgICByZW1vdmUkYShlbGVtLCBgJHsgZGF0YUFubm90YXRpb25DbGFzc2VzKCkgfWApO1xuICAgICAgcmVtb3ZlJGEoZWxlbSwgYCR7IGRhdGFBbm5vdGF0aW9uQXR0cmlidXRlcygpIH1gKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VBbm5vdGF0aW9uID0gKGVEb2MsIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKSA9PiB7XG4gICAgICBjb25zdCBtYXN0ZXIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnc3BhbicsIGVEb2MpO1xuICAgICAgYXBwbHlBbm5vdGF0aW9uKG1hc3RlciwgdWlkLCBkYXRhLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBtYXN0ZXI7XG4gICAgfTtcbiAgICBjb25zdCBhbm5vdGF0ZSA9IChlZGl0b3IsIHJuZywgdWlkLCBhbm5vdGF0aW9uTmFtZSwgZGVjb3JhdGUsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IG5ld1dyYXBwZXJzID0gW107XG4gICAgICBjb25zdCBtYXN0ZXIgPSBtYWtlQW5ub3RhdGlvbihlZGl0b3IuZ2V0RG9jKCksIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlKTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCBmaW5pc2hXcmFwcGVyID0gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0T3JPcGVuV3JhcHBlciA9ICgpID0+IHdyYXBwZXIuZ2V0KCkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG51ID0gc2hhbGxvdyQxKG1hc3Rlcik7XG4gICAgICAgIG5ld1dyYXBwZXJzLnB1c2gobnUpO1xuICAgICAgICB3cmFwcGVyLnNldChudSk7XG4gICAgICAgIHJldHVybiBudTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvY2Vzc0VsZW1lbnRzID0gZWxlbXMgPT4ge1xuICAgICAgICBlYWNoJGUoZWxlbXMsIHByb2Nlc3NFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IGVsZW0gPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0KGVkaXRvciwgZWxlbSwgJ3NwYW4nLCBuYW1lKGVsZW0pKTtcbiAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgY2FzZSAnaW52YWxpZC1jaGlsZCc6IHtcbiAgICAgICAgICAgIGZpbmlzaFdyYXBwZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW4kMShlbGVtKTtcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50cyhjaGlsZHJlbik7XG4gICAgICAgICAgICBmaW5pc2hXcmFwcGVyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3ZhbGlkLWJsb2NrJzoge1xuICAgICAgICAgICAgZmluaXNoV3JhcHBlcigpO1xuICAgICAgICAgICAgYXBwbHlBbm5vdGF0aW9uKGVsZW0sIHVpZCwgZGF0YSwgYW5ub3RhdGlvbk5hbWUsIGRlY29yYXRlLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmFsaWQnOiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gZ2V0T3JPcGVuV3JhcHBlcigpO1xuICAgICAgICAgICAgd3JhcCQyKGVsZW0sIHcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvY2Vzc05vZGVzID0gbm9kZXMgPT4ge1xuICAgICAgICBjb25zdCBlbGVtcyA9IG1hcCQzKG5vZGVzLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50cyhlbGVtcyk7XG4gICAgICB9O1xuICAgICAgd2FsayQzKGVkaXRvci5kb20sIHJuZywgbm9kZXMgPT4ge1xuICAgICAgICBmaW5pc2hXcmFwcGVyKCk7XG4gICAgICAgIHByb2Nlc3NOb2Rlcyhub2Rlcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdXcmFwcGVycztcbiAgICB9O1xuICAgIGNvbnN0IGFubm90YXRlV2l0aEJvb2ttYXJrID0gKGVkaXRvciwgbmFtZSwgc2V0dGluZ3MsIGRhdGEpID0+IHtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGluaXRpYWxSbmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGhhc0Zha2VTZWxlY3Rpb24gPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBtYXN0ZXJVaWQgPSBnZW5lcmF0ZSQxKCdtY2UtYW5ub3RhdGlvbicpO1xuICAgICAgICBpZiAoaW5pdGlhbFJuZy5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBhcHBseVdvcmRHcmFiKGVkaXRvciwgaW5pdGlhbFJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5nZXRSbmcoKS5jb2xsYXBzZWQgJiYgIWhhc0Zha2VTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0gbWFrZUFubm90YXRpb24oZWRpdG9yLmdldERvYygpLCBtYXN0ZXJVaWQsIGRhdGEsIG5hbWUsIHNldHRpbmdzLmRlY29yYXRlKTtcbiAgICAgICAgICBzZXQkMSh3cmFwcGVyLCBuYnNwKTtcbiAgICAgICAgICBzZWxlY3Rpb24uZ2V0Um5nKCkuaW5zZXJ0Tm9kZSh3cmFwcGVyLmRvbSk7XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdCh3cmFwcGVyLmRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlc2VydmUoc2VsZWN0aW9uLCBmYWxzZSwgKCkgPT4ge1xuICAgICAgICAgICAgcnVuT25SYW5nZXMoZWRpdG9yLCBzZWxlY3Rpb25SbmcgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0ZShlZGl0b3IsIHNlbGVjdGlvblJuZywgbWFzdGVyVWlkLCBuYW1lLCBzZXR0aW5ncy5kZWNvcmF0ZSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IEFubm90YXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IGNyZWF0ZSRjKCk7XG4gICAgICBzZXR1cCR3KGVkaXRvciwgcmVnaXN0cnkpO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHNldHVwJHgoZWRpdG9yLCByZWdpc3RyeSk7XG4gICAgICBjb25zdCBpc1NwYW4gPSBpc1RhZygnc3BhbicpO1xuICAgICAgY29uc3QgcmVtb3ZlQW5ub3RhdGlvbnMgPSBlbGVtZW50cyA9PiB7XG4gICAgICAgIGVhY2gkZShlbGVtZW50cywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKGlzU3BhbihlbGVtZW50KSkge1xuICAgICAgICAgICAgdW53cmFwKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVEaXJlY3RBbm5vdGF0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXI6IChuYW1lLCBzZXR0aW5ncykgPT4ge1xuICAgICAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKG5hbWUsIHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5ub3RhdGU6IChuYW1lLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmVnaXN0cnkubG9va3VwKG5hbWUpLmVhY2goc2V0dGluZ3MgPT4ge1xuICAgICAgICAgICAgYW5ub3RhdGVXaXRoQm9va21hcmsoZWRpdG9yLCBuYW1lLCBzZXR0aW5ncywgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFubm90YXRpb25DaGFuZ2VkOiAobmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBjaGFuZ2VzLmFkZExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBuYW1lID0+IHtcbiAgICAgICAgICBpZGVudGlmeShlZGl0b3IsIE9wdGlvbmFsLnNvbWUobmFtZSkpLmVhY2goKHtlbGVtZW50c30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgICAgcmVtb3ZlQW5ub3RhdGlvbnMoZWxlbWVudHMpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFsbDogbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgYm9va21hcmsgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgZWFjaCRkKGZpbmRBbGwoZWRpdG9yLCBuYW1lKSwgKGVsZW1lbnRzLCBfKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVBbm5vdGF0aW9ucyhlbGVtZW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFsbDogbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gZmluZEFsbChlZGl0b3IsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiBtYXAkMihkaXJlY3RvcnksIGVsZW1zID0+IG1hcCQzKGVsZW1zLCBlbGVtID0+IGVsZW0uZG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IEJvb2ttYXJrTWFuYWdlciA9IHNlbGVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRCb29rbWFyazogY3VycnkoZ2V0Qm9va21hcmskMSwgc2VsZWN0aW9uKSxcbiAgICAgICAgbW92ZVRvQm9va21hcms6IGN1cnJ5KG1vdmVUb0Jvb2ttYXJrLCBzZWxlY3Rpb24pXG4gICAgICB9O1xuICAgIH07XG4gICAgQm9va21hcmtNYW5hZ2VyLmlzQm9va21hcmtOb2RlID0gaXNCb29rbWFya05vZGUkMTtcblxuICAgIGNvbnN0IGlzWFlXaXRoaW5SYW5nZSA9IChjbGllbnRYLCBjbGllbnRZLCByYW5nZSkgPT4ge1xuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhpc3RzKHJhbmdlLmdldENsaWVudFJlY3RzKCksIHJlY3QgPT4gY29udGFpbnNYWShyZWN0LCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGZpcmVQcmVQcm9jZXNzID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdQcmVQcm9jZXNzJywgYXJncyk7XG4gICAgY29uc3QgZmlyZVBvc3RQcm9jZXNzID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdQb3N0UHJvY2VzcycsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVSZW1vdmUgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdyZW1vdmUnKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVEZXRhY2ggPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdkZXRhY2gnKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVTd2l0Y2hNb2RlID0gKGVkaXRvciwgbW9kZSkgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTd2l0Y2hNb2RlJywgeyBtb2RlIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZU9iamVjdFJlc2l6ZVN0YXJ0ID0gKGVkaXRvciwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4pID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnT2JqZWN0UmVzaXplU3RhcnQnLCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgb3JpZ2luXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVPYmplY3RSZXNpemVkID0gKGVkaXRvciwgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4pID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnT2JqZWN0UmVzaXplZCcsIHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBvcmlnaW5cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVByZUluaXQgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdQcmVJbml0Jyk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlUG9zdFJlbmRlciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Bvc3RSZW5kZXInKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVJbml0ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnSW5pdCcpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVBsYWNlaG9sZGVyVG9nZ2xlID0gKGVkaXRvciwgc3RhdGUpID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnUGxhY2Vob2xkZXJUb2dnbGUnLCB7IHN0YXRlIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUVycm9yID0gKGVkaXRvciwgZXJyb3JUeXBlLCBlcnJvcikgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKGVycm9yVHlwZSwgZXJyb3IpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUZvcm1hdEFwcGx5ID0gKGVkaXRvciwgZm9ybWF0LCBub2RlLCB2YXJzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0Zvcm1hdEFwcGx5Jywge1xuICAgICAgICBmb3JtYXQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHZhcnNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUZvcm1hdFJlbW92ZSA9IChlZGl0b3IsIGZvcm1hdCwgbm9kZSwgdmFycykgPT4ge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoKCdGb3JtYXRSZW1vdmUnLCB7XG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdmFyc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlQmVmb3JlU2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnQmVmb3JlU2V0Q29udGVudCcsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVTZXRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4gZWRpdG9yLmRpc3BhdGNoKCdTZXRDb250ZW50JywgYXJncyk7XG4gICAgY29uc3QgZmlyZUJlZm9yZUdldENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZUdldENvbnRlbnQnLCBhcmdzKTtcbiAgICBjb25zdCBmaXJlR2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IGVkaXRvci5kaXNwYXRjaCgnR2V0Q29udGVudCcsIGFyZ3MpO1xuICAgIGNvbnN0IGZpcmVBdXRvY29tcGxldGVyU3RhcnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJTdGFydCcsIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUF1dG9jb21wbGV0ZXJVcGRhdGUgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0F1dG9jb21wbGV0ZXJVcGRhdGUnLCBhcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVBdXRvY29tcGxldGVyRW5kID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnQXV0b2NvbXBsZXRlckVuZCcpO1xuICAgIH07XG4gICAgY29uc3QgZmlyZVBhc3RlUHJlUHJvY2VzcyA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bhc3RlUHJlUHJvY2VzcycsIHtcbiAgICAgIGNvbnRlbnQ6IGh0bWwsXG4gICAgICBpbnRlcm5hbFxuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVQYXN0ZVBvc3RQcm9jZXNzID0gKGVkaXRvciwgbm9kZSwgaW50ZXJuYWwpID0+IGVkaXRvci5kaXNwYXRjaCgnUGFzdGVQb3N0UHJvY2VzcycsIHtcbiAgICAgIG5vZGUsXG4gICAgICBpbnRlcm5hbFxuICAgIH0pO1xuICAgIGNvbnN0IGZpcmVQYXN0ZVBsYWluVGV4dFRvZ2dsZSA9IChlZGl0b3IsIHN0YXRlKSA9PiBlZGl0b3IuZGlzcGF0Y2goJ1Bhc3RlUGxhaW5UZXh0VG9nZ2xlJywgeyBzdGF0ZSB9KTtcbiAgICBjb25zdCBmaXJlRWRpdGFibGVSb290U3RhdGVDaGFuZ2UgPSAoZWRpdG9yLCBzdGF0ZSkgPT4gZWRpdG9yLmRpc3BhdGNoKCdFZGl0YWJsZVJvb3RTdGF0ZUNoYW5nZScsIHsgc3RhdGUgfSk7XG5cbiAgICBjb25zdCBWSyA9IHtcbiAgICAgIEJBQ0tTUEFDRTogOCxcbiAgICAgIERFTEVURTogNDYsXG4gICAgICBET1dOOiA0MCxcbiAgICAgIEVOVEVSOiAxMyxcbiAgICAgIEVTQzogMjcsXG4gICAgICBMRUZUOiAzNyxcbiAgICAgIFJJR0hUOiAzOSxcbiAgICAgIFNQQUNFQkFSOiAzMixcbiAgICAgIFRBQjogOSxcbiAgICAgIFVQOiAzOCxcbiAgICAgIFBBR0VfVVA6IDMzLFxuICAgICAgUEFHRV9ET1dOOiAzNCxcbiAgICAgIEVORDogMzUsXG4gICAgICBIT01FOiAzNixcbiAgICAgIG1vZGlmaWVyUHJlc3NlZDogZSA9PiB7XG4gICAgICAgIHJldHVybiBlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBWSy5tZXRhS2V5UHJlc3NlZChlKTtcbiAgICAgIH0sXG4gICAgICBtZXRhS2V5UHJlc3NlZDogZSA9PiB7XG4gICAgICAgIHJldHVybiBFbnYub3MuaXNNYWNPUygpIHx8IEVudi5vcy5pc2lPUygpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5ICYmICFlLmFsdEtleTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZWxlbWVudFNlbGVjdGlvbkF0dHIgPSAnZGF0YS1tY2Utc2VsZWN0ZWQnO1xuICAgIGNvbnN0IGNvbnRyb2xFbG1TZWxlY3RvciA9ICd0YWJsZSxpbWcsZmlndXJlLmltYWdlLGhyLHZpZGVvLHNwYW4ubWNlLXByZXZpZXctb2JqZWN0LGRldGFpbHMnO1xuICAgIGNvbnN0IGFicyA9IE1hdGguYWJzO1xuICAgIGNvbnN0IHJvdW5kJDEgPSBNYXRoLnJvdW5kO1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXMgPSB7XG4gICAgICBudzogW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAtMSxcbiAgICAgICAgLTFcbiAgICAgIF0sXG4gICAgICBuZTogW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAtMVxuICAgICAgXSxcbiAgICAgIHNlOiBbXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICAgIDFcbiAgICAgIF0sXG4gICAgICBzdzogW1xuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAtMSxcbiAgICAgICAgMVxuICAgICAgXVxuICAgIH07XG4gICAgY29uc3QgaXNUb3VjaEV2ZW50ID0gZXZ0ID0+IGV2dC50eXBlID09PSAnbG9uZ3ByZXNzJyB8fCBldnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwO1xuICAgIGNvbnN0IENvbnRyb2xTZWxlY3Rpb24gPSAoc2VsZWN0aW9uLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBlZGl0YWJsZURvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgIGNvbnN0IHJvb3REb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgbGV0IHNlbGVjdGVkRWxtLCBzZWxlY3RlZEVsbUdob3N0LCByZXNpemVIZWxwZXIsIHNlbGVjdGVkSGFuZGxlLCByZXNpemVCYWNrZHJvcDtcbiAgICAgIGxldCBzdGFydFgsIHN0YXJ0WSwgc2VsZWN0ZWRFbG1YLCBzZWxlY3RlZEVsbVksIHN0YXJ0Vywgc3RhcnRILCByYXRpbywgcmVzaXplU3RhcnRlZDtcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG4gICAgICBsZXQgc3RhcnRTY3JvbGxXaWR0aDtcbiAgICAgIGxldCBzdGFydFNjcm9sbEhlaWdodDtcbiAgICAgIGNvbnN0IGlzSW1hZ2UgPSBlbG0gPT4gaXNOb25OdWxsYWJsZShlbG0pICYmIChpc0ltZyhlbG0pIHx8IGRvbS5pcyhlbG0sICdmaWd1cmUuaW1hZ2UnKSk7XG4gICAgICBjb25zdCBpc01lZGlhID0gZWxtID0+IGlzTWVkaWEkMihlbG0pIHx8IGRvbS5oYXNDbGFzcyhlbG0sICdtY2UtcHJldmlldy1vYmplY3QnKTtcbiAgICAgIGNvbnN0IGlzRXZlbnRPbkltYWdlT3V0c2lkZVJhbmdlID0gKGV2dCwgcmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKGlzVG91Y2hFdmVudChldnQpKSB7XG4gICAgICAgICAgY29uc3QgdG91Y2ggPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNJbWFnZShldnQudGFyZ2V0KSAmJiAhaXNYWVdpdGhpblJhbmdlKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udGV4dE1lbnVTZWxlY3RJbWFnZSA9IGV2dCA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXQ7XG4gICAgICAgIGlmIChpc0V2ZW50T25JbWFnZU91dHNpZGVSYW5nZShldnQsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpICYmICFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UmVzaXplVGFyZ2V0cyA9IGVsbSA9PiB7XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxtLCAnbWNlLXByZXZpZXctb2JqZWN0JykgJiYgaXNOb25OdWxsYWJsZShlbG0uZmlyc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGVsbSxcbiAgICAgICAgICAgIGVsbS5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tLmlzKGVsbSwgJ2ZpZ3VyZS5pbWFnZScpKSB7XG4gICAgICAgICAgcmV0dXJuIFtlbG0ucXVlcnlTZWxlY3RvcignaW1nJyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbZWxtXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUmVzaXphYmxlID0gZWxtID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRPYmplY3RSZXNpemluZyhlZGl0b3IpO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbG0uZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1yZXNpemUnKSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxtID09PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxtLCAnbWNlLXByZXZpZXctb2JqZWN0JykgJiYgaXNOb25OdWxsYWJsZShlbG0uZmlyc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtLmZpcnN0RWxlbWVudENoaWxkKSwgc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSksIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZUdob3N0RWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICAgIGlmIChpc01lZGlhKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm4gZG9tLmNyZWF0ZSgnaW1nJywgeyBzcmM6IEVudi50cmFuc3BhcmVudFNyYyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldFNpemVQcm9wID0gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldHMgPSBnZXRSZXNpemVUYXJnZXRzKGVsZW1lbnQpO1xuICAgICAgICAgIGVhY2gkZSh0YXJnZXRzLCB0YXJnZXQgPT4ge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZVtuYW1lXSB8fCAhZWRpdG9yLnNjaGVtYS5pc1ZhbGlkKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBuYW1lKSkge1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGUodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKHRhcmdldCwgbmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRHaG9zdEVsbVNpemUgPSAoZ2hvc3RFbG0sIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgc2V0U2l6ZVByb3AoZ2hvc3RFbG0sICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgc2V0U2l6ZVByb3AoZ2hvc3RFbG0sICdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc2l6ZUdob3N0RWxlbWVudCA9IGUgPT4ge1xuICAgICAgICBsZXQgZGVsdGFYLCBkZWx0YVksIHByb3BvcnRpb25hbDtcbiAgICAgICAgbGV0IHJlc2l6ZUhlbHBlclgsIHJlc2l6ZUhlbHBlclk7XG4gICAgICAgIGRlbHRhWCA9IGUuc2NyZWVuWCAtIHN0YXJ0WDtcbiAgICAgICAgZGVsdGFZID0gZS5zY3JlZW5ZIC0gc3RhcnRZO1xuICAgICAgICB3aWR0aCA9IGRlbHRhWCAqIHNlbGVjdGVkSGFuZGxlWzJdICsgc3RhcnRXO1xuICAgICAgICBoZWlnaHQgPSBkZWx0YVkgKiBzZWxlY3RlZEhhbmRsZVszXSArIHN0YXJ0SDtcbiAgICAgICAgd2lkdGggPSB3aWR0aCA8IDUgPyA1IDogd2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCA8IDUgPyA1IDogaGVpZ2h0O1xuICAgICAgICBpZiAoKGlzSW1hZ2Uoc2VsZWN0ZWRFbG0pIHx8IGlzTWVkaWEoc2VsZWN0ZWRFbG0pKSAmJiBnZXRSZXNpemVJbWdQcm9wb3J0aW9uYWwoZWRpdG9yKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBwcm9wb3J0aW9uYWwgPSAhVksubW9kaWZpZXJQcmVzc2VkKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BvcnRpb25hbCA9IFZLLm1vZGlmaWVyUHJlc3NlZChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcG9ydGlvbmFsKSB7XG4gICAgICAgICAgaWYgKGFicyhkZWx0YVgpID4gYWJzKGRlbHRhWSkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHJvdW5kJDEod2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdW5kJDEoaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHJvdW5kJDEoaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcm91bmQkMSh3aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0R2hvc3RFbG1TaXplKHNlbGVjdGVkRWxtR2hvc3QsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXNpemVIZWxwZXJYID0gc2VsZWN0ZWRIYW5kbGUuc3RhcnRQb3MueCArIGRlbHRhWDtcbiAgICAgICAgcmVzaXplSGVscGVyWSA9IHNlbGVjdGVkSGFuZGxlLnN0YXJ0UG9zLnkgKyBkZWx0YVk7XG4gICAgICAgIHJlc2l6ZUhlbHBlclggPSByZXNpemVIZWxwZXJYID4gMCA/IHJlc2l6ZUhlbHBlclggOiAwO1xuICAgICAgICByZXNpemVIZWxwZXJZID0gcmVzaXplSGVscGVyWSA+IDAgPyByZXNpemVIZWxwZXJZIDogMDtcbiAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICBsZWZ0OiByZXNpemVIZWxwZXJYLFxuICAgICAgICAgIHRvcDogcmVzaXplSGVscGVyWSxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICByZXNpemVIZWxwZXIuaW5uZXJIVE1MID0gd2lkdGggKyAnICZ0aW1lczsgJyArIGhlaWdodDtcbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzJdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudFdpZHRoIDw9IHdpZHRoKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlKHNlbGVjdGVkRWxtR2hvc3QsICdsZWZ0Jywgc2VsZWN0ZWRFbG1YICsgKHN0YXJ0VyAtIHdpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkSGFuZGxlWzNdIDwgMCAmJiBzZWxlY3RlZEVsbUdob3N0LmNsaWVudEhlaWdodCA8PSBoZWlnaHQpIHtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoc2VsZWN0ZWRFbG1HaG9zdCwgJ3RvcCcsIHNlbGVjdGVkRWxtWSArIChzdGFydEggLSBoZWlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YVggPSByb290RWxlbWVudC5zY3JvbGxXaWR0aCAtIHN0YXJ0U2Nyb2xsV2lkdGg7XG4gICAgICAgIGRlbHRhWSA9IHJvb3RFbGVtZW50LnNjcm9sbEhlaWdodCAtIHN0YXJ0U2Nyb2xsSGVpZ2h0O1xuICAgICAgICBpZiAoZGVsdGFYICsgZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVIZWxwZXIsIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlc2l6ZUhlbHBlclggLSBkZWx0YVgsXG4gICAgICAgICAgICB0b3A6IHJlc2l6ZUhlbHBlclkgLSBkZWx0YVlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZVN0YXJ0ZWQpIHtcbiAgICAgICAgICBmaXJlT2JqZWN0UmVzaXplU3RhcnQoZWRpdG9yLCBzZWxlY3RlZEVsbSwgc3RhcnRXLCBzdGFydEgsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIHJlc2l6ZVN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZW5kR2hvc3RSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdhc1Jlc2l6ZVN0YXJ0ZWQgPSByZXNpemVTdGFydGVkO1xuICAgICAgICByZXNpemVTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh3YXNSZXNpemVTdGFydGVkKSB7XG4gICAgICAgICAgc2V0U2l6ZVByb3Aoc2VsZWN0ZWRFbG0sICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICBzZXRTaXplUHJvcChzZWxlY3RlZEVsbSwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnVuYmluZChlZGl0YWJsZURvYywgJ21vdXNlbW92ZScsIHJlc2l6ZUdob3N0RWxlbWVudCk7XG4gICAgICAgIGRvbS51bmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICBpZiAocm9vdERvY3VtZW50ICE9PSBlZGl0YWJsZURvYykge1xuICAgICAgICAgIGRvbS51bmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICBkb20udW5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNldXAnLCBlbmRHaG9zdFJlc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tLnJlbW92ZShzZWxlY3RlZEVsbUdob3N0KTtcbiAgICAgICAgZG9tLnJlbW92ZShyZXNpemVIZWxwZXIpO1xuICAgICAgICBkb20ucmVtb3ZlKHJlc2l6ZUJhY2tkcm9wKTtcbiAgICAgICAgc2hvd1Jlc2l6ZVJlY3Qoc2VsZWN0ZWRFbG0pO1xuICAgICAgICBpZiAod2FzUmVzaXplU3RhcnRlZCkge1xuICAgICAgICAgIGZpcmVPYmplY3RSZXNpemVkKGVkaXRvciwgc2VsZWN0ZWRFbG0sIHdpZHRoLCBoZWlnaHQsICdjb3JuZXItJyArIHNlbGVjdGVkSGFuZGxlLm5hbWUpO1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScsIGRvbS5nZXRBdHRyaWIoc2VsZWN0ZWRFbG0sICdzdHlsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93UmVzaXplUmVjdCA9IHRhcmdldEVsbSA9PiB7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGRvbS5nZXRQb3ModGFyZ2V0RWxtLCByb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRWxtWSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFdpZHRoID0gcmVjdC53aWR0aCB8fCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSByZWN0LmhlaWdodCB8fCByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0gIT09IHRhcmdldEVsbSkge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICAgICAgc2VsZWN0ZWRFbG0gPSB0YXJnZXRFbG07XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ09iamVjdFNlbGVjdGVkJywgeyB0YXJnZXQ6IHRhcmdldEVsbSB9KTtcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlKHRhcmdldEVsbSkgJiYgIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBlYWNoJGQocmVzaXplSGFuZGxlcywgKGhhbmRsZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnREcmFnID0gZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFJlc2l6ZVRhcmdldHMoc2VsZWN0ZWRFbG0pWzBdO1xuICAgICAgICAgICAgICBzdGFydFggPSBlLnNjcmVlblg7XG4gICAgICAgICAgICAgIHN0YXJ0WSA9IGUuc2NyZWVuWTtcbiAgICAgICAgICAgICAgc3RhcnRXID0gdGFyZ2V0LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICBzdGFydEggPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICByYXRpbyA9IHN0YXJ0SCAvIHN0YXJ0VztcbiAgICAgICAgICAgICAgc2VsZWN0ZWRIYW5kbGUgPSBoYW5kbGU7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSGFuZGxlLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICBzZWxlY3RlZEhhbmRsZS5zdGFydFBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0YXJnZXRXaWR0aCAqIGhhbmRsZVswXSArIHNlbGVjdGVkRWxtWCxcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXRIZWlnaHQgKiBoYW5kbGVbMV0gKyBzZWxlY3RlZEVsbVlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3RhcnRTY3JvbGxXaWR0aCA9IHJvb3RFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICBzdGFydFNjcm9sbEhlaWdodCA9IHJvb3RFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgcmVzaXplQmFja2Ryb3AgPSBkb20uYWRkKHJvb3RFbGVtZW50LCAnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtY2UtcmVzaXplLWJhY2tkcm9wJyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZG9tLnNldFN0eWxlcyhyZXNpemVCYWNrZHJvcCwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWxlY3RlZEVsbUdob3N0ID0gY3JlYXRlR2hvc3RFbGVtZW50KHNlbGVjdGVkRWxtKTtcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHNlbGVjdGVkRWxtR2hvc3QsICdtY2UtY2xvbmVkcmVzaXphYmxlJyk7XG4gICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoc2VsZWN0ZWRFbG1HaG9zdCwgJ2RhdGEtbWNlLWJvZ3VzJywgJ2FsbCcpO1xuICAgICAgICAgICAgICBzZWxlY3RlZEVsbUdob3N0LmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZXMoc2VsZWN0ZWRFbG1HaG9zdCwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGVjdGVkRWxtWCxcbiAgICAgICAgICAgICAgICB0b3A6IHNlbGVjdGVkRWxtWSxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNldEdob3N0RWxtU2l6ZShzZWxlY3RlZEVsbUdob3N0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbG1HaG9zdC5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICAgICAgICByb290RWxlbWVudC5hcHBlbmRDaGlsZChzZWxlY3RlZEVsbUdob3N0KTtcbiAgICAgICAgICAgICAgZG9tLmJpbmQoZWRpdGFibGVEb2MsICdtb3VzZW1vdmUnLCByZXNpemVHaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICBkb20uYmluZChlZGl0YWJsZURvYywgJ21vdXNldXAnLCBlbmRHaG9zdFJlc2l6ZSk7XG4gICAgICAgICAgICAgIGlmIChyb290RG9jdW1lbnQgIT09IGVkaXRhYmxlRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9tLmJpbmQocm9vdERvY3VtZW50LCAnbW91c2Vtb3ZlJywgcmVzaXplR2hvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBkb20uYmluZChyb290RG9jdW1lbnQsICdtb3VzZXVwJywgZW5kR2hvc3RSZXNpemUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc2l6ZUhlbHBlciA9IGRvbS5hZGQocm9vdEVsZW1lbnQsICdkaXYnLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21jZS1yZXNpemUtaGVscGVyJyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJ1xuICAgICAgICAgICAgICB9LCBzdGFydFcgKyAnICZ0aW1lczsgJyArIHN0YXJ0SCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGhhbmRsZUVsbSA9IGRvbS5nZXQoJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVFbG0pIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRWxtID0gZG9tLmFkZChyb290RWxlbWVudCwgJ2RpdicsIHtcbiAgICAgICAgICAgICAgJ2lkJzogJ21jZVJlc2l6ZUhhbmRsZScgKyBuYW1lLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgICAgICAgJ2NsYXNzJzogJ21jZS1yZXNpemVoYW5kbGUnLFxuICAgICAgICAgICAgICAndW5zZWxlY3RhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ3N0eWxlJzogJ2N1cnNvcjonICsgbmFtZSArICctcmVzaXplOyBtYXJnaW46MDsgcGFkZGluZzowJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb20uYmluZChoYW5kbGVFbG0sICdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBzdGFydERyYWcoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZS5lbG0gPSBoYW5kbGVFbG07XG4gICAgICAgICAgICBkb20uc2V0U3R5bGVzKGhhbmRsZUVsbSwge1xuICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRXaWR0aCAqIGhhbmRsZVswXSArIHNlbGVjdGVkRWxtWCAtIGhhbmRsZUVsbS5vZmZzZXRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgIHRvcDogdGFyZ2V0SGVpZ2h0ICogaGFuZGxlWzFdICsgc2VsZWN0ZWRFbG1ZIC0gaGFuZGxlRWxtLm9mZnNldEhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZGVSZXNpemVSZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHRocm90dGxlZFNob3dSZXNpemVSZWN0ID0gZmlyc3QkMShzaG93UmVzaXplUmVjdCwgMCk7XG4gICAgICBjb25zdCBoaWRlUmVzaXplUmVjdCA9IChyZW1vdmVTZWxlY3RlZCA9IHRydWUpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QuY2FuY2VsKCk7XG4gICAgICAgIHVuYmluZFJlc2l6ZUhhbmRsZUV2ZW50cygpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRFbG0gJiYgcmVtb3ZlU2VsZWN0ZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZEVsbS5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVhY2gkZChyZXNpemVIYW5kbGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBoYW5kbGVFbG0gPSBkb20uZ2V0KCdtY2VSZXNpemVIYW5kbGUnICsgbmFtZSk7XG4gICAgICAgICAgaWYgKGhhbmRsZUVsbSkge1xuICAgICAgICAgICAgZG9tLnVuYmluZChoYW5kbGVFbG0pO1xuICAgICAgICAgICAgZG9tLnJlbW92ZShoYW5kbGVFbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNDaGlsZE9yRXF1YWwgPSAobm9kZSwgcGFyZW50KSA9PiBkb20uaXNDaGlsZE9mKG5vZGUsIHBhcmVudCk7XG4gICAgICBjb25zdCB1cGRhdGVSZXNpemVSZWN0ID0gZSA9PiB7XG4gICAgICAgIGlmIChyZXNpemVTdGFydGVkIHx8IGVkaXRvci5yZW1vdmVkIHx8IGVkaXRvci5jb21wb3NpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0RWxtID0gZS50eXBlID09PSAnbW91c2Vkb3duJyA/IGUudGFyZ2V0IDogc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgICAgY29uc3QgY29udHJvbEVsbSA9IGNsb3Nlc3QkMyhTdWdhckVsZW1lbnQuZnJvbURvbSh0YXJnZXRFbG0pLCBjb250cm9sRWxtU2VsZWN0b3IpLm1hcChlID0+IGUuZG9tKS5maWx0ZXIoZSA9PiBkb20uaXNFZGl0YWJsZShlLnBhcmVudEVsZW1lbnQpKS5nZXRPclVuZGVmaW5lZCgpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gaXNOb25OdWxsYWJsZShjb250cm9sRWxtKSA/IGRvbS5nZXRBdHRyaWIoY29udHJvbEVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIsICcxJykgOiAnMSc7XG4gICAgICAgIGVhY2gkZShkb20uc2VsZWN0KGBpbWdbJHsgZWxlbWVudFNlbGVjdGlvbkF0dHIgfV0saHJbJHsgZWxlbWVudFNlbGVjdGlvbkF0dHIgfV1gKSwgaW1nID0+IHtcbiAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKGNvbnRyb2xFbG0pICYmIGlzQ2hpbGRPckVxdWFsKGNvbnRyb2xFbG0sIHJvb3RFbGVtZW50KSAmJiBlZGl0b3IuaGFzRm9jdXMoKSkge1xuICAgICAgICAgIGRpc2FibGVHZWNrb1Jlc2l6ZSgpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0RWxtID0gc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpO1xuICAgICAgICAgIGlmIChpc0NoaWxkT3JFcXVhbChzdGFydEVsbSwgY29udHJvbEVsbSkgJiYgaXNDaGlsZE9yRXF1YWwoc2VsZWN0aW9uLmdldEVuZCh0cnVlKSwgY29udHJvbEVsbSkpIHtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoY29udHJvbEVsbSwgZWxlbWVudFNlbGVjdGlvbkF0dHIsIHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QudGhyb3R0bGUoY29udHJvbEVsbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGVSZXNpemVSZWN0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5iaW5kUmVzaXplSGFuZGxlRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICBlYWNoJGQocmVzaXplSGFuZGxlcywgaGFuZGxlID0+IHtcbiAgICAgICAgICBpZiAoaGFuZGxlLmVsbSkge1xuICAgICAgICAgICAgZG9tLnVuYmluZChoYW5kbGUuZWxtKTtcbiAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGUuZWxtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGlzYWJsZUdlY2tvUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVkaXRvci5nZXREb2MoKS5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgJ2ZhbHNlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIGRpc2FibGVHZWNrb1Jlc2l6ZSgpO1xuICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UgUmVzaXplRWRpdG9yIFJlc2l6ZVdpbmRvdyBSZXNpemVDb250ZW50IGRyb3AnLCB1cGRhdGVSZXNpemVSZWN0KTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXl1cCBjb21wb3NpdGlvbmVuZCcsIGUgPT4ge1xuICAgICAgICAgIGlmIChzZWxlY3RlZEVsbSAmJiBzZWxlY3RlZEVsbS5ub2RlTmFtZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgdXBkYXRlUmVzaXplUmVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ2hpZGUgYmx1cicsIGhpZGVSZXNpemVSZWN0KTtcbiAgICAgICAgZWRpdG9yLm9uKCdjb250ZXh0bWVudSBsb25ncHJlc3MnLCBjb250ZXh0TWVudVNlbGVjdEltYWdlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCB1bmJpbmRSZXNpemVIYW5kbGVFdmVudHMpO1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU2hvd1Jlc2l6ZVJlY3QuY2FuY2VsKCk7XG4gICAgICAgIHNlbGVjdGVkRWxtID0gc2VsZWN0ZWRFbG1HaG9zdCA9IHJlc2l6ZUJhY2tkcm9wID0gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Jlc2l6YWJsZSxcbiAgICAgICAgc2hvd1Jlc2l6ZVJlY3QsXG4gICAgICAgIGhpZGVSZXNpemVSZWN0LFxuICAgICAgICB1cGRhdGVSZXNpemVSZWN0LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzZXRTdGFydCA9IChybmcsIHNpdHUpID0+IHtcbiAgICAgIHNpdHUuZm9sZChlID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGUuZG9tKTtcbiAgICAgIH0sIChlLCBvKSA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydChlLmRvbSwgbyk7XG4gICAgICB9LCBlID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIoZS5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRGaW5pc2ggPSAocm5nLCBzaXR1KSA9PiB7XG4gICAgICBzaXR1LmZvbGQoZSA9PiB7XG4gICAgICAgIHJuZy5zZXRFbmRCZWZvcmUoZS5kb20pO1xuICAgICAgfSwgKGUsIG8pID0+IHtcbiAgICAgICAgcm5nLnNldEVuZChlLmRvbSwgbyk7XG4gICAgICB9LCBlID0+IHtcbiAgICAgICAgcm5nLnNldEVuZEFmdGVyKGUuZG9tKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVsYXRpdmVUb05hdGl2ZSA9ICh3aW4sIHN0YXJ0U2l0dSwgZmluaXNoU2l0dSkgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW4uZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHNldFN0YXJ0KHJhbmdlLCBzdGFydFNpdHUpO1xuICAgICAgc2V0RmluaXNoKHJhbmdlLCBmaW5pc2hTaXR1KTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIGNvbnN0IGV4YWN0VG9OYXRpdmUgPSAod2luLCBzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSB3aW4uZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJuZy5zZXRTdGFydChzdGFydC5kb20sIHNvZmZzZXQpO1xuICAgICAgcm5nLnNldEVuZChmaW5pc2guZG9tLCBmb2Zmc2V0KTtcbiAgICAgIHJldHVybiBybmc7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCQzID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHtcbiAgICAgICAgbHRyOiBbXG4gICAgICAgICAgJ3N0YXJ0JyxcbiAgICAgICAgICAnc29mZnNldCcsXG4gICAgICAgICAgJ2ZpbmlzaCcsXG4gICAgICAgICAgJ2ZvZmZzZXQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJ0bDogW1xuICAgICAgICAgICdzdGFydCcsXG4gICAgICAgICAgJ3NvZmZzZXQnLFxuICAgICAgICAgICdmaW5pc2gnLFxuICAgICAgICAgICdmb2Zmc2V0J1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSk7XG4gICAgY29uc3QgZnJvbVJhbmdlID0gKHdpbiwgdHlwZSwgcmFuZ2UpID0+IHR5cGUoU3VnYXJFbGVtZW50LmZyb21Eb20ocmFuZ2Uuc3RhcnRDb250YWluZXIpLCByYW5nZS5zdGFydE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocmFuZ2UuZW5kQ29udGFpbmVyKSwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICBjb25zdCBnZXRSYW5nZXMgPSAod2luLCBzZWxlY3Rpb24pID0+IHNlbGVjdGlvbi5tYXRjaCh7XG4gICAgICBkb21SYW5nZTogcm5nID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsdHI6IGNvbnN0YW50KHJuZyksXG4gICAgICAgICAgcnRsOiBPcHRpb25hbC5ub25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVsYXRpdmU6IChzdGFydFNpdHUsIGZpbmlzaFNpdHUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsdHI6IGNhY2hlZCgoKSA9PiByZWxhdGl2ZVRvTmF0aXZlKHdpbiwgc3RhcnRTaXR1LCBmaW5pc2hTaXR1KSksXG4gICAgICAgICAgcnRsOiBjYWNoZWQoKCkgPT4gT3B0aW9uYWwuc29tZShyZWxhdGl2ZVRvTmF0aXZlKHdpbiwgZmluaXNoU2l0dSwgc3RhcnRTaXR1KSkpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZXhhY3Q6IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbHRyOiBjYWNoZWQoKCkgPT4gZXhhY3RUb05hdGl2ZSh3aW4sIHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpKSxcbiAgICAgICAgICBydGw6IGNhY2hlZCgoKSA9PiBPcHRpb25hbC5zb21lKGV4YWN0VG9OYXRpdmUod2luLCBmaW5pc2gsIGZvZmZzZXQsIHN0YXJ0LCBzb2Zmc2V0KSkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZG9EaWFnbm9zZSA9ICh3aW4sIHJhbmdlcykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gcmFuZ2VzLmx0cigpO1xuICAgICAgaWYgKHJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSByYW5nZXMucnRsKCkuZmlsdGVyKHJldiA9PiByZXYuY29sbGFwc2VkID09PSBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXZlcnNlZC5tYXAocmV2ID0+IGFkdCQzLnJ0bChTdWdhckVsZW1lbnQuZnJvbURvbShyZXYuZW5kQ29udGFpbmVyKSwgcmV2LmVuZE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocmV2LnN0YXJ0Q29udGFpbmVyKSwgcmV2LnN0YXJ0T2Zmc2V0KSkuZ2V0T3JUaHVuaygoKSA9PiBmcm9tUmFuZ2Uod2luLCBhZHQkMy5sdHIsIHJuZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb21SYW5nZSh3aW4sIGFkdCQzLmx0ciwgcm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRpYWdub3NlID0gKHdpbiwgc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCByYW5nZXMgPSBnZXRSYW5nZXMod2luLCBzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRvRGlhZ25vc2Uod2luLCByYW5nZXMpO1xuICAgIH07XG4gICAgYWR0JDMubHRyO1xuICAgIGFkdCQzLnJ0bDtcblxuICAgIGNvbnN0IGNyZWF0ZSRhID0gKHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpID0+ICh7XG4gICAgICBzdGFydCxcbiAgICAgIHNvZmZzZXQsXG4gICAgICBmaW5pc2gsXG4gICAgICBmb2Zmc2V0XG4gICAgfSk7XG4gICAgY29uc3QgU2ltUmFuZ2UgPSB7IGNyZWF0ZTogY3JlYXRlJGEgfTtcblxuICAgIGNvbnN0IGNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgPSAoZG9jLCB4LCB5KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oKF9iID0gKF9hID0gZG9jLmRvbSkuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHgsIHkpKS5iaW5kKHBvcyA9PiB7XG4gICAgICAgIGlmIChwb3Mub2Zmc2V0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGRvYy5kb20uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgci5zZXRTdGFydChwb3Mub2Zmc2V0Tm9kZSwgcG9zLm9mZnNldCk7XG4gICAgICAgIHIuY29sbGFwc2UoKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNhcmV0UmFuZ2VGcm9tUG9pbnQgPSAoZG9jLCB4LCB5KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oKF9iID0gKF9hID0gZG9jLmRvbSkuY2FyZXRSYW5nZUZyb21Qb2ludCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHgsIHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGF2YWlsYWJsZVNlYXJjaCA9ICgoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbkZyb21Qb2ludDtcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICByZXR1cm4gY2FyZXRSYW5nZUZyb21Qb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgZnJvbVBvaW50JDEgPSAod2luLCB4LCB5KSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBTdWdhckVsZW1lbnQuZnJvbURvbSh3aW4uZG9jdW1lbnQpO1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZVNlYXJjaChkb2MsIHgsIHkpLm1hcChybmcgPT4gU2ltUmFuZ2UuY3JlYXRlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5zdGFydENvbnRhaW5lciksIHJuZy5zdGFydE9mZnNldCwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmVuZENvbnRhaW5lciksIHJuZy5lbmRPZmZzZXQpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWR0JDIgPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBiZWZvcmU6IFsnZWxlbWVudCddIH0sXG4gICAgICB7XG4gICAgICAgIG9uOiBbXG4gICAgICAgICAgJ2VsZW1lbnQnLFxuICAgICAgICAgICdvZmZzZXQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7IGFmdGVyOiBbJ2VsZW1lbnQnXSB9XG4gICAgXSk7XG4gICAgY29uc3QgY2F0YSA9IChzdWJqZWN0LCBvbkJlZm9yZSwgb25Pbiwgb25BZnRlcikgPT4gc3ViamVjdC5mb2xkKG9uQmVmb3JlLCBvbk9uLCBvbkFmdGVyKTtcbiAgICBjb25zdCBnZXRTdGFydCQyID0gc2l0dSA9PiBzaXR1LmZvbGQoaWRlbnRpdHksIGlkZW50aXR5LCBpZGVudGl0eSk7XG4gICAgY29uc3QgYmVmb3JlJDEgPSBhZHQkMi5iZWZvcmU7XG4gICAgY29uc3Qgb24gPSBhZHQkMi5vbjtcbiAgICBjb25zdCBhZnRlciQxID0gYWR0JDIuYWZ0ZXI7XG4gICAgY29uc3QgU2l0dSA9IHtcbiAgICAgIGJlZm9yZTogYmVmb3JlJDEsXG4gICAgICBvbixcbiAgICAgIGFmdGVyOiBhZnRlciQxLFxuICAgICAgY2F0YSxcbiAgICAgIGdldFN0YXJ0OiBnZXRTdGFydCQyXG4gICAgfTtcblxuICAgIGNvbnN0IGFkdCQxID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgZG9tUmFuZ2U6IFsncm5nJ10gfSxcbiAgICAgIHtcbiAgICAgICAgcmVsYXRpdmU6IFtcbiAgICAgICAgICAnc3RhcnRTaXR1JyxcbiAgICAgICAgICAnZmluaXNoU2l0dSdcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZXhhY3Q6IFtcbiAgICAgICAgICAnc3RhcnQnLFxuICAgICAgICAgICdzb2Zmc2V0JyxcbiAgICAgICAgICAnZmluaXNoJyxcbiAgICAgICAgICAnZm9mZnNldCdcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGV4YWN0RnJvbVJhbmdlID0gc2ltUmFuZ2UgPT4gYWR0JDEuZXhhY3Qoc2ltUmFuZ2Uuc3RhcnQsIHNpbVJhbmdlLnNvZmZzZXQsIHNpbVJhbmdlLmZpbmlzaCwgc2ltUmFuZ2UuZm9mZnNldCk7XG4gICAgY29uc3QgZ2V0U3RhcnQkMSA9IHNlbGVjdGlvbiA9PiBzZWxlY3Rpb24ubWF0Y2goe1xuICAgICAgZG9tUmFuZ2U6IHJuZyA9PiBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpLFxuICAgICAgcmVsYXRpdmU6IChzdGFydFNpdHUsIF9maW5pc2hTaXR1KSA9PiBTaXR1LmdldFN0YXJ0KHN0YXJ0U2l0dSksXG4gICAgICBleGFjdDogKHN0YXJ0LCBfc29mZnNldCwgX2ZpbmlzaCwgX2ZvZmZzZXQpID0+IHN0YXJ0XG4gICAgfSk7XG4gICAgY29uc3QgZG9tUmFuZ2UgPSBhZHQkMS5kb21SYW5nZTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IGFkdCQxLnJlbGF0aXZlO1xuICAgIGNvbnN0IGV4YWN0ID0gYWR0JDEuZXhhY3Q7XG4gICAgY29uc3QgZ2V0V2luID0gc2VsZWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0U3RhcnQkMShzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWaWV3KHN0YXJ0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlID0gU2ltUmFuZ2UuY3JlYXRlO1xuICAgIGNvbnN0IFNpbVNlbGVjdGlvbiA9IHtcbiAgICAgIGRvbVJhbmdlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBleGFjdCxcbiAgICAgIGV4YWN0RnJvbVJhbmdlLFxuICAgICAgZ2V0V2luLFxuICAgICAgcmFuZ2VcbiAgICB9O1xuXG4gICAgY29uc3QgYmVmb3JlU3BlY2lhbCA9IChlbGVtZW50LCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUkMSA9IG5hbWUoZWxlbWVudCk7XG4gICAgICBpZiAoJ2lucHV0JyA9PT0gbmFtZSQxKSB7XG4gICAgICAgIHJldHVybiBTaXR1LmFmdGVyKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghY29udGFpbnMkMihbXG4gICAgICAgICAgJ2JyJyxcbiAgICAgICAgICAnaW1nJ1xuICAgICAgICBdLCBuYW1lJDEpKSB7XG4gICAgICAgIHJldHVybiBTaXR1Lm9uKGVsZW1lbnQsIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gU2l0dS5iZWZvcmUoZWxlbWVudCkgOiBTaXR1LmFmdGVyKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlcHJvY2Vzc1JlbGF0aXZlID0gKHN0YXJ0U2l0dSwgZmluaXNoU2l0dSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydFNpdHUuZm9sZChTaXR1LmJlZm9yZSwgYmVmb3JlU3BlY2lhbCwgU2l0dS5hZnRlcik7XG4gICAgICBjb25zdCBmaW5pc2ggPSBmaW5pc2hTaXR1LmZvbGQoU2l0dS5iZWZvcmUsIGJlZm9yZVNwZWNpYWwsIFNpdHUuYWZ0ZXIpO1xuICAgICAgcmV0dXJuIFNpbVNlbGVjdGlvbi5yZWxhdGl2ZShzdGFydCwgZmluaXNoKTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXByb2Nlc3NFeGFjdCA9IChzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBzdGFydFNpdHUgPSBiZWZvcmVTcGVjaWFsKHN0YXJ0LCBzb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpbmlzaFNpdHUgPSBiZWZvcmVTcGVjaWFsKGZpbmlzaCwgZm9mZnNldCk7XG4gICAgICByZXR1cm4gU2ltU2VsZWN0aW9uLnJlbGF0aXZlKHN0YXJ0U2l0dSwgZmluaXNoU2l0dSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwcm9jZXNzID0gc2VsZWN0aW9uID0+IHNlbGVjdGlvbi5tYXRjaCh7XG4gICAgICBkb21SYW5nZTogcm5nID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBjb25zdCBmaW5pc2ggPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuZW5kQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHByZXByb2Nlc3NFeGFjdChzdGFydCwgcm5nLnN0YXJ0T2Zmc2V0LCBmaW5pc2gsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgfSxcbiAgICAgIHJlbGF0aXZlOiBwcmVwcm9jZXNzUmVsYXRpdmUsXG4gICAgICBleGFjdDogcHJlcHJvY2Vzc0V4YWN0XG4gICAgfSk7XG5cbiAgICBjb25zdCBmcm9tRWxlbWVudHMgPSAoZWxlbWVudHMsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGVhY2gkZShlbGVtZW50cywgZWxlbWVudCA9PiB7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQuZG9tKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZyYWdtZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG9OYXRpdmUgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgd2luID0gU2ltU2VsZWN0aW9uLmdldFdpbihzZWxlY3Rpb24pLmRvbTtcbiAgICAgIGNvbnN0IGdldERvbVJhbmdlID0gKHN0YXJ0LCBzb2Zmc2V0LCBmaW5pc2gsIGZvZmZzZXQpID0+IGV4YWN0VG9OYXRpdmUod2luLCBzdGFydCwgc29mZnNldCwgZmluaXNoLCBmb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkID0gcHJlcHJvY2VzcyhzZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGRpYWdub3NlKHdpbiwgZmlsdGVyZWQpLm1hdGNoKHtcbiAgICAgICAgbHRyOiBnZXREb21SYW5nZSxcbiAgICAgICAgcnRsOiBnZXREb21SYW5nZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRBdFBvaW50ID0gKHdpbiwgeCwgeSkgPT4gZnJvbVBvaW50JDEod2luLCB4LCB5KTtcblxuICAgIGNvbnN0IGZyb21Qb2ludCA9IChjbGllbnRYLCBjbGllbnRZLCBkb2MpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IGRlZmF1bHRWaWV3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvYykpO1xuICAgICAgcmV0dXJuIGdldEF0UG9pbnQod2luLmRvbSwgY2xpZW50WCwgY2xpZW50WSkubWFwKHNpbVJhbmdlID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChzaW1SYW5nZS5zdGFydC5kb20sIHNpbVJhbmdlLnNvZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKHNpbVJhbmdlLmZpbmlzaC5kb20sIHNpbVJhbmdlLmZvZmZzZXQpO1xuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfSkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNFcSQ0ID0gKHJuZzEsIHJuZzIpID0+IHtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHJuZzEpICYmIGlzTm9uTnVsbGFibGUocm5nMikgJiYgKHJuZzEuc3RhcnRDb250YWluZXIgPT09IHJuZzIuc3RhcnRDb250YWluZXIgJiYgcm5nMS5zdGFydE9mZnNldCA9PT0gcm5nMi5zdGFydE9mZnNldCkgJiYgKHJuZzEuZW5kQ29udGFpbmVyID09PSBybmcyLmVuZENvbnRhaW5lciAmJiBybmcxLmVuZE9mZnNldCA9PT0gcm5nMi5lbmRPZmZzZXQpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kUGFyZW50ID0gKG5vZGUsIHJvb3ROb2RlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaGFzUGFyZW50JDEgPSAobm9kZSwgcm9vdE5vZGUsIHByZWRpY2F0ZSkgPT4gZmluZFBhcmVudChub2RlLCByb290Tm9kZSwgcHJlZGljYXRlKSAhPT0gbnVsbDtcbiAgICBjb25zdCBoYXNQYXJlbnRXaXRoTmFtZSA9IChub2RlLCByb290Tm9kZSwgbmFtZSkgPT4gaGFzUGFyZW50JDEobm9kZSwgcm9vdE5vZGUsIG5vZGUgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSk7XG4gICAgY29uc3QgaXNDZUZhbHNlQ2FyZXRDb250YWluZXIgPSAobm9kZSwgcm9vdE5vZGUpID0+IGlzQ2FyZXRDb250YWluZXIkMihub2RlKSAmJiAhaGFzUGFyZW50JDEobm9kZSwgcm9vdE5vZGUsIGlzQ2FyZXROb2RlKTtcbiAgICBjb25zdCBoYXNCckJlZm9yZUFmdGVyID0gKGRvbSwgbm9kZSwgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKG5vZGUsIGRvbS5nZXRQYXJlbnQocGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIHx8IGRvbS5nZXRSb290KCkpO1xuICAgICAgICBsZXQgY3VycmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IHdhbGtlcltsZWZ0ID8gJ3ByZXYnIDogJ25leHQnXSgpKSB7XG4gICAgICAgICAgaWYgKGlzQnIkNihjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNQcmV2Tm9kZSA9IChub2RlLCBuYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKChfYSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZU5hbWUpID09PSBuYW1lO1xuICAgIH07XG4gICAgY29uc3QgaGFzQ29udGVudEVkaXRhYmxlRmFsc2VQYXJlbnQgPSAocm9vdCwgbm9kZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRUZXh0Tm9kZVJlbGF0aXZlID0gKGRvbSwgaXNBZnRlck5vZGUsIGNvbGxhcHNlZCwgbGVmdCwgc3RhcnROb2RlKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZG9tLmdldFJvb3QoKTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGxldCBsYXN0SW5saW5lRWxlbWVudDtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja0NvbnRhaW5lciA9IGRvbS5nZXRQYXJlbnQocGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIHx8IGJvZHk7XG4gICAgICBpZiAobGVmdCAmJiBpc0JyJDYoc3RhcnROb2RlKSAmJiBpc0FmdGVyTm9kZSAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9ja0NvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihwYXJlbnROb2RlLCBkb20ubm9kZUluZGV4KHN0YXJ0Tm9kZSkpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHN0YXJ0Tm9kZSwgcGFyZW50QmxvY2tDb250YWluZXIpO1xuICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXJbbGVmdCA/ICdwcmV2JyA6ICduZXh0J10oKSkge1xuICAgICAgICBpZiAoZG9tLmdldENvbnRlbnRFZGl0YWJsZVBhcmVudChub2RlKSA9PT0gJ2ZhbHNlJyB8fCBpc0NlRmFsc2VDYXJldENvbnRhaW5lcihub2RlLCBib2R5KSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKCFoYXNQYXJlbnRXaXRoTmFtZShub2RlLCBib2R5LCAnQScpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShDYXJldFBvc2l0aW9uKG5vZGUsIGxlZnQgPyBub2RlLmRhdGEubGVuZ3RoIDogMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaXNCbG9jayhub2RlKSB8fCBub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmxpbmVFbGVtZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1lbnQobGFzdElubGluZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBpZiAoY29sbGFwc2VkICYmIGxhc3RJbmxpbmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKENhcmV0UG9zaXRpb24obGFzdElubGluZUVsZW1lbnQsIDApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVFbmRQb2ludCA9IChkb20sIGNvbGxhcHNlZCwgc3RhcnQsIHJuZykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IGRvbS5nZXRSb290KCk7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBub3JtYWxpemVkID0gZmFsc2U7XG4gICAgICBsZXQgY29udGFpbmVyID0gc3RhcnQgPyBybmcuc3RhcnRDb250YWluZXIgOiBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0ID8gcm5nLnN0YXJ0T2Zmc2V0IDogcm5nLmVuZE9mZnNldDtcbiAgICAgIGNvbnN0IGlzQWZ0ZXJOb2RlID0gaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHNNYXAgPSBkb20uc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGxldCBkaXJlY3Rpb25MZWZ0ID0gc3RhcnQ7XG4gICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpICYmIG9mZnNldCA+IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZGlyZWN0aW9uTGVmdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnQkMShjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGJvZHk7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyID09PSBib2R5KSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb25MZWZ0KSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogMF07XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVyJDIobm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub25FbXB0eUVsZW1lbnRzTWFwW25vZGUubm9kZU5hbWVdIHx8IGlzVGFibGUkMihub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKCFkaXJlY3Rpb25MZWZ0ICYmIG9mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogb2Zmc2V0LCBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgIG9mZnNldCA9IGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgaXNBZnRlck5vZGUgPyBjb250YWluZXIuZGF0YS5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICghY29sbGFwc2VkICYmIGNvbnRhaW5lciA9PT0gYm9keS5sYXN0Q2hpbGQgJiYgaXNUYWJsZSQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNDb250ZW50RWRpdGFibGVGYWxzZVBhcmVudChib2R5LCBjb250YWluZXIpIHx8IGlzQ2FyZXRDb250YWluZXIkMihjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSAmJiAhaXNUYWJsZSQyKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjb250YWluZXI7XG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIGJvZHkpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKG5vZGUpIHx8IGlzQ2FyZXRDb250YWluZXIkMihub2RlKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkaXJlY3Rpb25MZWZ0ID8gMCA6IG5vZGUuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9uRW1wdHlFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldICYmICFpc1RhYmxlQ2VsbE9yQ2FwdGlvbihub2RlKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRvbS5ub2RlSW5kZXgobm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmICghZGlyZWN0aW9uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChub2RlID0gZGlyZWN0aW9uTGVmdCA/IHdhbGtlci5uZXh0KCkgOiB3YWxrZXIucHJldigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgb2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgZmluZFRleHROb2RlUmVsYXRpdmUoZG9tLCBpc0FmdGVyTm9kZSwgY29sbGFwc2VkLCB0cnVlLCBjb250YWluZXIpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihjb250YWluZXIpKSB7XG4gICAgICAgICAgbm9kZSA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gY29udGFpbmVyLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlICYmIGlzQnIkNihub2RlKSAmJiAhaXNQcmV2Tm9kZShub2RlLCAnQScpICYmICFoYXNCckJlZm9yZUFmdGVyKGRvbSwgbm9kZSwgZmFsc2UpICYmICFoYXNCckJlZm9yZUFmdGVyKGRvbSwgbm9kZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGZpbmRUZXh0Tm9kZVJlbGF0aXZlKGRvbSwgaXNBZnRlck5vZGUsIGNvbGxhcHNlZCwgdHJ1ZSwgbm9kZSkuZWFjaChwb3MgPT4ge1xuICAgICAgICAgICAgICBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICAgICAgICAgIG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaXJlY3Rpb25MZWZ0ICYmICFjb2xsYXBzZWQgJiYgaXNUZXh0JGEoY29udGFpbmVyKSAmJiBvZmZzZXQgPT09IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICBmaW5kVGV4dE5vZGVSZWxhdGl2ZShkb20sIGlzQWZ0ZXJOb2RlLCBjb2xsYXBzZWQsIGZhbHNlLCBjb250YWluZXIpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVkICYmIGNvbnRhaW5lciA/IE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCkpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplJDIgPSAoZG9tLCBybmcpID0+IHtcbiAgICAgIGNvbnN0IGNvbGxhcHNlZCA9IHJuZy5jb2xsYXBzZWQsIG5vcm1SbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBub3JtYWxpemVFbmRQb2ludChkb20sIGNvbGxhcHNlZCwgdHJ1ZSwgbm9ybVJuZykuZWFjaChwb3MgPT4ge1xuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCAhQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlKHN0YXJ0UG9zLCBwb3MpKSB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRTdGFydChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybWFsaXplRW5kUG9pbnQoZG9tLCBjb2xsYXBzZWQsIGZhbHNlLCBub3JtUm5nKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgbm9ybVJuZy5zZXRFbmQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZWQpIHtcbiAgICAgICAgbm9ybVJuZy5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0VxJDQocm5nLCBub3JtUm5nKSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUobm9ybVJuZyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNwbGl0VGV4dCA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChvZmZzZXQpO1xuICAgIH07XG4gICAgY29uc3Qgc3BsaXQgPSBybmcgPT4ge1xuICAgICAgbGV0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldCwgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgIGlmIChzdGFydENvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyICYmIGlzVGV4dCRhKHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiAwICYmIHN0YXJ0T2Zmc2V0IDwgc3RhcnRDb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBzcGxpdFRleHQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGVuZENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCA+IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IHNwbGl0VGV4dChlbmRDb250YWluZXIsIGVuZE9mZnNldCkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBlbmRDb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBuZXdDb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNUZXh0JGEoc3RhcnRDb250YWluZXIpICYmIHN0YXJ0T2Zmc2V0ID4gMCAmJiBzdGFydE9mZnNldCA8IHN0YXJ0Q29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzcGxpdFRleHQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKGVuZENvbnRhaW5lcikgJiYgZW5kT2Zmc2V0ID4gMCAmJiBlbmRPZmZzZXQgPCBlbmRDb250YWluZXIuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdDb250YWluZXIgPSBzcGxpdFRleHQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBlbmRDb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICAgICAgZW5kT2Zmc2V0ID0gbmV3Q29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZENvbnRhaW5lcixcbiAgICAgICAgZW5kT2Zmc2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBSYW5nZVV0aWxzID0gZG9tID0+IHtcbiAgICAgIGNvbnN0IHdhbGsgPSAocm5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXR1cm4gd2FsayQzKGRvbSwgcm5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3BsaXQkMSA9IHNwbGl0O1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gcm5nID0+IHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSQyKGRvbSwgcm5nKS5mb2xkKG5ldmVyLCBub3JtYWxpemVkUm5nID0+IHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9ybWFsaXplZFJuZy5zdGFydENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgcm5nLnNldEVuZChub3JtYWxpemVkUm5nLmVuZENvbnRhaW5lciwgbm9ybWFsaXplZFJuZy5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBleHBhbmQgPSAocm5nLCBvcHRpb25zID0geyB0eXBlOiAnd29yZCcgfSkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnd29yZCcpIHtcbiAgICAgICAgICBjb25zdCByYW5nZUxpa2UgPSBleHBhbmRSbmcoZG9tLCBybmcsIFt7IGlubGluZTogJ3NwYW4nIH1dKTtcbiAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZUxpa2Uuc3RhcnRDb250YWluZXIsIHJhbmdlTGlrZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlTGlrZS5lbmRDb250YWluZXIsIHJhbmdlTGlrZS5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhbGssXG4gICAgICAgIHNwbGl0OiBzcGxpdCQxLFxuICAgICAgICBleHBhbmQsXG4gICAgICAgIG5vcm1hbGl6ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIFJhbmdlVXRpbHMuY29tcGFyZVJhbmdlcyA9IGlzRXEkNDtcbiAgICBSYW5nZVV0aWxzLmdldENhcmV0UmFuZ2VGcm9tUG9pbnQgPSBmcm9tUG9pbnQ7XG4gICAgUmFuZ2VVdGlscy5nZXRTZWxlY3RlZE5vZGUgPSBnZXRTZWxlY3RlZE5vZGU7XG4gICAgUmFuZ2VVdGlscy5nZXROb2RlID0gZ2V0Tm9kZSQxO1xuXG4gICAgY29uc3QgRGltZW5zaW9uID0gKG5hbWUsIGdldE9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc2V0ID0gKGVsZW1lbnQsIGgpID0+IHtcbiAgICAgICAgaWYgKCFpc051bWJlcihoKSAmJiAhaC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJy5zZXQgYWNjZXB0cyBvbmx5IHBvc2l0aXZlIGludGVnZXIgdmFsdWVzLiBWYWx1ZSB3YXMgJyArIGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAgICAgICBpZiAoaXNTdXBwb3J0ZWQoZG9tKSkge1xuICAgICAgICAgIGRvbS5zdHlsZVtuYW1lXSA9IGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0ID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBnZXRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChyIDw9IDAgfHwgciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNzcyA9IGdldCQ3KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGNzcykgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRPdXRlciA9IGdldDtcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IChlbGVtZW50LCBwcm9wZXJ0aWVzKSA9PiBmb2xkbChwcm9wZXJ0aWVzLCAoYWNjLCBwcm9wZXJ0eSkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXQkNyhlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsID09PSB1bmRlZmluZWQgPyAwIDogcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBhY2MgOiBhY2MgKyB2YWx1ZTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgbWF4ID0gKGVsZW1lbnQsIHZhbHVlLCBwcm9wZXJ0aWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1bXVsYXRpdmVJbmNsdXNpb25zID0gYWdncmVnYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZU1heCA9IHZhbHVlID4gY3VtdWxhdGl2ZUluY2x1c2lvbnMgPyB2YWx1ZSAtIGN1bXVsYXRpdmVJbmNsdXNpb25zIDogMDtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlTWF4O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZ2V0LFxuICAgICAgICBnZXRPdXRlcixcbiAgICAgICAgYWdncmVnYXRlLFxuICAgICAgICBtYXhcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IERpbWVuc2lvbignaGVpZ2h0JywgZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgICAgIHJldHVybiBpbkJvZHkoZWxlbWVudCkgPyBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogZG9tLm9mZnNldEhlaWdodDtcbiAgICB9KTtcbiAgICBjb25zdCBnZXQkMiA9IGVsZW1lbnQgPT4gYXBpLmdldChlbGVtZW50KTtcblxuICAgIGNvbnN0IGdldERvY3VtZW50ID0gKCkgPT4gU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnQpO1xuXG4gICAgY29uc3Qgd2Fsa1VwID0gKG5hdmlnYXRpb24sIGRvYykgPT4ge1xuICAgICAgY29uc3QgZnJhbWUgPSBuYXZpZ2F0aW9uLnZpZXcoZG9jKTtcbiAgICAgIHJldHVybiBmcmFtZS5mb2xkKGNvbnN0YW50KFtdKSwgZiA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5hdmlnYXRpb24ub3duZXIoZik7XG4gICAgICAgIGNvbnN0IHJlc3QgPSB3YWxrVXAobmF2aWdhdGlvbiwgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIFtmXS5jb25jYXQocmVzdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHBhdGhUbyA9IChlbGVtZW50LCBuYXZpZ2F0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkID0gbmF2aWdhdGlvbi5vd25lcihlbGVtZW50KTtcbiAgICAgIHJldHVybiB3YWxrVXAobmF2aWdhdGlvbiwgZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHZpZXcgPSBkb2MgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvYy5kb20gPT09IGRvY3VtZW50ID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuZnJvbSgoX2EgPSBkb2MuZG9tLmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJhbWVFbGVtZW50KTtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgfTtcbiAgICBjb25zdCBvd25lciA9IGVsZW1lbnQgPT4gZG9jdW1lbnRPck93bmVyKGVsZW1lbnQpO1xuXG4gICAgdmFyIE5hdmlnYXRpb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgdmlldzogdmlldyxcbiAgICAgICAgb3duZXI6IG93bmVyXG4gICAgfSk7XG5cbiAgICBjb25zdCBmaW5kID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3Qgc2Nyb2xsID0gZ2V0JDUoZG9jKTtcbiAgICAgIGNvbnN0IGZyYW1lcyA9IHBhdGhUbyhlbGVtZW50LCBOYXZpZ2F0aW9uKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHZpZXdwb3J0KGVsZW1lbnQpO1xuICAgICAgY29uc3QgciA9IGZvbGRyKGZyYW1lcywgKGIsIGEpID0+IHtcbiAgICAgICAgY29uc3QgbG9jID0gdmlld3BvcnQoYSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogYi5sZWZ0ICsgbG9jLmxlZnQsXG4gICAgICAgICAgdG9wOiBiLnRvcCArIGxvYy50b3BcbiAgICAgICAgfTtcbiAgICAgIH0sIHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTdWdhclBvc2l0aW9uKHIubGVmdCArIG9mZnNldC5sZWZ0ICsgc2Nyb2xsLmxlZnQsIHIudG9wICsgb2Zmc2V0LnRvcCArIHNjcm9sbC50b3ApO1xuICAgIH07XG5cbiAgICBjb25zdCBleGNsdWRlRnJvbURlc2NlbmQgPSBlbGVtZW50ID0+IG5hbWUoZWxlbWVudCkgPT09ICd0ZXh0YXJlYSc7XG4gICAgY29uc3QgZmlyZVNjcm9sbEludG9WaWV3RXZlbnQgPSAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxFdmVudCA9IGVkaXRvci5kaXNwYXRjaCgnU2Nyb2xsSW50b1ZpZXcnLCBkYXRhKTtcbiAgICAgIHJldHVybiBzY3JvbGxFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpcmVBZnRlclNjcm9sbEludG9WaWV3RXZlbnQgPSAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0FmdGVyU2Nyb2xsSW50b1ZpZXcnLCBkYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlc2NlbmQgPSAoZWxlbWVudCwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuJDEoZWxlbWVudCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGV4Y2x1ZGVGcm9tRGVzY2VuZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhZXhjbHVkZUZyb21EZXNjZW5kKGNoaWxkcmVuW29mZnNldF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWxlbWVudDogY2hpbGRyZW5bb2Zmc2V0XSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVGcm9tRGVzY2VuZChsYXN0KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmFtZShsYXN0KSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IGxhc3QsXG4gICAgICAgICAgICAgIG9mZnNldDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCRiKGxhc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbGVtZW50OiBsYXN0LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGdldCQzKGxhc3QpLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZWxlbWVudDogbGFzdCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBjaGlsZHJlbiQxKGxhc3QpLmxlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1hcmtlckluZm8gPSAoZWxlbWVudCwgY2xlYW51cEZ1bikgPT4ge1xuICAgICAgY29uc3QgcG9zID0gYWJzb2x1dGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXQkMihlbGVtZW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGJvdHRvbTogcG9zLnRvcCArIGhlaWdodCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBwb3MsXG4gICAgICAgIGNsZWFudXA6IGNsZWFudXBGdW5cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXIkMSA9IChlbGVtZW50LCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBkZXNjZW5kKGVsZW1lbnQsIG9mZnNldCk7XG4gICAgICBjb25zdCBzcGFuID0gU3VnYXJFbGVtZW50LmZyb21IdG1sKCc8c3BhbiBkYXRhLW1jZS1ib2d1cz1cImFsbFwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrO1wiPicgKyBaV1NQJDEgKyAnPC9zcGFuPicpO1xuICAgICAgYmVmb3JlJDMoc3RhcnRQb2ludC5lbGVtZW50LCBzcGFuKTtcbiAgICAgIHJldHVybiBtYXJrZXJJbmZvKHNwYW4sICgpID0+IHJlbW92ZSQ1KHNwYW4pKTtcbiAgICB9O1xuICAgIGNvbnN0IGVsZW1lbnRNYXJrZXIgPSBlbGVtZW50ID0+IG1hcmtlckluZm8oU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCksIG5vb3ApO1xuICAgIGNvbnN0IHdpdGhNYXJrZXIgPSAoZWRpdG9yLCBmLCBybmcsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIHByZXNlcnZlV2l0aChlZGl0b3IsIChfcywgX2UpID0+IGFwcGx5V2l0aE1hcmtlcihlZGl0b3IsIGYsIHJuZywgYWxpZ25Ub1RvcCksIHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCB3aXRoU2Nyb2xsRXZlbnRzID0gKGVkaXRvciwgZG9jLCBmLCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGVsbTogbWFya2VyLmVsZW1lbnQuZG9tLFxuICAgICAgICBhbGlnblRvVG9wXG4gICAgICB9O1xuICAgICAgaWYgKGZpcmVTY3JvbGxJbnRvVmlld0V2ZW50KGVkaXRvciwgZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZ2V0JDUoZG9jKS50b3A7XG4gICAgICBmKGVkaXRvciwgZG9jLCBzY3JvbGxUb3AsIG1hcmtlciwgYWxpZ25Ub1RvcCk7XG4gICAgICBmaXJlQWZ0ZXJTY3JvbGxJbnRvVmlld0V2ZW50KGVkaXRvciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVdpdGhNYXJrZXIgPSAoZWRpdG9yLCBmLCBybmcsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGRvYyA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXREb2MoKSk7XG4gICAgICByZWZsb3coYm9keSk7XG4gICAgICBjb25zdCBtYXJrZXIgPSBjcmVhdGVNYXJrZXIkMShTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpLCBybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgd2l0aFNjcm9sbEV2ZW50cyhlZGl0b3IsIGRvYywgZiwgbWFya2VyLCBhbGlnblRvVG9wKTtcbiAgICAgIG1hcmtlci5jbGVhbnVwKCk7XG4gICAgfTtcbiAgICBjb25zdCB3aXRoRWxlbWVudCA9IChlZGl0b3IsIGVsZW1lbnQsIGYsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXREb2MoKSk7XG4gICAgICB3aXRoU2Nyb2xsRXZlbnRzKGVkaXRvciwgZG9jLCBmLCBlbGVtZW50TWFya2VyKGVsZW1lbnQpLCBhbGlnblRvVG9wKTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXNlcnZlV2l0aCA9IChlZGl0b3IsIGYsIHJuZykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRFbGVtZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRFbGVtZW50ID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHJuZy5lbmRPZmZzZXQ7XG4gICAgICBmKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHN0YXJ0RWxlbWVudCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVuZEVsZW1lbnQpKTtcbiAgICAgIGNvbnN0IG5ld1JuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBuZXdSbmcuc2V0U3RhcnQoc3RhcnRFbGVtZW50LCBzdGFydE9mZnNldCk7XG4gICAgICBuZXdSbmcuc2V0RW5kKGVuZEVsZW1lbnQsIGVuZE9mZnNldCk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgIH07XG4gICAgY29uc3Qgc2Nyb2xsVG9NYXJrZXIgPSAoZWRpdG9yLCBtYXJrZXIsIHZpZXdIZWlnaHQsIGFsaWduVG9Ub3AsIGRvYykgPT4ge1xuICAgICAgY29uc3QgcG9zID0gbWFya2VyLnBvcztcbiAgICAgIGlmIChhbGlnblRvVG9wKSB7XG4gICAgICAgIHRvKHBvcy5sZWZ0LCBwb3MudG9wLCBkb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeSA9IHBvcy50b3AgLSB2aWV3SGVpZ2h0ICsgbWFya2VyLmhlaWdodDtcbiAgICAgICAgdG8oLWVkaXRvci5nZXRCb2R5KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCwgeSwgZG9jKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludG9XaW5kb3dJZk5lZWRlZCA9IChlZGl0b3IsIGRvYywgc2Nyb2xsVG9wLCB2aWV3SGVpZ2h0LCBtYXJrZXIsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0Qm90dG9tID0gdmlld0hlaWdodCArIHNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IG1hcmtlclRvcCA9IG1hcmtlci5wb3MudG9wO1xuICAgICAgY29uc3QgbWFya2VyQm90dG9tID0gbWFya2VyLmJvdHRvbTtcbiAgICAgIGNvbnN0IGxhcmdlclRoYW5WaWV3cG9ydCA9IG1hcmtlckJvdHRvbSAtIG1hcmtlclRvcCA+PSB2aWV3SGVpZ2h0O1xuICAgICAgaWYgKG1hcmtlclRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICBzY3JvbGxUb01hcmtlcihlZGl0b3IsIG1hcmtlciwgdmlld0hlaWdodCwgYWxpZ25Ub1RvcCAhPT0gZmFsc2UsIGRvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlclRvcCA+IHZpZXdwb3J0Qm90dG9tKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gbGFyZ2VyVGhhblZpZXdwb3J0ID8gYWxpZ25Ub1RvcCAhPT0gZmFsc2UgOiBhbGlnblRvVG9wID09PSB0cnVlO1xuICAgICAgICBzY3JvbGxUb01hcmtlcihlZGl0b3IsIG1hcmtlciwgdmlld0hlaWdodCwgYWxpZ24sIGRvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1hcmtlckJvdHRvbSA+IHZpZXdwb3J0Qm90dG9tICYmICFsYXJnZXJUaGFuVmlld3BvcnQpIHtcbiAgICAgICAgc2Nyb2xsVG9NYXJrZXIoZWRpdG9yLCBtYXJrZXIsIHZpZXdIZWlnaHQsIGFsaWduVG9Ub3AgPT09IHRydWUsIGRvYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRvV2luZG93ID0gKGVkaXRvciwgZG9jLCBzY3JvbGxUb3AsIG1hcmtlciwgYWxpZ25Ub1RvcCkgPT4ge1xuICAgICAgY29uc3Qgdmlld0hlaWdodCA9IGRlZmF1bHRWaWV3KGRvYykuZG9tLmlubmVySGVpZ2h0O1xuICAgICAgaW50b1dpbmRvd0lmTmVlZGVkKGVkaXRvciwgZG9jLCBzY3JvbGxUb3AsIHZpZXdIZWlnaHQsIG1hcmtlciwgYWxpZ25Ub1RvcCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnRvRnJhbWUgPSAoZWRpdG9yLCBkb2MsIHNjcm9sbFRvcCwgbWFya2VyLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZVZpZXdIZWlnaHQgPSBkZWZhdWx0Vmlldyhkb2MpLmRvbS5pbm5lckhlaWdodDtcbiAgICAgIGludG9XaW5kb3dJZk5lZWRlZChlZGl0b3IsIGRvYywgc2Nyb2xsVG9wLCBmcmFtZVZpZXdIZWlnaHQsIG1hcmtlciwgYWxpZ25Ub1RvcCk7XG4gICAgICBjb25zdCBvcCA9IGZpbmQobWFya2VyLmVsZW1lbnQpO1xuICAgICAgY29uc3Qgdmlld3BvcnRCb3VuZHMgPSBnZXRCb3VuZHMod2luZG93KTtcbiAgICAgIGlmIChvcC50b3AgPCB2aWV3cG9ydEJvdW5kcy55KSB7XG4gICAgICAgIGludG9WaWV3KG1hcmtlci5lbGVtZW50LCBhbGlnblRvVG9wICE9PSBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKG9wLnRvcCA+IHZpZXdwb3J0Qm91bmRzLmJvdHRvbSkge1xuICAgICAgICBpbnRvVmlldyhtYXJrZXIuZWxlbWVudCwgYWxpZ25Ub1RvcCA9PT0gdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByYW5nZUludG9XaW5kb3cgPSAoZWRpdG9yLCBybmcsIGFsaWduVG9Ub3ApID0+IHdpdGhNYXJrZXIoZWRpdG9yLCBpbnRvV2luZG93LCBybmcsIGFsaWduVG9Ub3ApO1xuICAgIGNvbnN0IGVsZW1lbnRJbnRvV2luZG93ID0gKGVkaXRvciwgZWxlbWVudCwgYWxpZ25Ub1RvcCkgPT4gd2l0aEVsZW1lbnQoZWRpdG9yLCBlbGVtZW50LCBpbnRvV2luZG93LCBhbGlnblRvVG9wKTtcbiAgICBjb25zdCByYW5nZUludG9GcmFtZSA9IChlZGl0b3IsIHJuZywgYWxpZ25Ub1RvcCkgPT4gd2l0aE1hcmtlcihlZGl0b3IsIGludG9GcmFtZSwgcm5nLCBhbGlnblRvVG9wKTtcbiAgICBjb25zdCBlbGVtZW50SW50b0ZyYW1lID0gKGVkaXRvciwgZWxlbWVudCwgYWxpZ25Ub1RvcCkgPT4gd2l0aEVsZW1lbnQoZWRpdG9yLCBlbGVtZW50LCBpbnRvRnJhbWUsIGFsaWduVG9Ub3ApO1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnRJbnRvVmlldyA9IChlZGl0b3IsIGVsZW1lbnQsIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbGVyID0gZWRpdG9yLmlubGluZSA/IGVsZW1lbnRJbnRvV2luZG93IDogZWxlbWVudEludG9GcmFtZTtcbiAgICAgIHNjcm9sbGVyKGVkaXRvciwgZWxlbWVudCwgYWxpZ25Ub1RvcCk7XG4gICAgfTtcbiAgICBjb25zdCBzY3JvbGxSYW5nZUludG9WaWV3ID0gKGVkaXRvciwgcm5nLCBhbGlnblRvVG9wKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxlciA9IGVkaXRvci5pbmxpbmUgPyByYW5nZUludG9XaW5kb3cgOiByYW5nZUludG9GcmFtZTtcbiAgICAgIHNjcm9sbGVyKGVkaXRvciwgcm5nLCBhbGlnblRvVG9wKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZm9jdXMkMSA9IGVsZW1lbnQgPT4gZWxlbWVudC5kb20uZm9jdXMoKTtcbiAgICBjb25zdCBoYXNGb2N1cyQxID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCByb290ID0gZ2V0Um9vdE5vZGUoZWxlbWVudCkuZG9tO1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZG9tID09PSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBhY3RpdmUkMSA9IChyb290ID0gZ2V0RG9jdW1lbnQoKSkgPT4gT3B0aW9uYWwuZnJvbShyb290LmRvbS5hY3RpdmVFbGVtZW50KS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IHNlYXJjaCA9IGVsZW1lbnQgPT4gYWN0aXZlJDEoZ2V0Um9vdE5vZGUoZWxlbWVudCkpLmZpbHRlcihlID0+IGVsZW1lbnQuZG9tLmNvbnRhaW5zKGUuZG9tKSk7XG5cbiAgICBjb25zdCBjbGFtcCQxID0gKG9mZnNldCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgbWF4ID0gaXNUZXh0JGIoZWxlbWVudCkgPyBnZXQkMyhlbGVtZW50KS5sZW5ndGggOiBjaGlsZHJlbiQxKGVsZW1lbnQpLmxlbmd0aCArIDE7XG4gICAgICBpZiAob2Zmc2V0ID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplUm5nID0gcm5nID0+IFNpbVNlbGVjdGlvbi5yYW5nZShybmcuc3RhcnQsIGNsYW1wJDEocm5nLnNvZmZzZXQsIHJuZy5zdGFydCksIHJuZy5maW5pc2gsIGNsYW1wJDEocm5nLmZvZmZzZXQsIHJuZy5maW5pc2gpKTtcbiAgICBjb25zdCBpc09yQ29udGFpbnMgPSAocm9vdCwgZWxtKSA9PiAhaXNSZXN0cmljdGVkTm9kZShlbG0uZG9tKSAmJiAoY29udGFpbnMocm9vdCwgZWxtKSB8fCBlcShyb290LCBlbG0pKTtcbiAgICBjb25zdCBpc1JuZ0luUm9vdCA9IHJvb3QgPT4gcm5nID0+IGlzT3JDb250YWlucyhyb290LCBybmcuc3RhcnQpICYmIGlzT3JDb250YWlucyhyb290LCBybmcuZmluaXNoKTtcbiAgICBjb25zdCBzaG91bGRTdG9yZSA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lIHx8IEVudi5icm93c2VyLmlzRmlyZWZveCgpO1xuICAgIGNvbnN0IG5hdGl2ZVJhbmdlVG9TZWxlY3Rpb25SYW5nZSA9IHIgPT4gU2ltU2VsZWN0aW9uLnJhbmdlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHIuc3RhcnRDb250YWluZXIpLCByLnN0YXJ0T2Zmc2V0LCBTdWdhckVsZW1lbnQuZnJvbURvbShyLmVuZENvbnRhaW5lciksIHIuZW5kT2Zmc2V0KTtcbiAgICBjb25zdCByZWFkUmFuZ2UgPSB3aW4gPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICAgICAgY29uc3Qgcm5nID0gIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLmZyb20oc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkpO1xuICAgICAgcmV0dXJuIHJuZy5tYXAobmF0aXZlUmFuZ2VUb1NlbGVjdGlvblJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvb2ttYXJrID0gcm9vdCA9PiB7XG4gICAgICBjb25zdCB3aW4gPSBkZWZhdWx0Vmlldyhyb290KTtcbiAgICAgIHJldHVybiByZWFkUmFuZ2Uod2luLmRvbSkuZmlsdGVyKGlzUm5nSW5Sb290KHJvb3QpKTtcbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRlID0gKHJvb3QsIGJvb2ttYXJrKSA9PiBPcHRpb25hbC5mcm9tKGJvb2ttYXJrKS5maWx0ZXIoaXNSbmdJblJvb3Qocm9vdCkpLm1hcChub3JtYWxpemVSbmcpO1xuICAgIGNvbnN0IGJvb2ttYXJrVG9OYXRpdmVSbmcgPSBib29rbWFyayA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGJvb2ttYXJrLnN0YXJ0LmRvbSwgYm9va21hcmsuc29mZnNldCk7XG4gICAgICAgIHJuZy5zZXRFbmQoYm9va21hcmsuZmluaXNoLmRvbSwgYm9va21hcmsuZm9mZnNldCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHJuZyk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdG9yZSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBuZXdCb29rbWFyayA9IHNob3VsZFN0b3JlKGVkaXRvcikgPyBnZXRCb29rbWFyayhTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICBlZGl0b3IuYm9va21hcmsgPSBuZXdCb29rbWFyay5pc1NvbWUoKSA/IG5ld0Jvb2ttYXJrIDogZWRpdG9yLmJvb2ttYXJrO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Um5nID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJvb2ttYXJrID0gZWRpdG9yLmJvb2ttYXJrID8gZWRpdG9yLmJvb2ttYXJrIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgcmV0dXJuIGJvb2ttYXJrLmJpbmQoeCA9PiB2YWxpZGF0ZShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgeCkpLmJpbmQoYm9va21hcmtUb05hdGl2ZVJuZyk7XG4gICAgfTtcbiAgICBjb25zdCByZXN0b3JlID0gZWRpdG9yID0+IHtcbiAgICAgIGdldFJuZyhlZGl0b3IpLmVhY2gocm5nID0+IGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZykpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VkaXRvclVJRWxlbWVudCQxID0gZWxtID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVsbS5jbGFzc05hbWUudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBjbGFzc05hbWUuaW5kZXhPZigndG94LScpICE9PSAtMSB8fCBjbGFzc05hbWUuaW5kZXhPZignbWNlLScpICE9PSAtMTtcbiAgICB9O1xuICAgIGNvbnN0IEZvY3VzTWFuYWdlciA9IHsgaXNFZGl0b3JVSUVsZW1lbnQ6IGlzRWRpdG9yVUlFbGVtZW50JDEgfTtcblxuICAgIGNvbnN0IHdyYXBwZWRTZXRUaW1lb3V0ID0gKGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICBpZiAoIWlzTnVtYmVyKHRpbWUpKSB7XG4gICAgICAgIHRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWUpO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlZFNldEludGVydmFsID0gKGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICBpZiAoIWlzTnVtYmVyKHRpbWUpKSB7XG4gICAgICAgIHRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldEludGVydmFsKGNhbGxiYWNrLCB0aW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IERlbGF5ID0ge1xuICAgICAgc2V0RWRpdG9yVGltZW91dDogKGVkaXRvciwgY2FsbGJhY2ssIHRpbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRTZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZSk7XG4gICAgICB9LFxuICAgICAgc2V0RWRpdG9ySW50ZXJ2YWw6IChlZGl0b3IsIGNhbGxiYWNrLCB0aW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gd3JhcHBlZFNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWUpO1xuICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzTWFudWFsTm9kZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ25vZGVjaGFuZ2UnICYmIGUuc2VsZWN0aW9uQ2hhbmdlO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJQYWdlTW91c2VVcCA9IChlZGl0b3IsIHRocm90dGxlZFN0b3JlKSA9PiB7XG4gICAgICBjb25zdCBtb3VzZVVwUGFnZSA9ICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU3RvcmUudGhyb3R0bGUoKTtcbiAgICAgIH07XG4gICAgICBET01VdGlscy5ET00uYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwUGFnZSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgRE9NVXRpbHMuRE9NLnVuYmluZChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwUGFnZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyTW91c2VVcCA9IChlZGl0b3IsIHRocm90dGxlZFN0b3JlKSA9PiB7XG4gICAgICBlZGl0b3Iub24oJ21vdXNldXAgdG91Y2hlbmQnLCBfZSA9PiB7XG4gICAgICAgIHRocm90dGxlZFN0b3JlLnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRWRpdG9yRXZlbnRzID0gKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpID0+IHtcbiAgICAgIHJlZ2lzdGVyTW91c2VVcChlZGl0b3IsIHRocm90dGxlZFN0b3JlKTtcbiAgICAgIGVkaXRvci5vbigna2V5dXAgTm9kZUNoYW5nZSBBZnRlclNldFNlbGVjdGlvblJhbmdlJywgZSA9PiB7XG4gICAgICAgIGlmICghaXNNYW51YWxOb2RlQ2hhbmdlKGUpKSB7XG4gICAgICAgICAgc3RvcmUoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciQ2ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRocm90dGxlZFN0b3JlID0gZmlyc3QkMSgoKSA9PiB7XG4gICAgICAgIHN0b3JlKGVkaXRvcik7XG4gICAgICB9LCAwKTtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICByZWdpc3RlclBhZ2VNb3VzZVVwKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyRWRpdG9yRXZlbnRzKGVkaXRvciwgdGhyb3R0bGVkU3RvcmUpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgdGhyb3R0bGVkU3RvcmUuY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGRvY3VtZW50Rm9jdXNJbkhhbmRsZXI7XG4gICAgY29uc3QgRE9NJDkgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgaXNFZGl0b3JVSUVsZW1lbnQgPSBlbG0gPT4ge1xuICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KGVsbSkgJiYgRm9jdXNNYW5hZ2VyLmlzRWRpdG9yVUlFbGVtZW50KGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VkaXRvckNvbnRlbnRBcmVhRWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbG0uY2xhc3NMaXN0O1xuICAgICAgaWYgKGNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0xpc3QuY29udGFpbnMoJ3RveC1lZGl0LWFyZWEnKSB8fCBjbGFzc0xpc3QuY29udGFpbnMoJ3RveC1lZGl0LWFyZWFfX2lmcmFtZScpIHx8IGNsYXNzTGlzdC5jb250YWlucygnbWNlLWNvbnRlbnQtYm9keScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNVSUVsZW1lbnQgPSAoZWRpdG9yLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGN1c3RvbVNlbGVjdG9yID0gZ2V0Q3VzdG9tVWlTZWxlY3RvcihlZGl0b3IpO1xuICAgICAgY29uc3QgcGFyZW50ID0gRE9NJDkuZ2V0UGFyZW50KGVsbSwgZWxtID0+IHtcbiAgICAgICAgcmV0dXJuIGlzRWRpdG9yVUlFbGVtZW50KGVsbSkgfHwgKGN1c3RvbVNlbGVjdG9yID8gZWRpdG9yLmRvbS5pcyhlbG0sIGN1c3RvbVNlbGVjdG9yKSA6IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFjdGl2ZUVsZW1lbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGdldFJvb3ROb2RlKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRFbGVtZW50KCkpKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSQxKHJvb3QpLmZvbGQoKCkgPT4gZG9jdW1lbnQuYm9keSwgeCA9PiB4LmRvbSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRzJDEgPSAoZWRpdG9yTWFuYWdlciwgZSkgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgICByZWdpc3RlciQ2KGVkaXRvcik7XG4gICAgICBjb25zdCB0b2dnbGVDb250ZW50QXJlYU9uRm9jdXMgPSAoZWRpdG9yLCBmbikgPT4ge1xuICAgICAgICBpZiAoc2hvdWxkSGlnaGxpZ2h0T25Gb2N1cyhlZGl0b3IpICYmIGVkaXRvci5pbmxpbmUgIT09IHRydWUpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50QXJlYSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgZm4oY29udGVudEFyZWEsICd0b3gtZWRpdC1mb2N1cycpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWRpdG9yLm9uKCdmb2N1c2luJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c2VkRWRpdG9yID0gZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yO1xuICAgICAgICBpZiAoaXNFZGl0b3JDb250ZW50QXJlYUVsZW1lbnQoZ2V0QWN0aXZlRWxlbWVudChlZGl0b3IpKSkge1xuICAgICAgICAgIHRvZ2dsZUNvbnRlbnRBcmVhT25Gb2N1cyhlZGl0b3IsIGFkZCQyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXNlZEVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRFZGl0b3IpIHtcbiAgICAgICAgICAgIGZvY3VzZWRFZGl0b3IuZGlzcGF0Y2goJ2JsdXInLCB7IGZvY3VzZWRFZGl0b3I6IGVkaXRvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgICAgICBlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdmb2N1cycsIHsgYmx1cnJlZEVkaXRvcjogZm9jdXNlZEVkaXRvciB9KTtcbiAgICAgICAgICBlZGl0b3IuZm9jdXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdmb2N1c291dCcsICgpID0+IHtcbiAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb2N1c2VkRWRpdG9yID0gZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yO1xuICAgICAgICAgIGlmICghaXNFZGl0b3JDb250ZW50QXJlYUVsZW1lbnQoZ2V0QWN0aXZlRWxlbWVudChlZGl0b3IpKSB8fCBmb2N1c2VkRWRpdG9yICE9PSBlZGl0b3IpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNvbnRlbnRBcmVhT25Gb2N1cyhlZGl0b3IsIHJlbW92ZSQ3KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VJRWxlbWVudChlZGl0b3IsIGdldEFjdGl2ZUVsZW1lbnQoZWRpdG9yKSkgJiYgZm9jdXNlZEVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2JsdXInLCB7IGZvY3VzZWRFZGl0b3I6IG51bGwgfSk7XG4gICAgICAgICAgICBlZGl0b3JNYW5hZ2VyLmZvY3VzZWRFZGl0b3IgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghZG9jdW1lbnRGb2N1c0luSGFuZGxlcikge1xuICAgICAgICBkb2N1bWVudEZvY3VzSW5IYW5kbGVyID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlRWRpdG9yID0gZWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3I7XG4gICAgICAgICAgaWYgKGFjdGl2ZUVkaXRvcikge1xuICAgICAgICAgICAgZ2V0T3JpZ2luYWxFdmVudFRhcmdldChlKS5lYWNoKHRhcmdldCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm93bmVyRG9jdW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gIT09IGRvY3VtZW50LmJvZHkgJiYgIWlzVUlFbGVtZW50KGFjdGl2ZUVkaXRvciwgZWxlbSkgJiYgZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID09PSBhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUVkaXRvci5kaXNwYXRjaCgnYmx1cicsIHsgZm9jdXNlZEVkaXRvcjogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgIGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERPTSQ5LmJpbmQoZG9jdW1lbnQsICdmb2N1c2luJywgZG9jdW1lbnRGb2N1c0luSGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyRG9jdW1lbnRFdmVudHMgPSAoZWRpdG9yTWFuYWdlciwgZSkgPT4ge1xuICAgICAgaWYgKGVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gZS5lZGl0b3IpIHtcbiAgICAgICAgZWRpdG9yTWFuYWdlci5mb2N1c2VkRWRpdG9yID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghZWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IgJiYgZG9jdW1lbnRGb2N1c0luSGFuZGxlcikge1xuICAgICAgICBET00kOS51bmJpbmQoZG9jdW1lbnQsICdmb2N1c2luJywgZG9jdW1lbnRGb2N1c0luSGFuZGxlcik7XG4gICAgICAgIGRvY3VtZW50Rm9jdXNJbkhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkdiA9IGVkaXRvck1hbmFnZXIgPT4ge1xuICAgICAgZWRpdG9yTWFuYWdlci5vbignQWRkRWRpdG9yJywgY3VycnkocmVnaXN0ZXJFdmVudHMkMSwgZWRpdG9yTWFuYWdlcikpO1xuICAgICAgZWRpdG9yTWFuYWdlci5vbignUmVtb3ZlRWRpdG9yJywgY3VycnkodW5yZWdpc3RlckRvY3VtZW50RXZlbnRzLCBlZGl0b3JNYW5hZ2VyKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZUhvc3QgPSAoZWRpdG9yLCBub2RlKSA9PiBlZGl0b3IuZG9tLmdldFBhcmVudChub2RlLCBub2RlID0+IGVkaXRvci5kb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpID09PSAndHJ1ZScpO1xuICAgIGNvbnN0IGdldENvbGxhcHNlZE5vZGUgPSBybmcgPT4gcm5nLmNvbGxhcHNlZCA/IE9wdGlvbmFsLmZyb20oZ2V0Tm9kZSQxKHJuZy5zdGFydENvbnRhaW5lciwgcm5nLnN0YXJ0T2Zmc2V0KSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICBjb25zdCBnZXRGb2N1c0luRWxlbWVudCA9IChyb290LCBybmcpID0+IGdldENvbGxhcHNlZE5vZGUocm5nKS5iaW5kKG5vZGUgPT4ge1xuICAgICAgaWYgKGlzVGFibGVTZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG5vZGUpO1xuICAgICAgfSBlbHNlIGlmICghY29udGFpbnMocm9vdCwgbm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocm9vdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVNlbGVjdGlvbiA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgZ2V0Rm9jdXNJbkVsZW1lbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSksIHJuZykuYmluZChlbG0gPT4ge1xuICAgICAgICByZXR1cm4gZmlyc3RQb3NpdGlvbkluKGVsbS5kb20pO1xuICAgICAgfSkuZm9sZCgoKSA9PiB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB9LCBjYXJldFBvcyA9PiBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFBvcy50b1JhbmdlKCkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvY3VzQm9keSA9IGJvZHkgPT4ge1xuICAgICAgaWYgKGJvZHkuc2V0QWN0aXZlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keS5zZXRBY3RpdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0VsZW1lbnRGb2N1cyA9IGVsbSA9PiBoYXNGb2N1cyQxKGVsbSkgfHwgc2VhcmNoKGVsbSkuaXNTb21lKCk7XG4gICAgY29uc3QgaGFzSWZyYW1lRm9jdXMgPSBlZGl0b3IgPT4gaXNOb25OdWxsYWJsZShlZGl0b3IuaWZyYW1lRWxlbWVudCkgJiYgaGFzRm9jdXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuaWZyYW1lRWxlbWVudCkpO1xuICAgIGNvbnN0IGhhc0lubGluZUZvY3VzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJhd0JvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmV0dXJuIHJhd0JvZHkgJiYgaGFzRWxlbWVudEZvY3VzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd0JvZHkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc1VpRm9jdXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9zID0gZ2V0Um9vdE5vZGUoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEVsZW1lbnQoKSkpO1xuICAgICAgcmV0dXJuIGFjdGl2ZSQxKGRvcykuZmlsdGVyKGVsZW0gPT4gIWlzRWRpdG9yQ29udGVudEFyZWFFbGVtZW50KGVsZW0uZG9tKSAmJiBpc1VJRWxlbWVudChlZGl0b3IsIGVsZW0uZG9tKSkuaXNTb21lKCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNGb2N1cyA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gaGFzSW5saW5lRm9jdXMoZWRpdG9yKSA6IGhhc0lmcmFtZUZvY3VzKGVkaXRvcik7XG4gICAgY29uc3QgaGFzRWRpdG9yT3JVaUZvY3VzID0gZWRpdG9yID0+IGhhc0ZvY3VzKGVkaXRvcikgfHwgaGFzVWlGb2N1cyhlZGl0b3IpO1xuICAgIGNvbnN0IGZvY3VzRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGxldCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBlZGl0b3IucXVpcmtzLnJlZnJlc2hDb250ZW50RWRpdGFibGUoKTtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKGVkaXRvci5ib29rbWFyaykgJiYgIWhhc0ZvY3VzKGVkaXRvcikpIHtcbiAgICAgICAgZ2V0Um5nKGVkaXRvcikuZWFjaChib29rbWFya1JuZyA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoYm9va21hcmtSbmcpO1xuICAgICAgICAgIHJuZyA9IGJvb2ttYXJrUm5nO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZUhvc3QgPSBnZXRDb250ZW50RWRpdGFibGVIb3N0KGVkaXRvciwgc2VsZWN0aW9uLmdldE5vZGUoKSk7XG4gICAgICBpZiAoY29udGVudEVkaXRhYmxlSG9zdCAmJiBlZGl0b3IuZG9tLmlzQ2hpbGRPZihjb250ZW50RWRpdGFibGVIb3N0LCBib2R5KSkge1xuICAgICAgICBmb2N1c0JvZHkoY29udGVudEVkaXRhYmxlSG9zdCk7XG4gICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvbihlZGl0b3IsIHJuZyk7XG4gICAgICAgIGFjdGl2YXRlRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZWRpdG9yLmlubGluZSkge1xuICAgICAgICBpZiAoIUVudi5icm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgICAgIGZvY3VzQm9keShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZ2V0V2luKCkuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKSB8fCBlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgIGZvY3VzQm9keShib2R5KTtcbiAgICAgICAgbm9ybWFsaXplU2VsZWN0aW9uKGVkaXRvciwgcm5nKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2YXRlRWRpdG9yKGVkaXRvcik7XG4gICAgfTtcbiAgICBjb25zdCBhY3RpdmF0ZUVkaXRvciA9IGVkaXRvciA9PiBlZGl0b3IuZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICBjb25zdCBmb2N1cyA9IChlZGl0b3IsIHNraXBGb2N1cykgPT4ge1xuICAgICAgaWYgKGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChza2lwRm9jdXMpIHtcbiAgICAgICAgYWN0aXZhdGVFZGl0b3IoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzRWRpdG9yKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGdldEVuZHBvaW50RWxlbWVudCA9IChyb290LCBybmcsIHN0YXJ0LCByZWFsLCByZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBzdGFydCA/IHJuZy5zdGFydENvbnRhaW5lciA6IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGFydCA/IHJuZy5zdGFydE9mZnNldCA6IHJuZy5lbmRPZmZzZXQ7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShjb250YWluZXIpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSkubWFwKGVsbSA9PiAhcmVhbCB8fCAhcm5nLmNvbGxhcHNlZCA/IGNoaWxkJDEoZWxtLCByZXNvbHZlKGVsbSwgb2Zmc2V0KSkuZ2V0T3IoZWxtKSA6IGVsbSkuYmluZChlbG0gPT4gaXNFbGVtZW50JDcoZWxtKSA/IE9wdGlvbmFsLnNvbWUoZWxtKSA6IHBhcmVudChlbG0pLmZpbHRlcihpc0VsZW1lbnQkNykpLm1hcChlbG0gPT4gZWxtLmRvbSkuZ2V0T3Iocm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTdGFydCA9IChyb290LCBybmcsIHJlYWwgPSBmYWxzZSkgPT4gZ2V0RW5kcG9pbnRFbGVtZW50KHJvb3QsIHJuZywgdHJ1ZSwgcmVhbCwgKGVsbSwgb2Zmc2V0KSA9PiBNYXRoLm1pbihjaGlsZE5vZGVzQ291bnQoZWxtKSwgb2Zmc2V0KSk7XG4gICAgY29uc3QgZ2V0RW5kJDEgPSAocm9vdCwgcm5nLCByZWFsID0gZmFsc2UpID0+IGdldEVuZHBvaW50RWxlbWVudChyb290LCBybmcsIGZhbHNlLCByZWFsLCAoZWxtLCBvZmZzZXQpID0+IG9mZnNldCA+IDAgPyBvZmZzZXQgLSAxIDogb2Zmc2V0KTtcbiAgICBjb25zdCBza2lwRW1wdHlUZXh0Tm9kZXMgPSAobm9kZSwgZm9yd2FyZHMpID0+IHtcbiAgICAgIGNvbnN0IG9yaWcgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgaXNUZXh0JGEobm9kZSkgJiYgbm9kZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbm9kZSA9IGZvcndhcmRzID8gbm9kZS5uZXh0U2libGluZyA6IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgfHwgb3JpZztcbiAgICB9O1xuICAgIGNvbnN0IGdldE5vZGUgPSAocm9vdCwgcm5nKSA9PiB7XG4gICAgICBpZiAoIXJuZykge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH1cbiAgICAgIGxldCBzdGFydENvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGxldCBlbmRDb250YWluZXIgPSBybmcuZW5kQ29udGFpbmVyO1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBlbmRPZmZzZXQgPSBybmcuZW5kT2Zmc2V0O1xuICAgICAgbGV0IG5vZGUgPSBybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRDb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBzdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3N0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKHN0YXJ0Q29udGFpbmVyKSAmJiBpc1RleHQkYShlbmRDb250YWluZXIpKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLmxlbmd0aCA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc2tpcEVtcHR5VGV4dE5vZGVzKHN0YXJ0Q29udGFpbmVyLm5leHRTaWJsaW5nLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBza2lwRW1wdHlUZXh0Tm9kZXMoZW5kQ29udGFpbmVyLnByZXZpb3VzU2libGluZywgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBlbmRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyICYmIHN0YXJ0Q29udGFpbmVyID09PSBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIG5vZGUgPSBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsbSA9IGlzVGV4dCRhKG5vZGUpID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZTtcbiAgICAgIHJldHVybiBpc0VsZW1lbnQkNihlbG0pID8gZWxtIDogcm9vdDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNlbGVjdGVkQmxvY2tzID0gKGRvbSwgcm5nLCBzdGFydEVsbSwgZW5kRWxtKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFtdO1xuICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICBjb25zdCBzdGFydCA9IGRvbS5nZXRQYXJlbnQoc3RhcnRFbG0gfHwgZ2V0U3RhcnQocm9vdCwgcm5nLCBybmcuY29sbGFwc2VkKSwgZG9tLmlzQmxvY2spO1xuICAgICAgY29uc3QgZW5kID0gZG9tLmdldFBhcmVudChlbmRFbG0gfHwgZ2V0RW5kJDEocm9vdCwgcm5nLCBybmcuY29sbGFwc2VkKSwgZG9tLmlzQmxvY2spO1xuICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0ICE9PSByb290KSB7XG4gICAgICAgIHNlbGVjdGVkQmxvY2tzLnB1c2goc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihzdGFydCwgcm9vdCk7XG4gICAgICAgIHdoaWxlICgobm9kZSA9IHdhbGtlci5uZXh0KCkpICYmIG5vZGUgIT09IGVuZCkge1xuICAgICAgICAgIGlmIChkb20uaXNCbG9jayhub2RlKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRCbG9ja3MucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgc3RhcnQgIT09IGVuZCAmJiBlbmQgIT09IHJvb3QpIHtcbiAgICAgICAgc2VsZWN0ZWRCbG9ja3MucHVzaChlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzO1xuICAgIH07XG4gICAgY29uc3Qgc2VsZWN0ID0gKGRvbSwgbm9kZSwgY29udGVudCkgPT4gT3B0aW9uYWwuZnJvbShub2RlKS5iaW5kKG5vZGUgPT4gT3B0aW9uYWwuZnJvbShub2RlLnBhcmVudE5vZGUpLm1hcChwYXJlbnQgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gZG9tLm5vZGVJbmRleChub2RlKTtcbiAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgIHJuZy5zZXRTdGFydChwYXJlbnQsIGlkeCk7XG4gICAgICBybmcuc2V0RW5kKHBhcmVudCwgaWR4ICsgMSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIG5vZGUsIHRydWUpO1xuICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBybmc7XG4gICAgfSkpO1xuXG4gICAgY29uc3QgcHJvY2Vzc1JhbmdlcyA9IChlZGl0b3IsIHJhbmdlcykgPT4gbWFwJDMocmFuZ2VzLCByYW5nZSA9PiB7XG4gICAgICBjb25zdCBldnQgPSBlZGl0b3IuZGlzcGF0Y2goJ0dldFNlbGVjdGlvblJhbmdlJywgeyByYW5nZSB9KTtcbiAgICAgIHJldHVybiBldnQucmFuZ2UgIT09IHJhbmdlID8gZXZ0LnJhbmdlIDogcmFuZ2U7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRFbmQgPSBlbGVtZW50ID0+IG5hbWUoZWxlbWVudCkgPT09ICdpbWcnID8gMSA6IGdldE9wdGlvbihlbGVtZW50KS5mb2xkKCgpID0+IGNoaWxkcmVuJDEoZWxlbWVudCkubGVuZ3RoLCB2ID0+IHYubGVuZ3RoKTtcbiAgICBjb25zdCBpc1RleHROb2RlV2l0aEN1cnNvclBvc2l0aW9uID0gZWwgPT4gZ2V0T3B0aW9uKGVsKS5maWx0ZXIodGV4dCA9PiB0ZXh0LnRyaW0oKS5sZW5ndGggIT09IDAgfHwgdGV4dC5pbmRleE9mKG5ic3ApID4gLTEpLmlzU29tZSgpO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkNSA9IGVsZW0gPT4gaXNIVE1MRWxlbWVudChlbGVtKSAmJiBnZXQkOShlbGVtLCAnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZSc7XG4gICAgY29uc3QgZWxlbWVudHNXaXRoQ3Vyc29yUG9zaXRpb24gPSBbXG4gICAgICAnaW1nJyxcbiAgICAgICdicidcbiAgICBdO1xuICAgIGNvbnN0IGlzQ3Vyc29yUG9zaXRpb24gPSBlbGVtID0+IHtcbiAgICAgIGNvbnN0IGhhc0N1cnNvclBvc2l0aW9uID0gaXNUZXh0Tm9kZVdpdGhDdXJzb3JQb3NpdGlvbihlbGVtKTtcbiAgICAgIHJldHVybiBoYXNDdXJzb3JQb3NpdGlvbiB8fCBjb250YWlucyQyKGVsZW1lbnRzV2l0aEN1cnNvclBvc2l0aW9uLCBuYW1lKGVsZW0pKSB8fCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDUoZWxlbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpcnN0ID0gZWxlbWVudCA9PiBkZXNjZW5kYW50JDEoZWxlbWVudCwgaXNDdXJzb3JQb3NpdGlvbik7XG4gICAgY29uc3QgbGFzdCA9IGVsZW1lbnQgPT4gZGVzY2VuZGFudFJ0bChlbGVtZW50LCBpc0N1cnNvclBvc2l0aW9uKTtcbiAgICBjb25zdCBkZXNjZW5kYW50UnRsID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NlbmQgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbiQxKGVsZW1lbnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcyA9IGRlc2NlbmQoY2hpbGQpO1xuICAgICAgICAgIGlmIChyZXMuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRlc2NlbmQoc2NvcGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBhdXRvY29tcGxldGVTZWxlY3RvciA9ICdbZGF0YS1tY2UtYXV0b2NvbXBsZXRlcl0nO1xuICAgIGNvbnN0IGNyZWF0ZSQ5ID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICAgIGlmIChmaW5kSW4oU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSkpLmlzTm9uZSgpKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBTdWdhckVsZW1lbnQuZnJvbUh0bWwoJzxzcGFuIGRhdGEtbWNlLWF1dG9jb21wbGV0ZXI9XCIxXCIgZGF0YS1tY2UtYm9ndXM9XCIxXCI+PC9zcGFuPicsIGVkaXRvci5nZXREb2MoKSk7XG4gICAgICAgIGFwcGVuZCQxKHdyYXBwZXIsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhbmdlLmV4dHJhY3RDb250ZW50cygpKSk7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUod3JhcHBlci5kb20pO1xuICAgICAgICBwYXJlbnQod3JhcHBlcikuZWFjaChlbG0gPT4gZWxtLmRvbS5ub3JtYWxpemUoKSk7XG4gICAgICAgIGxhc3Qod3JhcHBlcikubWFwKGxhc3QgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24obGFzdC5kb20sIGdldEVuZChsYXN0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGV0ZWN0JDEgPSBlbG0gPT4gY2xvc2VzdCQzKGVsbSwgYXV0b2NvbXBsZXRlU2VsZWN0b3IpO1xuICAgIGNvbnN0IGZpbmRJbiA9IGVsbSA9PiBkZXNjZW5kYW50KGVsbSwgYXV0b2NvbXBsZXRlU2VsZWN0b3IpO1xuICAgIGNvbnN0IHJlbW92ZSQyID0gKGVkaXRvciwgZWxtKSA9PiBmaW5kSW4oZWxtKS5lYWNoKHdyYXBwZXIgPT4ge1xuICAgICAgY29uc3QgYm9va21hcmsgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICB1bndyYXAod3JhcHBlcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGVMb29rdXAgPSB7XG4gICAgICAnI3RleHQnOiAzLFxuICAgICAgJyNjb21tZW50JzogOCxcbiAgICAgICcjY2RhdGEnOiA0LFxuICAgICAgJyNwaSc6IDcsXG4gICAgICAnI2RvY3R5cGUnOiAxMCxcbiAgICAgICcjZG9jdW1lbnQtZnJhZ21lbnQnOiAxMVxuICAgIH07XG4gICAgY29uc3Qgd2FsayQyID0gKG5vZGUsIHJvb3QsIHByZXYpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IHByZXYgPyAnbGFzdENoaWxkJyA6ICdmaXJzdENoaWxkJztcbiAgICAgIGNvbnN0IHNpYmxpbmdOYW1lID0gcHJldiA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgIGlmIChub2RlW3N0YXJ0TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbc3RhcnROYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICE9PSByb290KSB7XG4gICAgICAgIGxldCBzaWJsaW5nID0gbm9kZVtzaWJsaW5nTmFtZV07XG4gICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnQ7IHBhcmVudCAmJiBwYXJlbnQgIT09IHJvb3Q7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50W3NpYmxpbmdOYW1lXTtcbiAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgaXNFbXB0eVRleHROb2RlID0gbm9kZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0ZXh0ID0gKF9hID0gbm9kZS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICBpZiAoIWlzV2hpdGVzcGFjZVRleHQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKHBhcmVudE5vZGUgJiYgKHBhcmVudE5vZGUubmFtZSAhPT0gJ3NwYW4nIHx8IHBhcmVudE5vZGUuYXR0cignc3R5bGUnKSkgJiYgL15bIF0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTm9uRW1wdHlFbGVtZW50ID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBpc05hbWVkQW5jaG9yID0gbm9kZS5uYW1lID09PSAnYScgJiYgIW5vZGUuYXR0cignaHJlZicpICYmIG5vZGUuYXR0cignaWQnKTtcbiAgICAgIHJldHVybiBub2RlLmF0dHIoJ25hbWUnKSB8fCBub2RlLmF0dHIoJ2lkJykgJiYgIW5vZGUuZmlyc3RDaGlsZCB8fCBub2RlLmF0dHIoJ2RhdGEtbWNlLWJvb2ttYXJrJykgfHwgaXNOYW1lZEFuY2hvcjtcbiAgICB9O1xuICAgIGNsYXNzIEFzdE5vZGUge1xuICAgICAgc3RhdGljIGNyZWF0ZShuYW1lLCBhdHRycykge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IEFzdE5vZGUobmFtZSwgdHlwZUxvb2t1cFtuYW1lXSB8fCAxKTtcbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgZWFjaCRkKGF0dHJzLCAodmFsdWUsIGF0dHJOYW1lKSA9PiB7XG4gICAgICAgICAgICBub2RlLmF0dHIoYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMubWFwID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcGxhY2Uobm9kZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluc2VydChub2RlLCBzZWxmKTtcbiAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBhdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobmFtZSkpIHtcbiAgICAgICAgICAgIGVhY2gkZChuYW1lLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLmF0dHIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBzZWxmLmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gYXR0cnMubWFwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzLm1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGF0dHJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lIGluIGF0dHJzLm1hcCkge1xuICAgICAgICAgICAgICBsZXQgaSA9IGF0dHJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyc1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBhdHRyc1tpXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdHRycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cnMubWFwW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGF0dHJzLm1hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBBc3ROb2RlKHNlbGYubmFtZSwgc2VsZi50eXBlKTtcbiAgICAgICAgY29uc3Qgc2VsZkF0dHJzID0gc2VsZi5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoc2VsZkF0dHJzKSB7XG4gICAgICAgICAgY29uc3QgY2xvbmVBdHRycyA9IFtdO1xuICAgICAgICAgIGNsb25lQXR0cnMubWFwID0ge307XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzZWxmQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmQXR0ciA9IHNlbGZBdHRyc1tpXTtcbiAgICAgICAgICAgIGlmIChzZWxmQXR0ci5uYW1lICE9PSAnaWQnKSB7XG4gICAgICAgICAgICAgIGNsb25lQXR0cnNbY2xvbmVBdHRycy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlbGZBdHRyLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNlbGZBdHRyLnZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNsb25lQXR0cnMubWFwW3NlbGZBdHRyLm5hbWVdID0gc2VsZkF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsb25lLmF0dHJpYnV0ZXMgPSBjbG9uZUF0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnZhbHVlID0gc2VsZi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgICAgd3JhcCh3cmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5wYXJlbnQpIHtcbiAgICAgICAgICBzZWxmLnBhcmVudC5pbnNlcnQod3JhcHBlciwgc2VsZik7XG4gICAgICAgICAgd3JhcHBlci5hcHBlbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICB1bndyYXAoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsZi5maXJzdENoaWxkOyBub2RlOykge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgc2VsZi5pbnNlcnQobm9kZSwgc2VsZiwgdHJ1ZSk7XG4gICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIHBhcmVudCA9IHNlbGYucGFyZW50LCBuZXh0ID0gc2VsZi5uZXh0LCBwcmV2ID0gc2VsZi5wcmV2O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5maXJzdENoaWxkID09PSBzZWxmKSB7XG4gICAgICAgICAgICBwYXJlbnQuZmlyc3RDaGlsZCA9IG5leHQ7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LnByZXYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudC5sYXN0Q2hpbGQgPT09IHNlbGYpIHtcbiAgICAgICAgICAgIHBhcmVudC5sYXN0Q2hpbGQgPSBwcmV2O1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucGFyZW50ID0gc2VsZi5uZXh0ID0gc2VsZi5wcmV2ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3QgPSBzZWxmLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICBsYXN0Lm5leHQgPSBub2RlO1xuICAgICAgICAgIG5vZGUucHJldiA9IGxhc3Q7XG4gICAgICAgICAgc2VsZi5sYXN0Q2hpbGQgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYubGFzdENoaWxkID0gc2VsZi5maXJzdENoaWxkID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudCA9IHNlbGY7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgaW5zZXJ0KG5vZGUsIHJlZk5vZGUsIGJlZm9yZSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHJlZk5vZGUucGFyZW50IHx8IHRoaXM7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAocmVmTm9kZSA9PT0gcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZk5vZGUucHJldikge1xuICAgICAgICAgICAgcmVmTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnByZXYgPSByZWZOb2RlLnByZXY7XG4gICAgICAgICAgbm9kZS5uZXh0ID0gcmVmTm9kZTtcbiAgICAgICAgICByZWZOb2RlLnByZXYgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWZOb2RlID09PSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZk5vZGUubmV4dCkge1xuICAgICAgICAgICAgcmVmTm9kZS5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm5leHQgPSByZWZOb2RlLm5leHQ7XG4gICAgICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZTtcbiAgICAgICAgICByZWZOb2RlLm5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIGdldEFsbChuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSB3YWxrJDIobm9kZSwgc2VsZikpIHtcbiAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gW107XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBub2RlLm5leHQpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbXB0eSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSB3YWxrJDIobm9kZSwgc2VsZikpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbm9kZS5maXJzdENoaWxkID0gbm9kZS5sYXN0Q2hpbGQgPSBub2RlLm5leHQgPSBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZpcnN0Q2hpbGQgPSBzZWxmLmxhc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgaXNFbXB0eShlbGVtZW50cywgd2hpdGVzcGFjZSA9IHt9LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSBzZWxmLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChpc05vbkVtcHR5RWxlbWVudChzZWxmKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuYXR0cignZGF0YS1tY2UtYm9ndXMnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50c1tub2RlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc05vbkVtcHR5RWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAzICYmICFpc0VtcHR5VGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLnBhcmVudCAmJiB3aGl0ZXNwYWNlW25vZGUucGFyZW50Lm5hbWVdICYmIGlzV2hpdGVzcGFjZVRleHQoKF9hID0gbm9kZS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgJiYgcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChub2RlID0gd2FsayQyKG5vZGUsIHNlbGYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdhbGsocHJldikge1xuICAgICAgICByZXR1cm4gd2FsayQyKHRoaXMsIG51bGwsIHByZXYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQ29uZGl0aW9uYWxDb21tZW50ID0gKGh0bWwsIHN0YXJ0SW5kZXgpID0+IC9eXFxzKlxcW2lmIFtcXHdcXFddK1xcXT4uKjwhXFxbZW5kaWZcXF0oLS0hPyk/Pi8udGVzdChodG1sLnN1YnN0cihzdGFydEluZGV4KSk7XG4gICAgY29uc3QgZmluZENvbW1lbnRFbmRJbmRleCA9IChodG1sLCBpc0JvZ3VzLCBzdGFydEluZGV4ID0gMCkgPT4ge1xuICAgICAgY29uc3QgbGNIdG1sID0gaHRtbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxjSHRtbC5pbmRleE9mKCdbaWYgJywgc3RhcnRJbmRleCkgIT09IC0xICYmIGlzQ29uZGl0aW9uYWxDb21tZW50KGxjSHRtbCwgc3RhcnRJbmRleCkpIHtcbiAgICAgICAgY29uc3QgZW5kSWZJbmRleCA9IGxjSHRtbC5pbmRleE9mKCdbZW5kaWZdJywgc3RhcnRJbmRleCk7XG4gICAgICAgIHJldHVybiBsY0h0bWwuaW5kZXhPZignPicsIGVuZElmSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQm9ndXMpIHtcbiAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGxjSHRtbC5pbmRleE9mKCc+Jywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIGVuZEluZGV4ICE9PSAtMSA/IGVuZEluZGV4IDogbGNIdG1sLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbmRDb21tZW50UmVnZXhwID0gLy0tIT8+L2c7XG4gICAgICAgICAgZW5kQ29tbWVudFJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gZW5kQ29tbWVudFJlZ2V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGNIdG1sLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZE1hdGNoaW5nRW5kVGFnSW5kZXggPSAoc2NoZW1hLCBodG1sLCBzdGFydEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRhZ1JlZ0V4cCA9IC88KFshP1xcL10pPyhbQS1aYS16MC05XFwtXzouXSspL2c7XG4gICAgICBjb25zdCBlbmRUYWdSZWdFeHAgPSAvKD86XFxzKD86W14nXCI+XSsoPzpcIlteXCJdKlwifCdbXiddKicpKSpbXlwiJz5dKig/OlwiW15cIj5dKnwnW14nPl0qKT98XFxzKnxcXC8pPi9nO1xuICAgICAgY29uc3Qgdm9pZEVsZW1lbnRzID0gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgbGV0IGNvdW50ID0gMSwgaW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgd2hpbGUgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHN0YXJ0VGFnUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0TWF0Y2ggPSBzdGFydFRhZ1JlZ0V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgIGlmIChzdGFydE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydE1hdGNoWzFdID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHN0YXJ0TWF0Y2hbMl0sICctLScpKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gZmluZENvbW1lbnRFbmRJbmRleChodG1sLCBmYWxzZSwgc3RhcnRNYXRjaC5pbmRleCArICchLS0nLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleCA9IGZpbmRDb21tZW50RW5kSW5kZXgoaHRtbCwgdHJ1ZSwgc3RhcnRNYXRjaC5pbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZFRhZ1JlZ0V4cC5sYXN0SW5kZXggPSBzdGFydFRhZ1JlZ0V4cC5sYXN0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmRNYXRjaCA9IGVuZFRhZ1JlZ0V4cC5leGVjKGh0bWwpO1xuICAgICAgICAgICAgaWYgKGlzTnVsbChlbmRNYXRjaCkgfHwgZW5kTWF0Y2guaW5kZXggIT09IHN0YXJ0VGFnUmVnRXhwLmxhc3RJbmRleCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydE1hdGNoWzFdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWhhcyQyKHZvaWRFbGVtZW50cywgc3RhcnRNYXRjaFsyXSkpIHtcbiAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gc3RhcnRUYWdSZWdFeHAubGFzdEluZGV4ICsgZW5kTWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSHRtbCQxID0gKHRlbXBBdHRycywgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgdHJpbUNvbnRlbnRSZWdFeHAgPSBuZXcgUmVnRXhwKFsnXFxcXHM/KCcgKyB0ZW1wQXR0cnMuam9pbignfCcpICsgJyk9XCJbXlwiXStcIiddLmpvaW4oJ3wnKSwgJ2dpJyk7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHRyaW1Db250ZW50UmVnRXhwLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW50ZXJuYWwgPSAoc2VyaWFsaXplciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgYm9ndXNBbGxSZWdFeHAgPSAvPChcXHcrKSBbXj5dKmRhdGEtbWNlLWJvZ3VzPVwiYWxsXCJbXj5dKj4vZztcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHNlcmlhbGl6ZXIuc2NoZW1hO1xuICAgICAgbGV0IGNvbnRlbnQgPSB0cmltSHRtbCQxKHNlcmlhbGl6ZXIuZ2V0VGVtcEF0dHJzKCksIGh0bWwpO1xuICAgICAgY29uc3Qgdm9pZEVsZW1lbnRzID0gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICB3aGlsZSAobWF0Y2hlcyA9IGJvZ3VzQWxsUmVnRXhwLmV4ZWMoY29udGVudCkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBib2d1c0FsbFJlZ0V4cC5sYXN0SW5kZXg7XG4gICAgICAgIGNvbnN0IG1hdGNoTGVuZ3RoID0gbWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGxldCBlbmRUYWdJbmRleDtcbiAgICAgICAgaWYgKHZvaWRFbGVtZW50c1ttYXRjaGVzWzFdXSkge1xuICAgICAgICAgIGVuZFRhZ0luZGV4ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kVGFnSW5kZXggPSBmaW5kTWF0Y2hpbmdFbmRUYWdJbmRleChzY2hlbWEsIGNvbnRlbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXggLSBtYXRjaExlbmd0aCkgKyBjb250ZW50LnN1YnN0cmluZyhlbmRUYWdJbmRleCk7XG4gICAgICAgIGJvZ3VzQWxsUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4IC0gbWF0Y2hMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJpbSQxKGNvbnRlbnQpO1xuICAgIH07XG4gICAgY29uc3QgdHJpbUV4dGVybmFsID0gdHJpbUludGVybmFsO1xuXG4gICAgY29uc3QgY2xlYW51cEJvZ3VzRWxlbWVudHMgPSBwYXJlbnQgPT4ge1xuICAgICAgY29uc3QgYm9ndXNFbGVtZW50cyA9IGRlc2NlbmRhbnRzKHBhcmVudCwgJ1tkYXRhLW1jZS1ib2d1c10nKTtcbiAgICAgIGVhY2gkZShib2d1c0VsZW1lbnRzLCBlbGVtID0+IHtcbiAgICAgICAgY29uc3QgYm9ndXNWYWx1ZSA9IGdldCQ5KGVsZW0sICdkYXRhLW1jZS1ib2d1cycpO1xuICAgICAgICBpZiAoYm9ndXNWYWx1ZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICByZW1vdmUkNShlbGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0JyJDUoZWxlbSkpIHtcbiAgICAgICAgICBiZWZvcmUkMyhlbGVtLCBTdWdhckVsZW1lbnQuZnJvbVRleHQoemVyb1dpZHRoKSk7XG4gICAgICAgICAgcmVtb3ZlJDUoZWxlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW53cmFwKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFudXBJbnB1dE5hbWVzID0gcGFyZW50ID0+IHtcbiAgICAgIGNvbnN0IGlucHV0cyA9IGRlc2NlbmRhbnRzKHBhcmVudCwgJ2lucHV0Jyk7XG4gICAgICBlYWNoJGUoaW5wdXRzLCBpbnB1dCA9PiB7XG4gICAgICAgIHJlbW92ZSRhKGlucHV0LCAnbmFtZScpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaW1FbXB0eUNvbnRlbnRzID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgYmxvY2tOYW1lID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCBlbXB0eVJlZ0V4cCA9IG5ldyBSZWdFeHAoYF4oPCR7IGJsb2NrTmFtZSB9W14+XSo+KCZuYnNwO3wmIzE2MDt8XFxcXHN8XFx1MDBhMHw8YnIgXFxcXC8+fCk8XFxcXC8keyBibG9ja05hbWUgfT5bXFxyXFxuXSp8PGJyIFxcXFwvPltcXHJcXG5dKikkYCk7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVtcHR5UmVnRXhwLCAnJyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQbGFpblRleHRDb250ZW50ID0gKGVkaXRvciwgYm9keSkgPT4ge1xuICAgICAgY29uc3QgZG9jID0gZWRpdG9yLmdldERvYygpO1xuICAgICAgY29uc3QgZG9zID0gZ2V0Um9vdE5vZGUoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuRGl2ID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2RpdicsIGRvYyk7XG4gICAgICBzZXQkMyhvZmZzY3JlZW5EaXYsICdkYXRhLW1jZS1ib2d1cycsICdhbGwnKTtcbiAgICAgIHNldEFsbChvZmZzY3JlZW5EaXYsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIGxlZnQ6ICctOTk5OTk5OXB4JyxcbiAgICAgICAgdG9wOiAnMCdcbiAgICAgIH0pO1xuICAgICAgc2V0JDEob2Zmc2NyZWVuRGl2LCBib2R5LmlubmVySFRNTCk7XG4gICAgICBjbGVhbnVwQm9ndXNFbGVtZW50cyhvZmZzY3JlZW5EaXYpO1xuICAgICAgY2xlYW51cElucHV0TmFtZXMob2Zmc2NyZWVuRGl2KTtcbiAgICAgIGNvbnN0IHJvb3QgPSBnZXRDb250ZW50Q29udGFpbmVyKGRvcyk7XG4gICAgICBhcHBlbmQkMShyb290LCBvZmZzY3JlZW5EaXYpO1xuICAgICAgY29uc3QgY29udGVudCA9IHRyaW0kMShvZmZzY3JlZW5EaXYuZG9tLmlubmVyVGV4dCk7XG4gICAgICByZW1vdmUkNShvZmZzY3JlZW5EaXYpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDb250ZW50RnJvbUJvZHkgPSAoZWRpdG9yLCBhcmdzLCBib2R5KSA9PiB7XG4gICAgICBsZXQgY29udGVudDtcbiAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3JhdycpIHtcbiAgICAgICAgY29udGVudCA9IFRvb2xzLnRyaW0odHJpbUV4dGVybmFsKGVkaXRvci5zZXJpYWxpemVyLCBib2R5LmlubmVySFRNTCkpO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRlbnQgPSBnZXRQbGFpblRleHRDb250ZW50KGVkaXRvciwgYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MuZm9ybWF0ID09PSAndHJlZScpIHtcbiAgICAgICAgY29udGVudCA9IGVkaXRvci5zZXJpYWxpemVyLnNlcmlhbGl6ZShib2R5LCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSB0cmltRW1wdHlDb250ZW50cyhlZGl0b3IsIGVkaXRvci5zZXJpYWxpemVyLnNlcmlhbGl6ZShib2R5LCBhcmdzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGRUcmltID0gYXJncy5mb3JtYXQgIT09ICd0ZXh0JyAmJiAhaXNXc1ByZXNlcnZlRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShib2R5KSk7XG4gICAgICByZXR1cm4gc2hvdWxkVHJpbSAmJiBpc1N0cmluZyhjb250ZW50KSA/IFRvb2xzLnRyaW0oY29udGVudCkgOiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29udGVudEludGVybmFsID0gKGVkaXRvciwgYXJncykgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZ2V0Qm9keSgpKS5mb2xkKGNvbnN0YW50KGFyZ3MuZm9ybWF0ID09PSAndHJlZScgPyBuZXcgQXN0Tm9kZSgnYm9keScsIDExKSA6ICcnKSwgYm9keSA9PiBnZXRDb250ZW50RnJvbUJvZHkoZWRpdG9yLCBhcmdzLCBib2R5KSk7XG5cbiAgICBjb25zdCBtYWtlTWFwJDEgPSBUb29scy5tYWtlTWFwO1xuICAgIGNvbnN0IFdyaXRlciA9IHNldHRpbmdzID0+IHtcbiAgICAgIGNvbnN0IGh0bWwgPSBbXTtcbiAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICBjb25zdCBpbmRlbnQgPSBzZXR0aW5ncy5pbmRlbnQ7XG4gICAgICBjb25zdCBpbmRlbnRCZWZvcmUgPSBtYWtlTWFwJDEoc2V0dGluZ3MuaW5kZW50X2JlZm9yZSB8fCAnJyk7XG4gICAgICBjb25zdCBpbmRlbnRBZnRlciA9IG1ha2VNYXAkMShzZXR0aW5ncy5pbmRlbnRfYWZ0ZXIgfHwgJycpO1xuICAgICAgY29uc3QgZW5jb2RlID0gRW50aXRpZXMuZ2V0RW5jb2RlRnVuYyhzZXR0aW5ncy5lbnRpdHlfZW5jb2RpbmcgfHwgJ3JhdycsIHNldHRpbmdzLmVudGl0aWVzKTtcbiAgICAgIGNvbnN0IGh0bWxPdXRwdXQgPSBzZXR0aW5ncy5lbGVtZW50X2Zvcm1hdCAhPT0gJ3hodG1sJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAobmFtZSwgYXR0cnMsIGVtcHR5KSA9PiB7XG4gICAgICAgICAgaWYgKGluZGVudCAmJiBpbmRlbnRCZWZvcmVbbmFtZV0gJiYgaHRtbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGh0bWxbaHRtbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICBodG1sLnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLnB1c2goJzwnLCBuYW1lKTtcbiAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgaHRtbC5wdXNoKCcgJywgYXR0ci5uYW1lLCAnPVwiJywgZW5jb2RlKGF0dHIudmFsdWUsIHRydWUpLCAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlbXB0eSB8fCBodG1sT3V0cHV0KSB7XG4gICAgICAgICAgICBodG1sW2h0bWwubGVuZ3RoXSA9ICc+JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbFtodG1sLmxlbmd0aF0gPSAnIC8+JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVtcHR5ICYmIGluZGVudCAmJiBpbmRlbnRBZnRlcltuYW1lXSAmJiBodG1sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaHRtbFtodG1sLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWUgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGh0bWwucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IG5hbWUgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICBodG1sLnB1c2goJzwvJywgbmFtZSwgJz4nKTtcbiAgICAgICAgICBpZiAoaW5kZW50ICYmIGluZGVudEFmdGVyW25hbWVdICYmIGh0bWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSBodG1sW2h0bWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgaHRtbC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6ICh0ZXh0LCByYXcpID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBodG1sW2h0bWwubGVuZ3RoXSA9IHJhdyA/IHRleHQgOiBlbmNvZGUodGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjZGF0YTogdGV4dCA9PiB7XG4gICAgICAgICAgaHRtbC5wdXNoKCc8IVtDREFUQVsnLCB0ZXh0LCAnXV0+Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnQ6IHRleHQgPT4ge1xuICAgICAgICAgIGh0bWwucHVzaCgnPCEtLScsIHRleHQsICctLT4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGk6IChuYW1lLCB0ZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGh0bWwucHVzaCgnPD8nLCBuYW1lLCAnICcsIGVuY29kZSh0ZXh0KSwgJz8+Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwucHVzaCgnPD8nLCBuYW1lLCAnPz4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgICAgaHRtbC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvY3R5cGU6IHRleHQgPT4ge1xuICAgICAgICAgIGh0bWwucHVzaCgnPCFET0NUWVBFJywgdGV4dCwgJz4nLCBpbmRlbnQgPyAnXFxuJyA6ICcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICBodG1sLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbnRlbnQ6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gaHRtbC5qb2luKCcnKS5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBIdG1sU2VyaWFsaXplciA9IChzZXR0aW5ncyA9IHt9LCBzY2hlbWEgPSBTY2hlbWEoKSkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGVyID0gV3JpdGVyKHNldHRpbmdzKTtcbiAgICAgIHNldHRpbmdzLnZhbGlkYXRlID0gJ3ZhbGlkYXRlJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLnZhbGlkYXRlIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IHNldHRpbmdzLnZhbGlkYXRlO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgICAzOiBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHdyaXRlci50ZXh0KChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBub2RlLnJhdyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICA4OiBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHdyaXRlci5jb21tZW50KChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDc6IG5vZGUgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLnBpKG5vZGUubmFtZSwgbm9kZS52YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAxMDogbm9kZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB3cml0ZXIuZG9jdHlwZSgoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICA0OiBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHdyaXRlci5jZGF0YSgoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAxMTogbm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaWYgKHRlbXBOb2RlID0gdGVtcE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgd2Fsayh0ZW1wTm9kZSk7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKHRlbXBOb2RlID0gdGVtcE5vZGUubmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3cml0ZXIucmVzZXQoKTtcbiAgICAgICAgY29uc3Qgd2FsayA9IG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbm9kZS50eXBlXTtcbiAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gbmFtZSBpbiBzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBsZXQgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgYXR0cnMgJiYgYXR0cnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRBdHRycyA9IFtdO1xuICAgICAgICAgICAgICBzb3J0ZWRBdHRycy5tYXAgPSB7fTtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFJ1bGUgPSBzY2hlbWEuZ2V0RWxlbWVudFJ1bGUobm9kZS5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRSdWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbGVtZW50UnVsZS5hdHRyaWJ1dGVzT3JkZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGVsZW1lbnRSdWxlLmF0dHJpYnV0ZXNPcmRlcltpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZSBpbiBhdHRycy5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gYXR0cnMubWFwW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQXR0cnMubWFwW2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQXR0cnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogYXR0ck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGF0dHJOYW1lIGluIHNvcnRlZEF0dHJzLm1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gYXR0cnMubWFwW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQXR0cnMubWFwW2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkQXR0cnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogYXR0ck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0cnMgPSBzb3J0ZWRBdHRycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnN0YXJ0KG5hbWUsIGF0dHJzLCBpc0VtcHR5KTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICgobmFtZSA9PT0gJ3ByZScgfHwgbmFtZSA9PT0gJ3RleHRhcmVhJykgJiYgY2hpbGQudHlwZSA9PT0gMyAmJiAoKF9hID0gY2hpbGQudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICB3cml0ZXIudGV4dCgnXFxuJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQubmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGVyLmVuZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgJiYgIXNldHRpbmdzLmlubmVyKSB7XG4gICAgICAgICAgd2Fsayhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMpIHtcbiAgICAgICAgICBoYW5kbGVyc1szXShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVyc1sxMV0obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci5nZXRDb250ZW50KCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgc2VyaWFsaXplIH07XG4gICAgfTtcblxuICAgIGNvbnN0IG5vbkluaGVyaXRhYmxlU3R5bGVzID0gbmV3IFNldCgpO1xuICAgICgoKSA9PiB7XG4gICAgICBjb25zdCBub25Jbmhlcml0YWJsZVN0eWxlc0FyciA9IFtcbiAgICAgICAgJ21hcmdpbicsXG4gICAgICAgICdtYXJnaW4tbGVmdCcsXG4gICAgICAgICdtYXJnaW4tcmlnaHQnLFxuICAgICAgICAnbWFyZ2luLXRvcCcsXG4gICAgICAgICdtYXJnaW4tYm90dG9tJyxcbiAgICAgICAgJ3BhZGRpbmcnLFxuICAgICAgICAncGFkZGluZy1sZWZ0JyxcbiAgICAgICAgJ3BhZGRpbmctcmlnaHQnLFxuICAgICAgICAncGFkZGluZy10b3AnLFxuICAgICAgICAncGFkZGluZy1ib3R0b20nLFxuICAgICAgICAnYm9yZGVyJyxcbiAgICAgICAgJ2JvcmRlci13aWR0aCcsXG4gICAgICAgICdib3JkZXItc3R5bGUnLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJyxcbiAgICAgICAgJ2JhY2tncm91bmQnLFxuICAgICAgICAnYmFja2dyb3VuZC1hdHRhY2htZW50JyxcbiAgICAgICAgJ2JhY2tncm91bmQtY2xpcCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgICAgICAnYmFja2dyb3VuZC1vcmlnaW4nLFxuICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbicsXG4gICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgICAnZmxvYXQnLFxuICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdyaWdodCcsXG4gICAgICAgICd0b3AnLFxuICAgICAgICAnYm90dG9tJyxcbiAgICAgICAgJ3otaW5kZXgnLFxuICAgICAgICAnZGlzcGxheScsXG4gICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnbWF4LXdpZHRoJyxcbiAgICAgICAgJ21pbi13aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAnbWF4LWhlaWdodCcsXG4gICAgICAgICdtaW4taGVpZ2h0JyxcbiAgICAgICAgJ292ZXJmbG93JyxcbiAgICAgICAgJ292ZXJmbG93LXgnLFxuICAgICAgICAnb3ZlcmZsb3cteScsXG4gICAgICAgICd0ZXh0LW92ZXJmbG93JyxcbiAgICAgICAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgICAgICAgJ3RyYW5zaXRpb24nLFxuICAgICAgICAndHJhbnNpdGlvbi1kZWxheScsXG4gICAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAgICAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXG4gICAgICBdO1xuICAgICAgZWFjaCRlKG5vbkluaGVyaXRhYmxlU3R5bGVzQXJyLCBzdHlsZSA9PiB7XG4gICAgICAgIG5vbkluaGVyaXRhYmxlU3R5bGVzLmFkZChzdHlsZSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHNob3J0aGFuZFN0eWxlUHJvcHMgPSBbXG4gICAgICAnZm9udCcsXG4gICAgICAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICd0ZXh0LWVtcGhhc2lzJ1xuICAgIF07XG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wcyA9IChkb20sIG5vZGUpID0+IGtleXMoZG9tLnBhcnNlU3R5bGUoZG9tLmdldEF0dHJpYihub2RlLCAnc3R5bGUnKSkpO1xuICAgIGNvbnN0IGlzTm9uSW5oZXJpdGFibGVTdHlsZSA9IHN0eWxlID0+IG5vbkluaGVyaXRhYmxlU3R5bGVzLmhhcyhzdHlsZSk7XG4gICAgY29uc3QgaGFzSW5oZXJpdGFibGVTdHlsZXMgPSAoZG9tLCBub2RlKSA9PiBmb3JhbGwoZ2V0U3R5bGVQcm9wcyhkb20sIG5vZGUpLCBzdHlsZSA9PiAhaXNOb25Jbmhlcml0YWJsZVN0eWxlKHN0eWxlKSk7XG4gICAgY29uc3QgZ2V0TG9uZ2hhbmRTdHlsZVByb3BzID0gc3R5bGVzID0+IGZpbHRlciQ1KHN0eWxlcywgc3R5bGUgPT4gZXhpc3RzKHNob3J0aGFuZFN0eWxlUHJvcHMsIHByb3AgPT4gc3RhcnRzV2l0aChzdHlsZSwgcHJvcCkpKTtcbiAgICBjb25zdCBoYXNTdHlsZUNvbmZsaWN0ID0gKGRvbSwgbm9kZSwgcGFyZW50Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZVN0eWxlUHJvcHMgPSBnZXRTdHlsZVByb3BzKGRvbSwgbm9kZSk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlU3R5bGVQcm9wcyA9IGdldFN0eWxlUHJvcHMoZG9tLCBwYXJlbnROb2RlKTtcbiAgICAgIGNvbnN0IHZhbHVlTWlzbWF0Y2ggPSBwcm9wID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZVZhbHVlID0gKF9hID0gZG9tLmdldFN0eWxlKG5vZGUsIHByb3ApKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgcGFyZW50VmFsdWUgPSAoX2IgPSBkb20uZ2V0U3R5bGUocGFyZW50Tm9kZSwgcHJvcCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICByZXR1cm4gaXNOb3RFbXB0eShub2RlVmFsdWUpICYmIGlzTm90RW1wdHkocGFyZW50VmFsdWUpICYmIG5vZGVWYWx1ZSAhPT0gcGFyZW50VmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4aXN0cyhub2RlU3R5bGVQcm9wcywgbm9kZVN0eWxlUHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BFeGlzdHMgPSBwcm9wcyA9PiBleGlzdHMocHJvcHMsIHByb3AgPT4gcHJvcCA9PT0gbm9kZVN0eWxlUHJvcCk7XG4gICAgICAgIGlmICghcHJvcEV4aXN0cyhwYXJlbnROb2RlU3R5bGVQcm9wcykgJiYgcHJvcEV4aXN0cyhzaG9ydGhhbmRTdHlsZVByb3BzKSkge1xuICAgICAgICAgIGNvbnN0IGxvbmdoYW5kUHJvcHMgPSBnZXRMb25naGFuZFN0eWxlUHJvcHMocGFyZW50Tm9kZVN0eWxlUHJvcHMpO1xuICAgICAgICAgIHJldHVybiBleGlzdHMobG9uZ2hhbmRQcm9wcywgdmFsdWVNaXNtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlTWlzbWF0Y2gobm9kZVN0eWxlUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NoYXIgPSAoZm9yd2FyZCwgcHJlZGljYXRlLCBwb3MpID0+IE9wdGlvbmFsLmZyb20ocG9zLmNvbnRhaW5lcigpKS5maWx0ZXIoaXNUZXh0JGEpLmV4aXN0cyh0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZm9yd2FyZCA/IDAgOiAtMTtcbiAgICAgIHJldHVybiBwcmVkaWNhdGUodGV4dC5kYXRhLmNoYXJBdChwb3Mub2Zmc2V0KCkgKyBkZWx0YSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzQmVmb3JlU3BhY2UgPSBjdXJyeShpc0NoYXIsIHRydWUsIGlzV2hpdGVTcGFjZSk7XG4gICAgY29uc3QgaXNBZnRlclNwYWNlID0gY3VycnkoaXNDaGFyLCBmYWxzZSwgaXNXaGl0ZVNwYWNlKTtcbiAgICBjb25zdCBpc0VtcHR5VGV4dCA9IHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICByZXR1cm4gaXNUZXh0JGEoY29udGFpbmVyKSAmJiAoY29udGFpbmVyLmRhdGEubGVuZ3RoID09PSAwIHx8IGlzWndzcCQxKGNvbnRhaW5lci5kYXRhKSAmJiBCb29rbWFya01hbmFnZXIuaXNCb29rbWFya05vZGUoY29udGFpbmVyLnBhcmVudE5vZGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoZXNFbGVtZW50UG9zaXRpb24gPSAoYmVmb3JlLCBwcmVkaWNhdGUpID0+IHBvcyA9PiBnZXRDaGlsZE5vZGVBdFJlbGF0aXZlT2Zmc2V0KGJlZm9yZSA/IDAgOiAtMSwgcG9zKS5maWx0ZXIocHJlZGljYXRlKS5pc1NvbWUoKTtcbiAgICBjb25zdCBpc0ltYWdlQmxvY2sgPSBub2RlID0+IGlzSW1nKG5vZGUpICYmIGdldCQ3KFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCAnZGlzcGxheScpID09PSAnYmxvY2snO1xuICAgIGNvbnN0IGlzQ2VmTm9kZSA9IG5vZGUgPT4gaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKG5vZGUpICYmICFpc0JvZ3VzQWxsJDEobm9kZSk7XG4gICAgY29uc3QgaXNCZWZvcmVJbWFnZUJsb2NrID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbih0cnVlLCBpc0ltYWdlQmxvY2spO1xuICAgIGNvbnN0IGlzQWZ0ZXJJbWFnZUJsb2NrID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbihmYWxzZSwgaXNJbWFnZUJsb2NrKTtcbiAgICBjb25zdCBpc0JlZm9yZU1lZGlhID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbih0cnVlLCBpc01lZGlhJDIpO1xuICAgIGNvbnN0IGlzQWZ0ZXJNZWRpYSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24oZmFsc2UsIGlzTWVkaWEkMik7XG4gICAgY29uc3QgaXNCZWZvcmVUYWJsZSA9IG1hdGNoZXNFbGVtZW50UG9zaXRpb24odHJ1ZSwgaXNUYWJsZSQyKTtcbiAgICBjb25zdCBpc0FmdGVyVGFibGUgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKGZhbHNlLCBpc1RhYmxlJDIpO1xuICAgIGNvbnN0IGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UgPSBtYXRjaGVzRWxlbWVudFBvc2l0aW9uKHRydWUsIGlzQ2VmTm9kZSk7XG4gICAgY29uc3QgaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlID0gbWF0Y2hlc0VsZW1lbnRQb3NpdGlvbihmYWxzZSwgaXNDZWZOb2RlKTtcblxuICAgIGNvbnN0IGRyb3BMYXN0ID0geHMgPT4geHMuc2xpY2UoMCwgLTEpO1xuICAgIGNvbnN0IHBhcmVudHNVbnRpbCA9IChzdGFydCwgcm9vdCwgcHJlZGljYXRlKSA9PiB7XG4gICAgICBpZiAoY29udGFpbnMocm9vdCwgc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiBkcm9wTGFzdChwYXJlbnRzJDEoc3RhcnQsIGVsbSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZShlbG0pIHx8IGVxKGVsbSwgcm9vdCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhcmVudHMgPSAoc3RhcnQsIHJvb3QpID0+IHBhcmVudHNVbnRpbChzdGFydCwgcm9vdCwgbmV2ZXIpO1xuICAgIGNvbnN0IHBhcmVudHNBbmRTZWxmID0gKHN0YXJ0LCByb290KSA9PiBbc3RhcnRdLmNvbmNhdChwYXJlbnRzKHN0YXJ0LCByb290KSk7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZUlnbm9yZUVtcHR5VGV4dE5vZGVzID0gKGZvcndhcmQsIHJvb3QsIGZyb20pID0+IG5hdmlnYXRlSWdub3JlKGZvcndhcmQsIHJvb3QsIGZyb20sIGlzRW1wdHlUZXh0KTtcbiAgICBjb25zdCBnZXRDbG9zZXN0QmxvY2skMSA9IChyb290LCBwb3MpID0+IGZpbmQkMihwYXJlbnRzQW5kU2VsZihTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpLCByb290KSwgaXNCbG9jayQyKTtcbiAgICBjb25zdCBpc0F0QmVmb3JlQWZ0ZXJCbG9ja0JvdW5kYXJ5ID0gKGZvcndhcmQsIHJvb3QsIHBvcykgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCByb290LmRvbSwgcG9zKS5mb3JhbGwobmV3UG9zID0+IGdldENsb3Nlc3RCbG9jayQxKHJvb3QsIHBvcykuZm9sZCgoKSA9PiAhaXNJblNhbWVCbG9jayhuZXdQb3MsIHBvcywgcm9vdC5kb20pLCBmcm9tQmxvY2sgPT4gIWlzSW5TYW1lQmxvY2sobmV3UG9zLCBwb3MsIHJvb3QuZG9tKSAmJiBjb250YWlucyhmcm9tQmxvY2ssIFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5ld1Bvcy5jb250YWluZXIoKSkpKSk7XG4gICAgY29uc3QgaXNBdEJsb2NrQm91bmRhcnkgPSAoZm9yd2FyZCwgcm9vdCwgcG9zKSA9PiBnZXRDbG9zZXN0QmxvY2skMShyb290LCBwb3MpLmZvbGQoKCkgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCByb290LmRvbSwgcG9zKS5mb3JhbGwobmV3UG9zID0+ICFpc0luU2FtZUJsb2NrKG5ld1BvcywgcG9zLCByb290LmRvbSkpLCBwYXJlbnQgPT4gbmF2aWdhdGVJZ25vcmVFbXB0eVRleHROb2Rlcyhmb3J3YXJkLCBwYXJlbnQuZG9tLCBwb3MpLmlzTm9uZSgpKTtcbiAgICBjb25zdCBpc0F0U3RhcnRPZkJsb2NrID0gY3VycnkoaXNBdEJsb2NrQm91bmRhcnksIGZhbHNlKTtcbiAgICBjb25zdCBpc0F0RW5kT2ZCbG9jayA9IGN1cnJ5KGlzQXRCbG9ja0JvdW5kYXJ5LCB0cnVlKTtcbiAgICBjb25zdCBpc0JlZm9yZUJsb2NrID0gY3VycnkoaXNBdEJlZm9yZUFmdGVyQmxvY2tCb3VuZGFyeSwgZmFsc2UpO1xuICAgIGNvbnN0IGlzQWZ0ZXJCbG9jayA9IGN1cnJ5KGlzQXRCZWZvcmVBZnRlckJsb2NrQm91bmRhcnksIHRydWUpO1xuXG4gICAgY29uc3QgaXNCciQxID0gcG9zID0+IGdldEVsZW1lbnRGcm9tUG9zaXRpb24ocG9zKS5leGlzdHMoaXNCciQ1KTtcbiAgICBjb25zdCBmaW5kQnIgPSAoZm9yd2FyZCwgcm9vdCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja3MgPSBmaWx0ZXIkNShwYXJlbnRzQW5kU2VsZihTdWdhckVsZW1lbnQuZnJvbURvbShwb3MuY29udGFpbmVyKCkpLCByb290KSwgaXNCbG9jayQyKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gaGVhZChwYXJlbnRCbG9ja3MpLmdldE9yKHJvb3QpO1xuICAgICAgcmV0dXJuIGZyb21Qb3NpdGlvbihmb3J3YXJkLCBzY29wZS5kb20sIHBvcykuZmlsdGVyKGlzQnIkMSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUJyJDEgPSAocm9vdCwgcG9zKSA9PiBnZXRFbGVtZW50RnJvbVBvc2l0aW9uKHBvcykuZXhpc3RzKGlzQnIkNSkgfHwgZmluZEJyKHRydWUsIHJvb3QsIHBvcykuaXNTb21lKCk7XG4gICAgY29uc3QgaXNBZnRlckJyID0gKHJvb3QsIHBvcykgPT4gZ2V0RWxlbWVudEZyb21QcmV2UG9zaXRpb24ocG9zKS5leGlzdHMoaXNCciQ1KSB8fCBmaW5kQnIoZmFsc2UsIHJvb3QsIHBvcykuaXNTb21lKCk7XG4gICAgY29uc3QgZmluZFByZXZpb3VzQnIgPSBjdXJyeShmaW5kQnIsIGZhbHNlKTtcbiAgICBjb25zdCBmaW5kTmV4dEJyID0gY3VycnkoZmluZEJyLCB0cnVlKTtcblxuICAgIGNvbnN0IGlzSW5NaWRkbGVPZlRleHQgPSBwb3MgPT4gQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpICYmICFwb3MuaXNBdFN0YXJ0KCkgJiYgIXBvcy5pc0F0RW5kKCk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdEJsb2NrID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tzID0gZmlsdGVyJDUocGFyZW50c0FuZFNlbGYoU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKSwgcm9vdCksIGlzQmxvY2skMik7XG4gICAgICByZXR1cm4gaGVhZChwYXJlbnRCbG9ja3MpLmdldE9yKHJvb3QpO1xuICAgIH07XG4gICAgY29uc3QgaGFzU3BhY2VCZWZvcmUgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBpZiAoaXNJbk1pZGRsZU9mVGV4dChwb3MpKSB7XG4gICAgICAgIHJldHVybiBpc0FmdGVyU3BhY2UocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0FmdGVyU3BhY2UocG9zKSB8fCBwcmV2UG9zaXRpb24oZ2V0Q2xvc2VzdEJsb2NrKHJvb3QsIHBvcykuZG9tLCBwb3MpLmV4aXN0cyhpc0FmdGVyU3BhY2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFzU3BhY2VBZnRlciA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luTWlkZGxlT2ZUZXh0KHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGlzQmVmb3JlU3BhY2UocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0JlZm9yZVNwYWNlKHBvcykgfHwgbmV4dFBvc2l0aW9uKGdldENsb3Nlc3RCbG9jayhyb290LCBwb3MpLmRvbSwgcG9zKS5leGlzdHMoaXNCZWZvcmVTcGFjZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1ByZVZhbHVlID0gdmFsdWUgPT4gY29udGFpbnMkMihbXG4gICAgICAncHJlJyxcbiAgICAgICdwcmUtd3JhcCdcbiAgICBdLCB2YWx1ZSk7XG4gICAgY29uc3QgaXNJblByZSA9IHBvcyA9PiBnZXRFbGVtZW50RnJvbVBvc2l0aW9uKHBvcykuYmluZChlbG0gPT4gY2xvc2VzdCQ0KGVsbSwgaXNFbGVtZW50JDcpKS5leGlzdHMoZWxtID0+IGlzUHJlVmFsdWUoZ2V0JDcoZWxtLCAnd2hpdGUtc3BhY2UnKSkpO1xuICAgIGNvbnN0IGlzQXRCZWdpbm5pbmdPZkJvZHkgPSAocm9vdCwgcG9zKSA9PiBwcmV2UG9zaXRpb24ocm9vdC5kb20sIHBvcykuaXNOb25lKCk7XG4gICAgY29uc3QgaXNBdEVuZE9mQm9keSA9IChyb290LCBwb3MpID0+IG5leHRQb3NpdGlvbihyb290LmRvbSwgcG9zKS5pc05vbmUoKTtcbiAgICBjb25zdCBpc0F0TGluZUJvdW5kYXJ5ID0gKHJvb3QsIHBvcykgPT4gaXNBdEJlZ2lubmluZ09mQm9keShyb290LCBwb3MpIHx8IGlzQXRFbmRPZkJvZHkocm9vdCwgcG9zKSB8fCBpc0F0U3RhcnRPZkJsb2NrKHJvb3QsIHBvcykgfHwgaXNBdEVuZE9mQmxvY2socm9vdCwgcG9zKSB8fCBpc0FmdGVyQnIocm9vdCwgcG9zKSB8fCBpc0JlZm9yZUJyJDEocm9vdCwgcG9zKTtcbiAgICBjb25zdCBpc0NlZkJsb2NrID0gbm9kZSA9PiBpc05vbk51bGxhYmxlKG5vZGUpICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihub2RlKSAmJiBpc0Jsb2NrTGlrZShub2RlKTtcbiAgICBjb25zdCBpc1NpYmxpbmdDZWZCbG9jayA9IChyb290LCBkaXJlY3Rpb24pID0+IGNvbnRhaW5lciA9PiB7XG4gICAgICByZXR1cm4gaXNDZWZCbG9jayhuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIHJvb3QpW2RpcmVjdGlvbl0oKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0JlZm9yZUNlZkJsb2NrID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgY29uc3QgbmV4dFBvcyA9IG5leHRQb3NpdGlvbihyb290LmRvbSwgcG9zKS5nZXRPcihwb3MpO1xuICAgICAgY29uc3QgaXNOZXh0Q2VmQmxvY2sgPSBpc1NpYmxpbmdDZWZCbG9jayhyb290LmRvbSwgJ25leHQnKTtcbiAgICAgIHJldHVybiBwb3MuaXNBdEVuZCgpICYmIChpc05leHRDZWZCbG9jayhwb3MuY29udGFpbmVyKCkpIHx8IGlzTmV4dENlZkJsb2NrKG5leHRQb3MuY29udGFpbmVyKCkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWZ0ZXJDZWZCbG9jayA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHByZXZQb3MgPSBwcmV2UG9zaXRpb24ocm9vdC5kb20sIHBvcykuZ2V0T3IocG9zKTtcbiAgICAgIGNvbnN0IGlzUHJldkNlZkJsb2NrID0gaXNTaWJsaW5nQ2VmQmxvY2socm9vdC5kb20sICdwcmV2Jyk7XG4gICAgICByZXR1cm4gcG9zLmlzQXRTdGFydCgpICYmIChpc1ByZXZDZWZCbG9jayhwb3MuY29udGFpbmVyKCkpIHx8IGlzUHJldkNlZkJsb2NrKHByZXZQb3MuY29udGFpbmVyKCkpKTtcbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9IYXZlTmJzcCA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luUHJlKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQXRMaW5lQm91bmRhcnkocm9vdCwgcG9zKSB8fCBoYXNTcGFjZUJlZm9yZShyb290LCBwb3MpIHx8IGhhc1NwYWNlQWZ0ZXIocm9vdCwgcG9zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9CZU5ic3BMZWZ0ID0gKHJvb3QsIHBvcykgPT4ge1xuICAgICAgaWYgKGlzSW5QcmUocG9zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdFN0YXJ0T2ZCbG9jayhyb290LCBwb3MpIHx8IGlzQmVmb3JlQmxvY2socm9vdCwgcG9zKSB8fCBpc0FmdGVyQnIocm9vdCwgcG9zKSB8fCBoYXNTcGFjZUJlZm9yZShyb290LCBwb3MpIHx8IGlzQWZ0ZXJDZWZCbG9jayhyb290LCBwb3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGVhblJpZ2h0ID0gcG9zID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBvcy5vZmZzZXQoKTtcbiAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpICYmIG9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9CZU5ic3BSaWdodCA9IChyb290LCBwb3MpID0+IHtcbiAgICAgIGlmIChpc0luUHJlKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQXRFbmRPZkJsb2NrKHJvb3QsIHBvcykgfHwgaXNBZnRlckJsb2NrKHJvb3QsIHBvcykgfHwgaXNCZWZvcmVCciQxKHJvb3QsIHBvcykgfHwgaGFzU3BhY2VBZnRlcihyb290LCBwb3MpIHx8IGlzQmVmb3JlQ2VmQmxvY2socm9vdCwgcG9zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzVG9CZU5ic3AgPSAocm9vdCwgcG9zKSA9PiBuZWVkc1RvQmVOYnNwTGVmdChyb290LCBwb3MpIHx8IG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBsZWFuUmlnaHQocG9zKSk7XG4gICAgY29uc3QgaXNOYnNwQXQgPSAodGV4dCwgb2Zmc2V0KSA9PiBpc05ic3AodGV4dC5jaGFyQXQob2Zmc2V0KSk7XG4gICAgY29uc3QgaXNXaGl0ZVNwYWNlQXQgPSAodGV4dCwgb2Zmc2V0KSA9PiBpc1doaXRlU3BhY2UodGV4dC5jaGFyQXQob2Zmc2V0KSk7XG4gICAgY29uc3QgaGFzTmJzcCA9IHBvcyA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICByZXR1cm4gaXNUZXh0JGEoY29udGFpbmVyKSAmJiBjb250YWlucyQxKGNvbnRhaW5lci5kYXRhLCBuYnNwKTtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BNaWRkbGUgPSB0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IGNoYXJzID0gdGV4dC5zcGxpdCgnJyk7XG4gICAgICByZXR1cm4gbWFwJDMoY2hhcnMsIChjaHIsIGkpID0+IHtcbiAgICAgICAgaWYgKGlzTmJzcChjaHIpICYmIGkgPiAwICYmIGkgPCBjaGFycy5sZW5ndGggLSAxICYmIGlzQ29udGVudChjaGFyc1tpIC0gMV0pICYmIGlzQ29udGVudChjaGFyc1tpICsgMV0pKSB7XG4gICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hyO1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BBdFN0YXJ0ID0gKHJvb3QsIG5vZGUsIG1ha2VOYnNwKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgY29uc3QgZmlyc3RQb3MgPSBDYXJldFBvc2l0aW9uKG5vZGUsIDApO1xuICAgICAgaWYgKCFtYWtlTmJzcCAmJiBpc05ic3BBdCh0ZXh0LCAwKSAmJiAhbmVlZHNUb0JlTmJzcChyb290LCBmaXJzdFBvcykpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gJyAnICsgdGV4dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1ha2VOYnNwICYmIGlzV2hpdGVTcGFjZUF0KHRleHQsIDApICYmIG5lZWRzVG9CZU5ic3BMZWZ0KHJvb3QsIGZpcnN0UG9zKSkge1xuICAgICAgICBub2RlLmRhdGEgPSBuYnNwICsgdGV4dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVOYnNwSW5NaWRkbGVPZlRleHROb2RlID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgY29uc3QgbmV3VGV4dCA9IG5vcm1hbGl6ZU5ic3BNaWRkbGUodGV4dCk7XG4gICAgICBpZiAobmV3VGV4dCAhPT0gdGV4dCkge1xuICAgICAgICBub2RlLmRhdGEgPSBuZXdUZXh0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZU5ic3BBdEVuZCA9IChyb290LCBub2RlLCBtYWtlTmJzcCkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZGF0YTtcbiAgICAgIGNvbnN0IGxhc3RQb3MgPSBDYXJldFBvc2l0aW9uKG5vZGUsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoIW1ha2VOYnNwICYmIGlzTmJzcEF0KHRleHQsIHRleHQubGVuZ3RoIC0gMSkgJiYgIW5lZWRzVG9CZU5ic3Aocm9vdCwgbGFzdFBvcykpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gdGV4dC5zbGljZSgwLCAtMSkgKyAnICc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYWtlTmJzcCAmJiBpc1doaXRlU3BhY2VBdCh0ZXh0LCB0ZXh0Lmxlbmd0aCAtIDEpICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBsYXN0UG9zKSkge1xuICAgICAgICBub2RlLmRhdGEgPSB0ZXh0LnNsaWNlKDAsIC0xKSArIG5ic3A7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcHMgPSAocm9vdCwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBpZiAoIWlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNOYnNwKHBvcykpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU5ic3BBdFN0YXJ0KHJvb3QsIGNvbnRhaW5lciwgZmFsc2UpIHx8IG5vcm1hbGl6ZU5ic3BJbk1pZGRsZU9mVGV4dE5vZGUoY29udGFpbmVyKSB8fCBub3JtYWxpemVOYnNwQXRFbmQocm9vdCwgY29udGFpbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzb21lSWYobm9ybWFsaXplZCwgcG9zKTtcbiAgICAgIH0gZWxzZSBpZiAobmVlZHNUb0JlTmJzcChyb290LCBwb3MpKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVOYnNwQXRTdGFydChyb290LCBjb250YWluZXIsIHRydWUpIHx8IG5vcm1hbGl6ZU5ic3BBdEVuZChyb290LCBjb250YWluZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gc29tZUlmKG5vcm1hbGl6ZWQsIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplTmJzcHNJbkVkaXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIG5vcm1hbGl6ZU5ic3BzKHJvb3QsIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZSQxID0gKG5vZGUsIG9mZnNldCwgY291bnQpID0+IHtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIGNvbnN0IHJvb3QgPSBhbmNlc3RvciQ0KGVsbSwgaXNCbG9jayQyKS5nZXRPcihlbG0pO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IG5vZGUuZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KTtcbiAgICAgIGNvbnN0IGlzRW5kT2ZDb250ZW50ID0gb2Zmc2V0ICsgY291bnQgPj0gbm9kZS5kYXRhLmxlbmd0aCAmJiBuZWVkc1RvQmVOYnNwUmlnaHQocm9vdCwgQ2FyZXRQb3NpdGlvbihub2RlLCBub2RlLmRhdGEubGVuZ3RoKSk7XG4gICAgICBjb25zdCBpc1N0YXJ0T2ZDb250ZW50ID0gb2Zmc2V0ID09PSAwICYmIG5lZWRzVG9CZU5ic3BMZWZ0KHJvb3QsIENhcmV0UG9zaXRpb24obm9kZSwgMCkpO1xuICAgICAgbm9kZS5yZXBsYWNlRGF0YShvZmZzZXQsIGNvdW50LCBub3JtYWxpemUkNCh3aGl0ZXNwYWNlLCA0LCBpc1N0YXJ0T2ZDb250ZW50LCBpc0VuZE9mQ29udGVudCkpO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplV2hpdGVzcGFjZUFmdGVyID0gKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IG5vZGUuZGF0YS5zbGljZShvZmZzZXQpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUNvdW50ID0gY29udGVudC5sZW5ndGggLSBsVHJpbShjb250ZW50KS5sZW5ndGg7XG4gICAgICBub3JtYWxpemUkMShub2RlLCBvZmZzZXQsIHdoaXRlc3BhY2VDb3VudCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlID0gKG5vZGUsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgY29udGVudCA9IG5vZGUuZGF0YS5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUNvdW50ID0gY29udGVudC5sZW5ndGggLSByVHJpbShjb250ZW50KS5sZW5ndGg7XG4gICAgICBub3JtYWxpemUkMShub2RlLCBvZmZzZXQgLSB3aGl0ZXNwYWNlQ291bnQsIHdoaXRlc3BhY2VDb3VudCk7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVRleHROb2RlcyA9IChwcmV2Tm9kZSwgbmV4dE5vZGUsIG5vcm1hbGl6ZVdoaXRlc3BhY2UsIG1lcmdlVG9QcmV2ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZU9mZnNldCA9IHJUcmltKHByZXZOb2RlLmRhdGEpLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBtZXJnZVRvUHJldiA/IHByZXZOb2RlIDogbmV4dE5vZGU7XG4gICAgICBjb25zdCByZW1vdmVOb2RlID0gbWVyZ2VUb1ByZXYgPyBuZXh0Tm9kZSA6IHByZXZOb2RlO1xuICAgICAgaWYgKG1lcmdlVG9QcmV2KSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kRGF0YShyZW1vdmVOb2RlLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Tm9kZS5pbnNlcnREYXRhKDAsIHJlbW92ZU5vZGUuZGF0YSk7XG4gICAgICB9XG4gICAgICByZW1vdmUkNShTdWdhckVsZW1lbnQuZnJvbURvbShyZW1vdmVOb2RlKSk7XG4gICAgICBpZiAobm9ybWFsaXplV2hpdGVzcGFjZSkge1xuICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIobmV3Tm9kZSwgd2hpdGVzcGFjZU9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmVlZHNSZXBvc2l0aW9uID0gKHBvcywgZWxtKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBwb3MuY29udGFpbmVyKCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBwb3Mub2Zmc2V0KCk7XG4gICAgICByZXR1cm4gIUNhcmV0UG9zaXRpb24uaXNUZXh0UG9zaXRpb24ocG9zKSAmJiBjb250YWluZXIgPT09IGVsbS5wYXJlbnROb2RlICYmIG9mZnNldCA+IENhcmV0UG9zaXRpb24uYmVmb3JlKGVsbSkub2Zmc2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCByZXBvc2l0aW9uID0gKGVsbSwgcG9zKSA9PiBuZWVkc1JlcG9zaXRpb24ocG9zLCBlbG0pID8gQ2FyZXRQb3NpdGlvbihwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSAtIDEpIDogcG9zO1xuICAgIGNvbnN0IGJlZm9yZU9yU3RhcnRPZiA9IG5vZGUgPT4gaXNUZXh0JGEobm9kZSkgPyBDYXJldFBvc2l0aW9uKG5vZGUsIDApIDogQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSk7XG4gICAgY29uc3QgYWZ0ZXJPckVuZE9mID0gbm9kZSA9PiBpc1RleHQkYShub2RlKSA/IENhcmV0UG9zaXRpb24obm9kZSwgbm9kZS5kYXRhLmxlbmd0aCkgOiBDYXJldFBvc2l0aW9uLmFmdGVyKG5vZGUpO1xuICAgIGNvbnN0IGdldFByZXZpb3VzU2libGluZ0NhcmV0UG9zaXRpb24gPSBlbG0gPT4ge1xuICAgICAgaWYgKGlzQ2FyZXRDYW5kaWRhdGUkMyhlbG0ucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShhZnRlck9yRW5kT2YoZWxtLnByZXZpb3VzU2libGluZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsbS5wcmV2aW91c1NpYmxpbmcgPyBsYXN0UG9zaXRpb25JbihlbG0ucHJldmlvdXNTaWJsaW5nKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldE5leHRTaWJsaW5nQ2FyZXRQb3NpdGlvbiA9IGVsbSA9PiB7XG4gICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKGVsbS5uZXh0U2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoYmVmb3JlT3JTdGFydE9mKGVsbS5uZXh0U2libGluZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsbS5uZXh0U2libGluZyA/IGZpcnN0UG9zaXRpb25JbihlbG0ubmV4dFNpYmxpbmcpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb25CYWNrd2FyZHNGcm9tRWxtID0gKHJvb3RFbGVtZW50LCBlbG0pID0+IHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVsbS5wcmV2aW91c1NpYmxpbmcgPyBlbG0ucHJldmlvdXNTaWJsaW5nIDogZWxtLnBhcmVudE5vZGUpLmJpbmQobm9kZSA9PiBwcmV2UG9zaXRpb24ocm9vdEVsZW1lbnQsIENhcmV0UG9zaXRpb24uYmVmb3JlKG5vZGUpKSkub3JUaHVuaygoKSA9PiBuZXh0UG9zaXRpb24ocm9vdEVsZW1lbnQsIENhcmV0UG9zaXRpb24uYWZ0ZXIoZWxtKSkpO1xuICAgIH07XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb25Gb3J3YXJkc0Zyb21FbG0gPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gbmV4dFBvc2l0aW9uKHJvb3RFbGVtZW50LCBDYXJldFBvc2l0aW9uLmFmdGVyKGVsbSkpLm9yVGh1bmsoKCkgPT4gcHJldlBvc2l0aW9uKHJvb3RFbGVtZW50LCBDYXJldFBvc2l0aW9uLmJlZm9yZShlbG0pKSk7XG4gICAgY29uc3QgZmluZENhcmV0UG9zaXRpb25CYWNrd2FyZHMgPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gZ2V0UHJldmlvdXNTaWJsaW5nQ2FyZXRQb3NpdGlvbihlbG0pLm9yVGh1bmsoKCkgPT4gZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkpLm9yVGh1bmsoKCkgPT4gZmluZENhcmV0UG9zaXRpb25CYWNrd2FyZHNGcm9tRWxtKHJvb3RFbGVtZW50LCBlbG0pKTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmQgPSAocm9vdEVsZW1lbnQsIGVsbSkgPT4gZ2V0TmV4dFNpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkub3JUaHVuaygoKSA9PiBnZXRQcmV2aW91c1NpYmxpbmdDYXJldFBvc2l0aW9uKGVsbSkpLm9yVGh1bmsoKCkgPT4gZmluZENhcmV0UG9zaXRpb25Gb3J3YXJkc0Zyb21FbG0ocm9vdEVsZW1lbnQsIGVsbSkpO1xuICAgIGNvbnN0IGZpbmRDYXJldFBvc2l0aW9uID0gKGZvcndhcmQsIHJvb3RFbGVtZW50LCBlbG0pID0+IGZvcndhcmQgPyBmaW5kQ2FyZXRQb3NpdGlvbkZvcndhcmQocm9vdEVsZW1lbnQsIGVsbSkgOiBmaW5kQ2FyZXRQb3NpdGlvbkJhY2t3YXJkcyhyb290RWxlbWVudCwgZWxtKTtcbiAgICBjb25zdCBmaW5kQ2FyZXRQb3NPdXRzaWRlRWxtQWZ0ZXJEZWxldGUgPSAoZm9yd2FyZCwgcm9vdEVsZW1lbnQsIGVsbSkgPT4gZmluZENhcmV0UG9zaXRpb24oZm9yd2FyZCwgcm9vdEVsZW1lbnQsIGVsbSkubWFwKGN1cnJ5KHJlcG9zaXRpb24sIGVsbSkpO1xuICAgIGNvbnN0IHNldFNlbGVjdGlvbiQxID0gKGVkaXRvciwgZm9yd2FyZCwgcG9zKSA9PiB7XG4gICAgICBwb3MuZm9sZCgoKSA9PiB7XG4gICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgfSwgcG9zID0+IHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSwgZm9yd2FyZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGVxUmF3Tm9kZSA9IHJhd05vZGUgPT4gZWxtID0+IGVsbS5kb20gPT09IHJhd05vZGU7XG4gICAgY29uc3QgaXNCbG9jayA9IChlZGl0b3IsIGVsbSkgPT4gZWxtICYmIGhhcyQyKGVkaXRvci5zY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpLCBuYW1lKGVsbSkpO1xuICAgIGNvbnN0IHBhZGRFbXB0eUJsb2NrID0gZWxtID0+IHtcbiAgICAgIGlmIChpc0VtcHR5JDIoZWxtKSkge1xuICAgICAgICBjb25zdCBiciA9IFN1Z2FyRWxlbWVudC5mcm9tSHRtbCgnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPicpO1xuICAgICAgICBlbXB0eShlbG0pO1xuICAgICAgICBhcHBlbmQkMShlbG0sIGJyKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbi5iZWZvcmUoYnIuZG9tKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlTm9ybWFsaXplZCA9IChlbG0sIGFmdGVyRGVsZXRlUG9zT3B0LCBub3JtYWxpemVXaGl0ZXNwYWNlKSA9PiB7XG4gICAgICBjb25zdCBwcmV2VGV4dE9wdCA9IHByZXZTaWJsaW5nKGVsbSkuZmlsdGVyKGlzVGV4dCRiKTtcbiAgICAgIGNvbnN0IG5leHRUZXh0T3B0ID0gbmV4dFNpYmxpbmcoZWxtKS5maWx0ZXIoaXNUZXh0JGIpO1xuICAgICAgcmVtb3ZlJDUoZWxtKTtcbiAgICAgIHJldHVybiBsaWZ0MyhwcmV2VGV4dE9wdCwgbmV4dFRleHRPcHQsIGFmdGVyRGVsZXRlUG9zT3B0LCAocHJldiwgbmV4dCwgcG9zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gcHJldi5kb20sIG5leHROb2RlID0gbmV4dC5kb207XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHByZXZOb2RlLmRhdGEubGVuZ3RoO1xuICAgICAgICBtZXJnZVRleHROb2RlcyhwcmV2Tm9kZSwgbmV4dE5vZGUsIG5vcm1hbGl6ZVdoaXRlc3BhY2UpO1xuICAgICAgICByZXR1cm4gcG9zLmNvbnRhaW5lcigpID09PSBuZXh0Tm9kZSA/IENhcmV0UG9zaXRpb24ocHJldk5vZGUsIG9mZnNldCkgOiBwb3M7XG4gICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBwcmV2VGV4dE9wdC5lYWNoKGVsbSA9PiBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlKGVsbS5kb20sIGVsbS5kb20ubGVuZ3RoKSk7XG4gICAgICAgICAgbmV4dFRleHRPcHQuZWFjaChlbG0gPT4gbm9ybWFsaXplV2hpdGVzcGFjZUFmdGVyKGVsbS5kb20sIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWZ0ZXJEZWxldGVQb3NPcHQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSW5saW5lRWxlbWVudCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGhhcyQyKGVkaXRvci5zY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCksIG5hbWUoZWxlbWVudCkpO1xuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQkMiA9IChlZGl0b3IsIGZvcndhcmQsIGVsbSwgbW92ZUNhcmV0ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJEZWxldGVQb3MgPSBmaW5kQ2FyZXRQb3NPdXRzaWRlRWxtQWZ0ZXJEZWxldGUoZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSk7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGFuY2VzdG9yJDQoZWxtLCBjdXJyeShpc0Jsb2NrLCBlZGl0b3IpLCBlcVJhd05vZGUoZWRpdG9yLmdldEJvZHkoKSkpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEFmdGVyRGVsZXRlUG9zID0gZGVsZXRlTm9ybWFsaXplZChlbG0sIGFmdGVyRGVsZXRlUG9zLCBpc0lubGluZUVsZW1lbnQoZWRpdG9yLCBlbG0pKTtcbiAgICAgIGlmIChlZGl0b3IuZG9tLmlzRW1wdHkoZWRpdG9yLmdldEJvZHkoKSkpIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQoJycpO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRCbG9jay5iaW5kKHBhZGRFbXB0eUJsb2NrKS5mb2xkKCgpID0+IHtcbiAgICAgICAgICBpZiAobW92ZUNhcmV0KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24kMShlZGl0b3IsIGZvcndhcmQsIG5vcm1hbGl6ZWRBZnRlckRlbGV0ZVBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBwYWRkUG9zID0+IHtcbiAgICAgICAgICBpZiAobW92ZUNhcmV0KSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24kMShlZGl0b3IsIGZvcndhcmQsIE9wdGlvbmFsLnNvbWUocGFkZFBvcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHN0cm9uZ1J0bCA9IC9bXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZGXFx1RkU3MC1cXHVGRUZDXS87XG4gICAgY29uc3QgaGFzU3Ryb25nUnRsID0gdGV4dCA9PiBzdHJvbmdSdGwudGVzdCh0ZXh0KTtcblxuICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0ID0gKGVkaXRvciwgZWxtKSA9PiBpcyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsbSksIGdldElubGluZUJvdW5kYXJ5U2VsZWN0b3IoZWRpdG9yKSkgJiYgIWlzVHJhbnNwYXJlbnRCbG9jayhlZGl0b3Iuc2NoZW1hLCBlbG0pICYmIGVkaXRvci5kb20uaXNFZGl0YWJsZShlbG0pO1xuICAgIGNvbnN0IGlzUnRsID0gZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gRE9NVXRpbHMuRE9NLmdldFN0eWxlKGVsZW1lbnQsICdkaXJlY3Rpb24nLCB0cnVlKSA9PT0gJ3J0bCcgfHwgaGFzU3Ryb25nUnRsKChfYSA9IGVsZW1lbnQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbmxpbmVQYXJlbnRzID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiBmaWx0ZXIkNShET01VdGlscy5ET00uZ2V0UGFyZW50cyhwb3MuY29udGFpbmVyKCksICcqJywgcm9vdE5vZGUpLCBpc0lubGluZVRhcmdldCk7XG4gICAgY29uc3QgZmluZFJvb3RJbmxpbmUgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBmaW5kSW5saW5lUGFyZW50cyhpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcyk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV0pO1xuICAgIH07XG4gICAgY29uc3QgaGFzU2FtZVBhcmVudEJsb2NrID0gKHJvb3ROb2RlLCBub2RlMSwgbm9kZTIpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrMSA9IGdldFBhcmVudEJsb2NrJDMobm9kZTEsIHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IGJsb2NrMiA9IGdldFBhcmVudEJsb2NrJDMobm9kZTIsIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKGJsb2NrMSkgJiYgYmxvY2sxID09PSBibG9jazI7XG4gICAgfTtcbiAgICBjb25zdCBpc0F0WndzcCA9IHBvcyA9PiBpc0JlZm9yZUlubGluZShwb3MpIHx8IGlzQWZ0ZXJJbmxpbmUocG9zKTtcbiAgICBjb25zdCBub3JtYWxpemVQb3NpdGlvbiA9IChmb3J3YXJkLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBvcy5jb250YWluZXIoKSwgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoY29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbihjb250YWluZXIubmV4dFNpYmxpbmcsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbi5hZnRlcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNCZWZvcmVJbmxpbmUocG9zKSA/IENhcmV0UG9zaXRpb24oY29udGFpbmVyLCBvZmZzZXQgKyAxKSA6IHBvcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoY29udGFpbmVyKSkge1xuICAgICAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24oY29udGFpbmVyLnByZXZpb3VzU2libGluZywgY29udGFpbmVyLnByZXZpb3VzU2libGluZy5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uLmJlZm9yZShjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNBZnRlcklubGluZShwb3MpID8gQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCAtIDEpIDogcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVGb3J3YXJkcyA9IGN1cnJ5KG5vcm1hbGl6ZVBvc2l0aW9uLCB0cnVlKTtcbiAgICBjb25zdCBub3JtYWxpemVCYWNrd2FyZHMgPSBjdXJyeShub3JtYWxpemVQb3NpdGlvbiwgZmFsc2UpO1xuXG4gICAgY29uc3QgZXhlY0NvbW1hbmRJZ25vcmVJbnB1dEV2ZW50cyA9IChlZGl0b3IsIGNvbW1hbmQpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0QmxvY2tlciA9IGUgPT4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGVkaXRvci5vbignYmVmb3JlaW5wdXQgaW5wdXQnLCBpbnB1dEJsb2NrZXIsIHRydWUpO1xuICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgZWRpdG9yLm9mZignYmVmb3JlaW5wdXQgaW5wdXQnLCBpbnB1dEJsb2NrZXIpO1xuICAgIH07XG4gICAgY29uc3QgZXhlY0VkaXRvckRlbGV0ZUNvbW1hbmQgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdkZWxldGUnKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4ZWNOYXRpdmVEZWxldGVDb21tYW5kID0gZWRpdG9yID0+IGV4ZWNDb21tYW5kSWdub3JlSW5wdXRFdmVudHMoZWRpdG9yLCAnRGVsZXRlJyk7XG4gICAgY29uc3QgZXhlY05hdGl2ZUZvcndhcmREZWxldGVDb21tYW5kID0gZWRpdG9yID0+IGV4ZWNDb21tYW5kSWdub3JlSW5wdXRFdmVudHMoZWRpdG9yLCAnRm9yd2FyZERlbGV0ZScpO1xuICAgIGNvbnN0IGlzQmVmb3JlUm9vdCA9IHJvb3ROb2RlID0+IGVsbSA9PiBpcyQyKHBhcmVudChlbG0pLCByb290Tm9kZSwgZXEpO1xuICAgIGNvbnN0IGlzVGV4dEJsb2NrT3JMaXN0SXRlbSA9IGVsZW1lbnQgPT4gaXNUZXh0QmxvY2skMihlbGVtZW50KSB8fCBpc0xpc3RJdGVtJDEoZWxlbWVudCk7XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2skMiA9IChyb290Tm9kZSwgZWxtKSA9PiB7XG4gICAgICBpZiAoY29udGFpbnMocm9vdE5vZGUsIGVsbSkpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3QkNChlbG0sIGlzVGV4dEJsb2NrT3JMaXN0SXRlbSwgaXNCZWZvcmVSb290KHJvb3ROb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGFkZEVtcHR5Qm9keSA9IChlZGl0b3IsIG1vdmVTZWxlY3Rpb24gPSB0cnVlKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLmRvbS5pc0VtcHR5KGVkaXRvci5nZXRCb2R5KCkpKSB7XG4gICAgICAgIGVkaXRvci5zZXRDb250ZW50KCcnLCB7IG5vX3NlbGVjdGlvbjogIW1vdmVTZWxlY3Rpb24gfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3aWxsRGVsZXRlTGFzdFBvc2l0aW9uSW5FbGVtZW50ID0gKGZvcndhcmQsIGZyb21Qb3MsIGVsbSkgPT4gbGlmdDIoZmlyc3RQb3NpdGlvbkluKGVsbSksIGxhc3RQb3NpdGlvbkluKGVsbSksIChmaXJzdFBvcywgbGFzdFBvcykgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZpcnN0UG9zID0gbm9ybWFsaXplUG9zaXRpb24odHJ1ZSwgZmlyc3RQb3MpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZExhc3RQb3MgPSBub3JtYWxpemVQb3NpdGlvbihmYWxzZSwgbGFzdFBvcyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkRnJvbVBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZhbHNlLCBmcm9tUG9zKTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBuZXh0UG9zaXRpb24oZWxtLCBub3JtYWxpemVkRnJvbVBvcykuZXhpc3RzKG5leHRQb3MgPT4gbmV4dFBvcy5pc0VxdWFsKG5vcm1hbGl6ZWRMYXN0UG9zKSAmJiBmcm9tUG9zLmlzRXF1YWwobm9ybWFsaXplZEZpcnN0UG9zKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJldlBvc2l0aW9uKGVsbSwgbm9ybWFsaXplZEZyb21Qb3MpLmV4aXN0cyhwcmV2UG9zID0+IHByZXZQb3MuaXNFcXVhbChub3JtYWxpemVkRmlyc3RQb3MpICYmIGZyb21Qb3MuaXNFcXVhbChub3JtYWxpemVkTGFzdFBvcykpO1xuICAgICAgfVxuICAgIH0pLmdldE9yKHRydWUpO1xuICAgIGNvbnN0IGZyZWVmYWxsUnRsID0gcm9vdCA9PiB7XG4gICAgICBjb25zdCBjaGlsZCA9IGlzQ29tbWVudCQxKHJvb3QpID8gcHJldlNpYmxpbmcocm9vdCkgOiBsYXN0Q2hpbGQocm9vdCk7XG4gICAgICByZXR1cm4gY2hpbGQuYmluZChmcmVlZmFsbFJ0bCkub3JUaHVuaygoKSA9PiBPcHRpb25hbC5zb21lKHJvb3QpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVJhbmdlQ29udGVudHMgPSAoZWRpdG9yLCBybmcsIHJvb3QsIG1vdmVTZWxlY3Rpb24gPSB0cnVlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBybmcuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgIGNvbnN0IGxhc3ROb2RlID0gZnJlZWZhbGxSdGwocm9vdCkuZ2V0T3Iocm9vdCk7XG4gICAgICBjb25zdCBsYXN0QmxvY2sgPSBTdWdhckVsZW1lbnQuZnJvbURvbSgoX2EgPSBlZGl0b3IuZG9tLmdldFBhcmVudChsYXN0Tm9kZS5kb20sIGVkaXRvci5kb20uaXNCbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvb3QuZG9tKTtcbiAgICAgIGlmIChsYXN0QmxvY2suZG9tID09PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgIHBhZGRFbXB0eUJvZHkoZWRpdG9yLCBtb3ZlU2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbXB0eSQyKGxhc3RCbG9jaykpIHtcbiAgICAgICAgZmlsbFdpdGhQYWRkaW5nQnIobGFzdEJsb2NrKTtcbiAgICAgICAgaWYgKG1vdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGxhc3RCbG9jay5kb20sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVxKHJvb3QsIGxhc3RCbG9jaykpIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbENsZWFudXBOb2RlcyA9IGlzJDIocGFyZW50KGxhc3RCbG9jayksIHJvb3QpID8gW10gOiBzaWJsaW5ncyhsYXN0QmxvY2spO1xuICAgICAgICBlYWNoJGUoYWRkaXRpb25hbENsZWFudXBOb2Rlcy5jb25jYXQoY2hpbGRyZW4kMShyb290KSksIG5vZGUgPT4ge1xuICAgICAgICAgIGlmICghZXEobm9kZSwgbGFzdEJsb2NrKSAmJiAhY29udGFpbnMobm9kZSwgbGFzdEJsb2NrKSAmJiBpc0VtcHR5JDIobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZSQ1KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUm9vdEZyb21FbGVtZW50ID0gcm9vdCA9PiBjdXIgPT4gZXEocm9vdCwgY3VyKTtcbiAgICBjb25zdCBnZXRUYWJsZUNlbGxzID0gdGFibGUgPT4gZGVzY2VuZGFudHModGFibGUsICd0ZCx0aCcpO1xuICAgIGNvbnN0IGdldFRhYmxlRGV0YWlsc0Zyb21SYW5nZSA9IChybmcsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgZ2V0VGFibGUgPSBub2RlID0+IGdldENsb3Nlc3RUYWJsZShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgaXNSb290KTtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGUgPSBnZXRUYWJsZShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgY29uc3QgZW5kVGFibGUgPSBnZXRUYWJsZShybmcuZW5kQ29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGlzU3RhcnRJblRhYmxlID0gc3RhcnRUYWJsZS5pc1NvbWUoKTtcbiAgICAgIGNvbnN0IGlzRW5kSW5UYWJsZSA9IGVuZFRhYmxlLmlzU29tZSgpO1xuICAgICAgY29uc3QgaXNTYW1lVGFibGUgPSBsaWZ0MihzdGFydFRhYmxlLCBlbmRUYWJsZSwgZXEpLmdldE9yKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTXVsdGlUYWJsZSA9ICFpc1NhbWVUYWJsZSAmJiBpc1N0YXJ0SW5UYWJsZSAmJiBpc0VuZEluVGFibGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRhYmxlLFxuICAgICAgICBlbmRUYWJsZSxcbiAgICAgICAgaXNTdGFydEluVGFibGUsXG4gICAgICAgIGlzRW5kSW5UYWJsZSxcbiAgICAgICAgaXNTYW1lVGFibGUsXG4gICAgICAgIGlzTXVsdGlUYWJsZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdGFibGVDZWxsUm5nID0gKHN0YXJ0LCBlbmQpID0+ICh7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0pO1xuICAgIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gKHJuZywgdGFibGUsIGNlbGxzKSA9PiAoe1xuICAgICAgcm5nLFxuICAgICAgdGFibGUsXG4gICAgICBjZWxsc1xuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZUFjdGlvbiA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7XG4gICAgICAgIHNpbmdsZUNlbGxUYWJsZTogW1xuICAgICAgICAgICdybmcnLFxuICAgICAgICAgICdjZWxsJ1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyBmdWxsVGFibGU6IFsndGFibGUnXSB9LFxuICAgICAge1xuICAgICAgICBwYXJ0aWFsVGFibGU6IFtcbiAgICAgICAgICAnY2VsbHMnLFxuICAgICAgICAgICdvdXRzaWRlRGV0YWlscydcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbXVsdGlUYWJsZTogW1xuICAgICAgICAgICdzdGFydFRhYmxlQ2VsbHMnLFxuICAgICAgICAgICdlbmRUYWJsZUNlbGxzJyxcbiAgICAgICAgICAnYmV0d2VlblJuZydcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0pO1xuICAgIGNvbnN0IGdldENsb3Nlc3RDZWxsJDEgPSAoY29udGFpbmVyLCBpc1Jvb3QpID0+IGNsb3Nlc3QkMyhTdWdhckVsZW1lbnQuZnJvbURvbShjb250YWluZXIpLCAndGQsdGgnLCBpc1Jvb3QpO1xuICAgIGNvbnN0IGlzRXhwYW5kZWRDZWxsUm5nID0gY2VsbFJuZyA9PiAhZXEoY2VsbFJuZy5zdGFydCwgY2VsbFJuZy5lbmQpO1xuICAgIGNvbnN0IGdldFRhYmxlRnJvbUNlbGxSbmcgPSAoY2VsbFJuZywgaXNSb290KSA9PiBnZXRDbG9zZXN0VGFibGUoY2VsbFJuZy5zdGFydCwgaXNSb290KS5iaW5kKHN0YXJ0UGFyZW50VGFibGUgPT4gZ2V0Q2xvc2VzdFRhYmxlKGNlbGxSbmcuZW5kLCBpc1Jvb3QpLmJpbmQoZW5kUGFyZW50VGFibGUgPT4gc29tZUlmKGVxKHN0YXJ0UGFyZW50VGFibGUsIGVuZFBhcmVudFRhYmxlKSwgc3RhcnRQYXJlbnRUYWJsZSkpKTtcbiAgICBjb25zdCBpc1NpbmdsZUNlbGxUYWJsZSA9IChjZWxsUm5nLCBpc1Jvb3QpID0+ICFpc0V4cGFuZGVkQ2VsbFJuZyhjZWxsUm5nKSAmJiBnZXRUYWJsZUZyb21DZWxsUm5nKGNlbGxSbmcsIGlzUm9vdCkuZXhpc3RzKHRhYmxlID0+IHtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5kb20ucm93cztcbiAgICAgIHJldHVybiByb3dzLmxlbmd0aCA9PT0gMSAmJiByb3dzWzBdLmNlbGxzLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRDZWxsUm5nID0gKHJuZywgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBzdGFydENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5zdGFydENvbnRhaW5lciwgaXNSb290KTtcbiAgICAgIGNvbnN0IGVuZENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5lbmRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICByZXR1cm4gbGlmdDIoc3RhcnRDZWxsLCBlbmRDZWxsLCB0YWJsZUNlbGxSbmcpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2VsbFJhbmdlRnJvbVN0YXJ0VGFibGUgPSBpc1Jvb3QgPT4gc3RhcnRDZWxsID0+IGdldENsb3Nlc3RUYWJsZShzdGFydENlbGwsIGlzUm9vdCkuYmluZCh0YWJsZSA9PiBsYXN0JDMoZ2V0VGFibGVDZWxscyh0YWJsZSkpLm1hcChlbmRDZWxsID0+IHRhYmxlQ2VsbFJuZyhzdGFydENlbGwsIGVuZENlbGwpKSk7XG4gICAgY29uc3QgZ2V0Q2VsbFJhbmdlRnJvbUVuZFRhYmxlID0gaXNSb290ID0+IGVuZENlbGwgPT4gZ2V0Q2xvc2VzdFRhYmxlKGVuZENlbGwsIGlzUm9vdCkuYmluZCh0YWJsZSA9PiBoZWFkKGdldFRhYmxlQ2VsbHModGFibGUpKS5tYXAoc3RhcnRDZWxsID0+IHRhYmxlQ2VsbFJuZyhzdGFydENlbGwsIGVuZENlbGwpKSk7XG4gICAgY29uc3QgZ2V0VGFibGVTZWxlY3Rpb25Gcm9tQ2VsbFJuZyA9IGlzUm9vdCA9PiBjZWxsUm5nID0+IGdldFRhYmxlRnJvbUNlbGxSbmcoY2VsbFJuZywgaXNSb290KS5tYXAodGFibGUgPT4gdGFibGVTZWxlY3Rpb24oY2VsbFJuZywgdGFibGUsIGdldFRhYmxlQ2VsbHModGFibGUpKSk7XG4gICAgY29uc3QgZ2V0VGFibGVTZWxlY3Rpb25zID0gKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KSA9PiB7XG4gICAgICBpZiAocm5nLmNvbGxhcHNlZCB8fCAhY2VsbFJuZy5mb3JhbGwoaXNFeHBhbmRlZENlbGxSbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkRldGFpbHMuaXNTYW1lVGFibGUpIHtcbiAgICAgICAgY29uc3Qgc2FtZVRhYmxlU2VsZWN0aW9uID0gY2VsbFJuZy5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICBzdGFydDogc2FtZVRhYmxlU2VsZWN0aW9uLFxuICAgICAgICAgIGVuZDogc2FtZVRhYmxlU2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gZ2V0Q2xvc2VzdENlbGwkMShybmcuc3RhcnRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICAgIGNvbnN0IGVuZENlbGwgPSBnZXRDbG9zZXN0Q2VsbCQxKHJuZy5lbmRDb250YWluZXIsIGlzUm9vdCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFibGVTZWxlY3Rpb24gPSBzdGFydENlbGwuYmluZChnZXRDZWxsUmFuZ2VGcm9tU3RhcnRUYWJsZShpc1Jvb3QpKS5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIGNvbnN0IGVuZFRhYmxlU2VsZWN0aW9uID0gZW5kQ2VsbC5iaW5kKGdldENlbGxSYW5nZUZyb21FbmRUYWJsZShpc1Jvb3QpKS5iaW5kKGdldFRhYmxlU2VsZWN0aW9uRnJvbUNlbGxSbmcoaXNSb290KSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICBzdGFydDogc3RhcnRUYWJsZVNlbGVjdGlvbixcbiAgICAgICAgICBlbmQ6IGVuZFRhYmxlU2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0Q2VsbEluZGV4ID0gKGNlbGxzLCBjZWxsKSA9PiBmaW5kSW5kZXgkMihjZWxscywgeCA9PiBlcSh4LCBjZWxsKSk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDZWxscyA9IHRhYmxlU2VsZWN0aW9uID0+IGxpZnQyKGdldENlbGxJbmRleCh0YWJsZVNlbGVjdGlvbi5jZWxscywgdGFibGVTZWxlY3Rpb24ucm5nLnN0YXJ0KSwgZ2V0Q2VsbEluZGV4KHRhYmxlU2VsZWN0aW9uLmNlbGxzLCB0YWJsZVNlbGVjdGlvbi5ybmcuZW5kKSwgKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB0YWJsZVNlbGVjdGlvbi5jZWxscy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCArIDEpKTtcbiAgICBjb25zdCBpc1NpbmdsZUNlbGxUYWJsZUNvbnRlbnRTZWxlY3RlZCA9IChvcHRDZWxsUm5nLCBybmcsIGlzUm9vdCkgPT4gb3B0Q2VsbFJuZy5leGlzdHMoY2VsbFJuZyA9PiBpc1NpbmdsZUNlbGxUYWJsZShjZWxsUm5nLCBpc1Jvb3QpICYmIGhhc0FsbENvbnRlbnRzU2VsZWN0ZWQoY2VsbFJuZy5zdGFydCwgcm5nKSk7XG4gICAgY29uc3QgdW5zZWxlY3RDZWxscyA9IChybmcsIHNlbGVjdGlvbkRldGFpbHMpID0+IHtcbiAgICAgIGNvbnN0IHtzdGFydFRhYmxlLCBlbmRUYWJsZX0gPSBzZWxlY3Rpb25EZXRhaWxzO1xuICAgICAgY29uc3Qgb3RoZXJDb250ZW50Um5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIHN0YXJ0VGFibGUuZWFjaCh0YWJsZSA9PiBvdGhlckNvbnRlbnRSbmcuc2V0U3RhcnRBZnRlcih0YWJsZS5kb20pKTtcbiAgICAgIGVuZFRhYmxlLmVhY2godGFibGUgPT4gb3RoZXJDb250ZW50Um5nLnNldEVuZEJlZm9yZSh0YWJsZS5kb20pKTtcbiAgICAgIHJldHVybiBvdGhlckNvbnRlbnRSbmc7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTaW5nbGVUYWJsZSA9IChjZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCkgPT4gZ2V0VGFibGVTZWxlY3Rpb25zKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KS5iaW5kKCh7c3RhcnQsIGVuZH0pID0+IHN0YXJ0Lm9yKGVuZCkpLmJpbmQodGFibGVTZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qge2lzU2FtZVRhYmxlfSA9IHNlbGVjdGlvbkRldGFpbHM7XG4gICAgICBjb25zdCBzZWxlY3RlZENlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyh0YWJsZVNlbGVjdGlvbikuZ2V0T3IoW10pO1xuICAgICAgaWYgKGlzU2FtZVRhYmxlICYmIHRhYmxlU2VsZWN0aW9uLmNlbGxzLmxlbmd0aCA9PT0gc2VsZWN0ZWRDZWxscy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLmZ1bGxUYWJsZSh0YWJsZVNlbGVjdGlvbi50YWJsZSkpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZENlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGlzU2FtZVRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLnBhcnRpYWxUYWJsZShzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5ub25lKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvdGhlckNvbnRlbnRSbmcgPSB1bnNlbGVjdENlbGxzKHJuZywgc2VsZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZGVsZXRlQWN0aW9uLnBhcnRpYWxUYWJsZShzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICAgIC4uLnNlbGVjdGlvbkRldGFpbHMsXG4gICAgICAgICAgICBybmc6IG90aGVyQ29udGVudFJuZ1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlTXVsdGlUYWJsZSA9IChjZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCkgPT4gZ2V0VGFibGVTZWxlY3Rpb25zKGNlbGxSbmcsIHNlbGVjdGlvbkRldGFpbHMsIHJuZywgaXNSb290KS5iaW5kKCh7c3RhcnQsIGVuZH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGVTZWxlY3RlZENlbGxzID0gc3RhcnQuYmluZChnZXRTZWxlY3RlZENlbGxzKS5nZXRPcihbXSk7XG4gICAgICBjb25zdCBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMgPSBlbmQuYmluZChnZXRTZWxlY3RlZENlbGxzKS5nZXRPcihbXSk7XG4gICAgICBpZiAoc3RhcnRUYWJsZVNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCAmJiBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvdGhlckNvbnRlbnRSbmcgPSB1bnNlbGVjdENlbGxzKHJuZywgc2VsZWN0aW9uRGV0YWlscyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGRlbGV0ZUFjdGlvbi5tdWx0aVRhYmxlKHN0YXJ0VGFibGVTZWxlY3RlZENlbGxzLCBlbmRUYWJsZVNlbGVjdGVkQ2VsbHMsIG90aGVyQ29udGVudFJuZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRBY3Rpb25Gcm9tUmFuZ2UgPSAocm9vdCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBpc1Jvb3RGcm9tRWxlbWVudChyb290KTtcbiAgICAgIGNvbnN0IG9wdENlbGxSbmcgPSBnZXRDZWxsUm5nKHJuZywgaXNSb290KTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkRldGFpbHMgPSBnZXRUYWJsZURldGFpbHNGcm9tUmFuZ2Uocm5nLCBpc1Jvb3QpO1xuICAgICAgaWYgKGlzU2luZ2xlQ2VsbFRhYmxlQ29udGVudFNlbGVjdGVkKG9wdENlbGxSbmcsIHJuZywgaXNSb290KSkge1xuICAgICAgICByZXR1cm4gb3B0Q2VsbFJuZy5tYXAoY2VsbFJuZyA9PiBkZWxldGVBY3Rpb24uc2luZ2xlQ2VsbFRhYmxlKHJuZywgY2VsbFJuZy5zdGFydCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25EZXRhaWxzLmlzTXVsdGlUYWJsZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlTXVsdGlUYWJsZShvcHRDZWxsUm5nLCBzZWxlY3Rpb25EZXRhaWxzLCBybmcsIGlzUm9vdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFuZGxlU2luZ2xlVGFibGUob3B0Q2VsbFJuZywgc2VsZWN0aW9uRGV0YWlscywgcm5nLCBpc1Jvb3QpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjbGVhbkNlbGxzID0gY2VsbHMgPT4gZWFjaCRlKGNlbGxzLCBjZWxsID0+IHtcbiAgICAgIHJlbW92ZSRhKGNlbGwsICdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKGNlbGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldE91dHNpZGVCbG9jayA9IChlZGl0b3IsIGNvbnRhaW5lcikgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChjb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG4gICAgY29uc3QgaGFuZGxlRW1wdHlCbG9jayA9IChlZGl0b3IsIHN0YXJ0SW5UYWJsZSwgZW1wdHlCbG9jaykgPT4ge1xuICAgICAgZW1wdHlCbG9jay5lYWNoKGJsb2NrID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0SW5UYWJsZSkge1xuICAgICAgICAgIHJlbW92ZSQ1KGJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihibG9jayk7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihibG9jay5kb20sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsID0gKGVkaXRvciwgY2VsbCwgcm5nLCBpc0ZpcnN0Q2VsbEluU2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBpbnNpZGVUYWJsZVJuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICBpZiAoaXNGaXJzdENlbGxJblNlbGVjdGlvbikge1xuICAgICAgICBpbnNpZGVUYWJsZVJuZy5zZXRTdGFydChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgIGluc2lkZVRhYmxlUm5nLnNldEVuZEFmdGVyKGNlbGwuZG9tLmxhc3RDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnNpZGVUYWJsZVJuZy5zZXRTdGFydEJlZm9yZShjZWxsLmRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgaW5zaWRlVGFibGVSbmcuc2V0RW5kKHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgZGVsZXRlQ2VsbENvbnRlbnRzKGVkaXRvciwgaW5zaWRlVGFibGVSbmcsIGNlbGwsIGZhbHNlKS5lYWNoKGFjdGlvbiA9PiBhY3Rpb24oKSk7XG4gICAgfTtcbiAgICBjb25zdCBjb2xsYXBzZUFuZFJlc3RvcmVDZWxsU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FZGl0b3IoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpKTtcbiAgICAgIGlmIChpc1RhYmxlQ2VsbCQzKHNlbGVjdGVkTm9kZS5kb20pICYmIGlzRW1wdHkkMihzZWxlY3RlZE5vZGUpKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oc2VsZWN0ZWROb2RlLmRvbSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkQ2VsbHMubGVuZ3RoID4gMSAmJiBleGlzdHMoc2VsZWN0ZWRDZWxscywgY2VsbCA9PiBlcShjZWxsLCBzZWxlY3RlZE5vZGUpKSkge1xuICAgICAgICBzZXQkMyhzZWxlY3RlZE5vZGUsICdkYXRhLW1jZS1zZWxlY3RlZCcsICcxJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlbXB0eVNpbmdsZVRhYmxlQ2VsbHMgPSAoZWRpdG9yLCBjZWxscywgb3V0c2lkZURldGFpbHMpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yUm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNlbGxzVG9DbGVhbiA9IG91dHNpZGVEZXRhaWxzLmJpbmQoKHtybmcsIGlzU3RhcnRJblRhYmxlfSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRzaWRlQmxvY2sgPSBnZXRPdXRzaWRlQmxvY2soZWRpdG9yLCBpc1N0YXJ0SW5UYWJsZSA/IHJuZy5lbmRDb250YWluZXIgOiBybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBybmcuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgaGFuZGxlRW1wdHlCbG9jayhlZGl0b3IsIGlzU3RhcnRJblRhYmxlLCBvdXRzaWRlQmxvY2suZmlsdGVyKGlzRW1wdHkkMikpO1xuICAgICAgICBjb25zdCBlbmRQb2ludENlbGwgPSBpc1N0YXJ0SW5UYWJsZSA/IGNlbGxzWzBdIDogY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsKGVkaXRvciwgZW5kUG9pbnRDZWxsLCBlZGl0b3JSbmcsIGlzU3RhcnRJblRhYmxlKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5JDIoZW5kUG9pbnRDZWxsKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGlzU3RhcnRJblRhYmxlID8gY2VsbHMuc2xpY2UoMSkgOiBjZWxscy5zbGljZSgwLCAtMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmdldE9yKGNlbGxzKTtcbiAgICAgIGNsZWFuQ2VsbHMoY2VsbHNUb0NsZWFuKTtcbiAgICAgIGNvbGxhcHNlQW5kUmVzdG9yZUNlbGxTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICB9KTtcbiAgICBjb25zdCBlbXB0eU11bHRpVGFibGVDZWxscyA9IChlZGl0b3IsIHN0YXJ0VGFibGVDZWxscywgZW5kVGFibGVDZWxscywgYmV0d2VlblJuZykgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qgc3RhcnRDZWxsID0gc3RhcnRUYWJsZUNlbGxzWzBdO1xuICAgICAgY29uc3QgZW5kQ2VsbCA9IGVuZFRhYmxlQ2VsbHNbZW5kVGFibGVDZWxscy5sZW5ndGggLSAxXTtcbiAgICAgIGRlbGV0ZUNvbnRlbnRJbnNpZGVDZWxsKGVkaXRvciwgc3RhcnRDZWxsLCBybmcsIHRydWUpO1xuICAgICAgZGVsZXRlQ29udGVudEluc2lkZUNlbGwoZWRpdG9yLCBlbmRDZWxsLCBybmcsIGZhbHNlKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGFibGVDZWxsc1RvQ2xlYW4gPSBpc0VtcHR5JDIoc3RhcnRDZWxsKSA/IHN0YXJ0VGFibGVDZWxscyA6IHN0YXJ0VGFibGVDZWxscy5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGVuZFRhYmxlQ2VsbHNUb0NsZWFuID0gaXNFbXB0eSQyKGVuZENlbGwpID8gZW5kVGFibGVDZWxscyA6IGVuZFRhYmxlQ2VsbHMuc2xpY2UoMCwgLTEpO1xuICAgICAgY2xlYW5DZWxscyhzdGFydFRhYmxlQ2VsbHNUb0NsZWFuLmNvbmNhdChlbmRUYWJsZUNlbGxzVG9DbGVhbikpO1xuICAgICAgYmV0d2VlblJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgY29sbGFwc2VBbmRSZXN0b3JlQ2VsbFNlbGVjdGlvbihlZGl0b3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRlbGV0ZUNlbGxDb250ZW50cyA9IChlZGl0b3IsIHJuZywgY2VsbCwgbW92ZVNlbGVjdGlvbiA9IHRydWUpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4ge1xuICAgICAgZGVsZXRlUmFuZ2VDb250ZW50cyhlZGl0b3IsIHJuZywgY2VsbCwgbW92ZVNlbGVjdGlvbik7XG4gICAgfSk7XG4gICAgY29uc3QgZGVsZXRlVGFibGVFbGVtZW50ID0gKGVkaXRvciwgdGFibGUpID0+IE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZmFsc2UsIHRhYmxlKSk7XG4gICAgY29uc3QgZGVsZXRlQ2VsbFJhbmdlID0gKGVkaXRvciwgcm9vdEVsbSwgcm5nKSA9PiBnZXRBY3Rpb25Gcm9tUmFuZ2Uocm9vdEVsbSwgcm5nKS5iaW5kKGFjdGlvbiA9PiBhY3Rpb24uZm9sZChjdXJyeShkZWxldGVDZWxsQ29udGVudHMsIGVkaXRvciksIGN1cnJ5KGRlbGV0ZVRhYmxlRWxlbWVudCwgZWRpdG9yKSwgY3VycnkoZW1wdHlTaW5nbGVUYWJsZUNlbGxzLCBlZGl0b3IpLCBjdXJyeShlbXB0eU11bHRpVGFibGVDZWxscywgZWRpdG9yKSkpO1xuICAgIGNvbnN0IGRlbGV0ZUNhcHRpb25SYW5nZSA9IChlZGl0b3IsIGNhcHRpb24pID0+IGVtcHR5RWxlbWVudChlZGl0b3IsIGNhcHRpb24pO1xuICAgIGNvbnN0IGRlbGV0ZVRhYmxlUmFuZ2UgPSAoZWRpdG9yLCByb290RWxtLCBybmcsIHN0YXJ0RWxtKSA9PiBnZXRQYXJlbnRDYXB0aW9uKHJvb3RFbG0sIHN0YXJ0RWxtKS5mb2xkKCgpID0+IGRlbGV0ZUNlbGxSYW5nZShlZGl0b3IsIHJvb3RFbG0sIHJuZyksIGNhcHRpb24gPT4gZGVsZXRlQ2FwdGlvblJhbmdlKGVkaXRvciwgY2FwdGlvbikpO1xuICAgIGNvbnN0IGRlbGV0ZVJhbmdlJDMgPSAoZWRpdG9yLCBzdGFydEVsbSwgc2VsZWN0ZWRDZWxscykgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRDZWxscy5sZW5ndGggIT09IDAgPyBlbXB0eVNpbmdsZVRhYmxlQ2VsbHMoZWRpdG9yLCBzZWxlY3RlZENlbGxzLCBPcHRpb25hbC5ub25lKCkpIDogZGVsZXRlVGFibGVSYW5nZShlZGl0b3IsIHJvb3ROb2RlLCBybmcsIHN0YXJ0RWxtKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudENlbGwgPSAocm9vdEVsbSwgZWxtKSA9PiBmaW5kJDIocGFyZW50c0FuZFNlbGYoZWxtLCByb290RWxtKSwgaXNUYWJsZUNlbGwkMik7XG4gICAgY29uc3QgZ2V0UGFyZW50Q2FwdGlvbiA9IChyb290RWxtLCBlbG0pID0+IGZpbmQkMihwYXJlbnRzQW5kU2VsZihlbG0sIHJvb3RFbG0pLCBpc1RhZygnY2FwdGlvbicpKTtcbiAgICBjb25zdCBkZWxldGVCZXR3ZWVuQ2VsbHMgPSAoZWRpdG9yLCByb290RWxtLCBmb3J3YXJkLCBmcm9tQ2VsbCwgZnJvbSkgPT4gbmF2aWdhdGUoZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbSkuYmluZCh0byA9PiBnZXRQYXJlbnRDZWxsKHJvb3RFbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRvLmdldE5vZGUoKSkpLmJpbmQodG9DZWxsID0+IGVxKHRvQ2VsbCwgZnJvbUNlbGwpID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuc29tZShub29wKSkpO1xuICAgIGNvbnN0IGVtcHR5RWxlbWVudCA9IChlZGl0b3IsIGVsbSkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICBmaWxsV2l0aFBhZGRpbmdCcihlbG0pO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihlbG0uZG9tLCAwKTtcbiAgICB9KTtcbiAgICBjb25zdCBpc0RlbGV0ZU9mTGFzdENoYXJQb3MgPSAoZnJvbUNhcHRpb24sIGZvcndhcmQsIGZyb20sIHRvKSA9PiBmaXJzdFBvc2l0aW9uSW4oZnJvbUNhcHRpb24uZG9tKS5iaW5kKGZpcnN0ID0+IGxhc3RQb3NpdGlvbkluKGZyb21DYXB0aW9uLmRvbSkubWFwKGxhc3QgPT4gZm9yd2FyZCA/IGZyb20uaXNFcXVhbChmaXJzdCkgJiYgdG8uaXNFcXVhbChsYXN0KSA6IGZyb20uaXNFcXVhbChsYXN0KSAmJiB0by5pc0VxdWFsKGZpcnN0KSkpLmdldE9yKHRydWUpO1xuICAgIGNvbnN0IGVtcHR5Q2FyZXRDYXB0aW9uID0gKGVkaXRvciwgZWxtKSA9PiBlbXB0eUVsZW1lbnQoZWRpdG9yLCBlbG0pO1xuICAgIGNvbnN0IHZhbGlkYXRlQ2FyZXRDYXB0aW9uID0gKHJvb3RFbG0sIGZyb21DYXB0aW9uLCB0bykgPT4gZ2V0UGFyZW50Q2FwdGlvbihyb290RWxtLCBTdWdhckVsZW1lbnQuZnJvbURvbSh0by5nZXROb2RlKCkpKS5mb2xkKCgpID0+IE9wdGlvbmFsLnNvbWUobm9vcCksIHRvQ2FwdGlvbiA9PiBzb21lSWYoIWVxKHRvQ2FwdGlvbiwgZnJvbUNhcHRpb24pLCBub29wKSk7XG4gICAgY29uc3QgZGVsZXRlQ2FyZXRJbnNpZGVDYXB0aW9uID0gKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNhcHRpb24sIGZyb20pID0+IG5hdmlnYXRlKGZvcndhcmQsIGVkaXRvci5nZXRCb2R5KCksIGZyb20pLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSwgdG8gPT4gaXNEZWxldGVPZkxhc3RDaGFyUG9zKGZyb21DYXB0aW9uLCBmb3J3YXJkLCBmcm9tLCB0bykgPyBlbXB0eUNhcmV0Q2FwdGlvbihlZGl0b3IsIGZyb21DYXB0aW9uKSA6IHZhbGlkYXRlQ2FyZXRDYXB0aW9uKHJvb3RFbG0sIGZyb21DYXB0aW9uLCB0bykpO1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0Q2VsbHMgPSAoZWRpdG9yLCBmb3J3YXJkLCByb290RWxtLCBzdGFydEVsbSkgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50Q2VsbChyb290RWxtLCBzdGFydEVsbSkuYmluZChmcm9tQ2VsbCA9PiBpc0VtcHR5JDIoZnJvbUNlbGwpID8gZW1wdHlFbGVtZW50KGVkaXRvciwgZnJvbUNlbGwpIDogZGVsZXRlQmV0d2VlbkNlbGxzKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNlbGwsIGZyb20pKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0Q2FwdGlvbiA9IChlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIGZyb21DYXB0aW9uKSA9PiB7XG4gICAgICBjb25zdCBmcm9tID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBpc0VtcHR5JDIoZnJvbUNhcHRpb24pID8gZW1wdHlFbGVtZW50KGVkaXRvciwgZnJvbUNhcHRpb24pIDogZGVsZXRlQ2FyZXRJbnNpZGVDYXB0aW9uKGVkaXRvciwgcm9vdEVsbSwgZm9yd2FyZCwgZnJvbUNhcHRpb24sIGZyb20pO1xuICAgIH07XG4gICAgY29uc3QgaXNOZWFyVGFibGUgPSAoZm9yd2FyZCwgcG9zKSA9PiBmb3J3YXJkID8gaXNCZWZvcmVUYWJsZShwb3MpIDogaXNBZnRlclRhYmxlKHBvcyk7XG4gICAgY29uc3QgaXNCZWZvcmVPckFmdGVyVGFibGUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBmcm9tUG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIHJldHVybiBpc05lYXJUYWJsZShmb3J3YXJkLCBmcm9tUG9zKSB8fCBmcm9tUG9zaXRpb24oZm9yd2FyZCwgZWRpdG9yLmdldEJvZHkoKSwgZnJvbVBvcykuZXhpc3RzKHBvcyA9PiBpc05lYXJUYWJsZShmb3J3YXJkLCBwb3MpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNhcmV0JDMgPSAoZWRpdG9yLCBmb3J3YXJkLCBzdGFydEVsbSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgcmV0dXJuIGdldFBhcmVudENhcHRpb24ocm9vdEVsbSwgc3RhcnRFbG0pLmZvbGQoKCkgPT4gZGVsZXRlQ2FyZXRDZWxscyhlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIHN0YXJ0RWxtKS5vclRodW5rKCgpID0+IHNvbWVJZihpc0JlZm9yZU9yQWZ0ZXJUYWJsZShlZGl0b3IsIGZvcndhcmQpLCBub29wKSksIGZyb21DYXB0aW9uID0+IGRlbGV0ZUNhcmV0Q2FwdGlvbihlZGl0b3IsIGZvcndhcmQsIHJvb3RFbG0sIGZyb21DYXB0aW9uKSk7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUkYSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSk7XG4gICAgICBjb25zdCBjZWxscyA9IGdldENlbGxzRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBjZWxscy5sZW5ndGggPT09IDAgPyBkZWxldGVDYXJldCQzKGVkaXRvciwgZm9yd2FyZCwgc3RhcnRFbG0pIDogZGVsZXRlUmFuZ2UkMyhlZGl0b3IsIHN0YXJ0RWxtLCBjZWxscyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMSA9IChyb290LCBub2RlKSA9PiB7XG4gICAgICBsZXQgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKHRlbXBOb2RlICYmIHRlbXBOb2RlICE9PSByb290KSB7XG4gICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyh0ZW1wTm9kZSkgfHwgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKHRlbXBOb2RlKSkge1xuICAgICAgICAgIHJldHVybiB0ZW1wTm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJuYWxBdHRyaWJ1dGVzUHJlZml4ZXMgPSBbXG4gICAgICAnZGF0YS1lcGhveC0nLFxuICAgICAgJ2RhdGEtbWNlLScsXG4gICAgICAnZGF0YS1hbGxveS0nLFxuICAgICAgJ2RhdGEtc25vb2tlci0nLFxuICAgICAgJ18nXG4gICAgXTtcbiAgICBjb25zdCBlYWNoJDkgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IEVsZW1lbnRVdGlscyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgaW50ZXJuYWxBdHRyaWJ1dGVzID0gbmV3IFNldChlZGl0b3Iuc2VyaWFsaXplci5nZXRUZW1wQXR0cnMoKSk7XG4gICAgICBjb25zdCBjb21wYXJlID0gKG5vZGUxLCBub2RlMikgPT4ge1xuICAgICAgICBpZiAobm9kZTEubm9kZU5hbWUgIT09IG5vZGUyLm5vZGVOYW1lIHx8IG5vZGUxLm5vZGVUeXBlICE9PSBub2RlMi5ub2RlVHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZXRBdHRyaWJzID0gbm9kZSA9PiB7XG4gICAgICAgICAgY29uc3QgYXR0cmlicyA9IHt9O1xuICAgICAgICAgIGVhY2gkOShkb20uZ2V0QXR0cmlicyhub2RlKSwgYXR0ciA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgIWlzQXR0cmlidXRlSW50ZXJuYWwobmFtZSkpIHtcbiAgICAgICAgICAgICAgYXR0cmlic1tuYW1lXSA9IGRvbS5nZXRBdHRyaWIobm9kZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbXBhcmVPYmplY3RzID0gKG9iajEsIG9iajIpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKGhhcyQyKG9iajEsIG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqMltuYW1lXTtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob2JqMVtuYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIG9iajJbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvYmoyKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIob2JqMiwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUxKSAmJiBpc0VsZW1lbnQkNihub2RlMikpIHtcbiAgICAgICAgICBpZiAoIWNvbXBhcmVPYmplY3RzKGdldEF0dHJpYnMobm9kZTEpLCBnZXRBdHRyaWJzKG5vZGUyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb21wYXJlT2JqZWN0cyhkb20ucGFyc2VTdHlsZShkb20uZ2V0QXR0cmliKG5vZGUxLCAnc3R5bGUnKSksIGRvbS5wYXJzZVN0eWxlKGRvbS5nZXRBdHRyaWIobm9kZTIsICdzdHlsZScpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFpc0Jvb2ttYXJrTm9kZSQxKG5vZGUxKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlMik7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNBdHRyaWJ1dGVJbnRlcm5hbCA9IGF0dHJpYnV0ZU5hbWUgPT4gZXhpc3RzKGludGVybmFsQXR0cmlidXRlc1ByZWZpeGVzLCB2YWx1ZSA9PiBzdGFydHNXaXRoKGF0dHJpYnV0ZU5hbWUsIHZhbHVlKSkgfHwgaW50ZXJuYWxBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBhcmUsXG4gICAgICAgIGlzQXR0cmlidXRlSW50ZXJuYWxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHRyYXZlcnNlID0gKHJvb3QsIGZuKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUud2FsaygpKSB7XG4gICAgICAgIGZuKG5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWF0Y2hOb2RlJDEgPSAobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIG5vZGUsIG1hdGNoZXMpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBmb3IgKGxldCBuaSA9IDAsIG5sID0gbm9kZUZpbHRlcnMubGVuZ3RoOyBuaSA8IG5sOyBuaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IG5vZGVGaWx0ZXJzW25pXTtcbiAgICAgICAgaWYgKGZpbHRlci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzLm5vZGVzW25hbWVdO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2gubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcy5ub2Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKGxldCBhaSA9IDAsIGFsID0gYXR0cmlidXRlRmlsdGVycy5sZW5ndGg7IGFpIDwgYWw7IGFpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhdHRyaWJ1dGVGaWx0ZXJzW2FpXTtcbiAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGZpbHRlci5uYW1lO1xuICAgICAgICAgIGlmIChhdHRyTmFtZSBpbiBub2RlLmF0dHJpYnV0ZXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXMuYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgbWF0Y2gubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoZXMuYXR0cmlidXRlc1thdHRyTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRNYXRjaGluZ05vZGVzID0gKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0ge1xuICAgICAgICBub2Rlczoge30sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9XG4gICAgICB9O1xuICAgICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICB0cmF2ZXJzZShub2RlLCBjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgIG1hdGNoTm9kZSQxKG5vZGVGaWx0ZXJzLCBhdHRyaWJ1dGVGaWx0ZXJzLCBjaGlsZE5vZGUsIG1hdGNoZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH07XG4gICAgY29uc3QgcnVuRmlsdGVycyA9IChtYXRjaGVzLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBydW4gPSAobWF0Y2hSZWNvcmQsIGZpbHRlcmluZ0F0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgZWFjaCRkKG1hdGNoUmVjb3JkLCBtYXRjaCA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBmcm9tKG1hdGNoLm5vZGVzKTtcbiAgICAgICAgICBlYWNoJGUobWF0Y2guZmlsdGVyLmNhbGxiYWNrcywgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVNYXRjaGVzID0gZmlsdGVyaW5nQXR0cmlidXRlcyA/IG5vZGUuYXR0cihtYXRjaC5maWx0ZXIubmFtZSkgIT09IHVuZGVmaW5lZCA6IG5vZGUubmFtZSA9PT0gbWF0Y2guZmlsdGVyLm5hbWU7XG4gICAgICAgICAgICAgIGlmICghdmFsdWVNYXRjaGVzIHx8IGlzTnVsbGFibGUobm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhub2RlcywgbWF0Y2guZmlsdGVyLm5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBydW4obWF0Y2hlcy5ub2RlcywgZmFsc2UpO1xuICAgICAgcnVuKG1hdGNoZXMuYXR0cmlidXRlcywgdHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXIkMiA9IChub2RlRmlsdGVycywgYXR0cmlidXRlRmlsdGVycywgbm9kZSwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZmluZE1hdGNoaW5nTm9kZXMobm9kZUZpbHRlcnMsIGF0dHJpYnV0ZUZpbHRlcnMsIG5vZGUpO1xuICAgICAgcnVuRmlsdGVycyhtYXRjaGVzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFkZEVtcHR5Tm9kZSA9IChzZXR0aW5ncywgYXJncywgaXNCbG9jaywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgYnJQcmVmZXJyZWQgPSBzZXR0aW5ncy5wYWRfZW1wdHlfd2l0aF9iciB8fCBhcmdzLmluc2VydDtcbiAgICAgIGlmIChiclByZWZlcnJlZCAmJiBpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGUgPSBuZXcgQXN0Tm9kZSgnYnInLCAxKTtcbiAgICAgICAgaWYgKGFyZ3MuaW5zZXJ0KSB7XG4gICAgICAgICAgYXN0Tm9kZS5hdHRyKCdkYXRhLW1jZS1ib2d1cycsICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5lbXB0eSgpLmFwcGVuZChhc3ROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZW1wdHkoKS5hcHBlbmQobmV3IEFzdE5vZGUoJyN0ZXh0JywgMykpLnZhbHVlID0gbmJzcDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzUGFkZGVkV2l0aE5ic3AgPSBub2RlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBoYXNPbmx5Q2hpbGQobm9kZSwgJyN0ZXh0JykgJiYgKChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpID09PSBuYnNwO1xuICAgIH07XG4gICAgY29uc3QgaGFzT25seUNoaWxkID0gKG5vZGUsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKGZpcnN0Q2hpbGQpICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubmFtZSA9PT0gbmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUGFkZGVkID0gKHNjaGVtYSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShub2RlLm5hbWUpO1xuICAgICAgcmV0dXJuIChydWxlID09PSBudWxsIHx8IHJ1bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJ1bGUucGFkZEVtcHR5KSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIG5vZGUpID0+IG5vZGUuaXNFbXB0eShub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIG5vZGUgPT4gaXNQYWRkZWQoc2NoZW1hLCBub2RlKSk7XG4gICAgY29uc3QgaXNMaW5lQnJlYWtOb2RlID0gKG5vZGUsIGlzQmxvY2spID0+IGlzTm9uTnVsbGFibGUobm9kZSkgJiYgKGlzQmxvY2sobm9kZSkgfHwgbm9kZS5uYW1lID09PSAnYnInKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdEVkaXRpbmdIb3N0ID0gc2NvcGUgPT4ge1xuICAgICAgbGV0IGVkaXRhYmxlTm9kZTtcbiAgICAgIGZvciAobGV0IG5vZGUgPSBzY29wZTsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZSA9IG5vZGUuYXR0cignY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgIGlmIChjb250ZW50RWRpdGFibGUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGVkaXRhYmxlTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVkaXRhYmxlTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZU9yVW53cmFwSW52YWxpZE5vZGUgPSAobm9kZSwgc2NoZW1hLCBvcmlnaW5hbE5vZGVQYXJlbnQgPSBub2RlLnBhcmVudCkgPT4ge1xuICAgICAgaWYgKHNjaGVtYS5nZXRTcGVjaWFsRWxlbWVudHMoKVtub2RlLm5hbWVdKSB7XG4gICAgICAgIG5vZGUuZW1wdHkoKS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmIChvcmlnaW5hbE5vZGVQYXJlbnQgJiYgIXNjaGVtYS5pc1ZhbGlkQ2hpbGQob3JpZ2luYWxOb2RlUGFyZW50Lm5hbWUsIGNoaWxkTm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgcmVtb3ZlT3JVbndyYXBJbnZhbGlkTm9kZShjaGlsZE5vZGUsIHNjaGVtYSwgb3JpZ2luYWxOb2RlUGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS51bndyYXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsZWFuSW52YWxpZE5vZGVzID0gKG5vZGVzLCBzY2hlbWEsIHJvb3ROb2RlLCBvbkNyZWF0ZSA9IG5vb3ApID0+IHtcbiAgICAgIGNvbnN0IHRleHRCbG9ja0VsZW1lbnRzID0gc2NoZW1hLmdldFRleHRCbG9ja0VsZW1lbnRzKCk7XG4gICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbGVtZW50cyA9IHNjaGVtYS5nZXRXaGl0ZXNwYWNlRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IG5vblNwbGl0dGFibGVFbGVtZW50cyA9IFRvb2xzLm1ha2VNYXAoJ3RyLHRkLHRoLHRib2R5LHRoZWFkLHRmb290LHRhYmxlLHN1bW1hcnknKTtcbiAgICAgIGNvbnN0IGZpeGVkID0gbmV3IFNldCgpO1xuICAgICAgY29uc3QgaXNTcGxpdHRhYmxlRWxlbWVudCA9IG5vZGUgPT4gbm9kZSAhPT0gcm9vdE5vZGUgJiYgIW5vblNwbGl0dGFibGVFbGVtZW50c1tub2RlLm5hbWVdO1xuICAgICAgZm9yIChsZXQgbmkgPSAwOyBuaSA8IG5vZGVzLmxlbmd0aDsgbmkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbbmldO1xuICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICBsZXQgbmV3UGFyZW50O1xuICAgICAgICBsZXQgdGVtcE5vZGU7XG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQgfHwgZml4ZWQuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRCbG9ja0VsZW1lbnRzW25vZGUubmFtZV0gJiYgbm9kZS5wYXJlbnQubmFtZSA9PT0gJ2xpJykge1xuICAgICAgICAgIGxldCBzaWJsaW5nID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHdoaWxlIChzaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAodGV4dEJsb2NrRWxlbWVudHNbc2libGluZy5uYW1lXSkge1xuICAgICAgICAgICAgICBzaWJsaW5nLm5hbWUgPSAnbGknO1xuICAgICAgICAgICAgICBmaXhlZC5hZGQoc2libGluZyk7XG4gICAgICAgICAgICAgIG5vZGUucGFyZW50Lmluc2VydChzaWJsaW5nLCBub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtub2RlXTtcbiAgICAgICAgZm9yIChwYXJlbnQgPSBub2RlLnBhcmVudDsgcGFyZW50ICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudC5uYW1lLCBub2RlLm5hbWUpICYmIGlzU3BsaXR0YWJsZUVsZW1lbnQocGFyZW50KTsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYS5pc1ZhbGlkQ2hpbGQocGFyZW50Lm5hbWUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIHBhcmVudHMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbmV3UGFyZW50ID0gcGFyZW50c1swXS5jbG9uZSgpO1xuICAgICAgICAgICAgb25DcmVhdGUobmV3UGFyZW50KTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHNjaGVtYS5pc1ZhbGlkQ2hpbGQoY3VycmVudE5vZGUubmFtZSwgcGFyZW50c1tpXS5uYW1lKSAmJiBpID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXBOb2RlID0gcGFyZW50c1tpXS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9uQ3JlYXRlKHRlbXBOb2RlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hcHBlbmQodGVtcE5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBOb2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlID0gcGFyZW50c1tpXS5maXJzdENoaWxkOyBjaGlsZE5vZGUgJiYgY2hpbGROb2RlICE9PSBwYXJlbnRzW2kgKyAxXTspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IGNoaWxkTm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIHRlbXBOb2RlLmFwcGVuZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGVtcE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkoc2NoZW1hLCBub25FbXB0eUVsZW1lbnRzLCB3aGl0ZXNwYWNlRWxlbWVudHMsIG5ld1BhcmVudCkpIHtcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydChuZXdQYXJlbnQsIHBhcmVudHNbMF0sIHRydWUpO1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KG5vZGUsIG5ld1BhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KG5vZGUsIHBhcmVudHNbMF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50c1swXTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHNjaGVtYSwgbm9uRW1wdHlFbGVtZW50cywgd2hpdGVzcGFjZUVsZW1lbnRzLCBwYXJlbnQpIHx8IGhhc09ubHlDaGlsZChwYXJlbnQsICdicicpKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5lbXB0eSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVPclVud3JhcEludmFsaWROb2RlKG5vZGUsIHNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ2xpJykge1xuICAgICAgICAgICAgbGV0IHNpYmxpbmcgPSBub2RlLnByZXY7XG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiAoc2libGluZy5uYW1lID09PSAndWwnIHx8IHNpYmxpbmcubmFtZSA9PT0gJ29sJykpIHtcbiAgICAgICAgICAgICAgc2libGluZy5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZyA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIChzaWJsaW5nLm5hbWUgPT09ICd1bCcgfHwgc2libGluZy5uYW1lID09PSAnb2wnKSAmJiBzaWJsaW5nLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgc2libGluZy5pbnNlcnQobm9kZSwgc2libGluZy5maXJzdENoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gbmV3IEFzdE5vZGUoJ3VsJywgMSk7XG4gICAgICAgICAgICBvbkNyZWF0ZSh3cmFwcGVyKTtcbiAgICAgICAgICAgIG5vZGUud3JhcCh3cmFwcGVyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2NoZW1hLmlzVmFsaWRDaGlsZChub2RlLnBhcmVudC5uYW1lLCAnZGl2JykgJiYgc2NoZW1hLmlzVmFsaWRDaGlsZCgnZGl2Jywgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBBc3ROb2RlKCdkaXYnLCAxKTtcbiAgICAgICAgICAgIG9uQ3JlYXRlKHdyYXBwZXIpO1xuICAgICAgICAgICAgbm9kZS53cmFwKHdyYXBwZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVPclVud3JhcEludmFsaWROb2RlKG5vZGUsIHNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNDbG9zZXN0ID0gKG5vZGUsIHBhcmVudE5hbWUpID0+IHtcbiAgICAgIGxldCB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAodGVtcE5vZGUpIHtcbiAgICAgICAgaWYgKHRlbXBOb2RlLm5hbWUgPT09IHBhcmVudE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSW52YWxpZCA9IChzY2hlbWEsIG5vZGUsIHBhcmVudCA9IG5vZGUucGFyZW50KSA9PiB7XG4gICAgICBpZiAocGFyZW50ICYmIHNjaGVtYS5jaGlsZHJlbltub2RlLm5hbWVdICYmICFzY2hlbWEuaXNWYWxpZENoaWxkKHBhcmVudC5uYW1lLCBub2RlLm5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgbm9kZS5uYW1lID09PSAnYScgJiYgaGFzQ2xvc2VzdChwYXJlbnQsICdhJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZVJhbmdlID0gKHNjLCBzbywgZWMsIGVvKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0KHNjLCBzbyk7XG4gICAgICBybmcuc2V0RW5kKGVjLCBlbyk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplQmxvY2tTZWxlY3Rpb25SYW5nZSA9IHJuZyA9PiB7XG4gICAgICBjb25zdCBzdGFydFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZyk7XG4gICAgICBjb25zdCByb290Tm9kZSA9IHJuZy5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBmcm9tUG9zaXRpb24oZmFsc2UsIHJvb3ROb2RlLCBlbmRQb3MpLm1hcChuZXdFbmRQb3MgPT4ge1xuICAgICAgICBpZiAoIWlzSW5TYW1lQmxvY2soc3RhcnRQb3MsIGVuZFBvcywgcm9vdE5vZGUpICYmIGlzSW5TYW1lQmxvY2soc3RhcnRQb3MsIG5ld0VuZFBvcywgcm9vdE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJhbmdlKHN0YXJ0UG9zLmNvbnRhaW5lcigpLCBzdGFydFBvcy5vZmZzZXQoKSwgbmV3RW5kUG9zLmNvbnRhaW5lcigpLCBuZXdFbmRQb3Mub2Zmc2V0KCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBybmc7XG4gICAgICAgIH1cbiAgICAgIH0pLmdldE9yKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemUgPSBybmcgPT4gcm5nLmNvbGxhcHNlZCA/IHJuZyA6IG5vcm1hbGl6ZUJsb2NrU2VsZWN0aW9uUmFuZ2Uocm5nKTtcblxuICAgIGNvbnN0IGhhc09ubHlPbmVDaGlsZCQxID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlLmZpcnN0Q2hpbGQpICYmIG5vZGUuZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRpbmdOb2RlID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gbm9kZS5uYW1lID09PSAnYnInIHx8IG5vZGUudmFsdWUgPT09IG5ic3A7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhZGRlZEVtcHR5QmxvY2sgPSAoc2NoZW1hLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBibG9ja0VsZW1lbnRzID0gc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBibG9ja0VsZW1lbnRzW25vZGUubmFtZV0gJiYgaGFzT25seU9uZUNoaWxkJDEobm9kZSkgJiYgaXNQYWRkaW5nTm9kZShub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH07XG4gICAgY29uc3QgaXNFbXB0eUZyYWdtZW50RWxlbWVudCA9IChzY2hlbWEsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUobm9kZSkgJiYgKG5vZGUuaXNFbXB0eShub25FbXB0eUVsZW1lbnRzKSB8fCBpc1BhZGRlZEVtcHR5QmxvY2soc2NoZW1hLCBub2RlKSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RGcmFnbWVudCA9IChzY2hlbWEsIGZyYWdtZW50KSA9PiB7XG4gICAgICBsZXQgZmlyc3RDaGlsZCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBsZXQgbGFzdENoaWxkID0gZnJhZ21lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5uYW1lID09PSAnbWV0YScpIHtcbiAgICAgICAgZmlyc3RDaGlsZCA9IGZpcnN0Q2hpbGQubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmF0dHIoJ2lkJykgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICBsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQucHJldjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VtcHR5RnJhZ21lbnRFbGVtZW50KHNjaGVtYSwgbGFzdENoaWxkKSkge1xuICAgICAgICBsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQgPT09IG51bGwgfHwgbGFzdENoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0Q2hpbGQucHJldjtcbiAgICAgIH1cbiAgICAgIGlmICghZmlyc3RDaGlsZCB8fCBmaXJzdENoaWxkICE9PSBsYXN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQubmFtZSA9PT0gJ3VsJyB8fCBmaXJzdENoaWxkLm5hbWUgPT09ICdvbCc7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbnVwRG9tRnJhZ21lbnQgPSBkb21GcmFnbWVudCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGRvbUZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBkb21GcmFnbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnTUVUQScpIHtcbiAgICAgICAgKF9hID0gZmlyc3RDaGlsZC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5pZCA9PT0gJ21jZV9tYXJrZXInKSB7XG4gICAgICAgIChfYiA9IGxhc3RDaGlsZC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb21GcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHRvRG9tRnJhZ21lbnQgPSAoZG9tLCBzZXJpYWxpemVyLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgaHRtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKGZyYWdtZW50KTtcbiAgICAgIGNvbnN0IGRvbUZyYWdtZW50ID0gZG9tLmNyZWF0ZUZyYWdtZW50KGh0bWwpO1xuICAgICAgcmV0dXJuIGNsZWFudXBEb21GcmFnbWVudChkb21GcmFnbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSBlbG0gPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIGZpbHRlciQ1KChfYSA9IGVsbSA9PT0gbnVsbCB8fCBlbG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsbS5jaGlsZE5vZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgY2hpbGQgPT4ge1xuICAgICAgICByZXR1cm4gY2hpbGQubm9kZU5hbWUgPT09ICdMSSc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUGFkZGluZyA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUuZGF0YSA9PT0gbmJzcCB8fCBpc0JyJDYobm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RJdGVtUGFkZGVkID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuZmlyc3RDaGlsZCkgJiYgbm9kZS5maXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBpc1BhZGRpbmcobm9kZS5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzRW1wdHlPclBhZGRlZCA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gIWVsbS5maXJzdENoaWxkIHx8IGlzTGlzdEl0ZW1QYWRkZWQoZWxtKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1MaXN0SXRlbXMgPSBlbG1zID0+IHtcbiAgICAgIHJldHVybiBlbG1zLmxlbmd0aCA+IDAgJiYgaXNFbXB0eU9yUGFkZGVkKGVsbXNbZWxtcy5sZW5ndGggLSAxXSkgPyBlbG1zLnNsaWNlKDAsIC0xKSA6IGVsbXM7XG4gICAgfTtcbiAgICBjb25zdCBnZXRQYXJlbnRMaSA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChub2RlLCBkb20uaXNCbG9jayk7XG4gICAgICByZXR1cm4gcGFyZW50QmxvY2sgJiYgcGFyZW50QmxvY2subm9kZU5hbWUgPT09ICdMSScgPyBwYXJlbnRCbG9jayA6IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpc1BhcmVudEJsb2NrTGkgPSAoZG9tLCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gISFnZXRQYXJlbnRMaShkb20sIG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U3BsaXQgPSAocGFyZW50Tm9kZSwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBiZWZvcmVSbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgY29uc3QgYWZ0ZXJSbmcgPSBybmcuY2xvbmVSYW5nZSgpO1xuICAgICAgYmVmb3JlUm5nLnNldFN0YXJ0QmVmb3JlKHBhcmVudE5vZGUpO1xuICAgICAgYWZ0ZXJSbmcuc2V0RW5kQWZ0ZXIocGFyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiZWZvcmVSbmcuY2xvbmVDb250ZW50cygpLFxuICAgICAgICBhZnRlclJuZy5jbG9uZUNvbnRlbnRzKClcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb25zdCBmaW5kRmlyc3RJbiA9IChub2RlLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRQb3MgPSBDYXJldFBvc2l0aW9uLmJlZm9yZShub2RlKTtcbiAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIocm9vdE5vZGUpO1xuICAgICAgY29uc3QgbmV3Q2FyZXRQb3MgPSBjYXJldFdhbGtlci5uZXh0KGNhcmV0UG9zKTtcbiAgICAgIHJldHVybiBuZXdDYXJldFBvcyA/IG5ld0NhcmV0UG9zLnRvUmFuZ2UoKSA6IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTGFzdE9mID0gKG5vZGUsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBjb25zdCBjYXJldFBvcyA9IENhcmV0UG9zaXRpb24uYWZ0ZXIobm9kZSk7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IG5ld0NhcmV0UG9zID0gY2FyZXRXYWxrZXIucHJldihjYXJldFBvcyk7XG4gICAgICByZXR1cm4gbmV3Q2FyZXRQb3MgPyBuZXdDYXJldFBvcy50b1JhbmdlKCkgOiBudWxsO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0TWlkZGxlID0gKHRhcmdldCwgZWxtcywgcm9vdE5vZGUsIHJuZykgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBnZXRTcGxpdCh0YXJnZXQsIHJuZyk7XG4gICAgICBjb25zdCBwYXJlbnRFbG0gPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnRFbG0pIHtcbiAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShwYXJ0c1swXSwgdGFyZ2V0KTtcbiAgICAgICAgVG9vbHMuZWFjaChlbG1zLCBsaSA9PiB7XG4gICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShsaSwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUocGFydHNbMV0sIHRhcmdldCk7XG4gICAgICAgIHBhcmVudEVsbS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRMYXN0T2YoZWxtc1tlbG1zLmxlbmd0aCAtIDFdLCByb290Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmUkMiA9ICh0YXJnZXQsIGVsbXMsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRFbG0gPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnRFbG0pIHtcbiAgICAgICAgVG9vbHMuZWFjaChlbG1zLCBlbG0gPT4ge1xuICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUoZWxtLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kRmlyc3RJbih0YXJnZXQsIHJvb3ROb2RlKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEFmdGVyJDIgPSAodGFyZ2V0LCBlbG1zLCByb290Tm9kZSwgZG9tKSA9PiB7XG4gICAgICBkb20uaW5zZXJ0QWZ0ZXIoZWxtcy5yZXZlcnNlKCksIHRhcmdldCk7XG4gICAgICByZXR1cm4gZmluZExhc3RPZihlbG1zWzBdLCByb290Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBdENhcmV0JDEgPSAoc2VyaWFsaXplciwgZG9tLCBybmcsIGZyYWdtZW50KSA9PiB7XG4gICAgICBjb25zdCBkb21GcmFnbWVudCA9IHRvRG9tRnJhZ21lbnQoZG9tLCBzZXJpYWxpemVyLCBmcmFnbWVudCk7XG4gICAgICBjb25zdCBsaVRhcmdldCA9IGdldFBhcmVudExpKGRvbSwgcm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGxpRWxtcyA9IHRyaW1MaXN0SXRlbXMobGlzdEl0ZW1zKGRvbUZyYWdtZW50LmZpcnN0Q2hpbGQpKTtcbiAgICAgIGNvbnN0IEJFR0lOTklORyA9IDEsIEVORCA9IDI7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGRvbS5nZXRSb290KCk7XG4gICAgICBjb25zdCBpc0F0ID0gbG9jYXRpb24gPT4ge1xuICAgICAgICBjb25zdCBjYXJldFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihkb20uZ2V0Um9vdCgpKTtcbiAgICAgICAgY29uc3QgbmV3UG9zID0gbG9jYXRpb24gPT09IEJFR0lOTklORyA/IGNhcmV0V2Fsa2VyLnByZXYoY2FyZXRQb3MpIDogY2FyZXRXYWxrZXIubmV4dChjYXJldFBvcyk7XG4gICAgICAgIGNvbnN0IG5ld1Bvc05vZGUgPSBuZXdQb3MgPT09IG51bGwgfHwgbmV3UG9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdQb3MuZ2V0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gbmV3UG9zTm9kZSA/IGdldFBhcmVudExpKGRvbSwgbmV3UG9zTm9kZSkgIT09IGxpVGFyZ2V0IDogdHJ1ZTtcbiAgICAgIH07XG4gICAgICBpZiAoIWxpVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChpc0F0KEJFR0lOTklORykpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydEJlZm9yZSQyKGxpVGFyZ2V0LCBsaUVsbXMsIHJvb3ROb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdChFTkQpKSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRBZnRlciQyKGxpVGFyZ2V0LCBsaUVsbXMsIHJvb3ROb2RlLCBkb20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluc2VydE1pZGRsZShsaVRhcmdldCwgbGlFbG1zLCByb290Tm9kZSwgcm5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbWVyZ2VhYmxlV3JhcHBlZEVsZW1lbnRzID0gWydwcmUnXTtcbiAgICBjb25zdCBzaG91bGRQYXN0ZUNvbnRlbnRPbmx5ID0gKGRvbSwgZnJhZ21lbnQsIHBhcmVudE5vZGUsIHJvb3QpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBjb25zdCBsYXN0Tm9kZSA9IGZyYWdtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGNvbnN0IGxhc3QgPSBsYXN0Tm9kZS5hdHRyKCdkYXRhLW1jZS10eXBlJykgPT09ICdib29rbWFyaycgPyBsYXN0Tm9kZS5wcmV2IDogbGFzdE5vZGU7XG4gICAgICBjb25zdCBpc1Bhc3RpbmdTaW5nbGVFbGVtZW50ID0gZmlyc3ROb2RlID09PSBsYXN0O1xuICAgICAgY29uc3QgaXNXcmFwcGVkRWxlbWVudCA9IGNvbnRhaW5zJDIobWVyZ2VhYmxlV3JhcHBlZEVsZW1lbnRzLCBmaXJzdE5vZGUubmFtZSk7XG4gICAgICBpZiAoaXNQYXN0aW5nU2luZ2xlRWxlbWVudCAmJiBpc1dyYXBwZWRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlID0gZmlyc3ROb2RlLmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScpICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBpc1Bhc3RpbmdJblRoZVNhbWVCbG9ja1RhZyA9ICgoX2EgPSBkb20uZ2V0UGFyZW50KHBhcmVudE5vZGUsIGRvbS5pc0Jsb2NrKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSBmaXJzdE5vZGUubmFtZTtcbiAgICAgICAgY29uc3QgaXNQYXN0aW5nSW5Db250ZW50RWRpdGFibGUgPSBPcHRpb25hbC5mcm9tKGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShyb290LCBwYXJlbnROb2RlKSkuZm9yYWxsKGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKTtcbiAgICAgICAgcmV0dXJuIGlzQ29udGVudEVkaXRhYmxlICYmIGlzUGFzdGluZ0luVGhlU2FtZUJsb2NrVGFnICYmIGlzUGFzdGluZ0luQ29udGVudEVkaXRhYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNUYWJsZUNlbGwgPSBpc1RhYmxlQ2VsbCQzO1xuICAgIGNvbnN0IGlzVGFibGVDZWxsQ29udGVudFNlbGVjdGVkID0gKGRvbSwgcm5nLCBjZWxsKSA9PiB7XG4gICAgICBpZiAoaXNOb25OdWxsYWJsZShjZWxsKSkge1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gZG9tLmdldFBhcmVudChybmcuZW5kQ29udGFpbmVyLCBpc1RhYmxlQ2VsbCk7XG4gICAgICAgIHJldHVybiBjZWxsID09PSBlbmRDZWxsICYmIGhhc0FsbENvbnRlbnRzU2VsZWN0ZWQoU3VnYXJFbGVtZW50LmZyb21Eb20oY2VsbCksIHJuZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB2YWxpZEluc2VydGlvbiA9IChlZGl0b3IsIHZhbHVlLCBwYXJlbnROb2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAocGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykgPT09ICdhbGwnKSB7XG4gICAgICAgIChfYSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc2VydEJlZm9yZShlZGl0b3IuZG9tLmNyZWF0ZUZyYWdtZW50KHZhbHVlKSwgcGFyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gcGFyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICBjb25zdCBub2RlMiA9IHBhcmVudE5vZGUubGFzdENoaWxkO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gbm9kZTIgJiYgbm9kZS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgIGVkaXRvci5kb20uc2V0SFRNTChwYXJlbnROb2RlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDb250ZW50KHZhbHVlLCB7IG5vX2V2ZW50czogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdHJpbUJyc0Zyb21UYWJsZUNlbGwgPSAoZG9tLCBlbG0pID0+IHtcbiAgICAgIE9wdGlvbmFsLmZyb20oZG9tLmdldFBhcmVudChlbG0sICd0ZCx0aCcpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pLmVhY2godHJpbUJsb2NrVHJhaWxpbmdCcik7XG4gICAgfTtcbiAgICBjb25zdCByZWR1Y2VJbmxpbmVUZXh0RWxlbWVudHMgPSAoZWRpdG9yLCBtZXJnZSkgPT4ge1xuICAgICAgY29uc3QgdGV4dElubGluZUVsZW1lbnRzID0gZWRpdG9yLnNjaGVtYS5nZXRUZXh0SW5saW5lRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRVdGlscyA9IEVsZW1lbnRVdGlscyhlZGl0b3IpO1xuICAgICAgICBUb29scy5lYWNoKGRvbS5zZWxlY3QoJypbZGF0YS1tY2UtZnJhZ21lbnRdJyksIG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzSW5saW5lID0gaXNOb25OdWxsYWJsZSh0ZXh0SW5saW5lRWxlbWVudHNbbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgaWYgKGlzSW5saW5lICYmIGhhc0luaGVyaXRhYmxlU3R5bGVzKGRvbSwgbm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7IGlzTm9uTnVsbGFibGUocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZSAhPT0gcm9vdDsgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZUNvbmZsaWN0ID0gaGFzU3R5bGVDb25mbGljdChkb20sIG5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICBpZiAoc3R5bGVDb25mbGljdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50VXRpbHMuY29tcGFyZShwYXJlbnROb2RlLCBub2RlKSkge1xuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWFya0ZyYWdtZW50RWxlbWVudHMgPSBmcmFnbWVudCA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGZyYWdtZW50O1xuICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLndhbGsoKSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5hdHRyKCdkYXRhLW1jZS1mcmFnbWVudCcsICcxJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVubWFya0ZyYWdtZW50RWxlbWVudHMgPSBlbG0gPT4ge1xuICAgICAgVG9vbHMuZWFjaChlbG0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSwgZWxtID0+IHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2UtZnJhZ21lbnQnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNQYXJ0T2ZGcmFnbWVudCA9IG5vZGUgPT4ge1xuICAgICAgcmV0dXJuICEhbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLWZyYWdtZW50Jyk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5IYXZlQ2hpbGRyZW4gPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShub2RlKSAmJiAhZWRpdG9yLnNjaGVtYS5nZXRWb2lkRWxlbWVudHMoKVtub2RlLm5vZGVOYW1lXTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVTZWxlY3Rpb25Ub01hcmtlciA9IChlZGl0b3IsIG1hcmtlcikgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBsZXQgbmV4dFJuZztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKCFtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KG1hcmtlcik7XG4gICAgICBjb25zdCBwYXJlbnRFZGl0YWJsZUVsbSA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QkMShlZGl0b3IuZ2V0Qm9keSgpLCBtYXJrZXIpO1xuICAgICAgaWYgKHBhcmVudEVkaXRhYmxlRWxtICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUocGFyZW50RWRpdGFibGVFbG0pID09PSAnZmFsc2UnKSB7XG4gICAgICAgIGRvbS5yZW1vdmUobWFya2VyKTtcbiAgICAgICAgc2VsZWN0aW9uLnNlbGVjdChwYXJlbnRFZGl0YWJsZUVsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBjb25zdCBub2RlID0gbWFya2VyLnByZXZpb3VzU2libGluZztcbiAgICAgIGlmIChpc1RleHQkYShub2RlKSkge1xuICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgKF9iID0gKF9hID0gbm9kZS5ub2RlVmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICBjb25zdCBub2RlMiA9IG1hcmtlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUyKSkge1xuICAgICAgICAgIG5vZGUuYXBwZW5kRGF0YShub2RlMi5kYXRhKTtcbiAgICAgICAgICAoX2MgPSBub2RlMi5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVtb3ZlQ2hpbGQobm9kZTIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUobWFya2VyKTtcbiAgICAgICAgcm5nLnNldEVuZEJlZm9yZShtYXJrZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmluZE5leHRDYXJldFJuZyA9IHJuZyA9PiB7XG4gICAgICAgIGxldCBjYXJldFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgICAgY2FyZXRQb3MgPSBjYXJldFdhbGtlci5uZXh0KGNhcmV0UG9zKTtcbiAgICAgICAgcmV0dXJuIGNhcmV0UG9zID09PSBudWxsIHx8IGNhcmV0UG9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXJldFBvcy50b1JhbmdlKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcGFyZW50QmxvY2sgPSBkb20uZ2V0UGFyZW50KG1hcmtlciwgZG9tLmlzQmxvY2spO1xuICAgICAgZG9tLnJlbW92ZShtYXJrZXIpO1xuICAgICAgaWYgKHBhcmVudEJsb2NrICYmIGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICBjb25zdCBpc0NlbGwgPSBpc1RhYmxlQ2VsbChwYXJlbnRCbG9jayk7XG4gICAgICAgIGVtcHR5KFN1Z2FyRWxlbWVudC5mcm9tRG9tKHBhcmVudEJsb2NrKSk7XG4gICAgICAgIHJuZy5zZXRTdGFydChwYXJlbnRCbG9jaywgMCk7XG4gICAgICAgIHJuZy5zZXRFbmQocGFyZW50QmxvY2ssIDApO1xuICAgICAgICBpZiAoIWlzQ2VsbCAmJiAhaXNQYXJ0T2ZGcmFnbWVudChwYXJlbnRCbG9jaykgJiYgKG5leHRSbmcgPSBmaW5kTmV4dENhcmV0Um5nKHJuZykpKSB7XG4gICAgICAgICAgcm5nID0gbmV4dFJuZztcbiAgICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uYWRkKHBhcmVudEJsb2NrLCBkb20uY3JlYXRlKCdicicsIGlzQ2VsbCA/IHt9IDogeyAnZGF0YS1tY2UtYm9ndXMnOiAnMScgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVTZWxlY3RlZENvbnRlbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IG5vcm1hbGl6ZShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBjb25zdCBzdGFydENlbGwgPSBkb20uZ2V0UGFyZW50KHJuZy5zdGFydENvbnRhaW5lciwgaXNUYWJsZUNlbGwpO1xuICAgICAgaWYgKGlzVGFibGVDZWxsQ29udGVudFNlbGVjdGVkKGRvbSwgcm5nLCBzdGFydENlbGwpKSB7XG4gICAgICAgIGRlbGV0ZUNlbGxDb250ZW50cyhlZGl0b3IsIHJuZywgU3VnYXJFbGVtZW50LmZyb21Eb20oc3RhcnRDZWxsKSk7XG4gICAgICB9IGVsc2UgaWYgKHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lciAmJiBybmcuZW5kT2Zmc2V0IC0gcm5nLnN0YXJ0T2Zmc2V0ID09PSAxICYmIGlzVGV4dCRhKHJuZy5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW3JuZy5zdGFydE9mZnNldF0pKSB7XG4gICAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKCdEZWxldGUnLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmaW5kTWFya2VyTm9kZSA9IHNjb3BlID0+IHtcbiAgICAgIGZvciAobGV0IG1hcmtlck5vZGUgPSBzY29wZTsgbWFya2VyTm9kZTsgbWFya2VyTm9kZSA9IG1hcmtlck5vZGUud2FsaygpKSB7XG4gICAgICAgIGlmIChtYXJrZXJOb2RlLmF0dHIoJ2lkJykgPT09ICdtY2VfbWFya2VyJykge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG1hcmtlck5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0SHRtbEF0Q2FyZXQgPSAoZWRpdG9yLCB2YWx1ZSwgZGV0YWlscykgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgcGFyc2VyID0gZWRpdG9yLnBhcnNlcjtcbiAgICAgIGNvbnN0IG1lcmdlID0gZGV0YWlscy5tZXJnZTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiB0cnVlIH0sIGVkaXRvci5zY2hlbWEpO1xuICAgICAgY29uc3QgYm9va21hcmtIdG1sID0gJzxzcGFuIGlkPVwibWNlX21hcmtlclwiIGRhdGEtbWNlLXR5cGU9XCJib29rbWFya1wiPiYjeEZFRkY7PC9zcGFuPic7XG4gICAgICBpZiAodmFsdWUuaW5kZXhPZigneyRjYXJldH0nKSA9PT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gJ3skY2FyZXR9JztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFx7XFwkY2FyZXRcXH0vLCBib29rbWFya0h0bWwpO1xuICAgICAgbGV0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNhcmV0RWxlbWVudCA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgaWYgKGNhcmV0RWxlbWVudCA9PT0gYm9keSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBpZiAoZG9tLmlzQmxvY2soYm9keS5maXJzdENoaWxkKSAmJiBjYW5IYXZlQ2hpbGRyZW4oZWRpdG9yLCBib2R5LmZpcnN0Q2hpbGQpICYmIGRvbS5pc0VtcHR5KGJvZHkuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGJvZHkuZmlyc3RDaGlsZCwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChib2R5LmZpcnN0Q2hpbGQsIDApO1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBkZWxldGVTZWxlY3RlZENvbnRlbnQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgcGFyc2VyQXJncyA9IHtcbiAgICAgICAgY29udGV4dDogcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBkYXRhOiBkZXRhaWxzLmRhdGEsXG4gICAgICAgIGluc2VydDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VyLnBhcnNlKHZhbHVlLCBwYXJzZXJBcmdzKTtcbiAgICAgIGlmIChkZXRhaWxzLnBhc3RlID09PSB0cnVlICYmIGlzTGlzdEZyYWdtZW50KGVkaXRvci5zY2hlbWEsIGZyYWdtZW50KSAmJiBpc1BhcmVudEJsb2NrTGkoZG9tLCBwYXJlbnROb2RlKSkge1xuICAgICAgICBybmcgPSBpbnNlcnRBdENhcmV0JDEoc2VyaWFsaXplciwgZG9tLCBzZWxlY3Rpb24uZ2V0Um5nKCksIGZyYWdtZW50KTtcbiAgICAgICAgaWYgKHJuZykge1xuICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGV0YWlscy5wYXN0ZSA9PT0gdHJ1ZSAmJiBzaG91bGRQYXN0ZUNvbnRlbnRPbmx5KGRvbSwgZnJhZ21lbnQsIHBhcmVudE5vZGUsIGVkaXRvci5nZXRCb2R5KCkpKSB7XG4gICAgICAgIChfYSA9IGZyYWdtZW50LmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bndyYXAoKTtcbiAgICAgIH1cbiAgICAgIG1hcmtGcmFnbWVudEVsZW1lbnRzKGZyYWdtZW50KTtcbiAgICAgIGxldCBub2RlID0gZnJhZ21lbnQubGFzdENoaWxkO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5hdHRyKCdpZCcpID09PSAnbWNlX21hcmtlcicpIHtcbiAgICAgICAgY29uc3QgbWFya2VyID0gbm9kZTtcbiAgICAgICAgZm9yIChub2RlID0gbm9kZS5wcmV2OyBub2RlOyBub2RlID0gbm9kZS53YWxrKHRydWUpKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMyB8fCAhZG9tLmlzQmxvY2sobm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIGVkaXRvci5zY2hlbWEuaXNWYWxpZENoaWxkKG5vZGUucGFyZW50Lm5hbWUsICdzcGFuJykpIHtcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuaW5zZXJ0KG1hcmtlciwgbm9kZSwgbm9kZS5uYW1lID09PSAnYnInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuc2hvd0Jsb2NrQ2FyZXRDb250YWluZXIocGFyZW50Tm9kZSk7XG4gICAgICBpZiAoIXBhcnNlckFyZ3MuaW52YWxpZCkge1xuICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKGZyYWdtZW50KTtcbiAgICAgICAgdmFsaWRJbnNlcnRpb24oZWRpdG9yLCB2YWx1ZSwgcGFyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldENvbnRlbnQoYm9va21hcmtIdG1sKTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBsZXQgdGVtcE5vZGU7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnQkMShwYXJlbnROb2RlKSkge1xuICAgICAgICAgIHBhcmVudE5vZGUgPSB0ZW1wTm9kZSA9IHJvb3ROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBOb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGVtcE5vZGUgJiYgdGVtcE5vZGUgIT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IHRlbXBOb2RlO1xuICAgICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHBhcmVudE5vZGUgPT09IHJvb3ROb2RlID8gcm9vdE5vZGUuaW5uZXJIVE1MIDogZG9tLmdldE91dGVySFRNTChwYXJlbnROb2RlKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHBhcnNlci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG1hcmtlck5vZGUgPSBmaW5kTWFya2VyTm9kZShyb290KTtcbiAgICAgICAgY29uc3QgZWRpdGluZ0hvc3QgPSBtYXJrZXJOb2RlLmJpbmQoZmluZENsb3Nlc3RFZGl0aW5nSG9zdCkuZ2V0T3Iocm9vdCk7XG4gICAgICAgIG1hcmtlck5vZGUuZWFjaChtYXJrZXIgPT4gbWFya2VyLnJlcGxhY2UoZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgdG9FeHRyYWN0ID0gZnJhZ21lbnQuY2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gKF9iID0gZnJhZ21lbnQucGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiByb290O1xuICAgICAgICBmcmFnbWVudC51bndyYXAoKTtcbiAgICAgICAgY29uc3QgaW52YWxpZENoaWxkcmVuID0gZmlsdGVyJDUodG9FeHRyYWN0LCBub2RlID0+IGlzSW52YWxpZChlZGl0b3Iuc2NoZW1hLCBub2RlLCBwYXJlbnQpKTtcbiAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMoaW52YWxpZENoaWxkcmVuLCBlZGl0b3Iuc2NoZW1hLCBlZGl0aW5nSG9zdCk7XG4gICAgICAgIGZpbHRlciQyKHBhcnNlci5nZXROb2RlRmlsdGVycygpLCBwYXJzZXIuZ2V0QXR0cmlidXRlRmlsdGVycygpLCByb290KTtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShyb290KTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgZG9tLnNldEhUTUwocm9vdE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uc2V0T3V0ZXJIVE1MKHBhcmVudE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVkdWNlSW5saW5lVGV4dEVsZW1lbnRzKGVkaXRvciwgbWVyZ2UpO1xuICAgICAgbW92ZVNlbGVjdGlvblRvTWFya2VyKGVkaXRvciwgZG9tLmdldCgnbWNlX21hcmtlcicpKTtcbiAgICAgIHVubWFya0ZyYWdtZW50RWxlbWVudHMoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICB0cmltQnJzRnJvbVRhYmxlQ2VsbChkb20sIHNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHVwZGF0ZUNhcmV0KGVkaXRvci5zY2hlbWEsIGVkaXRvci5nZXRCb2R5KCksIHNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNUcmVlTm9kZSA9IGNvbnRlbnQgPT4gY29udGVudCBpbnN0YW5jZW9mIEFzdE5vZGU7XG5cbiAgICBjb25zdCBtb3ZlU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChoYXNGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgIGZpcnN0UG9zaXRpb25JbihlZGl0b3IuZ2V0Qm9keSgpKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHBvcy5nZXROb2RlKCk7XG4gICAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBpc1RhYmxlJDIobm9kZSkgPyBmaXJzdFBvc2l0aW9uSW4obm9kZSkuZ2V0T3IocG9zKSA6IHBvcztcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFBvcy50b1JhbmdlKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldEVkaXRvckh0bWwgPSAoZWRpdG9yLCBodG1sLCBub1NlbGVjdGlvbikgPT4ge1xuICAgICAgZWRpdG9yLmRvbS5zZXRIVE1MKGVkaXRvci5nZXRCb2R5KCksIGh0bWwpO1xuICAgICAgaWYgKG5vU2VsZWN0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgIG1vdmVTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRTdHJpbmcgPSAoZWRpdG9yLCBib2R5LCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDAgfHwgL15cXHMrJC8udGVzdChjb250ZW50KSkge1xuICAgICAgICBjb25zdCBwYWRkID0gJzxiciBkYXRhLW1jZS1ib2d1cz1cIjFcIj4nO1xuICAgICAgICBpZiAoYm9keS5ub2RlTmFtZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgIGNvbnRlbnQgPSAnPHRyPjx0ZD4nICsgcGFkZCArICc8L3RkPjwvdHI+JztcbiAgICAgICAgfSBlbHNlIGlmICgvXihVTHxPTCkkLy50ZXN0KGJvZHkubm9kZU5hbWUpKSB7XG4gICAgICAgICAgY29udGVudCA9ICc8bGk+JyArIHBhZGQgKyAnPC9saT4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9ja05hbWUgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgICAgaWYgKGVkaXRvci5zY2hlbWEuaXNWYWxpZENoaWxkKGJvZHkubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgZm9yY2VkUm9vdEJsb2NrTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBwYWRkO1xuICAgICAgICAgIGNvbnRlbnQgPSBlZGl0b3IuZG9tLmNyZWF0ZUhUTUwoZm9yY2VkUm9vdEJsb2NrTmFtZSwgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWRpdG9yKSwgY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gcGFkZDtcbiAgICAgICAgfVxuICAgICAgICBzZXRFZGl0b3JIdG1sKGVkaXRvciwgY29udGVudCwgYXJncy5ub19zZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgaHRtbDogY29udGVudFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ3MuZm9ybWF0ICE9PSAncmF3Jykge1xuICAgICAgICAgIGNvbnRlbnQgPSBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUoZWRpdG9yLnBhcnNlci5wYXJzZShjb250ZW50LCB7XG4gICAgICAgICAgICBpc1Jvb3RDb250ZW50OiB0cnVlLFxuICAgICAgICAgICAgaW5zZXJ0OiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyaW1tZWRIdG1sID0gaXNXc1ByZXNlcnZlRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShib2R5KSkgPyBjb250ZW50IDogVG9vbHMudHJpbShjb250ZW50KTtcbiAgICAgICAgc2V0RWRpdG9ySHRtbChlZGl0b3IsIHRyaW1tZWRIdG1sLCBhcmdzLm5vX3NlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogdHJpbW1lZEh0bWwsXG4gICAgICAgICAgaHRtbDogdHJpbW1lZEh0bWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRUcmVlID0gKGVkaXRvciwgYm9keSwgY29udGVudCwgYXJncykgPT4ge1xuICAgICAgZmlsdGVyJDIoZWRpdG9yLnBhcnNlci5nZXROb2RlRmlsdGVycygpLCBlZGl0b3IucGFyc2VyLmdldEF0dHJpYnV0ZUZpbHRlcnMoKSwgY29udGVudCk7XG4gICAgICBjb25zdCBodG1sID0gSHRtbFNlcmlhbGl6ZXIoeyB2YWxpZGF0ZTogZmFsc2UgfSwgZWRpdG9yLnNjaGVtYSkuc2VyaWFsaXplKGNvbnRlbnQpO1xuICAgICAgY29uc3QgdHJpbW1lZEh0bWwgPSBpc1dzUHJlc2VydmVFbGVtZW50KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGJvZHkpKSA/IGh0bWwgOiBUb29scy50cmltKGh0bWwpO1xuICAgICAgc2V0RWRpdG9ySHRtbChlZGl0b3IsIHRyaW1tZWRIdG1sLCBhcmdzLm5vX3NlbGVjdGlvbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBodG1sOiB0cmltbWVkSHRtbFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHNldENvbnRlbnRJbnRlcm5hbCA9IChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVkaXRvci5nZXRCb2R5KCkpLm1hcChib2R5ID0+IHtcbiAgICAgICAgaWYgKGlzVHJlZU5vZGUoY29udGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gc2V0Q29udGVudFRyZWUoZWRpdG9yLCBib2R5LCBjb250ZW50LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2V0Q29udGVudFN0cmluZyhlZGl0b3IsIGJvZHksIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KS5nZXRPcih7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGh0bWw6IGlzVHJlZU5vZGUoYXJncy5jb250ZW50KSA/ICcnIDogYXJncy5jb250ZW50XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYW5jZXN0b3IkMSA9IChzY29wZSwgcHJlZGljYXRlLCBpc1Jvb3QpID0+IGFuY2VzdG9yJDQoc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KS5pc1NvbWUoKTtcbiAgICBjb25zdCBzaWJsaW5nID0gKHNjb3BlLCBwcmVkaWNhdGUpID0+IHNpYmxpbmckMShzY29wZSwgcHJlZGljYXRlKS5pc1NvbWUoKTtcblxuICAgIGNvbnN0IGVuc3VyZUlzUm9vdCA9IGlzUm9vdCA9PiBpc0Z1bmN0aW9uKGlzUm9vdCkgPyBpc1Jvb3QgOiBuZXZlcjtcbiAgICBjb25zdCBhbmNlc3RvciA9IChzY29wZSwgdHJhbnNmb3JtLCBpc1Jvb3QpID0+IHtcbiAgICAgIGxldCBlbGVtZW50ID0gc2NvcGUuZG9tO1xuICAgICAgY29uc3Qgc3RvcCA9IGVuc3VyZUlzUm9vdChpc1Jvb3QpO1xuICAgICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBlbCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybShlbCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZC5pc1NvbWUoKSkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzdG9wKGVsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdCQxID0gKHNjb3BlLCB0cmFuc2Zvcm0sIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRyYW5zZm9ybShzY29wZSk7XG4gICAgICBjb25zdCBzdG9wID0gZW5zdXJlSXNSb290KGlzUm9vdCk7XG4gICAgICByZXR1cm4gY3VycmVudC5vclRodW5rKCgpID0+IHN0b3Aoc2NvcGUpID8gT3B0aW9uYWwubm9uZSgpIDogYW5jZXN0b3Ioc2NvcGUsIHRyYW5zZm9ybSwgc3RvcCkpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0VxJDMgPSBpc0VxJDU7XG4gICAgY29uc3QgbWF0Y2hlc1VuSW5oZXJpdGVkRm9ybWF0U2VsZWN0b3IgPSAoZWQsIG5vZGUsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZvcm1hdExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFtpXTtcbiAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5pbmhlcml0ID09PSBmYWxzZSAmJiBlZC5kb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaFBhcmVudHMgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmRvbS5nZXRSb290KCk7XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaGVkTm9kZSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KG5vZGUsIGVsbSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVzVW5Jbmhlcml0ZWRGb3JtYXRTZWxlY3RvcihlZGl0b3IsIGVsbSwgbmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxtLnBhcmVudE5vZGUgPT09IHJvb3QgfHwgISFtYXRjaE5vZGUoZWRpdG9yLCBlbG0sIG5hbWUsIHZhcnMsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFtYXRjaE5vZGUoZWRpdG9yLCBtYXRjaGVkTm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaE5hbWUgPSAoZG9tLCBub2RlLCBmb3JtYXQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpICYmIGlzRXEkMyhub2RlLCBmb3JtYXQuaW5saW5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrRm9ybWF0KGZvcm1hdCkgJiYgaXNFcSQzKG5vZGUsIGZvcm1hdC5ibG9jaykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIHJldHVybiBpc0VsZW1lbnQkNihub2RlKSAmJiBkb20uaXMobm9kZSwgZm9ybWF0LnNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoSXRlbXMgPSAoZG9tLCBub2RlLCBmb3JtYXQsIGl0ZW1OYW1lLCBzaW1pbGFyLCB2YXJzKSA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGZvcm1hdFtpdGVtTmFtZV07XG4gICAgICBjb25zdCBtYXRjaEF0dHJpYnV0ZXMgPSBpdGVtTmFtZSA9PT0gJ2F0dHJpYnV0ZXMnO1xuICAgICAgaWYgKGlzRnVuY3Rpb24oZm9ybWF0Lm9ubWF0Y2gpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQub25tYXRjaChub2RlLCBmb3JtYXQsIGl0ZW1OYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtcykge1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGl0ZW1zKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaGFzJDIoaXRlbXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaEF0dHJpYnV0ZXMgPyBkb20uZ2V0QXR0cmliKG5vZGUsIGtleSkgOiBnZXRTdHlsZShkb20sIG5vZGUsIGtleSk7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSByZXBsYWNlVmFycyhpdGVtc1trZXldLCB2YXJzKTtcbiAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eVZhbHVlID0gaXNOdWxsYWJsZSh2YWx1ZSkgfHwgaXNFbXB0eSQzKHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGlzRW1wdHlWYWx1ZSAmJiBpc051bGxhYmxlKGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNpbWlsYXIgJiYgaXNFbXB0eVZhbHVlICYmICFmb3JtYXQuZXhhY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCghc2ltaWxhciB8fCBmb3JtYXQuZXhhY3QpICYmICFpc0VxJDModmFsdWUsIG5vcm1hbGl6ZVN0eWxlVmFsdWUoZXhwZWN0ZWRWYWx1ZSwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hdGNoQXR0cmlidXRlcyA/IGRvbS5nZXRBdHRyaWIobm9kZSwgaXRlbXNbaV0pIDogZ2V0U3R5bGUoZG9tLCBub2RlLCBpdGVtc1tpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoTm9kZSA9IChlZCwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBpZiAoZm9ybWF0TGlzdCAmJiBpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRMaXN0W2ldO1xuICAgICAgICAgIGlmIChtYXRjaE5hbWUoZWQuZG9tLCBub2RlLCBmb3JtYXQpICYmIG1hdGNoSXRlbXMoZG9tLCBub2RlLCBmb3JtYXQsICdhdHRyaWJ1dGVzJywgc2ltaWxhciwgdmFycykgJiYgbWF0Y2hJdGVtcyhkb20sIG5vZGUsIGZvcm1hdCwgJ3N0eWxlcycsIHNpbWlsYXIsIHZhcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gZm9ybWF0LmNsYXNzZXM7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGNsYXNzZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVkLmRvbS5oYXNDbGFzcyhub2RlLCByZXBsYWNlVmFycyhjbGFzc2VzW3hdLCB2YXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2gkMiA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpID0+IHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFBhcmVudHMoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChtYXRjaFBhcmVudHMoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgIGlmIChzdGFydE5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKG1hdGNoUGFyZW50cyhlZGl0b3IsIHN0YXJ0Tm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgbWF0Y2hBbGwgPSAoZWRpdG9yLCBuYW1lcywgdmFycykgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlZEZvcm1hdE5hbWVzID0gW107XG4gICAgICBjb25zdCBjaGVja2VkTWFwID0ge307XG4gICAgICBjb25zdCBzdGFydEVsZW1lbnQgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBlZGl0b3IuZG9tLmdldFBhcmVudChzdGFydEVsZW1lbnQsIG5vZGUgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgIGlmICghY2hlY2tlZE1hcFtuYW1lXSAmJiBtYXRjaE5vZGUoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzKSkge1xuICAgICAgICAgICAgY2hlY2tlZE1hcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBtYXRjaGVkRm9ybWF0TmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGVkaXRvci5kb20uZ2V0Um9vdCgpKTtcbiAgICAgIHJldHVybiBtYXRjaGVkRm9ybWF0TmFtZXM7XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXN0ID0gKGVkaXRvciwgbmFtZXMpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShlbG0sIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gKGVsbSwgbmFtZSkgPT4gbWF0Y2hOb2RlKGVkaXRvciwgZWxtLmRvbSwgbmFtZSkgPyBPcHRpb25hbC5zb21lKG5hbWUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSkuYmluZChyYXdFbG0gPT4gY2xvc2VzdCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd0VsbSksIGVsbSA9PiBmaW5kTWFwKG5hbWVzLCBuYW1lID0+IG1hdGNoKGVsbSwgbmFtZSkpLCBpc1Jvb3QpKS5nZXRPck51bGwoKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkFwcGx5ID0gKGVkaXRvciwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGlmIChmb3JtYXRMaXN0ICYmIGVkaXRvci5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IGdldFBhcmVudHMkMihkb20sIHN0YXJ0Tm9kZSk7XG4gICAgICAgIGZvciAobGV0IHggPSBmb3JtYXRMaXN0Lmxlbmd0aCAtIDE7IHggPj0gMDsgeC0tKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFt4XTtcbiAgICAgICAgICBpZiAoIWlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoZG9tLmlzKHBhcmVudHNbaV0sIGZvcm1hdC5zZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaEFsbE9uTm9kZSA9IChlZGl0b3IsIG5vZGUsIGZvcm1hdE5hbWVzKSA9PiBmb2xkbChmb3JtYXROYW1lcywgKGFjYywgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hTaW1pbGFyID0gaXNWYXJpYWJsZUZvcm1hdE5hbWUoZWRpdG9yLCBuYW1lKTtcbiAgICAgIGlmIChlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBuYW1lLCB7fSwgbWF0Y2hTaW1pbGFyKSkge1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBaV1NQID0gWldTUCQxO1xuICAgIGNvbnN0IGltcG9ydE5vZGUgPSAob3duZXJEb2N1bWVudCwgbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVtcHR5Q2FyZXRDb250YWluZXJzID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlICh0ZW1wTm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpICYmIHRlbXBOb2RlLmRhdGEgIT09IFpXU1AgfHwgdGVtcE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNih0ZW1wTm9kZSkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0Q29udGFpbmVyRW1wdHkgPSBub2RlID0+IHtcbiAgICAgIHJldHVybiBnZXRFbXB0eUNhcmV0Q29udGFpbmVycyhub2RlKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgY29uc3QgZmluZEZpcnN0VGV4dE5vZGUgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKG5vZGUsIG5vZGUpO1xuICAgICAgICBmb3IgKGxldCB0ZW1wTm9kZSA9IHdhbGtlci5jdXJyZW50KCk7IHRlbXBOb2RlOyB0ZW1wTm9kZSA9IHdhbGtlci5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0JGEodGVtcE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVtcE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUNhcmV0Q29udGFpbmVyID0gZmlsbCA9PiB7XG4gICAgICBjb25zdCBjYXJldENvbnRhaW5lciA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdzcGFuJyk7XG4gICAgICBzZXRBbGwkMShjYXJldENvbnRhaW5lciwge1xuICAgICAgICAnaWQnOiBDQVJFVF9JRCxcbiAgICAgICAgJ2RhdGEtbWNlLWJvZ3VzJzogJzEnLFxuICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdmb3JtYXQtY2FyZXQnXG4gICAgICB9KTtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGFwcGVuZCQxKGNhcmV0Q29udGFpbmVyLCBTdWdhckVsZW1lbnQuZnJvbVRleHQoWldTUCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcmV0Q29udGFpbmVyO1xuICAgIH07XG4gICAgY29uc3QgdHJpbVp3c3BGcm9tQ2FyZXRDb250YWluZXIgPSBjYXJldENvbnRhaW5lck5vZGUgPT4ge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBmaW5kRmlyc3RUZXh0Tm9kZShjYXJldENvbnRhaW5lck5vZGUpO1xuICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLmRhdGEuY2hhckF0KDApID09PSBaV1NQKSB7XG4gICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVDYXJldENvbnRhaW5lck5vZGUgPSAoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJFbXB0eShub2RlKSkge1xuICAgICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmYWxzZSwgU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIG1vdmVDYXJldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChub2RlLCBkb20uaXNCbG9jayk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSB0cmltWndzcEZyb21DYXJldENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyID09PSB0ZXh0Tm9kZSAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICBybmcuc2V0U3RhcnQodGV4dE5vZGUsIHN0YXJ0T2Zmc2V0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENvbnRhaW5lciA9PT0gdGV4dE5vZGUgJiYgZW5kT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHJuZy5zZXRFbmQodGV4dE5vZGUsIGVuZE9mZnNldCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jayAmJiBkb20uaXNFbXB0eShibG9jaykpIHtcbiAgICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihTdWdhckVsZW1lbnQuZnJvbURvbShibG9jaykpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgbm9kZSwgbW92ZUNhcmV0ID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gZ2V0UGFyZW50Q2FyZXRDb250YWluZXIoZWRpdG9yLmdldEJvZHkoKSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IGRvbS5nZXQoQ0FSRVRfSUQpKSB7XG4gICAgICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBub2RlLCBtb3ZlQ2FyZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2FyZXRDb250YWluZXJOb2RlKGVkaXRvciwgbm9kZSwgbW92ZUNhcmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydENhcmV0Q29udGFpbmVyTm9kZSA9IChlZGl0b3IsIGNhcmV0Q29udGFpbmVyLCBmb3JtYXROb2RlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChmb3JtYXROb2RlLCBjdXJyeShpc1RleHRCbG9jayQxLCBlZGl0b3Iuc2NoZW1hKSk7XG4gICAgICBpZiAoYmxvY2sgJiYgZG9tLmlzRW1wdHkoYmxvY2spKSB7XG4gICAgICAgIChfYSA9IGZvcm1hdE5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VDaGlsZChjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVUcmFpbGluZ0JyKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZvcm1hdE5vZGUpKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KGZvcm1hdE5vZGUpKSB7XG4gICAgICAgICAgKF9iID0gZm9ybWF0Tm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZUNoaWxkKGNhcmV0Q29udGFpbmVyLCBmb3JtYXROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoY2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmROb2RlID0gKHBhcmVudE5vZGUsIG5vZGUpID0+IHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEZvcm1hdE5vZGVzSW50b0NhcmV0Q29udGFpbmVyID0gKGZvcm1hdE5vZGVzLCBjYXJldENvbnRhaW5lcikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgaW5uZXJNb3N0Rm9ybWF0Tm9kZSA9IGZvbGRyKGZvcm1hdE5vZGVzLCAocGFyZW50Tm9kZSwgZm9ybWF0Tm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gYXBwZW5kTm9kZShwYXJlbnROb2RlLCBmb3JtYXROb2RlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgfSwgY2FyZXRDb250YWluZXIpO1xuICAgICAgY29uc3QgZG9jID0gKF9hID0gaW5uZXJNb3N0Rm9ybWF0Tm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2N1bWVudDtcbiAgICAgIHJldHVybiBhcHBlbmROb2RlKGlubmVyTW9zdEZvcm1hdE5vZGUsIGRvYy5jcmVhdGVUZXh0Tm9kZShaV1NQKSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbkZvcm1hdE5vZGUgPSAoZWRpdG9yLCBjYXJldENvbnRhaW5lciwgZm9ybWF0Tm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gZWRpdG9yLmZvcm1hdHRlcjtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCB2YWxpZEZvcm1hdHMgPSBmaWx0ZXIkNShrZXlzKGZvcm1hdHRlci5nZXQoKSksIGZvcm1hdE5hbWUgPT4gZm9ybWF0TmFtZSAhPT0gbmFtZSAmJiAhY29udGFpbnMkMShmb3JtYXROYW1lLCAncmVtb3ZlZm9ybWF0JykpO1xuICAgICAgY29uc3QgbWF0Y2hlZEZvcm1hdHMgPSBtYXRjaEFsbE9uTm9kZShlZGl0b3IsIGZvcm1hdE5vZGUsIHZhbGlkRm9ybWF0cyk7XG4gICAgICBjb25zdCB1bmlxdWVGb3JtYXRzID0gZmlsdGVyJDUobWF0Y2hlZEZvcm1hdHMsIGZtdE5hbWUgPT4gIWFyZVNpbWlsYXJGb3JtYXRzKGVkaXRvciwgZm10TmFtZSwgbmFtZSkpO1xuICAgICAgaWYgKHVuaXF1ZUZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjbG9uZWRGb3JtYXROb2RlID0gZm9ybWF0Tm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBkb20uYWRkKGNhcmV0Q29udGFpbmVyLCBjbG9uZWRGb3JtYXROb2RlKTtcbiAgICAgICAgZm9ybWF0dGVyLnJlbW92ZShuYW1lLCB2YXJzLCBjbG9uZWRGb3JtYXROb2RlLCBzaW1pbGFyKTtcbiAgICAgICAgZG9tLnJlbW92ZShjbG9uZWRGb3JtYXROb2RlKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2xvbmVkRm9ybWF0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlDYXJldEZvcm1hdCA9IChlZGl0b3IsIG5hbWUsIHZhcnMpID0+IHtcbiAgICAgIGxldCBjYXJldENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBmb3JtYXRMaXN0ID0gZWRpdG9yLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBpZiAoIWZvcm1hdExpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uUm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgbGV0IG9mZnNldCA9IHNlbGVjdGlvblJuZy5zdGFydE9mZnNldDtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHNlbGVjdGlvblJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IHRleHQgPSBjb250YWluZXIubm9kZVZhbHVlO1xuICAgICAgY2FyZXRDb250YWluZXIgPSBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihlZGl0b3IuZ2V0Qm9keSgpLCBzZWxlY3Rpb24uZ2V0U3RhcnQoKSk7XG4gICAgICBjb25zdCB3b3JkY2hhclJlZ2V4ID0gL1teXFxzXFx1MDBhMFxcdTAwYWRcXHUyMDBiXFx1ZmVmZl0vO1xuICAgICAgaWYgKHRleHQgJiYgb2Zmc2V0ID4gMCAmJiBvZmZzZXQgPCB0ZXh0Lmxlbmd0aCAmJiB3b3JkY2hhclJlZ2V4LnRlc3QodGV4dC5jaGFyQXQob2Zmc2V0KSkgJiYgd29yZGNoYXJSZWdleC50ZXN0KHRleHQuY2hhckF0KG9mZnNldCAtIDEpKSkge1xuICAgICAgICBjb25zdCBib29rbWFyayA9IHNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICBzZWxlY3Rpb25SbmcuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIGxldCBybmcgPSBleHBhbmRSbmcoZWRpdG9yLmRvbSwgc2VsZWN0aW9uUm5nLCBmb3JtYXRMaXN0KTtcbiAgICAgICAgcm5nID0gc3BsaXQocm5nKTtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseShuYW1lLCB2YXJzLCBybmcpO1xuICAgICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHRleHROb2RlID0gY2FyZXRDb250YWluZXIgPyBmaW5kRmlyc3RUZXh0Tm9kZShjYXJldENvbnRhaW5lcikgOiBudWxsO1xuICAgICAgICBpZiAoIWNhcmV0Q29udGFpbmVyIHx8ICh0ZXh0Tm9kZSA9PT0gbnVsbCB8fCB0ZXh0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dE5vZGUuZGF0YSkgIT09IFpXU1ApIHtcbiAgICAgICAgICBjYXJldENvbnRhaW5lciA9IGltcG9ydE5vZGUoZWRpdG9yLmdldERvYygpLCBjcmVhdGVDYXJldENvbnRhaW5lcih0cnVlKS5kb20pO1xuICAgICAgICAgIHRleHROb2RlID0gY2FyZXRDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICBzZWxlY3Rpb25SbmcuaW5zZXJ0Tm9kZShjYXJldENvbnRhaW5lcik7XG4gICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KG5hbWUsIHZhcnMsIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KG5hbWUsIHZhcnMsIGNhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24odGV4dE5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVDYXJldEZvcm1hdCA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgbGV0IGhhc0NvbnRlbnRBZnRlciA9IGZhbHNlO1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFmb3JtYXRMaXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgIGxldCBub2RlID0gY29udGFpbmVyO1xuICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgaGFzQ29udGVudEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGZvcm1hdE5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobWF0Y2hOb2RlKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikpIHtcbiAgICAgICAgICBmb3JtYXROb2RlID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIGhhc0NvbnRlbnRBZnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3JtYXROb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDb250ZW50QWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgYm9va21hcmsgPSBzZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgcm5nLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICBsZXQgZXhwYW5kZWRSbmcgPSBleHBhbmRSbmcoZG9tLCBybmcsIGZvcm1hdExpc3QsIHRydWUpO1xuICAgICAgICBleHBhbmRlZFJuZyA9IHNwbGl0KGV4cGFuZGVkUm5nKTtcbiAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUobmFtZSwgdmFycywgZXhwYW5kZWRSbmcsIHNpbWlsYXIpO1xuICAgICAgICBzZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2FyZXRDb250YWluZXIgPSBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihlZGl0b3IuZ2V0Qm9keSgpLCBmb3JtYXROb2RlKTtcbiAgICAgICAgY29uc3QgbmV3Q2FyZXRDb250YWluZXIgPSBjcmVhdGVDYXJldENvbnRhaW5lcihmYWxzZSkuZG9tO1xuICAgICAgICBpbnNlcnRDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBuZXdDYXJldENvbnRhaW5lciwgY2FyZXRDb250YWluZXIgIT09IG51bGwgJiYgY2FyZXRDb250YWluZXIgIT09IHZvaWQgMCA/IGNhcmV0Q29udGFpbmVyIDogZm9ybWF0Tm9kZSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRGb3JtYXROb2RlID0gY2xlYW5Gb3JtYXROb2RlKGVkaXRvciwgbmV3Q2FyZXRDb250YWluZXIsIGZvcm1hdE5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpO1xuICAgICAgICBjb25zdCBjYXJldFRleHROb2RlID0gaW5zZXJ0Rm9ybWF0Tm9kZXNJbnRvQ2FyZXRDb250YWluZXIocGFyZW50cy5jb25jYXQoY2xlYW5lZEZvcm1hdE5vZGUudG9BcnJheSgpKSwgbmV3Q2FyZXRDb250YWluZXIpO1xuICAgICAgICBpZiAoY2FyZXRDb250YWluZXIpIHtcbiAgICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lck5vZGUoZWRpdG9yLCBjYXJldENvbnRhaW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihjYXJldFRleHROb2RlLCAxKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KGZvcm1hdE5vZGUpKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZShmb3JtYXROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGlzYWJsZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwga2V5Q29kZSwgbW92ZUNhcmV0KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIHJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgbnVsbCwgbW92ZUNhcmV0KTtcbiAgICAgIGlmICgoa2V5Q29kZSA9PT0gOCB8fCBrZXlDb2RlID09PSA0NikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLmdldFN0YXJ0KCkuaW5uZXJIVE1MID09PSBaV1NQKSB7XG4gICAgICAgIHJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgZ2V0UGFyZW50Q2FyZXRDb250YWluZXIoYm9keSwgc2VsZWN0aW9uLmdldFN0YXJ0KCkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlDb2RlID09PSAzNyB8fCBrZXlDb2RlID09PSAzOSkge1xuICAgICAgICByZW1vdmVDYXJldENvbnRhaW5lcihlZGl0b3IsIGdldFBhcmVudENhcmV0Q29udGFpbmVyKGJvZHksIHNlbGVjdGlvbi5nZXRTdGFydCgpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBlbmRzV2l0aE5ic3AgPSBlbGVtZW50ID0+IGlzVGV4dCRhKGVsZW1lbnQpICYmIGVuZHNXaXRoKGVsZW1lbnQuZGF0YSwgbmJzcCk7XG4gICAgY29uc3Qgc2V0dXAkdSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ21vdXNldXAga2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBkaXNhYmxlQ2FyZXRDb250YWluZXIoZWRpdG9yLCBlLmtleUNvZGUsIGVuZHNXaXRoTmJzcChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLmVuZENvbnRhaW5lcikpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVDYXJldEZvcm1hdCA9IGZvcm1hdE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0Q29udGFpbmVyID0gY3JlYXRlQ2FyZXRDb250YWluZXIoZmFsc2UpO1xuICAgICAgY29uc3QgaW5uZXJNb3N0ID0gaW5zZXJ0Rm9ybWF0Tm9kZXNJbnRvQ2FyZXRDb250YWluZXIoZm9ybWF0Tm9kZXMsIGNhcmV0Q29udGFpbmVyLmRvbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXJldENvbnRhaW5lcixcbiAgICAgICAgY2FyZXRQb3NpdGlvbjogQ2FyZXRQb3NpdGlvbihpbm5lck1vc3QsIDApXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVwbGFjZVdpdGhDYXJldEZvcm1hdCA9ICh0YXJnZXROb2RlLCBmb3JtYXROb2RlcykgPT4ge1xuICAgICAgY29uc3Qge2NhcmV0Q29udGFpbmVyLCBjYXJldFBvc2l0aW9ufSA9IGNyZWF0ZUNhcmV0Rm9ybWF0KGZvcm1hdE5vZGVzKTtcbiAgICAgIGJlZm9yZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhcmdldE5vZGUpLCBjYXJldENvbnRhaW5lcik7XG4gICAgICByZW1vdmUkNShTdWdhckVsZW1lbnQuZnJvbURvbSh0YXJnZXROb2RlKSk7XG4gICAgICByZXR1cm4gY2FyZXRQb3NpdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUNhcmV0Rm9ybWF0QXRTdGFydCQxID0gKHJuZywgZm9ybWF0Tm9kZXMpID0+IHtcbiAgICAgIGNvbnN0IHtjYXJldENvbnRhaW5lciwgY2FyZXRQb3NpdGlvbn0gPSBjcmVhdGVDYXJldEZvcm1hdChmb3JtYXROb2Rlcyk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShjYXJldENvbnRhaW5lci5kb20pO1xuICAgICAgcmV0dXJuIGNhcmV0UG9zaXRpb247XG4gICAgfTtcbiAgICBjb25zdCBpc0Zvcm1hdEVsZW1lbnQgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBpbmxpbmVFbGVtZW50cyA9IGVkaXRvci5zY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gaGFzJDIoaW5saW5lRWxlbWVudHMsIG5hbWUoZWxlbWVudCkpICYmICFpc0NhcmV0Tm9kZShlbGVtZW50LmRvbSkgJiYgIWlzQm9ndXMkMihlbGVtZW50LmRvbSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5Q2FyZXRGb3JtYXRFbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gaXNDYXJldE5vZGUoZWxlbWVudC5kb20pICYmIGlzQ2FyZXRDb250YWluZXJFbXB0eShlbGVtZW50LmRvbSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHBvc3RQcm9jZXNzSG9va3MgPSB7fTtcbiAgICBjb25zdCBpc1ByZSA9IG1hdGNoTm9kZU5hbWVzKFsncHJlJ10pO1xuICAgIGNvbnN0IGFkZFBvc3RQcm9jZXNzSG9vayA9IChuYW1lLCBob29rKSA9PiB7XG4gICAgICBjb25zdCBob29rcyA9IHBvc3RQcm9jZXNzSG9va3NbbmFtZV07XG4gICAgICBpZiAoIWhvb2tzKSB7XG4gICAgICAgIHBvc3RQcm9jZXNzSG9va3NbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHBvc3RQcm9jZXNzSG9va3NbbmFtZV0ucHVzaChob29rKTtcbiAgICB9O1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzJDEgPSAobmFtZSwgZWRpdG9yKSA9PiB7XG4gICAgICBpZiAoaGFzJDIocG9zdFByb2Nlc3NIb29rcywgbmFtZSkpIHtcbiAgICAgICAgZWFjaCRlKHBvc3RQcm9jZXNzSG9va3NbbmFtZV0sIGhvb2sgPT4ge1xuICAgICAgICAgIGhvb2soZWRpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGRQb3N0UHJvY2Vzc0hvb2soJ3ByZScsIGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgaGFzUHJlU2libGluZyA9IGJsb2NrcyA9PiBwcmUgPT4ge1xuICAgICAgICBjb25zdCBwcmV2ID0gcHJlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgcmV0dXJuIGlzUHJlKHByZXYpICYmIGNvbnRhaW5zJDIoYmxvY2tzLCBwcmV2KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBqb2luUHJlID0gKHByZTEsIHByZTIpID0+IHtcbiAgICAgICAgY29uc3Qgc1ByZTIgPSBTdWdhckVsZW1lbnQuZnJvbURvbShwcmUyKTtcbiAgICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRPck93bmVyKHNQcmUyKS5kb207XG4gICAgICAgIHJlbW92ZSQ1KHNQcmUyKTtcbiAgICAgICAgYXBwZW5kKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZTEpLCBbXG4gICAgICAgICAgU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJywgZG9jKSxcbiAgICAgICAgICBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInLCBkb2MpLFxuICAgICAgICAgIC4uLmNoaWxkcmVuJDEoc1ByZTIpXG4gICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIGlmICghcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICBjb25zdCBibG9ja3MgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGVkQmxvY2tzKCk7XG4gICAgICAgIGNvbnN0IHByZUJsb2NrcyA9IGZpbHRlciQ1KGZpbHRlciQ1KGJsb2NrcywgaXNQcmUpLCBoYXNQcmVTaWJsaW5nKGJsb2NrcykpO1xuICAgICAgICBlYWNoJGUocHJlQmxvY2tzLCBwcmUgPT4ge1xuICAgICAgICAgIGpvaW5QcmUocHJlLnByZXZpb3VzU2libGluZywgcHJlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBsaXN0SXRlbVN0eWxlcyA9IFtcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2NvbG9yJyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udEZhbWlseSdcbiAgICBdO1xuICAgIGNvbnN0IGhhc0xpc3RTdHlsZXMgPSBmbXQgPT4gaXNPYmplY3QoZm10LnN0eWxlcykgJiYgZXhpc3RzKGtleXMoZm10LnN0eWxlcyksIG5hbWUgPT4gY29udGFpbnMkMihsaXN0SXRlbVN0eWxlcywgbmFtZSkpO1xuICAgIGNvbnN0IGZpbmRFeHBhbmRlZExpc3RJdGVtRm9ybWF0ID0gZm9ybWF0cyA9PiBmaW5kJDIoZm9ybWF0cywgZm10ID0+IGlzSW5saW5lRm9ybWF0KGZtdCkgJiYgZm10LmlubGluZSA9PT0gJ3NwYW4nICYmIGhhc0xpc3RTdHlsZXMoZm10KSk7XG4gICAgY29uc3QgZ2V0RXhwYW5kZWRMaXN0SXRlbUZvcm1hdCA9IChmb3JtYXR0ZXIsIGZvcm1hdCkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGZvcm1hdHRlci5nZXQoZm9ybWF0KTtcbiAgICAgIHJldHVybiBpc0FycmF5JDEoZm9ybWF0TGlzdCkgPyBmaW5kRXhwYW5kZWRMaXN0SXRlbUZvcm1hdChmb3JtYXRMaXN0KSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUm5nU3RhcnRBdFN0YXJ0T2ZFbGVtZW50ID0gKHJuZywgZWxtKSA9PiBwcmV2UG9zaXRpb24oZWxtLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpLmlzTm9uZSgpO1xuICAgIGNvbnN0IGlzUm5nRW5kQXRFbmRPZkVsZW1lbnQgPSAocm5nLCBlbG0pID0+IHtcbiAgICAgIHJldHVybiBuZXh0UG9zaXRpb24oZWxtLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpKS5leGlzdHMocG9zID0+ICFpc0JyJDYocG9zLmdldE5vZGUoKSkgfHwgbmV4dFBvc2l0aW9uKGVsbSwgcG9zKS5pc1NvbWUoKSkgPT09IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNFZGl0YWJsZUxpc3RJdGVtID0gZG9tID0+IGVsbSA9PiBpc0xpc3RJdGVtJDIoZWxtKSAmJiBkb20uaXNFZGl0YWJsZShlbG0pO1xuICAgIGNvbnN0IGdldEZ1bGx5U2VsZWN0ZWRCbG9ja3MgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3QgYmxvY2tzID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkQmxvY2tzKCk7XG4gICAgICBjb25zdCBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGlzUm5nU3RhcnRBdFN0YXJ0T2ZFbGVtZW50KHJuZywgYmxvY2tzWzBdKSAmJiBpc1JuZ0VuZEF0RW5kT2ZFbGVtZW50KHJuZywgYmxvY2tzWzBdKSA/IGJsb2NrcyA6IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBoZWFkKGJsb2NrcykuZmlsdGVyKGVsbSA9PiBpc1JuZ1N0YXJ0QXRTdGFydE9mRWxlbWVudChybmcsIGVsbSkpLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGFzdCA9IGxhc3QkMyhibG9ja3MpLmZpbHRlcihlbG0gPT4gaXNSbmdFbmRBdEVuZE9mRWxlbWVudChybmcsIGVsbSkpLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgbWlkZGxlID0gYmxvY2tzLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChtaWRkbGUpLmNvbmNhdChsYXN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEZ1bGx5U2VsZWN0ZWRMaXN0SXRlbXMgPSBzZWxlY3Rpb24gPT4gZmlsdGVyJDUoZ2V0RnVsbHlTZWxlY3RlZEJsb2NrcyhzZWxlY3Rpb24pLCBpc0VkaXRhYmxlTGlzdEl0ZW0oc2VsZWN0aW9uLmRvbSkpO1xuICAgIGNvbnN0IGdldFBhcnRpYWxseVNlbGVjdGVkTGlzdEl0ZW1zID0gc2VsZWN0aW9uID0+IGZpbHRlciQ1KHNlbGVjdGlvbi5nZXRTZWxlY3RlZEJsb2NrcygpLCBpc0VkaXRhYmxlTGlzdEl0ZW0oc2VsZWN0aW9uLmRvbSkpO1xuXG4gICAgY29uc3QgZWFjaCQ4ID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBpc0VsZW1lbnROb2RlID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlKSAmJiAhaXNDYXJldE5vZGUobm9kZSkgJiYgIWlzQm9ndXMkMihub2RlKTtcbiAgICBjb25zdCBmaW5kRWxlbWVudFNpYmxpbmcgPSAobm9kZSwgc2libGluZ05hbWUpID0+IHtcbiAgICAgIGZvciAobGV0IHNpYmxpbmcgPSBub2RlOyBzaWJsaW5nOyBzaWJsaW5nID0gc2libGluZ1tzaWJsaW5nTmFtZV0pIHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKHNpYmxpbmcpICYmIGlzTm90RW1wdHkoc2libGluZy5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihzaWJsaW5nKSAmJiAhaXNCb29rbWFya05vZGUkMShzaWJsaW5nKSkge1xuICAgICAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlU2libGluZ3NOb2RlcyA9IChlZGl0b3IsIHByZXYsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRVdGlscyA9IEVsZW1lbnRVdGlscyhlZGl0b3IpO1xuICAgICAgY29uc3QgaXNQcmV2RWRpdGFibGUgPSBpc0VsZW1lbnQkNihwcmV2KSAmJiBpc0VkaXRhYmxlJDIocHJldik7XG4gICAgICBjb25zdCBpc05leHRFZGl0YWJsZSA9IGlzRWxlbWVudCQ2KG5leHQpICYmIGlzRWRpdGFibGUkMihuZXh0KTtcbiAgICAgIGlmIChpc1ByZXZFZGl0YWJsZSAmJiBpc05leHRFZGl0YWJsZSkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZyA9IGZpbmRFbGVtZW50U2libGluZyhwcmV2LCAncHJldmlvdXNTaWJsaW5nJyk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZmluZEVsZW1lbnRTaWJsaW5nKG5leHQsICduZXh0U2libGluZycpO1xuICAgICAgICBpZiAoZWxlbWVudFV0aWxzLmNvbXBhcmUocHJldlNpYmxpbmcsIG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIGZvciAobGV0IHNpYmxpbmcgPSBwcmV2U2libGluZy5uZXh0U2libGluZzsgc2libGluZyAmJiBzaWJsaW5nICE9PSBuZXh0U2libGluZzspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcFNpYmxpbmcgPSBzaWJsaW5nO1xuICAgICAgICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwcmV2U2libGluZy5hcHBlbmRDaGlsZCh0bXBTaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUobmV4dFNpYmxpbmcpO1xuICAgICAgICAgIFRvb2xzLmVhY2goVG9vbHMuZ3JlcChuZXh0U2libGluZy5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBwcmV2U2libGluZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcHJldlNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VTaWJsaW5ncyA9IChlZGl0b3IsIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKG5vZGUgJiYgZm9ybWF0Lm1lcmdlX3NpYmxpbmdzICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBuZXdOb2RlID0gKF9hID0gbWVyZ2VTaWJsaW5nc05vZGVzKGVkaXRvciwgZ2V0Tm9uV2hpdGVTcGFjZVNpYmxpbmcobm9kZSksIG5vZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBub2RlO1xuICAgICAgICBtZXJnZVNpYmxpbmdzTm9kZXMoZWRpdG9yLCBuZXdOb2RlLCBnZXROb25XaGl0ZVNwYWNlU2libGluZyhuZXdOb2RlLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhckNoaWxkU3R5bGVzID0gKGRvbSwgZm9ybWF0LCBub2RlKSA9PiB7XG4gICAgICBpZiAoZm9ybWF0LmNsZWFyX2NoaWxkX3N0eWxlcykge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGZvcm1hdC5saW5rcyA/ICcqOm5vdChhKScgOiAnKic7XG4gICAgICAgIGVhY2gkOChkb20uc2VsZWN0KHNlbGVjdG9yLCBub2RlKSwgY2hpbGROb2RlID0+IHtcbiAgICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShjaGlsZE5vZGUpICYmIGlzRWRpdGFibGUkMihjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICBlYWNoJDgoZm9ybWF0LnN0eWxlcywgKF92YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICBkb20uc2V0U3R5bGUoY2hpbGROb2RlLCBuYW1lLCAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0NoaWxkRWxlbWVudHMgPSAobm9kZSwgZmlsdGVyLCBwcm9jZXNzKSA9PiB7XG4gICAgICBlYWNoJDgobm9kZS5jaGlsZE5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgICBpZiAoZmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICBwcm9jZXNzKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaGlsZEVsZW1lbnRzKG5vZGUsIGZpbHRlciwgcHJvY2Vzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVud3JhcEVtcHR5U3BhbiA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnU1BBTicgJiYgZG9tLmdldEF0dHJpYnMobm9kZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNTdHlsZSA9IChkb20sIG5hbWUpID0+IG5vZGUgPT4gISEobm9kZSAmJiBnZXRTdHlsZShkb20sIG5vZGUsIG5hbWUpKTtcbiAgICBjb25zdCBhcHBseVN0eWxlID0gKGRvbSwgbmFtZSwgdmFsdWUpID0+IG5vZGUgPT4ge1xuICAgICAgZG9tLnNldFN0eWxlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA9PT0gJycpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgICB1bndyYXBFbXB0eVNwYW4oZG9tLCBub2RlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVtb3ZlUmVzdWx0ID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsga2VlcDogW10gfSxcbiAgICAgIHsgcmVuYW1lOiBbJ25hbWUnXSB9LFxuICAgICAgeyByZW1vdmVkOiBbXSB9XG4gICAgXSk7XG4gICAgY29uc3QgTUNFX0FUVFJfUkUgPSAvXihzcmN8aHJlZnxzdHlsZSkkLztcbiAgICBjb25zdCBlYWNoJDcgPSBUb29scy5lYWNoO1xuICAgIGNvbnN0IGlzRXEkMiA9IGlzRXEkNTtcbiAgICBjb25zdCBpc1RhYmxlQ2VsbE9yUm93ID0gbm9kZSA9PiAvXihUUnxUSHxURCkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xuICAgIGNvbnN0IGlzQ2hpbGRPZklubGluZVBhcmVudCA9IChkb20sIG5vZGUsIHBhcmVudCkgPT4gZG9tLmlzQ2hpbGRPZihub2RlLCBwYXJlbnQpICYmIG5vZGUgIT09IHBhcmVudCAmJiAhZG9tLmlzQmxvY2socGFyZW50KTtcbiAgICBjb25zdCBnZXRDb250YWluZXIgPSAoZWQsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIGxldCBjb250YWluZXIgPSBybmdbc3RhcnQgPyAnc3RhcnRDb250YWluZXInIDogJ2VuZENvbnRhaW5lciddO1xuICAgICAgbGV0IG9mZnNldCA9IHJuZ1tzdGFydCA/ICdzdGFydE9mZnNldCcgOiAnZW5kT2Zmc2V0J107XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBsYXN0SWR4ID0gY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCFzdGFydCAmJiBvZmZzZXQpIHtcbiAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY2hpbGROb2Rlc1tvZmZzZXQgPiBsYXN0SWR4ID8gbGFzdElkeCA6IG9mZnNldF07XG4gICAgICB9XG4gICAgICBpZiAoaXNUZXh0JGEoY29udGFpbmVyKSAmJiBzdGFydCAmJiBvZmZzZXQgPj0gY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgZWQuZ2V0Qm9keSgpKS5uZXh0KCkgfHwgY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgIXN0YXJ0ICYmIG9mZnNldCA9PT0gMCkge1xuICAgICAgICBjb250YWluZXIgPSBuZXcgRG9tVHJlZVdhbGtlcihjb250YWluZXIsIGVkLmdldEJvZHkoKSkucHJldigpIHx8IGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVUYWJsZVNlbGVjdGlvbiA9IChub2RlLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3QgcHJvcCA9IHN0YXJ0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCc7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlW3Byb3BdO1xuICAgICAgaWYgKGlzVGFibGVDZWxsT3JSb3cobm9kZSkgJiYgY2hpbGROb2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZVtwcm9wXSB8fCBjaGlsZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjb25zdCB3cmFwJDEgPSAoZG9tLCBub2RlLCBuYW1lLCBhdHRycykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGRvbS5jcmVhdGUobmFtZSwgYXR0cnMpO1xuICAgICAgKF9hID0gbm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIG5vZGUpO1xuICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcFdpdGhTaWJsaW5ncyA9IChkb20sIG5vZGUsIG5leHQsIG5hbWUsIGF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpO1xuICAgICAgY29uc3Qgd3JhcHBlciA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvbS5jcmVhdGUobmFtZSwgYXR0cnMpKTtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gbmV4dCA/IG5leHRTaWJsaW5ncyhzdGFydCkgOiBwcmV2U2libGluZ3Moc3RhcnQpO1xuICAgICAgYXBwZW5kKHdyYXBwZXIsIHNpYmxpbmdzKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGJlZm9yZSQzKHN0YXJ0LCB3cmFwcGVyKTtcbiAgICAgICAgcHJlcGVuZCh3cmFwcGVyLCBzdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlciQ0KHN0YXJ0LCB3cmFwcGVyKTtcbiAgICAgICAgYXBwZW5kJDEod3JhcHBlciwgc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXIuZG9tO1xuICAgIH07XG4gICAgY29uc3QgaXNDb2xvckZvcm1hdEFuZEFuY2hvciA9IChub2RlLCBmb3JtYXQpID0+IGZvcm1hdC5saW5rcyAmJiBub2RlLm5vZGVOYW1lID09PSAnQSc7XG4gICAgY29uc3QgcmVtb3ZlTm9kZSA9IChlZCwgbm9kZSwgZm9ybWF0KSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgbGV0IHJvb3RCbG9ja0VsbTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkLmRvbTtcbiAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZCk7XG4gICAgICBpZiAoaXNCbG9ja0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlID09PSBkb20uZ2V0Um9vdCgpKSB7XG4gICAgICAgICAgaWYgKCFmb3JtYXQubGlzdF9ibG9jayB8fCAhaXNFcSQyKG5vZGUsIGZvcm1hdC5saXN0X2Jsb2NrKSkge1xuICAgICAgICAgICAgZWFjaCRlKGZyb20obm9kZS5jaGlsZE5vZGVzKSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGVkLCBmb3JjZWRSb290QmxvY2ssIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RCbG9ja0VsbSkge1xuICAgICAgICAgICAgICAgICAgcm9vdEJsb2NrRWxtID0gd3JhcCQxKGRvbSwgbm9kZSwgZm9yY2VkUm9vdEJsb2NrKTtcbiAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJzKHJvb3RCbG9ja0VsbSwgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcm9vdEJsb2NrRWxtLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290QmxvY2tFbG0gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc01peGVkRm9ybWF0KGZvcm1hdCkgJiYgIWlzRXEkMihmb3JtYXQuaW5saW5lLCBub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20ucmVtb3ZlKG5vZGUsIHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0Zvcm1hdEF0dHJPclN0eWxlID0gKG5hbWUsIHZhbHVlLCB2YXJzKSA9PiB7XG4gICAgICBpZiAoaXNOdW1iZXIobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiB2YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlOiByZXBsYWNlVmFycyh2YWx1ZSwgdmFycylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUVtcHR5U3R5bGVBdHRyaWJ1dGVJZk5lZWRlZCA9IChkb20sIGVsbSkgPT4ge1xuICAgICAgaWYgKGRvbS5nZXRBdHRyaWIoZWxtLCAnc3R5bGUnKSA9PT0gJycpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZVN0eWxlcyA9IChkb20sIGVsbSwgZm9ybWF0LCB2YXJzLCBjb21wYXJlTm9kZSkgPT4ge1xuICAgICAgbGV0IHN0eWxlc01vZGlmaWVkID0gZmFsc2U7XG4gICAgICBlYWNoJDcoZm9ybWF0LnN0eWxlcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBuYW1lOiBzdHlsZU5hbWUsXG4gICAgICAgICAgdmFsdWU6IHN0eWxlVmFsdWVcbiAgICAgICAgfSA9IHByb2Nlc3NGb3JtYXRBdHRyT3JTdHlsZShuYW1lLCB2YWx1ZSwgdmFycyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTdHlsZVZhbHVlID0gbm9ybWFsaXplU3R5bGVWYWx1ZShzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgICBpZiAoZm9ybWF0LnJlbW92ZV9zaW1pbGFyIHx8IGlzTnVsbChzdHlsZVZhbHVlKSB8fCAhaXNFbGVtZW50JDYoY29tcGFyZU5vZGUpIHx8IGlzRXEkMihnZXRTdHlsZShkb20sIGNvbXBhcmVOb2RlLCBzdHlsZU5hbWUpLCBub3JtYWxpemVkU3R5bGVWYWx1ZSkpIHtcbiAgICAgICAgICBkb20uc2V0U3R5bGUoZWxtLCBzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChzdHlsZXNNb2RpZmllZCkge1xuICAgICAgICByZW1vdmVFbXB0eVN0eWxlQXR0cmlidXRlSWZOZWVkZWQoZG9tLCBlbG0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlTGlzdFN0eWxlRm9ybWF0cyA9IChlZGl0b3IsIG5hbWUsIHZhcnMpID0+IHtcbiAgICAgIGlmIChuYW1lID09PSAncmVtb3ZlZm9ybWF0Jykge1xuICAgICAgICBlYWNoJGUoZ2V0UGFydGlhbGx5U2VsZWN0ZWRMaXN0SXRlbXMoZWRpdG9yLnNlbGVjdGlvbiksIGxpID0+IHtcbiAgICAgICAgICBlYWNoJGUobGlzdEl0ZW1TdHlsZXMsIG5hbWUgPT4gZWRpdG9yLmRvbS5zZXRTdHlsZShsaSwgbmFtZSwgJycpKTtcbiAgICAgICAgICByZW1vdmVFbXB0eVN0eWxlQXR0cmlidXRlSWZOZWVkZWQoZWRpdG9yLmRvbSwgbGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldEV4cGFuZGVkTGlzdEl0ZW1Gb3JtYXQoZWRpdG9yLmZvcm1hdHRlciwgbmFtZSkuZWFjaChsaUZtdCA9PiB7XG4gICAgICAgICAgZWFjaCRlKGdldFBhcnRpYWxseVNlbGVjdGVkTGlzdEl0ZW1zKGVkaXRvci5zZWxlY3Rpb24pLCBsaSA9PiByZW1vdmVTdHlsZXMoZWRpdG9yLmRvbSwgbGksIGxpRm10LCB2YXJzLCBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlTm9kZUZvcm1hdEludGVybmFsID0gKGVkLCBmb3JtYXQsIHZhcnMsIG5vZGUsIGNvbXBhcmVOb2RlKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBjb25zdCBlbGVtZW50VXRpbHMgPSBFbGVtZW50VXRpbHMoZWQpO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWQuc2NoZW1hO1xuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgJiYgaXNUcmFuc3BhcmVudEVsZW1lbnROYW1lKHNjaGVtYSwgZm9ybWF0LmlubGluZSkgJiYgaXNUcmFuc3BhcmVudEJsb2NrKHNjaGVtYSwgbm9kZSkgJiYgbm9kZS5wYXJlbnRFbGVtZW50ID09PSBlZC5nZXRCb2R5KCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShlZCwgbm9kZSwgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5yZW1vdmVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdC5jZUZhbHNlT3ZlcnJpZGUgJiYgbm9kZSAmJiBkb20uZ2V0Q29udGVudEVkaXRhYmxlUGFyZW50KG5vZGUpID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVSZXN1bHQua2VlcCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgJiYgIW1hdGNoTmFtZShkb20sIG5vZGUsIGZvcm1hdCkgJiYgIWlzQ29sb3JGb3JtYXRBbmRBbmNob3Iobm9kZSwgZm9ybWF0KSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LmtlZXAoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsbSA9IG5vZGU7XG4gICAgICBjb25zdCBwcmVzZXJ2ZUF0dHJpYnV0ZXMgPSBmb3JtYXQucHJlc2VydmVfYXR0cmlidXRlcztcbiAgICAgIGlmIChpc0lubGluZUZvcm1hdChmb3JtYXQpICYmIGZvcm1hdC5yZW1vdmUgPT09ICdhbGwnICYmIGlzQXJyYXkkMShwcmVzZXJ2ZUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzVG9QcmVzZXJ2ZSA9IGZpbHRlciQ1KGRvbS5nZXRBdHRyaWJzKGVsbSksIGF0dHIgPT4gY29udGFpbnMkMihwcmVzZXJ2ZUF0dHJpYnV0ZXMsIGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIGRvbS5yZW1vdmVBbGxBdHRyaWJzKGVsbSk7XG4gICAgICAgIGVhY2gkZShhdHRyc1RvUHJlc2VydmUsIGF0dHIgPT4gZG9tLnNldEF0dHJpYihlbG0sIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpO1xuICAgICAgICBpZiAoYXR0cnNUb1ByZXNlcnZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LnJlbmFtZSgnc3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0LnJlbW92ZSAhPT0gJ2FsbCcpIHtcbiAgICAgICAgcmVtb3ZlU3R5bGVzKGRvbSwgZWxtLCBmb3JtYXQsIHZhcnMsIGNvbXBhcmVOb2RlKTtcbiAgICAgICAgZWFjaCQ3KGZvcm1hdC5hdHRyaWJ1dGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBuYW1lOiBhdHRyTmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgICAgICB9ID0gcHJvY2Vzc0Zvcm1hdEF0dHJPclN0eWxlKG5hbWUsIHZhbHVlLCB2YXJzKTtcbiAgICAgICAgICBpZiAoZm9ybWF0LnJlbW92ZV9zaW1pbGFyIHx8IGlzTnVsbChhdHRyVmFsdWUpIHx8ICFpc0VsZW1lbnQkNihjb21wYXJlTm9kZSkgfHwgaXNFcSQyKGRvbS5nZXRBdHRyaWIoY29tcGFyZU5vZGUsIGF0dHJOYW1lKSwgYXR0clZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRvbS5nZXRBdHRyaWIoZWxtLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVPdXQgPSAnJztcbiAgICAgICAgICAgICAgICBlYWNoJGUoY3VycmVudFZhbHVlLnNwbGl0KC9cXHMrLyksIGNscyA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoL21jZVxcLVxcdysvLnRlc3QoY2xzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZU91dCArPSAodmFsdWVPdXQgPyAnICcgOiAnJykgKyBjbHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlT3V0KSB7XG4gICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKGVsbSwgYXR0ck5hbWUsIHZhbHVlT3V0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNQ0VfQVRUUl9SRS50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1jZS0nICsgYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAnc3R5bGUnICYmIG1hdGNoTm9kZU5hbWVzKFsnbGknXSkoZWxtKSAmJiBkb20uZ2V0U3R5bGUoZWxtLCAnbGlzdC1zdHlsZS10eXBlJykgPT09ICdub25lJykge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKGVsbSwgJ2xpc3Qtc3R5bGUtdHlwZScsICdub25lJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzc05hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2gkNyhmb3JtYXQuY2xhc3NlcywgdmFsdWUgPT4ge1xuICAgICAgICAgIHZhbHVlID0gcmVwbGFjZVZhcnModmFsdWUsIHZhcnMpO1xuICAgICAgICAgIGlmICghaXNFbGVtZW50JDYoY29tcGFyZU5vZGUpIHx8IGRvbS5oYXNDbGFzcyhjb21wYXJlTm9kZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZWxtLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBkb20uZ2V0QXR0cmlicyhlbG0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBhdHRyc1tpXS5ub2RlTmFtZTtcbiAgICAgICAgICBpZiAoIWVsZW1lbnRVdGlscy5pc0F0dHJpYnV0ZUludGVybmFsKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5rZWVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0LnJlbW92ZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoZWQsIGVsbSwgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVJlc3VsdC5yZW1vdmVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlUmVzdWx0LmtlZXAoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRGb3JtYXRSb290ID0gKGVkaXRvciwgY29udGFpbmVyLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiB7XG4gICAgICBsZXQgZm9ybWF0Um9vdDtcbiAgICAgIGlmIChjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBlYWNoJGUoZ2V0UGFyZW50cyQyKGVkaXRvci5kb20sIGNvbnRhaW5lci5wYXJlbnROb2RlKS5yZXZlcnNlKCksIHBhcmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFmb3JtYXRSb290ICYmIGlzRWxlbWVudCQ2KHBhcmVudCkgJiYgcGFyZW50LmlkICE9PSAnX3N0YXJ0JyAmJiBwYXJlbnQuaWQgIT09ICdfZW5kJykge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gbWF0Y2hOb2RlKGVkaXRvciwgcGFyZW50LCBuYW1lLCB2YXJzLCBzaW1pbGFyKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgJiYgZm9ybWF0LnNwbGl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBmb3JtYXRSb290ID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9ybWF0Um9vdDtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU5vZGVGb3JtYXRGcm9tQ2xvbmUgPSAoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIGNsb25lKSA9PiByZW1vdmVOb2RlRm9ybWF0SW50ZXJuYWwoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIGNsb25lLCBjbG9uZSkuZm9sZChjb25zdGFudChjbG9uZSksIG5ld05hbWUgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBlZGl0b3IuZG9tLmNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gZWRpdG9yLmRvbS5yZW5hbWUoY2xvbmUsIG5ld05hbWUpO1xuICAgIH0sIGNvbnN0YW50KG51bGwpKTtcbiAgICBjb25zdCB3cmFwQW5kU3BsaXQgPSAoZWRpdG9yLCBmb3JtYXRMaXN0LCBmb3JtYXRSb290LCBjb250YWluZXIsIHRhcmdldCwgc3BsaXQsIGZvcm1hdCwgdmFycykgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGxldCBsYXN0Q2xvbmU7XG4gICAgICBsZXQgZmlyc3RDbG9uZTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBpZiAoZm9ybWF0Um9vdCkge1xuICAgICAgICBjb25zdCBmb3JtYXRSb290UGFyZW50ID0gZm9ybWF0Um9vdC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTsgcGFyZW50ICYmIHBhcmVudCAhPT0gZm9ybWF0Um9vdFBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBsZXQgY2xvbmUgPSBkb20uY2xvbmUocGFyZW50LCBmYWxzZSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9uZSA9IHJlbW92ZU5vZGVGb3JtYXRGcm9tQ2xvbmUoZWRpdG9yLCBmb3JtYXRMaXN0W2ldLCB2YXJzLCBjbG9uZSk7XG4gICAgICAgICAgICBpZiAoY2xvbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbG9uZSkge1xuICAgICAgICAgICAgaWYgKGxhc3RDbG9uZSkge1xuICAgICAgICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChsYXN0Q2xvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaXJzdENsb25lKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q2xvbmUgPSBjbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDbG9uZSA9IGNsb25lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXQgJiYgKCFmb3JtYXQubWl4ZWQgfHwgIWRvbS5pc0Jsb2NrKGZvcm1hdFJvb3QpKSkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IChfYSA9IGRvbS5zcGxpdChmb3JtYXRSb290LCBjb250YWluZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RDbG9uZSAmJiBmaXJzdENsb25lKSB7XG4gICAgICAgICAgKF9iID0gdGFyZ2V0LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnNlcnRCZWZvcmUobGFzdENsb25lLCB0YXJnZXQpO1xuICAgICAgICAgIGZpcnN0Q2xvbmUuYXBwZW5kQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgbWVyZ2VTaWJsaW5ncyhlZGl0b3IsIGZvcm1hdCwgdmFycywgbGFzdENsb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXRJbnRlcm5hbCA9IChlZCwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0TGlzdCA9IGVkLmZvcm1hdHRlci5nZXQobmFtZSk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXRMaXN0WzBdO1xuICAgICAgY29uc3QgZG9tID0gZWQuZG9tO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWQuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc3BsaXRUb0Zvcm1hdFJvb3QgPSBjb250YWluZXIgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRSb290ID0gZmluZEZvcm1hdFJvb3QoZWQsIGNvbnRhaW5lciwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgICAgIHJldHVybiB3cmFwQW5kU3BsaXQoZWQsIGZvcm1hdExpc3QsIGZvcm1hdFJvb3QsIGNvbnRhaW5lciwgY29udGFpbmVyLCB0cnVlLCBmb3JtYXQsIHZhcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzUmVtb3ZlQm9va21hcmtOb2RlID0gbm9kZSA9PiBpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpICYmIGlzRWxlbWVudCQ2KG5vZGUpICYmIChub2RlLmlkID09PSAnX3N0YXJ0JyB8fCBub2RlLmlkID09PSAnX2VuZCcpO1xuICAgICAgY29uc3QgcmVtb3ZlRm9ybWF0T25Ob2RlID0gbm9kZSA9PiBleGlzdHMoZm9ybWF0TGlzdCwgZm10ID0+IHJlbW92ZU5vZGVGb3JtYXQoZWQsIGZtdCwgdmFycywgbm9kZSwgbm9kZSkpO1xuICAgICAgY29uc3QgcHJvY2VzcyA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZUZvcm1hdE9uTm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGVNYXRjaGVzID0gcmVtb3ZlZCB8fCBleGlzdHMoZm9ybWF0TGlzdCwgZiA9PiBtYXRjaE5hbWUoZG9tLCBub2RlLCBmKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghY3VycmVudE5vZGVNYXRjaGVzICYmIGlzTm9uTnVsbGFibGUocGFyZW50Tm9kZSkgJiYgc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgICAgcmVtb3ZlRm9ybWF0T25Ob2RlKHBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQuZGVlcCkge1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcHJvY2VzcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAndW5kZXJsaW5lJyxcbiAgICAgICAgICAnbGluZS10aHJvdWdoJyxcbiAgICAgICAgICAnb3ZlcmxpbmUnXG4gICAgICAgIF07XG4gICAgICAgIGVhY2gkZSh0ZXh0RGVjb3JhdGlvbnMsIGRlY29yYXRpb24gPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiBlZC5kb20uZ2V0U3R5bGUobm9kZSwgJ3RleHQtZGVjb3JhdGlvbicpID09PSBkZWNvcmF0aW9uICYmIG5vZGUucGFyZW50Tm9kZSAmJiBnZXRUZXh0RGVjb3JhdGlvbihkb20sIG5vZGUucGFyZW50Tm9kZSkgPT09IGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGVGb3JtYXQoZWQsIHtcbiAgICAgICAgICAgICAgZGVlcDogZmFsc2UsXG4gICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgICAgc3R5bGVzOiB7IHRleHREZWNvcmF0aW9uOiBkZWNvcmF0aW9uIH1cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bndyYXAgPSBzdGFydCA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb20uZ2V0KHN0YXJ0ID8gJ19zdGFydCcgOiAnX2VuZCcpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGxldCBvdXQgPSBub2RlW3N0YXJ0ID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgICAgIGlmIChpc1JlbW92ZUJvb2ttYXJrTm9kZShvdXQpKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXRbc3RhcnQgPyAnZmlyc3RDaGlsZCcgOiAnbGFzdENoaWxkJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RleHQkYShvdXQpICYmIG91dC5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3V0ID0gc3RhcnQgPyBub2RlLnByZXZpb3VzU2libGluZyB8fCBub2RlLm5leHRTaWJsaW5nIDogbm9kZS5uZXh0U2libGluZyB8fCBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlUm5nU3R5bGUgPSBybmcgPT4ge1xuICAgICAgICBsZXQgc3RhcnRDb250YWluZXI7XG4gICAgICAgIGxldCBlbmRDb250YWluZXI7XG4gICAgICAgIGxldCBleHBhbmRlZFJuZyA9IGV4cGFuZFJuZyhkb20sIHJuZywgZm9ybWF0TGlzdCwgcm5nLmNvbGxhcHNlZCk7XG4gICAgICAgIGlmIChmb3JtYXQuc3BsaXQpIHtcbiAgICAgICAgICBleHBhbmRlZFJuZyA9IHNwbGl0KGV4cGFuZGVkUm5nKTtcbiAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGdldENvbnRhaW5lcihlZCwgZXhwYW5kZWRSbmcsIHRydWUpO1xuICAgICAgICAgIGVuZENvbnRhaW5lciA9IGdldENvbnRhaW5lcihlZCwgZXhwYW5kZWRSbmcpO1xuICAgICAgICAgIGlmIChzdGFydENvbnRhaW5lciAhPT0gZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IG5vcm1hbGl6ZVRhYmxlU2VsZWN0aW9uKHN0YXJ0Q29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IG5vcm1hbGl6ZVRhYmxlU2VsZWN0aW9uKGVuZENvbnRhaW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGlzQ2hpbGRPZklubGluZVBhcmVudChkb20sIHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IE9wdGlvbmFsLmZyb20oc3RhcnRDb250YWluZXIuZmlyc3RDaGlsZCkuZ2V0T3Ioc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICBzcGxpdFRvRm9ybWF0Um9vdCh3cmFwV2l0aFNpYmxpbmdzKGRvbSwgbWFya2VyLCB0cnVlLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAnaWQnOiAnX3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB1bndyYXAodHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NoaWxkT2ZJbmxpbmVQYXJlbnQoZG9tLCBlbmRDb250YWluZXIsIHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBPcHRpb25hbC5mcm9tKGVuZENvbnRhaW5lci5sYXN0Q2hpbGQpLmdldE9yKGVuZENvbnRhaW5lcik7XG4gICAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KHdyYXBXaXRoU2libGluZ3MoZG9tLCBtYXJrZXIsIGZhbHNlLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgICAnaWQnOiAnX2VuZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGEtbWNlLXR5cGUnOiAnYm9va21hcmsnXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdW53cmFwKGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRDb250YWluZXIgPSB3cmFwJDEoZG9tLCBzdGFydENvbnRhaW5lciwgJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICdpZCc6ICdfc3RhcnQnLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZW5kQ29udGFpbmVyID0gd3JhcCQxKGRvbSwgZW5kQ29udGFpbmVyLCAnc3BhbicsIHtcbiAgICAgICAgICAgICAgJ2lkJzogJ19lbmQnLFxuICAgICAgICAgICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV3Um5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgbmV3Um5nLnNldFN0YXJ0QWZ0ZXIoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgbmV3Um5nLnNldEVuZEJlZm9yZShlbmRDb250YWluZXIpO1xuICAgICAgICAgICAgd2FsayQzKGRvbSwgbmV3Um5nLCBub2RlcyA9PiB7XG4gICAgICAgICAgICAgIGVhY2gkZShub2RlcywgbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jvb2ttYXJrTm9kZSQxKG4pICYmICFpc0Jvb2ttYXJrTm9kZSQxKG4ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHNwbGl0VG9Gb3JtYXRSb290KGVuZENvbnRhaW5lcik7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHVud3JhcCh0cnVlKTtcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IHVud3JhcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydENvbnRhaW5lciA9IGVuZENvbnRhaW5lciA9IHNwbGl0VG9Gb3JtYXRSb290KHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwYW5kZWRSbmcuc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlID8gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZSA6IHN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgIGV4cGFuZGVkUm5nLnN0YXJ0T2Zmc2V0ID0gZG9tLm5vZGVJbmRleChzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgZXhwYW5kZWRSbmcuZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyLnBhcmVudE5vZGUgPyBlbmRDb250YWluZXIucGFyZW50Tm9kZSA6IGVuZENvbnRhaW5lcjtcbiAgICAgICAgICBleHBhbmRlZFJuZy5lbmRPZmZzZXQgPSBkb20ubm9kZUluZGV4KGVuZENvbnRhaW5lcikgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHdhbGskMyhkb20sIGV4cGFuZGVkUm5nLCBub2RlcyA9PiB7XG4gICAgICAgICAgZWFjaCRlKG5vZGVzLCBwcm9jZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgcm5nLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgICAgIHJlbW92ZVJuZ1N0eWxlKHJuZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlUm5nU3R5bGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZUZvcm1hdFJlbW92ZShlZCwgbmFtZSwgbm9kZSwgdmFycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgZ2V0Q2VsbHNGcm9tRWRpdG9yKGVkKS5sZW5ndGgpIHtcbiAgICAgICAgcHJlc2VydmVTZWxlY3Rpb24oZWQsICgpID0+IHJ1bk9uUmFuZ2VzKGVkLCByZW1vdmVSbmdTdHlsZSksIHN0YXJ0Tm9kZSA9PiBpc0lubGluZUZvcm1hdChmb3JtYXQpICYmIG1hdGNoJDIoZWQsIG5hbWUsIHZhcnMsIHN0YXJ0Tm9kZSkpO1xuICAgICAgICBlZC5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2FyZXRGb3JtYXQoZWQsIG5hbWUsIHZhcnMsIHNpbWlsYXIpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlTGlzdFN0eWxlRm9ybWF0cyhlZCwgbmFtZSwgdmFycyk7XG4gICAgICBmaXJlRm9ybWF0UmVtb3ZlKGVkLCBuYW1lLCBub2RlLCB2YXJzKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUZvcm1hdCQxID0gKGVkLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBpZiAobm9kZSB8fCBlZC5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIHJlbW92ZUZvcm1hdEludGVybmFsKGVkLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU5vZGVGb3JtYXQgPSAoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIG5vZGUsIGNvbXBhcmVOb2RlKSA9PiB7XG4gICAgICByZXR1cm4gcmVtb3ZlTm9kZUZvcm1hdEludGVybmFsKGVkaXRvciwgZm9ybWF0LCB2YXJzLCBub2RlLCBjb21wYXJlTm9kZSkuZm9sZChuZXZlciwgbmV3TmFtZSA9PiB7XG4gICAgICAgIGVkaXRvci5kb20ucmVuYW1lKG5vZGUsIG5ld05hbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sIGFsd2F5cyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkNiA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgbWVyZ2VUZXh0RGVjb3JhdGlvbnNBbmRDb2xvciA9IChkb20sIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcHJvY2Vzc1RleHREZWNvcmF0aW9uc0FuZENvbG9yID0gbiA9PiB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihuKSAmJiBpc0VsZW1lbnQkNihuLnBhcmVudE5vZGUpICYmIGlzRWRpdGFibGUkMihuKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudFRleHREZWNvcmF0aW9uID0gZ2V0VGV4dERlY29yYXRpb24oZG9tLCBuLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGlmIChkb20uZ2V0U3R5bGUobiwgJ2NvbG9yJykgJiYgcGFyZW50VGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJywgcGFyZW50VGV4dERlY29yYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9tLmdldFN0eWxlKG4sICd0ZXh0LWRlY29yYXRpb24nKSA9PT0gcGFyZW50VGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZShuLCAndGV4dC1kZWNvcmF0aW9uJywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGZvcm1hdC5zdHlsZXMgJiYgKGZvcm1hdC5zdHlsZXMuY29sb3IgfHwgZm9ybWF0LnN0eWxlcy50ZXh0RGVjb3JhdGlvbikpIHtcbiAgICAgICAgVG9vbHMud2Fsayhub2RlLCBwcm9jZXNzVGV4dERlY29yYXRpb25zQW5kQ29sb3IsICdjaGlsZE5vZGVzJyk7XG4gICAgICAgIHByb2Nlc3NUZXh0RGVjb3JhdGlvbnNBbmRDb2xvcihub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlQmFja2dyb3VuZENvbG9yQW5kRm9udFNpemUgPSAoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChmb3JtYXQuc3R5bGVzICYmIGZvcm1hdC5zdHlsZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGNvbnN0IGhhc0ZvbnRTaXplID0gaGFzU3R5bGUoZG9tLCAnZm9udFNpemUnKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkRWxlbWVudHMobm9kZSwgZWxtID0+IGhhc0ZvbnRTaXplKGVsbSkgJiYgaXNFZGl0YWJsZSQyKGVsbSksIGFwcGx5U3R5bGUoZG9tLCAnYmFja2dyb3VuZENvbG9yJywgcmVwbGFjZVZhcnMoZm9ybWF0LnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IsIHZhcnMpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVN1YlN1cCA9IChkb20sIGZvcm1hdCwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgJiYgKGZvcm1hdC5pbmxpbmUgPT09ICdzdWInIHx8IGZvcm1hdC5pbmxpbmUgPT09ICdzdXAnKSkge1xuICAgICAgICBjb25zdCBoYXNGb250U2l6ZSA9IGhhc1N0eWxlKGRvbSwgJ2ZvbnRTaXplJyk7XG4gICAgICAgIHByb2Nlc3NDaGlsZEVsZW1lbnRzKG5vZGUsIGVsbSA9PiBoYXNGb250U2l6ZShlbG0pICYmIGlzRWRpdGFibGUkMihlbG0pLCBhcHBseVN0eWxlKGRvbSwgJ2ZvbnRTaXplJywgJycpKTtcbiAgICAgICAgY29uc3QgaW52ZXJzZVRhZ0Rlc2NlbmRhbnRzID0gZmlsdGVyJDUoZG9tLnNlbGVjdChmb3JtYXQuaW5saW5lID09PSAnc3VwJyA/ICdzdWInIDogJ3N1cCcsIG5vZGUpLCBpc0VkaXRhYmxlJDIpO1xuICAgICAgICBkb20ucmVtb3ZlKGludmVyc2VUYWdEZXNjZW5kYW50cywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZVdpdGhDaGlsZHJlbiA9IChlZGl0b3IsIGZvcm1hdExpc3QsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGVhY2gkNihmb3JtYXRMaXN0LCBmb3JtYXQgPT4ge1xuICAgICAgICBpZiAoaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgIGVhY2gkNihlZGl0b3IuZG9tLnNlbGVjdChmb3JtYXQuaW5saW5lLCBub2RlKSwgY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZU5vZGVGb3JtYXQoZWRpdG9yLCBmb3JtYXQsIHZhcnMsIGNoaWxkLCBmb3JtYXQuZXhhY3QgPyBjaGlsZCA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ2hpbGRTdHlsZXMoZWRpdG9yLmRvbSwgZm9ybWF0LCBub2RlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VXaXRoUGFyZW50cyA9IChlZGl0b3IsIGZvcm1hdCwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChtYXRjaE5vZGUoZWRpdG9yLCBwYXJlbnROb2RlLCBuYW1lLCB2YXJzKSkge1xuICAgICAgICBpZiAocmVtb3ZlTm9kZUZvcm1hdChlZGl0b3IsIGZvcm1hdCwgdmFycywgbm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQubWVyZ2Vfd2l0aF9wYXJlbnRzICYmIHBhcmVudE5vZGUpIHtcbiAgICAgICAgZWRpdG9yLmRvbS5nZXRQYXJlbnQocGFyZW50Tm9kZSwgcGFyZW50ID0+IHtcbiAgICAgICAgICBpZiAobWF0Y2hOb2RlKGVkaXRvciwgcGFyZW50LCBuYW1lLCB2YXJzKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZUZvcm1hdChlZGl0b3IsIGZvcm1hdCwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkNSA9IFRvb2xzLmVhY2g7XG4gICAgY29uc3QgY2FuRm9ybWF0QlIgPSAoZWRpdG9yLCBmb3JtYXQsIG5vZGUsIHBhcmVudE5hbWUpID0+IHtcbiAgICAgIGlmIChjYW5Gb3JtYXRFbXB0eUxpbmVzKGVkaXRvcikgJiYgaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsaWRCUlBhcmVudEVsZW1lbnRzID0gZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzKGVkaXRvci5zY2hlbWEpO1xuICAgICAgICBjb25zdCBoYXNDYXJldE5vZGVTaWJsaW5nID0gc2libGluZyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgc2libGluZyA9PiBpc0NhcmV0Tm9kZShzaWJsaW5nLmRvbSkpO1xuICAgICAgICByZXR1cm4gaGFzTm9uTnVsbGFibGVLZXkodmFsaWRCUlBhcmVudEVsZW1lbnRzLCBwYXJlbnROYW1lKSAmJiBpc0VtcHR5JDIoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZS5wYXJlbnROb2RlKSwgZmFsc2UpICYmICFoYXNDYXJldE5vZGVTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlTdHlsZXMgPSAoZG9tLCBlbG0sIGZvcm1hdCwgdmFycykgPT4ge1xuICAgICAgZWFjaCQ1KGZvcm1hdC5zdHlsZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICBkb20uc2V0U3R5bGUoZWxtLCBuYW1lLCByZXBsYWNlVmFycyh2YWx1ZSwgdmFycykpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZm9ybWF0LnN0eWxlcykge1xuICAgICAgICBjb25zdCBzdHlsZVZhbCA9IGRvbS5nZXRBdHRyaWIoZWxtLCAnc3R5bGUnKTtcbiAgICAgICAgaWYgKHN0eWxlVmFsKSB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihlbG0sICdkYXRhLW1jZS1zdHlsZScsIHN0eWxlVmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlGb3JtYXRBY3Rpb24gPSAoZWQsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBlZC5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TGlzdFswXTtcbiAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gIW5vZGUgJiYgZWQuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gICAgICBjb25zdCBkb20gPSBlZC5kb207XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZC5zZWxlY3Rpb247XG4gICAgICBjb25zdCBzZXRFbGVtZW50Rm9ybWF0ID0gKGVsbSwgZm10ID0gZm9ybWF0KSA9PiB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZtdC5vbmZvcm1hdCkpIHtcbiAgICAgICAgICBmbXQub25mb3JtYXQoZWxtLCBmbXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5U3R5bGVzKGRvbSwgZWxtLCBmbXQsIHZhcnMpO1xuICAgICAgICBlYWNoJDUoZm10LmF0dHJpYnV0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGRvbS5zZXRBdHRyaWIoZWxtLCBuYW1lLCByZXBsYWNlVmFycyh2YWx1ZSwgdmFycykpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCQ1KGZtdC5jbGFzc2VzLCB2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZXBsYWNlVmFycyh2YWx1ZSwgdmFycyk7XG4gICAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3MoZWxtLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhlbG0sIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFwcGx5Tm9kZVN0eWxlID0gKGZvcm1hdExpc3QsIG5vZGUpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGVhY2gkNShmb3JtYXRMaXN0LCBmb3JtYXQgPT4ge1xuICAgICAgICAgIGlmICghaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpID09PSAnZmFsc2UnICYmICFmb3JtYXQuY2VGYWxzZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZm9ybWF0LmNvbGxhcHNlZCkgJiYgZm9ybWF0LmNvbGxhcHNlZCAhPT0gaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9tLmlzKG5vZGUsIGZvcm1hdC5zZWxlY3RvcikgJiYgIWlzQ2FyZXROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KG5vZGUsIGZvcm1hdCk7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyZWF0ZVdyYXBFbGVtZW50ID0gd3JhcE5hbWUgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcod3JhcE5hbWUpKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcEVsbSA9IGRvbS5jcmVhdGUod3JhcE5hbWUpO1xuICAgICAgICAgIHNldEVsZW1lbnRGb3JtYXQod3JhcEVsbSk7XG4gICAgICAgICAgcmV0dXJuIHdyYXBFbG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBhcHBseVJuZ1N0eWxlID0gKGRvbSwgcm5nLCBub2RlU3BlY2lmaWMpID0+IHtcbiAgICAgICAgY29uc3QgbmV3V3JhcHBlcnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHdyYXBOYW1lID0gZm9ybWF0LmlubGluZSB8fCBmb3JtYXQuYmxvY2s7XG4gICAgICAgIGNvbnN0IHdyYXBFbG0gPSBjcmVhdGVXcmFwRWxlbWVudCh3cmFwTmFtZSk7XG4gICAgICAgIGNvbnN0IGlzTWF0Y2hpbmdXcmFwcGluZ0Jsb2NrID0gbm9kZSA9PiBpc1dyYXBwaW5nQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBtYXRjaE5vZGUoZWQsIG5vZGUsIG5hbWUsIHZhcnMpO1xuICAgICAgICBjb25zdCBjYW5SZW5hbWVCbG9jayA9IChub2RlLCBwYXJlbnROYW1lLCBpc0VkaXRhYmxlRGVzY2VuZGFudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWRCbG9ja0Zvcm1hdEZvck5vZGUgPSBpc05vbldyYXBwaW5nQmxvY2tGb3JtYXQoZm9ybWF0KSAmJiBpc1RleHRCbG9jayQxKGVkLnNjaGVtYSwgbm9kZSkgJiYgaXNWYWxpZChlZCwgcGFyZW50TmFtZSwgd3JhcE5hbWUpO1xuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlRGVzY2VuZGFudCAmJiBpc1ZhbGlkQmxvY2tGb3JtYXRGb3JOb2RlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYW5XcmFwTm9kZSA9IChub2RlLCBwYXJlbnROYW1lLCBpc0VkaXRhYmxlRGVzY2VuZGFudCwgaXNXcmFwcGFibGVOb25lZGl0YWJsZUVsbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWRXcmFwTm9kZSA9IGlzVmFsaWQoZWQsIHdyYXBOYW1lLCBub2RlTmFtZSkgJiYgaXNWYWxpZChlZCwgcGFyZW50TmFtZSwgd3JhcE5hbWUpO1xuICAgICAgICAgIGNvbnN0IGlzWndzcCA9ICFub2RlU3BlY2lmaWMgJiYgaXNUZXh0JGEobm9kZSkgJiYgaXNad3NwJDEobm9kZS5kYXRhKTtcbiAgICAgICAgICBjb25zdCBpc0NhcmV0ID0gaXNDYXJldE5vZGUobm9kZSk7XG4gICAgICAgICAgY29uc3QgaXNDb3JyZWN0Rm9ybWF0Rm9yTm9kZSA9ICFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8ICFkb20uaXNCbG9jayhub2RlKTtcbiAgICAgICAgICByZXR1cm4gKGlzRWRpdGFibGVEZXNjZW5kYW50IHx8IGlzV3JhcHBhYmxlTm9uZWRpdGFibGVFbG0pICYmIGlzVmFsaWRXcmFwTm9kZSAmJiAhaXNad3NwICYmICFpc0NhcmV0ICYmIGlzQ29ycmVjdEZvcm1hdEZvck5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIHdhbGskMyhkb20sIHJuZywgbm9kZXMgPT4ge1xuICAgICAgICAgIGxldCBjdXJyZW50V3JhcEVsbTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzID0gbm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGFzQ29udGVudEVkaXRhYmxlU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBsYXN0Q29udGVudEVkaXRhYmxlID0gY29udGVudEVkaXRhYmxlO1xuICAgICAgICAgICAgbGV0IGlzV3JhcHBhYmxlTm9uZWRpdGFibGVFbG0gPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudEVkaXRhYmxlVmFsdWUgPSBkb20uZ2V0Q29udGVudEVkaXRhYmxlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY29udGVudEVkaXRhYmxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGxhc3RDb250ZW50RWRpdGFibGUgPSBjb250ZW50RWRpdGFibGU7XG4gICAgICAgICAgICAgIGNvbnRlbnRFZGl0YWJsZSA9IGNvbnRlbnRFZGl0YWJsZVZhbHVlID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgIGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXNXcmFwcGFibGVOb25lZGl0YWJsZUVsbSA9IGlzV3JhcHBhYmxlTm9uZWRpdGFibGUoZWQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNFZGl0YWJsZURlc2NlbmRhbnQgPSBjb250ZW50RWRpdGFibGUgJiYgIWhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlO1xuICAgICAgICAgICAgaWYgKGlzQnIkNihub2RlKSAmJiAhY2FuRm9ybWF0QlIoZWQsIGZvcm1hdCwgbm9kZSwgcGFyZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoaXNCbG9ja0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNNYXRjaGluZ1dyYXBwaW5nQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuUmVuYW1lQmxvY2sobm9kZSwgcGFyZW50TmFtZSwgaXNFZGl0YWJsZURlc2NlbmRhbnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsbSA9IGRvbS5yZW5hbWUobm9kZSwgd3JhcE5hbWUpO1xuICAgICAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KGVsbSk7XG4gICAgICAgICAgICAgIG5ld1dyYXBwZXJzLnB1c2goZWxtKTtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgIGxldCBmb3VuZCA9IGFwcGx5Tm9kZVN0eWxlKGZvcm1hdExpc3QsIG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoIWZvdW5kICYmIGlzTm9uTnVsbGFibGUocGFyZW50Tm9kZSkgJiYgc2hvdWxkRXhwYW5kVG9TZWxlY3Rvcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBhcHBseU5vZGVTdHlsZShmb3JtYXRMaXN0LCBwYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgZm91bmQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZSh3cmFwRWxtKSAmJiBjYW5XcmFwTm9kZShub2RlLCBwYXJlbnROYW1lLCBpc0VkaXRhYmxlRGVzY2VuZGFudCwgaXNXcmFwcGFibGVOb25lZGl0YWJsZUVsbSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50V3JhcEVsbSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtID0gZG9tLmNsb25lKHdyYXBFbG0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjdXJyZW50V3JhcEVsbSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgbmV3V3JhcHBlcnMucHVzaChjdXJyZW50V3JhcEVsbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzV3JhcHBhYmxlTm9uZWRpdGFibGVFbG0gJiYgaGFzQ29udGVudEVkaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RWRpdGFibGUgPSBsYXN0Q29udGVudEVkaXRhYmxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRXcmFwRWxtLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudFdyYXBFbG0gPSBudWxsO1xuICAgICAgICAgICAgICBlYWNoJGUoZnJvbShub2RlLmNoaWxkTm9kZXMpLCBwcm9jZXNzKTtcbiAgICAgICAgICAgICAgaWYgKGhhc0NvbnRlbnRFZGl0YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEVkaXRhYmxlID0gbGFzdENvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50V3JhcEVsbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlYWNoJGUobm9kZXMsIHByb2Nlc3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvcm1hdC5saW5rcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVhY2gkZShuZXdXcmFwcGVycywgbm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gbm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50Rm9ybWF0KG5vZGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWFjaCRlKGZyb20obm9kZS5jaGlsZE5vZGVzKSwgcHJvY2Vzcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2Vzcyhub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoJGUobmV3V3JhcHBlcnMsIG5vZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGdldENoaWxkQ291bnQgPSBub2RlID0+IHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBlYWNoJGUobm9kZS5jaGlsZE5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5VGV4dE5vZGUkMShub2RlKSAmJiAhaXNCb29rbWFya05vZGUkMShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbWVyZ2VTdHlsZXMgPSBub2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxlbWVudCA9IGZpbmQkMihub2RlLmNoaWxkTm9kZXMsIGlzRWxlbWVudE5vZGUkMSkuZmlsdGVyKGNoaWxkID0+IGRvbS5nZXRDb250ZW50RWRpdGFibGUoY2hpbGQpICE9PSAnZmFsc2UnICYmIG1hdGNoTmFtZShkb20sIGNoaWxkLCBmb3JtYXQpKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZEVsZW1lbnQubWFwKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBkb20uY2xvbmUoY2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgc2V0RWxlbWVudEZvcm1hdChjbG9uZSk7XG4gICAgICAgICAgICAgIGRvbS5yZXBsYWNlKGNsb25lLCBub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZShjaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgIH0pLmdldE9yKG5vZGUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQobm9kZSk7XG4gICAgICAgICAgaWYgKChuZXdXcmFwcGVycy5sZW5ndGggPiAxIHx8ICFkb20uaXNCbG9jayhub2RlKSkgJiYgY2hpbGRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSW5saW5lRm9ybWF0KGZvcm1hdCkgfHwgaXNCbG9ja0Zvcm1hdChmb3JtYXQpICYmIGZvcm1hdC53cmFwcGVyKSB7XG4gICAgICAgICAgICBpZiAoIWZvcm1hdC5leGFjdCAmJiBjaGlsZENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBtZXJnZVN0eWxlcyhub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlV2l0aENoaWxkcmVuKGVkLCBmb3JtYXRMaXN0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlV2l0aFBhcmVudHMoZWQsIGZvcm1hdCwgbmFtZSwgdmFycywgbm9kZSk7XG4gICAgICAgICAgICBtZXJnZUJhY2tncm91bmRDb2xvckFuZEZvbnRTaXplKGRvbSwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICAgIG1lcmdlVGV4dERlY29yYXRpb25zQW5kQ29sb3IoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgICAgbWVyZ2VTdWJTdXAoZG9tLCBmb3JtYXQsIHZhcnMsIG5vZGUpO1xuICAgICAgICAgICAgbWVyZ2VTaWJsaW5ncyhlZCwgZm9ybWF0LCB2YXJzLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBpc05vZGUobm9kZSkgPyBub2RlIDogc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChkb20uZ2V0Q29udGVudEVkaXRhYmxlKHRhcmdldE5vZGUpID09PSAnZmFsc2UnICYmICFpc1dyYXBwYWJsZU5vbmVkaXRhYmxlKGVkLCB0YXJnZXROb2RlKSkge1xuICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYXBwbHlOb2RlU3R5bGUoZm9ybWF0TGlzdCwgbm9kZSk7XG4gICAgICAgIGZpcmVGb3JtYXRBcHBseShlZCwgbmFtZSwgbm9kZSwgdmFycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIWFwcGx5Tm9kZVN0eWxlKGZvcm1hdExpc3QsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgICBybmcuc2V0RW5kQWZ0ZXIobm9kZSk7XG4gICAgICAgICAgICAgIGFwcGx5Um5nU3R5bGUoZG9tLCBleHBhbmRSbmcoZG9tLCBybmcsIGZvcm1hdExpc3QpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlSbmdTdHlsZShkb20sIG5vZGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VkIHx8ICFpc0lubGluZUZvcm1hdChmb3JtYXQpIHx8IGdldENlbGxzRnJvbUVkaXRvcihlZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKG5vcm1hbGl6ZShzZWxlY3Rpb24uZ2V0Um5nKCkpKTtcbiAgICAgICAgICAgIHByZXNlcnZlU2VsZWN0aW9uKGVkLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJ1bk9uUmFuZ2VzKGVkLCAoc2VsZWN0aW9uUm5nLCBmYWtlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRSbmcgPSBmYWtlID8gc2VsZWN0aW9uUm5nIDogZXhwYW5kUm5nKGRvbSwgc2VsZWN0aW9uUm5nLCBmb3JtYXRMaXN0KTtcbiAgICAgICAgICAgICAgICBhcHBseVJuZ1N0eWxlKGRvbSwgZXhwYW5kZWRSbmcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBhbHdheXMpO1xuICAgICAgICAgICAgZWQubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwbHlDYXJldEZvcm1hdChlZCwgbmFtZSwgdmFycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEV4cGFuZGVkTGlzdEl0ZW1Gb3JtYXQoZWQuZm9ybWF0dGVyLCBuYW1lKS5lYWNoKGxpRm10ID0+IHtcbiAgICAgICAgICAgIGVhY2gkZShnZXRGdWxseVNlbGVjdGVkTGlzdEl0ZW1zKGVkLnNlbGVjdGlvbiksIGxpID0+IGFwcGx5U3R5bGVzKGRvbSwgbGksIGxpRm10LCB2YXJzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zdFByb2Nlc3MkMShuYW1lLCBlZCk7XG4gICAgICB9XG4gICAgICBmaXJlRm9ybWF0QXBwbHkoZWQsIG5hbWUsIG5vZGUsIHZhcnMpO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlGb3JtYXQkMSA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlIHx8IGVkaXRvci5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIGFwcGx5Rm9ybWF0QWN0aW9uKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhc1ZhcnMgPSB2YWx1ZSA9PiBoYXMkMih2YWx1ZSwgJ3ZhcnMnKTtcbiAgICBjb25zdCBzZXR1cCR0ID0gKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGVkaXRvcikgPT4ge1xuICAgICAgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5zZXQoe30pO1xuICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgZSA9PiB7XG4gICAgICAgIHVwZGF0ZUFuZEZpcmVDaGFuZ2VDYWxsYmFja3MoZWRpdG9yLCBlLmVsZW1lbnQsIHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuZ2V0KCkpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0Zvcm1hdEFwcGx5IEZvcm1hdFJlbW92ZScsIGUgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gT3B0aW9uYWwuZnJvbShlLm5vZGUpLm1hcChub2RlT3JSYW5nZSA9PiBpc05vZGUobm9kZU9yUmFuZ2UpID8gbm9kZU9yUmFuZ2UgOiBub2RlT3JSYW5nZS5zdGFydENvbnRhaW5lcikuYmluZChub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpID8gT3B0aW9uYWwuc29tZShub2RlKSA6IE9wdGlvbmFsLmZyb20obm9kZS5wYXJlbnRFbGVtZW50KSkuZ2V0T3JUaHVuaygoKSA9PiBmYWxsYmFja0VsZW1lbnQoZWRpdG9yKSk7XG4gICAgICAgIHVwZGF0ZUFuZEZpcmVDaGFuZ2VDYWxsYmFja3MoZWRpdG9yLCBlbGVtZW50LCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLmdldCgpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmFsbGJhY2tFbGVtZW50ID0gZWRpdG9yID0+IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKTtcbiAgICBjb25zdCBtYXRjaGluZ05vZGUgPSAoZWRpdG9yLCBwYXJlbnRzLCBmb3JtYXQsIHNpbWlsYXIsIHZhcnMpID0+IHtcbiAgICAgIGNvbnN0IGlzTWF0Y2hpbmdOb2RlID0gbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRm9ybWF0ID0gZWRpdG9yLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgZm9ybWF0LCB2YXJzICE9PSBudWxsICYmIHZhcnMgIT09IHZvaWQgMCA/IHZhcnMgOiB7fSwgc2ltaWxhcik7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQobWF0Y2hpbmdGb3JtYXQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzVW5hYmxlVG9NYXRjaCA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlc1VuSW5oZXJpdGVkRm9ybWF0U2VsZWN0b3IoZWRpdG9yLCBub2RlLCBmb3JtYXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFzaW1pbGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBmb3JtYXQsIHZhcnMsIHRydWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmaW5kVW50aWwkMShwYXJlbnRzLCBpc01hdGNoaW5nTm9kZSwgaXNVbmFibGVUb01hdGNoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudHMgPSAoZWRpdG9yLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbG0gIT09IG51bGwgJiYgZWxtICE9PSB2b2lkIDAgPyBlbG0gOiBmYWxsYmFja0VsZW1lbnQoZWRpdG9yKTtcbiAgICAgIHJldHVybiBmaWx0ZXIkNShnZXRQYXJlbnRzJDIoZWRpdG9yLmRvbSwgZWxlbWVudCksIG5vZGUgPT4gaXNFbGVtZW50JDYobm9kZSkgJiYgIWlzQm9ndXMkMihub2RlKSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVBbmRGaXJlQ2hhbmdlQ2FsbGJhY2tzID0gKGVkaXRvciwgZWxtLCByZWdpc3RlcmVkQ2FsbGJhY2tzKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gZ2V0UGFyZW50cyhlZGl0b3IsIGVsbSk7XG4gICAgICBlYWNoJGQocmVnaXN0ZXJlZENhbGxiYWNrcywgKGRhdGEsIGZvcm1hdCkgPT4ge1xuICAgICAgICBjb25zdCBydW5JZkNoYW5nZWQgPSBzcGVjID0+IHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoaW5nTm9kZShlZGl0b3IsIHBhcmVudHMsIGZvcm1hdCwgc3BlYy5zaW1pbGFyLCBoYXNWYXJzKHNwZWMpID8gc3BlYy52YXJzIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBpc1NldCA9IG1hdGNoLmlzU29tZSgpO1xuICAgICAgICAgIGlmIChzcGVjLnN0YXRlLmdldCgpICE9PSBpc1NldCkge1xuICAgICAgICAgICAgc3BlYy5zdGF0ZS5zZXQoaXNTZXQpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG1hdGNoLmdldE9yKGVsbSk7XG4gICAgICAgICAgICBpZiAoaGFzVmFycyhzcGVjKSkge1xuICAgICAgICAgICAgICBzcGVjLmNhbGxiYWNrKGlzU2V0LCB7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICAgICAgcGFyZW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVhY2gkZShzcGVjLmNhbGxiYWNrcywgY2FsbGJhY2sgPT4gY2FsbGJhY2soaXNTZXQsIHtcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICBwYXJlbnRzXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVhY2gkZShbXG4gICAgICAgICAgZGF0YS53aXRoU2ltaWxhcixcbiAgICAgICAgICBkYXRhLndpdGhvdXRTaW1pbGFyXG4gICAgICAgIF0sIHJ1bklmQ2hhbmdlZCk7XG4gICAgICAgIGVhY2gkZShkYXRhLndpdGhWYXJzLCBydW5JZkNoYW5nZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRMaXN0ZW5lcnMgPSAoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycykgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0Q2hhbmdlSXRlbXMgPSByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLmdldCgpO1xuICAgICAgZWFjaCRlKGZvcm1hdHMuc3BsaXQoJywnKSwgZm9ybWF0ID0+IHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBnZXQkYShmb3JtYXRDaGFuZ2VJdGVtcywgZm9ybWF0KS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBiYXNlID0ge1xuICAgICAgICAgICAgd2l0aFNpbWlsYXI6IHtcbiAgICAgICAgICAgICAgc3RhdGU6IENlbGwoZmFsc2UpLFxuICAgICAgICAgICAgICBzaW1pbGFyOiB0cnVlLFxuICAgICAgICAgICAgICBjYWxsYmFja3M6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2l0aG91dFNpbWlsYXI6IHtcbiAgICAgICAgICAgICAgc3RhdGU6IENlbGwoZmFsc2UpLFxuICAgICAgICAgICAgICBzaW1pbGFyOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpdGhWYXJzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgZm9ybWF0Q2hhbmdlSXRlbXNbZm9ybWF0XSA9IGJhc2U7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBnZXRDdXJyZW50ID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKGVkaXRvcik7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZShlZGl0b3IsIHBhcmVudHMsIGZvcm1hdCwgc2ltaWxhciwgdmFycykuaXNTb21lKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YXJzKSkge1xuICAgICAgICAgIGNvbnN0IHRvQXBwZW5kVG8gPSBzaW1pbGFyID8gZ3JvdXAud2l0aFNpbWlsYXIgOiBncm91cC53aXRob3V0U2ltaWxhcjtcbiAgICAgICAgICB0b0FwcGVuZFRvLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAodG9BcHBlbmRUby5jYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0b0FwcGVuZFRvLnN0YXRlLnNldChnZXRDdXJyZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cC53aXRoVmFycy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXRlOiBDZWxsKGdldEN1cnJlbnQoKSksXG4gICAgICAgICAgICBzaW1pbGFyLFxuICAgICAgICAgICAgdmFycyxcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycy5zZXQoZm9ybWF0Q2hhbmdlSXRlbXMpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXJzID0gKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRDaGFuZ2VJdGVtcyA9IHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMuZ2V0KCk7XG4gICAgICBlYWNoJGUoZm9ybWF0cy5zcGxpdCgnLCcpLCBmb3JtYXQgPT4gZ2V0JGEoZm9ybWF0Q2hhbmdlSXRlbXMsIGZvcm1hdCkuZWFjaChncm91cCA9PiB7XG4gICAgICAgIGZvcm1hdENoYW5nZUl0ZW1zW2Zvcm1hdF0gPSB7XG4gICAgICAgICAgd2l0aFNpbWlsYXI6IHtcbiAgICAgICAgICAgIC4uLmdyb3VwLndpdGhTaW1pbGFyLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBmaWx0ZXIkNShncm91cC53aXRoU2ltaWxhci5jYWxsYmFja3MsIGNiID0+IGNiICE9PSBjYWxsYmFjaylcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdpdGhvdXRTaW1pbGFyOiB7XG4gICAgICAgICAgICAuLi5ncm91cC53aXRob3V0U2ltaWxhcixcbiAgICAgICAgICAgIGNhbGxiYWNrczogZmlsdGVyJDUoZ3JvdXAud2l0aG91dFNpbWlsYXIuY2FsbGJhY2tzLCBjYiA9PiBjYiAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3aXRoVmFyczogZmlsdGVyJDUoZ3JvdXAud2l0aFZhcnMsIGl0ZW0gPT4gaXRlbS5jYWxsYmFjayAhPT0gY2FsbGJhY2spXG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgICByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLnNldChmb3JtYXRDaGFuZ2VJdGVtcyk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXRDaGFuZ2VkSW50ZXJuYWwgPSAoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycykgPT4ge1xuICAgICAgYWRkTGlzdGVuZXJzKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpO1xuICAgICAgcmV0dXJuIHsgdW5iaW5kOiAoKSA9PiByZW1vdmVMaXN0ZW5lcnMocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2spIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZSA9IChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGZtdCA9IGVkaXRvci5mb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGZtdCkge1xuICAgICAgICBpZiAobWF0Y2gkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpICYmICghKCd0b2dnbGUnIGluIGZtdFswXSkgfHwgZm10WzBdLnRvZ2dsZSkpIHtcbiAgICAgICAgICByZW1vdmVGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5Rm9ybWF0JDEoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBleHBsb2RlJDEgPSBUb29scy5leHBsb2RlO1xuICAgIGNvbnN0IGNyZWF0ZSQ4ID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlsdGVycyA9IHt9O1xuICAgICAgY29uc3QgYWRkRmlsdGVyID0gKG5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGVhY2gkZShleHBsb2RlJDEobmFtZSksIG5hbWUgPT4ge1xuICAgICAgICAgIGlmICghaGFzJDIoZmlsdGVycywgbmFtZSkpIHtcbiAgICAgICAgICAgIGZpbHRlcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbHRlcnNbbmFtZV0uY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRGaWx0ZXJzID0gKCkgPT4gdmFsdWVzKGZpbHRlcnMpO1xuICAgICAgY29uc3QgcmVtb3ZlRmlsdGVyID0gKG5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGVhY2gkZShleHBsb2RlJDEobmFtZSksIG5hbWUgPT4ge1xuICAgICAgICAgIGlmIChoYXMkMihmaWx0ZXJzLCBuYW1lKSkge1xuICAgICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhbGxiYWNrcyA9IGZpbHRlciQ1KGZpbHRlci5jYWxsYmFja3MsIGMgPT4gYyAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgICBpZiAobmV3Q2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuY2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJzW25hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgZmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZEZpbHRlcixcbiAgICAgICAgZ2V0RmlsdGVycyxcbiAgICAgICAgcmVtb3ZlRmlsdGVyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVBdHRycyA9IChub2RlLCBuYW1lcykgPT4ge1xuICAgICAgZWFjaCRlKG5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgbm9kZS5hdHRyKG5hbWUsIG51bGwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhZGRGb250VG9TcGFuc0ZpbHRlciA9IChkb21QYXJzZXIsIHN0eWxlcywgZm9udFNpemVzKSA9PiB7XG4gICAgICBkb21QYXJzZXIuYWRkTm9kZUZpbHRlcignZm9udCcsIG5vZGVzID0+IHtcbiAgICAgICAgZWFjaCRlKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHN0eWxlcy5wYXJzZShub2RlLmF0dHIoJ3N0eWxlJykpO1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gbm9kZS5hdHRyKCdjb2xvcicpO1xuICAgICAgICAgIGNvbnN0IGZhY2UgPSBub2RlLmF0dHIoJ2ZhY2UnKTtcbiAgICAgICAgICBjb25zdCBzaXplID0gbm9kZS5hdHRyKCdzaXplJyk7XG4gICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBwcm9wcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmFjZSkge1xuICAgICAgICAgICAgcHJvcHNbJ2ZvbnQtZmFtaWx5J10gPSBmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgdG9JbnQoc2l6ZSkuZWFjaChudW0gPT4ge1xuICAgICAgICAgICAgICBwcm9wc1snZm9udC1zaXplJ10gPSBmb250U2l6ZXNbbnVtIC0gMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5uYW1lID0gJ3NwYW4nO1xuICAgICAgICAgIG5vZGUuYXR0cignc3R5bGUnLCBzdHlsZXMuc2VyaWFsaXplKHByb3BzKSk7XG4gICAgICAgICAgcmVtb3ZlQXR0cnMobm9kZSwgW1xuICAgICAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgICAgICdmYWNlJyxcbiAgICAgICAgICAgICdzaXplJ1xuICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWRkU3RyaWtlRmlsdGVyID0gKGRvbVBhcnNlciwgc2NoZW1hLCBzdHlsZXMpID0+IHtcbiAgICAgIGRvbVBhcnNlci5hZGROb2RlRmlsdGVyKCdzdHJpa2UnLCBub2RlcyA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRUb1NUYWcgPSBzY2hlbWEudHlwZSAhPT0gJ2h0bWw0JztcbiAgICAgICAgZWFjaCRlKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICBpZiAoY29udmVydFRvU1RhZykge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJ3MnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHN0eWxlcy5wYXJzZShub2RlLmF0dHIoJ3N0eWxlJykpO1xuICAgICAgICAgICAgcHJvcHNbJ3RleHQtZGVjb3JhdGlvbiddID0gJ2xpbmUtdGhyb3VnaCc7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnc3Bhbic7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ3N0eWxlJywgc3R5bGVzLnNlcmlhbGl6ZShwcm9wcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEZpbHRlcnMgPSAoZG9tUGFyc2VyLCBzZXR0aW5ncywgc2NoZW1hKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzdHlsZXMgPSBTdHlsZXMoKTtcbiAgICAgIGlmIChzZXR0aW5ncy5jb252ZXJ0X2ZvbnRzX3RvX3NwYW5zKSB7XG4gICAgICAgIGFkZEZvbnRUb1NwYW5zRmlsdGVyKGRvbVBhcnNlciwgc3R5bGVzLCBUb29scy5leHBsb2RlKChfYSA9IHNldHRpbmdzLmZvbnRfc2l6ZV9sZWdhY3lfdmFsdWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykpO1xuICAgICAgfVxuICAgICAgYWRkU3RyaWtlRmlsdGVyKGRvbVBhcnNlciwgc2NoZW1hLCBzdHlsZXMpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNSA9IChkb21QYXJzZXIsIHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGlmIChzZXR0aW5ncy5pbmxpbmVfc3R5bGVzKSB7XG4gICAgICAgIGFkZEZpbHRlcnMoZG9tUGFyc2VyLCBzZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWRkTm9kZUZpbHRlciA9IChzZXR0aW5ncywgaHRtbFBhcnNlciwgc2NoZW1hKSA9PiB7XG4gICAgICBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2JyJywgKG5vZGVzLCBfLCBhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBUb29scy5leHRlbmQoe30sIHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgICBibG9ja0VsZW1lbnRzLmJvZHkgPSAxO1xuICAgICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZSA9PiBub2RlLm5hbWUgaW4gYmxvY2tFbGVtZW50cyB8fCBpc1RyYW5zcGFyZW50QXN0QmxvY2soc2NoZW1hLCBub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICBpZiAocGFyZW50ICYmIGlzQmxvY2socGFyZW50KSAmJiBub2RlID09PSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZOYW1lID0gcHJldi5uYW1lO1xuICAgICAgICAgICAgICBpZiAocHJldk5hbWUgIT09ICdzcGFuJyB8fCBwcmV2LmF0dHIoJ2RhdGEtbWNlLXR5cGUnKSAhPT0gJ2Jvb2ttYXJrJykge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TmFtZSA9PT0gJ2JyJykge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBpZiAoaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSdWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKHBhcmVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50UnVsZS5yZW1vdmVFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRSdWxlLnBhZGRFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYWRkRW1wdHlOb2RlKHNldHRpbmdzLCBhcmdzLCBpc0Jsb2NrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFzdFBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkID09PSBsYXN0UGFyZW50ICYmIHBhcmVudC5sYXN0Q2hpbGQgPT09IGxhc3RQYXJlbnQpIHtcbiAgICAgICAgICAgICAgbGFzdFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrRWxlbWVudHNbcGFyZW50Lm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0UGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBuZXcgQXN0Tm9kZSgnI3RleHQnLCAzKTtcbiAgICAgICAgICAgICAgdGV4dE5vZGUudmFsdWUgPSBuYnNwO1xuICAgICAgICAgICAgICBub2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGJsb2JVcmlUb0Jsb2IgPSB1cmwgPT4gZmV0Y2godXJsKS50aGVuKHJlcyA9PiByZXMub2sgPyByZXMuYmxvYigpIDogUHJvbWlzZS5yZWplY3QoKSkuY2F0Y2goKCkgPT4gUHJvbWlzZS5yZWplY3Qoe1xuICAgICAgbWVzc2FnZTogYENhbm5vdCBjb252ZXJ0ICR7IHVybCB9IHRvIEJsb2IuIFJlc291cmNlIG1pZ2h0IG5vdCBleGlzdCBvciBpcyBpbmFjY2Vzc2libGUuYCxcbiAgICAgIHVyaVR5cGU6ICdibG9iJ1xuICAgIH0pKTtcbiAgICBjb25zdCBleHRyYWN0QmFzZTY0RGF0YSA9IGRhdGEgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC8oW2EtejAtOStcXC89XFxzXSspL2kuZXhlYyhkYXRhKTtcbiAgICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6ICcnO1xuICAgIH07XG4gICAgY29uc3QgcGFyc2VEYXRhVXJpID0gdXJpID0+IHtcbiAgICAgIGNvbnN0IFt0eXBlLCAuLi5yZXN0XSA9IHVyaS5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgZGF0YSA9IHJlc3Quam9pbignLCcpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9kYXRhOihbXi9dK1xcL1teO10rKSg7LispPy8uZXhlYyh0eXBlKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWQgPSBtYXRjaGVzWzJdID09PSAnO2Jhc2U2NCc7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZERhdGEgPSBiYXNlNjRFbmNvZGVkID8gZXh0cmFjdEJhc2U2NERhdGEoZGF0YSkgOiBkZWNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHtcbiAgICAgICAgICB0eXBlOiBtYXRjaGVzWzFdLFxuICAgICAgICAgIGRhdGE6IGV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgYmFzZTY0RW5jb2RlZFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBidWlsZEJsb2IgPSAodHlwZSwgZGF0YSwgYmFzZTY0RW5jb2RlZCA9IHRydWUpID0+IHtcbiAgICAgIGxldCBzdHIgPSBkYXRhO1xuICAgICAgaWYgKGJhc2U2NEVuY29kZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHIgPSBhdG9iKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG5ldyBCbG9iKFthcnJdLCB7IHR5cGUgfSkpO1xuICAgIH07XG4gICAgY29uc3QgZGF0YVVyaVRvQmxvYiA9IHVyaSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBwYXJzZURhdGFVcmkodXJpKS5iaW5kKCh7dHlwZSwgZGF0YSwgYmFzZTY0RW5jb2RlZH0pID0+IGJ1aWxkQmxvYih0eXBlLCBkYXRhLCBiYXNlNjRFbmNvZGVkKSkuZm9sZCgoKSA9PiByZWplY3QoJ0ludmFsaWQgZGF0YSBVUkknKSwgcmVzb2x2ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVyaVRvQmxvYiA9IHVybCA9PiB7XG4gICAgICBpZiAoc3RhcnRzV2l0aCh1cmwsICdibG9iOicpKSB7XG4gICAgICAgIHJldHVybiBibG9iVXJpVG9CbG9iKHVybCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodXJsLCAnZGF0YTonKSkge1xuICAgICAgICByZXR1cm4gZGF0YVVyaVRvQmxvYih1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdVbmtub3duIFVSSSBmb3JtYXQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJsb2JUb0RhdGFVcmkgPSBibG9iID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJlamVjdCgoX2EgPSByZWFkZXIuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgbGV0IGNvdW50JDEgPSAwO1xuICAgIGNvbnN0IHVuaXF1ZUlkJDEgPSBwcmVmaXggPT4ge1xuICAgICAgcmV0dXJuIChwcmVmaXggfHwgJ2Jsb2JpZCcpICsgY291bnQkMSsrO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0RhdGFVcmkgPSAoZGF0YVVyaSwgYmFzZTY0T25seSwgZ2VuZXJhdGVCbG9iSW5mbykgPT4ge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVVyaShkYXRhVXJpKS5iaW5kKCh7ZGF0YSwgdHlwZSwgYmFzZTY0RW5jb2RlZH0pID0+IHtcbiAgICAgICAgaWYgKGJhc2U2NE9ubHkgJiYgIWJhc2U2NEVuY29kZWQpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGJhc2U2NEVuY29kZWQgPyBkYXRhIDogYnRvYShkYXRhKTtcbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVCbG9iSW5mbyhiYXNlNjQsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUJsb2JJbmZvJDEgPSAoYmxvYkNhY2hlLCBibG9iLCBiYXNlNjQpID0+IHtcbiAgICAgIGNvbnN0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmNyZWF0ZSh1bmlxdWVJZCQxKCksIGJsb2IsIGJhc2U2NCk7XG4gICAgICBibG9iQ2FjaGUuYWRkKGJsb2JJbmZvKTtcbiAgICAgIHJldHVybiBibG9iSW5mbztcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFVcmlUb0Jsb2JJbmZvID0gKGJsb2JDYWNoZSwgZGF0YVVyaSwgYmFzZTY0T25seSA9IGZhbHNlKSA9PiB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0RhdGFVcmkoZGF0YVVyaSwgYmFzZTY0T25seSwgKGJhc2U2NCwgdHlwZSkgPT4gT3B0aW9uYWwuZnJvbShibG9iQ2FjaGUuZ2V0QnlEYXRhKGJhc2U2NCwgdHlwZSkpLm9yVGh1bmsoKCkgPT4gYnVpbGRCbG9iKHR5cGUsIGJhc2U2NCkubWFwKGJsb2IgPT4gY3JlYXRlQmxvYkluZm8kMShibG9iQ2FjaGUsIGJsb2IsIGJhc2U2NCkpKSk7XG4gICAgfTtcbiAgICBjb25zdCBpbWFnZVRvQmxvYkluZm8gPSAoYmxvYkNhY2hlLCBpbWFnZVNyYykgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZERhdGFVcmkgPSAoKSA9PiBQcm9taXNlLnJlamVjdCgnSW52YWxpZCBkYXRhIFVSSScpO1xuICAgICAgaWYgKHN0YXJ0c1dpdGgoaW1hZ2VTcmMsICdibG9iOicpKSB7XG4gICAgICAgIGNvbnN0IGJsb2JJbmZvID0gYmxvYkNhY2hlLmdldEJ5VXJpKGltYWdlU3JjKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYmxvYkluZm8pKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShibG9iSW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVyaVRvQmxvYihpbWFnZVNyYykudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgIHJldHVybiBibG9iVG9EYXRhVXJpKGJsb2IpLnRoZW4oZGF0YVVyaSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRGF0YVVyaShkYXRhVXJpLCBmYWxzZSwgYmFzZTY0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShjcmVhdGVCbG9iSW5mbyQxKGJsb2JDYWNoZSwgYmxvYiwgYmFzZTY0KSk7XG4gICAgICAgICAgICAgIH0pLmdldE9yVGh1bmsoaW52YWxpZERhdGFVcmkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aChpbWFnZVNyYywgJ2RhdGE6JykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFVcmlUb0Jsb2JJbmZvKGJsb2JDYWNoZSwgaW1hZ2VTcmMpLmZvbGQoaW52YWxpZERhdGFVcmksIGJsb2JJbmZvID0+IFByb21pc2UucmVzb2x2ZShibG9iSW5mbykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdVbmtub3duIGltYWdlIGRhdGEgZm9ybWF0Jyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzQm9ndXNJbWFnZSA9IGltZyA9PiBpc05vbk51bGxhYmxlKGltZy5hdHRyKCdkYXRhLW1jZS1ib2d1cycpKTtcbiAgICBjb25zdCBpc0ludGVybmFsSW1hZ2VTb3VyY2UgPSBpbWcgPT4gaW1nLmF0dHIoJ3NyYycpID09PSBFbnYudHJhbnNwYXJlbnRTcmMgfHwgaXNOb25OdWxsYWJsZShpbWcuYXR0cignZGF0YS1tY2UtcGxhY2Vob2xkZXInKSk7XG4gICAgY29uc3QgcmVnaXN0ZXJCYXNlNjRJbWFnZUZpbHRlciA9IChwYXJzZXIsIHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCB7YmxvYl9jYWNoZTogYmxvYkNhY2hlfSA9IHNldHRpbmdzO1xuICAgICAgaWYgKGJsb2JDYWNoZSkge1xuICAgICAgICBjb25zdCBwcm9jZXNzSW1hZ2UgPSBpbWcgPT4ge1xuICAgICAgICAgIGNvbnN0IGlucHV0U3JjID0gaW1nLmF0dHIoJ3NyYycpO1xuICAgICAgICAgIGlmIChpc0ludGVybmFsSW1hZ2VTb3VyY2UoaW1nKSB8fCBpc0JvZ3VzSW1hZ2UoaW1nKSB8fCBpc051bGxhYmxlKGlucHV0U3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhVXJpVG9CbG9iSW5mbyhibG9iQ2FjaGUsIGlucHV0U3JjLCB0cnVlKS5lYWNoKGJsb2JJbmZvID0+IHtcbiAgICAgICAgICAgIGltZy5hdHRyKCdzcmMnLCBibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdzcmMnLCBub2RlcyA9PiBlYWNoJGUobm9kZXMsIHByb2Nlc3NJbWFnZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIkNCA9IChwYXJzZXIsIHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBwYXJzZXIuc2NoZW1hO1xuICAgICAgaWYgKHNldHRpbmdzLnJlbW92ZV90cmFpbGluZ19icnMpIHtcbiAgICAgICAgYWRkTm9kZUZpbHRlcihzZXR0aW5ncywgcGFyc2VyLCBzY2hlbWEpO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaHJlZicsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFwcGVuZFJlbCA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSByZWwuc3BsaXQoJyAnKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuICAgICAgICAgIHJldHVybiBwYXJ0cy5jb25jYXQoWydub29wZW5lciddKS5zb3J0KCkuam9pbignICcpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGROb09wZW5lciA9IHJlbCA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3UmVsID0gcmVsID8gVG9vbHMudHJpbShyZWwpIDogJyc7XG4gICAgICAgICAgaWYgKCEvXFxiKG5vb3BlbmVyKVxcYi9nLnRlc3QobmV3UmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVuZFJlbChuZXdSZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3UmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hbGxvd191bnNhZmVfbGlua190YXJnZXQpIHtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5hdHRyKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKCdyZWwnLCBhZGROb09wZW5lcihub2RlLmF0dHIoJ3JlbCcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghc2V0dGluZ3MuYWxsb3dfaHRtbF9pbl9uYW1lZF9hbmNob3IpIHtcbiAgICAgICAgcGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignaWQsbmFtZScsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aCwgc2libGluZywgcHJldlNpYmxpbmcsIHBhcmVudCwgbm9kZTtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSAnYScgJiYgbm9kZS5maXJzdENoaWxkICYmICFub2RlLmF0dHIoJ2hyZWYnKSkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgc2libGluZyA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgICB3aGlsZSAoc2libGluZyAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZyA9IHNpYmxpbmcucHJldjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0KHNpYmxpbmcsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwcmV2U2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZml4X2xpc3RfZWxlbWVudHMpIHtcbiAgICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3VsLG9sJywgbm9kZXMgPT4ge1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoLCBub2RlLCBwYXJlbnROb2RlO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIChwYXJlbnROb2RlLm5hbWUgPT09ICd1bCcgfHwgcGFyZW50Tm9kZS5uYW1lID09PSAnb2wnKSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2ICYmIG5vZGUucHJldi5uYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2LmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaSA9IG5ldyBBc3ROb2RlKCdsaScsIDEpO1xuICAgICAgICAgICAgICAgIGxpLmF0dHIoJ3N0eWxlJywgJ2xpc3Qtc3R5bGUtdHlwZTogbm9uZScpO1xuICAgICAgICAgICAgICAgIG5vZGUud3JhcChsaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRDbGFzc2VzID0gc2NoZW1hLmdldFZhbGlkQ2xhc3NlcygpO1xuICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRlICYmIHZhbGlkQ2xhc3Nlcykge1xuICAgICAgICBwYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdjbGFzcycsIG5vZGVzID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgY2xhenogPSAoX2EgPSBub2RlLmF0dHIoJ2NsYXNzJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gVG9vbHMuZXhwbG9kZShjbGF6eiwgJyAnKTtcbiAgICAgICAgICAgIGxldCBjbGFzc1ZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc0xpc3RbY2ldO1xuICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1snKiddO1xuICAgICAgICAgICAgICBpZiAodmFsaWRDbGFzc2VzTWFwICYmIHZhbGlkQ2xhc3Nlc01hcFtjbGFzc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbGlkQ2xhc3Nlc01hcCA9IHZhbGlkQ2xhc3Nlc1tub2RlLm5hbWVdO1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkICYmIHZhbGlkQ2xhc3Nlc01hcCAmJiB2YWxpZENsYXNzZXNNYXBbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgY2xhc3NWYWx1ZSArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYXNzVmFsdWUgKz0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsYXNzVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNsYXNzVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5hdHRyKCdjbGFzcycsIGNsYXNzVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlckJhc2U2NEltYWdlRmlsdGVyKHBhcnNlciwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgJ0BiYWJlbC9oZWxwZXJzIC0gdHlwZW9mJztcbiAgICAgIHJldHVybiBfdHlwZW9mID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgU3ltYm9sICYmICdzeW1ib2wnID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gJ3N5bWJvbCcgOiB0eXBlb2Ygb2JqO1xuICAgICAgfSwgX3R5cGVvZihvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgIVJlZmxlY3QuY29uc3RydWN0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgaWYgKENsYXNzKVxuICAgICAgICAgICAgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyWydAQGl0ZXJhdG9yJ10gIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICAgIGlmICghbylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgICBpZiAobiA9PT0gJ09iamVjdCcgJiYgby5jb25zdHJ1Y3RvcilcbiAgICAgICAgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChuID09PSAnTWFwJyB8fCBuID09PSAnU2V0JylcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgICBpZiAobiA9PT0gJ0FyZ3VtZW50cycgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpXG4gICAgICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpXG4gICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLicpO1xuICAgIH1cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QuaGFzT3duUHJvcGVydHksIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbiwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsIHNlYWwgPSBPYmplY3Quc2VhbCwgY3JlYXRlJDcgPSBPYmplY3QuY3JlYXRlO1xuICAgIHZhciBfcmVmID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3QsIGFwcGx5ID0gX3JlZi5hcHBseSwgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG4gICAgaWYgKCFhcHBseSkge1xuICAgICAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW4sIHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICByZXR1cm4gZnVuLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWZyZWV6ZSkge1xuICAgICAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXNlYWwpIHtcbiAgICAgIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWNvbnN0cnVjdCkge1xuICAgICAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoRnVuYywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbiAgICB2YXIgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xuICAgIHZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICB2YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuICAgIHZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG4gICAgdmFyIHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG4gICAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gICAgdmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG4gICAgdmFyIHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG4gICAgdmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG4gICAgZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVG9TZXQoc2V0LCBhcnJheSkge1xuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsY0VsZW1lbnQgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50KTtcbiAgICAgICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgICAgICBhcnJheVtsXSA9IGxjRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFtlbGVtZW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICAgIHZhciBuZXdPYmplY3QgPSBjcmVhdGUkNyhudWxsKTtcbiAgICAgIHZhciBwcm9wZXJ0eTtcbiAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkge1xuICAgICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gICAgICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdmYWxsYmFjayB2YWx1ZSBmb3InLCBlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG4gICAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbXG4gICAgICAnYScsXG4gICAgICAnYWJicicsXG4gICAgICAnYWNyb255bScsXG4gICAgICAnYWRkcmVzcycsXG4gICAgICAnYXJlYScsXG4gICAgICAnYXJ0aWNsZScsXG4gICAgICAnYXNpZGUnLFxuICAgICAgJ2F1ZGlvJyxcbiAgICAgICdiJyxcbiAgICAgICdiZGknLFxuICAgICAgJ2JkbycsXG4gICAgICAnYmlnJyxcbiAgICAgICdibGluaycsXG4gICAgICAnYmxvY2txdW90ZScsXG4gICAgICAnYm9keScsXG4gICAgICAnYnInLFxuICAgICAgJ2J1dHRvbicsXG4gICAgICAnY2FudmFzJyxcbiAgICAgICdjYXB0aW9uJyxcbiAgICAgICdjZW50ZXInLFxuICAgICAgJ2NpdGUnLFxuICAgICAgJ2NvZGUnLFxuICAgICAgJ2NvbCcsXG4gICAgICAnY29sZ3JvdXAnLFxuICAgICAgJ2NvbnRlbnQnLFxuICAgICAgJ2RhdGEnLFxuICAgICAgJ2RhdGFsaXN0JyxcbiAgICAgICdkZCcsXG4gICAgICAnZGVjb3JhdG9yJyxcbiAgICAgICdkZWwnLFxuICAgICAgJ2RldGFpbHMnLFxuICAgICAgJ2RmbicsXG4gICAgICAnZGlhbG9nJyxcbiAgICAgICdkaXInLFxuICAgICAgJ2RpdicsXG4gICAgICAnZGwnLFxuICAgICAgJ2R0JyxcbiAgICAgICdlbGVtZW50JyxcbiAgICAgICdlbScsXG4gICAgICAnZmllbGRzZXQnLFxuICAgICAgJ2ZpZ2NhcHRpb24nLFxuICAgICAgJ2ZpZ3VyZScsXG4gICAgICAnZm9udCcsXG4gICAgICAnZm9vdGVyJyxcbiAgICAgICdmb3JtJyxcbiAgICAgICdoMScsXG4gICAgICAnaDInLFxuICAgICAgJ2gzJyxcbiAgICAgICdoNCcsXG4gICAgICAnaDUnLFxuICAgICAgJ2g2JyxcbiAgICAgICdoZWFkJyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJ2hncm91cCcsXG4gICAgICAnaHInLFxuICAgICAgJ2h0bWwnLFxuICAgICAgJ2knLFxuICAgICAgJ2ltZycsXG4gICAgICAnaW5wdXQnLFxuICAgICAgJ2lucycsXG4gICAgICAna2JkJyxcbiAgICAgICdsYWJlbCcsXG4gICAgICAnbGVnZW5kJyxcbiAgICAgICdsaScsXG4gICAgICAnbWFpbicsXG4gICAgICAnbWFwJyxcbiAgICAgICdtYXJrJyxcbiAgICAgICdtYXJxdWVlJyxcbiAgICAgICdtZW51JyxcbiAgICAgICdtZW51aXRlbScsXG4gICAgICAnbWV0ZXInLFxuICAgICAgJ25hdicsXG4gICAgICAnbm9icicsXG4gICAgICAnb2wnLFxuICAgICAgJ29wdGdyb3VwJyxcbiAgICAgICdvcHRpb24nLFxuICAgICAgJ291dHB1dCcsXG4gICAgICAncCcsXG4gICAgICAncGljdHVyZScsXG4gICAgICAncHJlJyxcbiAgICAgICdwcm9ncmVzcycsXG4gICAgICAncScsXG4gICAgICAncnAnLFxuICAgICAgJ3J0JyxcbiAgICAgICdydWJ5JyxcbiAgICAgICdzJyxcbiAgICAgICdzYW1wJyxcbiAgICAgICdzZWN0aW9uJyxcbiAgICAgICdzZWxlY3QnLFxuICAgICAgJ3NoYWRvdycsXG4gICAgICAnc21hbGwnLFxuICAgICAgJ3NvdXJjZScsXG4gICAgICAnc3BhY2VyJyxcbiAgICAgICdzcGFuJyxcbiAgICAgICdzdHJpa2UnLFxuICAgICAgJ3N0cm9uZycsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1YicsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAnc3VwJyxcbiAgICAgICd0YWJsZScsXG4gICAgICAndGJvZHknLFxuICAgICAgJ3RkJyxcbiAgICAgICd0ZW1wbGF0ZScsXG4gICAgICAndGV4dGFyZWEnLFxuICAgICAgJ3Rmb290JyxcbiAgICAgICd0aCcsXG4gICAgICAndGhlYWQnLFxuICAgICAgJ3RpbWUnLFxuICAgICAgJ3RyJyxcbiAgICAgICd0cmFjaycsXG4gICAgICAndHQnLFxuICAgICAgJ3UnLFxuICAgICAgJ3VsJyxcbiAgICAgICd2YXInLFxuICAgICAgJ3ZpZGVvJyxcbiAgICAgICd3YnInXG4gICAgXSk7XG4gICAgdmFyIHN2ZyQxID0gZnJlZXplKFtcbiAgICAgICdzdmcnLFxuICAgICAgJ2EnLFxuICAgICAgJ2FsdGdseXBoJyxcbiAgICAgICdhbHRnbHlwaGRlZicsXG4gICAgICAnYWx0Z2x5cGhpdGVtJyxcbiAgICAgICdhbmltYXRlY29sb3InLFxuICAgICAgJ2FuaW1hdGVtb3Rpb24nLFxuICAgICAgJ2FuaW1hdGV0cmFuc2Zvcm0nLFxuICAgICAgJ2NpcmNsZScsXG4gICAgICAnY2xpcHBhdGgnLFxuICAgICAgJ2RlZnMnLFxuICAgICAgJ2Rlc2MnLFxuICAgICAgJ2VsbGlwc2UnLFxuICAgICAgJ2ZpbHRlcicsXG4gICAgICAnZm9udCcsXG4gICAgICAnZycsXG4gICAgICAnZ2x5cGgnLFxuICAgICAgJ2dseXBocmVmJyxcbiAgICAgICdoa2VybicsXG4gICAgICAnaW1hZ2UnLFxuICAgICAgJ2xpbmUnLFxuICAgICAgJ2xpbmVhcmdyYWRpZW50JyxcbiAgICAgICdtYXJrZXInLFxuICAgICAgJ21hc2snLFxuICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICdtcGF0aCcsXG4gICAgICAncGF0aCcsXG4gICAgICAncGF0dGVybicsXG4gICAgICAncG9seWdvbicsXG4gICAgICAncG9seWxpbmUnLFxuICAgICAgJ3JhZGlhbGdyYWRpZW50JyxcbiAgICAgICdyZWN0JyxcbiAgICAgICdzdG9wJyxcbiAgICAgICdzdHlsZScsXG4gICAgICAnc3dpdGNoJyxcbiAgICAgICdzeW1ib2wnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3RleHRwYXRoJyxcbiAgICAgICd0aXRsZScsXG4gICAgICAndHJlZicsXG4gICAgICAndHNwYW4nLFxuICAgICAgJ3ZpZXcnLFxuICAgICAgJ3ZrZXJuJ1xuICAgIF0pO1xuICAgIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFtcbiAgICAgICdmZUJsZW5kJyxcbiAgICAgICdmZUNvbG9yTWF0cml4JyxcbiAgICAgICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcbiAgICAgICdmZUNvbXBvc2l0ZScsXG4gICAgICAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICAgICAnZmVEaWZmdXNlTGlnaHRpbmcnLFxuICAgICAgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgICAgICdmZURpc3RhbnRMaWdodCcsXG4gICAgICAnZmVGbG9vZCcsXG4gICAgICAnZmVGdW5jQScsXG4gICAgICAnZmVGdW5jQicsXG4gICAgICAnZmVGdW5jRycsXG4gICAgICAnZmVGdW5jUicsXG4gICAgICAnZmVHYXVzc2lhbkJsdXInLFxuICAgICAgJ2ZlSW1hZ2UnLFxuICAgICAgJ2ZlTWVyZ2UnLFxuICAgICAgJ2ZlTWVyZ2VOb2RlJyxcbiAgICAgICdmZU1vcnBob2xvZ3knLFxuICAgICAgJ2ZlT2Zmc2V0JyxcbiAgICAgICdmZVBvaW50TGlnaHQnLFxuICAgICAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICAgICAnZmVTcG90TGlnaHQnLFxuICAgICAgJ2ZlVGlsZScsXG4gICAgICAnZmVUdXJidWxlbmNlJ1xuICAgIF0pO1xuICAgIHZhciBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFtcbiAgICAgICdhbmltYXRlJyxcbiAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICdjdXJzb3InLFxuICAgICAgJ2Rpc2NhcmQnLFxuICAgICAgJ2ZlZHJvcHNoYWRvdycsXG4gICAgICAnZm9udC1mYWNlJyxcbiAgICAgICdmb250LWZhY2UtZm9ybWF0JyxcbiAgICAgICdmb250LWZhY2UtbmFtZScsXG4gICAgICAnZm9udC1mYWNlLXNyYycsXG4gICAgICAnZm9udC1mYWNlLXVyaScsXG4gICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAnaGF0Y2gnLFxuICAgICAgJ2hhdGNocGF0aCcsXG4gICAgICAnbWVzaCcsXG4gICAgICAnbWVzaGdyYWRpZW50JyxcbiAgICAgICdtZXNocGF0Y2gnLFxuICAgICAgJ21lc2hyb3cnLFxuICAgICAgJ21pc3NpbmctZ2x5cGgnLFxuICAgICAgJ3NjcmlwdCcsXG4gICAgICAnc2V0JyxcbiAgICAgICdzb2xpZGNvbG9yJyxcbiAgICAgICd1bmtub3duJyxcbiAgICAgICd1c2UnXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbCQxID0gZnJlZXplKFtcbiAgICAgICdtYXRoJyxcbiAgICAgICdtZW5jbG9zZScsXG4gICAgICAnbWVycm9yJyxcbiAgICAgICdtZmVuY2VkJyxcbiAgICAgICdtZnJhYycsXG4gICAgICAnbWdseXBoJyxcbiAgICAgICdtaScsXG4gICAgICAnbWxhYmVsZWR0cicsXG4gICAgICAnbW11bHRpc2NyaXB0cycsXG4gICAgICAnbW4nLFxuICAgICAgJ21vJyxcbiAgICAgICdtb3ZlcicsXG4gICAgICAnbXBhZGRlZCcsXG4gICAgICAnbXBoYW50b20nLFxuICAgICAgJ21yb290JyxcbiAgICAgICdtcm93JyxcbiAgICAgICdtcycsXG4gICAgICAnbXNwYWNlJyxcbiAgICAgICdtc3FydCcsXG4gICAgICAnbXN0eWxlJyxcbiAgICAgICdtc3ViJyxcbiAgICAgICdtc3VwJyxcbiAgICAgICdtc3Vic3VwJyxcbiAgICAgICdtdGFibGUnLFxuICAgICAgJ210ZCcsXG4gICAgICAnbXRleHQnLFxuICAgICAgJ210cicsXG4gICAgICAnbXVuZGVyJyxcbiAgICAgICdtdW5kZXJvdmVyJ1xuICAgIF0pO1xuICAgIHZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFtcbiAgICAgICdtYWN0aW9uJyxcbiAgICAgICdtYWxpZ25ncm91cCcsXG4gICAgICAnbWFsaWdubWFyaycsXG4gICAgICAnbWxvbmdkaXYnLFxuICAgICAgJ21zY2FycmllcycsXG4gICAgICAnbXNjYXJyeScsXG4gICAgICAnbXNncm91cCcsXG4gICAgICAnbXN0YWNrJyxcbiAgICAgICdtc2xpbmUnLFxuICAgICAgJ21zcm93JyxcbiAgICAgICdzZW1hbnRpY3MnLFxuICAgICAgJ2Fubm90YXRpb24nLFxuICAgICAgJ2Fubm90YXRpb24teG1sJyxcbiAgICAgICdtcHJlc2NyaXB0cycsXG4gICAgICAnbm9uZSdcbiAgICBdKTtcbiAgICB2YXIgdGV4dCA9IGZyZWV6ZShbJyN0ZXh0J10pO1xuICAgIHZhciBodG1sID0gZnJlZXplKFtcbiAgICAgICdhY2NlcHQnLFxuICAgICAgJ2FjdGlvbicsXG4gICAgICAnYWxpZ24nLFxuICAgICAgJ2FsdCcsXG4gICAgICAnYXV0b2NhcGl0YWxpemUnLFxuICAgICAgJ2F1dG9jb21wbGV0ZScsXG4gICAgICAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgJ2F1dG9wbGF5JyxcbiAgICAgICdiYWNrZ3JvdW5kJyxcbiAgICAgICdiZ2NvbG9yJyxcbiAgICAgICdib3JkZXInLFxuICAgICAgJ2NhcHR1cmUnLFxuICAgICAgJ2NlbGxwYWRkaW5nJyxcbiAgICAgICdjZWxsc3BhY2luZycsXG4gICAgICAnY2hlY2tlZCcsXG4gICAgICAnY2l0ZScsXG4gICAgICAnY2xhc3MnLFxuICAgICAgJ2NsZWFyJyxcbiAgICAgICdjb2xvcicsXG4gICAgICAnY29scycsXG4gICAgICAnY29sc3BhbicsXG4gICAgICAnY29udHJvbHMnLFxuICAgICAgJ2NvbnRyb2xzbGlzdCcsXG4gICAgICAnY29vcmRzJyxcbiAgICAgICdjcm9zc29yaWdpbicsXG4gICAgICAnZGF0ZXRpbWUnLFxuICAgICAgJ2RlY29kaW5nJyxcbiAgICAgICdkZWZhdWx0JyxcbiAgICAgICdkaXInLFxuICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsXG4gICAgICAnZGlzYWJsZXJlbW90ZXBsYXliYWNrJyxcbiAgICAgICdkb3dubG9hZCcsXG4gICAgICAnZHJhZ2dhYmxlJyxcbiAgICAgICdlbmN0eXBlJyxcbiAgICAgICdlbnRlcmtleWhpbnQnLFxuICAgICAgJ2ZhY2UnLFxuICAgICAgJ2ZvcicsXG4gICAgICAnaGVhZGVycycsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICdoaWRkZW4nLFxuICAgICAgJ2hpZ2gnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2hyZWZsYW5nJyxcbiAgICAgICdpZCcsXG4gICAgICAnaW5wdXRtb2RlJyxcbiAgICAgICdpbnRlZ3JpdHknLFxuICAgICAgJ2lzbWFwJyxcbiAgICAgICdraW5kJyxcbiAgICAgICdsYWJlbCcsXG4gICAgICAnbGFuZycsXG4gICAgICAnbGlzdCcsXG4gICAgICAnbG9hZGluZycsXG4gICAgICAnbG9vcCcsXG4gICAgICAnbG93JyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21heGxlbmd0aCcsXG4gICAgICAnbWVkaWEnLFxuICAgICAgJ21ldGhvZCcsXG4gICAgICAnbWluJyxcbiAgICAgICdtaW5sZW5ndGgnLFxuICAgICAgJ211bHRpcGxlJyxcbiAgICAgICdtdXRlZCcsXG4gICAgICAnbmFtZScsXG4gICAgICAnbm9uY2UnLFxuICAgICAgJ25vc2hhZGUnLFxuICAgICAgJ25vdmFsaWRhdGUnLFxuICAgICAgJ25vd3JhcCcsXG4gICAgICAnb3BlbicsXG4gICAgICAnb3B0aW11bScsXG4gICAgICAncGF0dGVybicsXG4gICAgICAncGxhY2Vob2xkZXInLFxuICAgICAgJ3BsYXlzaW5saW5lJyxcbiAgICAgICdwb3N0ZXInLFxuICAgICAgJ3ByZWxvYWQnLFxuICAgICAgJ3B1YmRhdGUnLFxuICAgICAgJ3JhZGlvZ3JvdXAnLFxuICAgICAgJ3JlYWRvbmx5JyxcbiAgICAgICdyZWwnLFxuICAgICAgJ3JlcXVpcmVkJyxcbiAgICAgICdyZXYnLFxuICAgICAgJ3JldmVyc2VkJyxcbiAgICAgICdyb2xlJyxcbiAgICAgICdyb3dzJyxcbiAgICAgICdyb3dzcGFuJyxcbiAgICAgICdzcGVsbGNoZWNrJyxcbiAgICAgICdzY29wZScsXG4gICAgICAnc2VsZWN0ZWQnLFxuICAgICAgJ3NoYXBlJyxcbiAgICAgICdzaXplJyxcbiAgICAgICdzaXplcycsXG4gICAgICAnc3BhbicsXG4gICAgICAnc3JjbGFuZycsXG4gICAgICAnc3RhcnQnLFxuICAgICAgJ3NyYycsXG4gICAgICAnc3Jjc2V0JyxcbiAgICAgICdzdGVwJyxcbiAgICAgICdzdHlsZScsXG4gICAgICAnc3VtbWFyeScsXG4gICAgICAndGFiaW5kZXgnLFxuICAgICAgJ3RpdGxlJyxcbiAgICAgICd0cmFuc2xhdGUnLFxuICAgICAgJ3R5cGUnLFxuICAgICAgJ3VzZW1hcCcsXG4gICAgICAndmFsaWduJyxcbiAgICAgICd2YWx1ZScsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ3htbG5zJyxcbiAgICAgICdzbG90J1xuICAgIF0pO1xuICAgIHZhciBzdmcgPSBmcmVlemUoW1xuICAgICAgJ2FjY2VudC1oZWlnaHQnLFxuICAgICAgJ2FjY3VtdWxhdGUnLFxuICAgICAgJ2FkZGl0aXZlJyxcbiAgICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICAgICAgJ2FzY2VudCcsXG4gICAgICAnYXR0cmlidXRlbmFtZScsXG4gICAgICAnYXR0cmlidXRldHlwZScsXG4gICAgICAnYXppbXV0aCcsXG4gICAgICAnYmFzZWZyZXF1ZW5jeScsXG4gICAgICAnYmFzZWxpbmUtc2hpZnQnLFxuICAgICAgJ2JlZ2luJyxcbiAgICAgICdiaWFzJyxcbiAgICAgICdieScsXG4gICAgICAnY2xhc3MnLFxuICAgICAgJ2NsaXAnLFxuICAgICAgJ2NsaXBwYXRodW5pdHMnLFxuICAgICAgJ2NsaXAtcGF0aCcsXG4gICAgICAnY2xpcC1ydWxlJyxcbiAgICAgICdjb2xvcicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gICAgICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgICAgICdjb2xvci1wcm9maWxlJyxcbiAgICAgICdjb2xvci1yZW5kZXJpbmcnLFxuICAgICAgJ2N4JyxcbiAgICAgICdjeScsXG4gICAgICAnZCcsXG4gICAgICAnZHgnLFxuICAgICAgJ2R5JyxcbiAgICAgICdkaWZmdXNlY29uc3RhbnQnLFxuICAgICAgJ2RpcmVjdGlvbicsXG4gICAgICAnZGlzcGxheScsXG4gICAgICAnZGl2aXNvcicsXG4gICAgICAnZHVyJyxcbiAgICAgICdlZGdlbW9kZScsXG4gICAgICAnZWxldmF0aW9uJyxcbiAgICAgICdlbmQnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAnZmlsbC1ydWxlJyxcbiAgICAgICdmaWx0ZXInLFxuICAgICAgJ2ZpbHRlcnVuaXRzJyxcbiAgICAgICdmbG9vZC1jb2xvcicsXG4gICAgICAnZmxvb2Qtb3BhY2l0eScsXG4gICAgICAnZm9udC1mYW1pbHknLFxuICAgICAgJ2ZvbnQtc2l6ZScsXG4gICAgICAnZm9udC1zaXplLWFkanVzdCcsXG4gICAgICAnZm9udC1zdHJldGNoJyxcbiAgICAgICdmb250LXN0eWxlJyxcbiAgICAgICdmb250LXZhcmlhbnQnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICdmeCcsXG4gICAgICAnZnknLFxuICAgICAgJ2cxJyxcbiAgICAgICdnMicsXG4gICAgICAnZ2x5cGgtbmFtZScsXG4gICAgICAnZ2x5cGhyZWYnLFxuICAgICAgJ2dyYWRpZW50dW5pdHMnLFxuICAgICAgJ2dyYWRpZW50dHJhbnNmb3JtJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2lkJyxcbiAgICAgICdpbWFnZS1yZW5kZXJpbmcnLFxuICAgICAgJ2luJyxcbiAgICAgICdpbjInLFxuICAgICAgJ2snLFxuICAgICAgJ2sxJyxcbiAgICAgICdrMicsXG4gICAgICAnazMnLFxuICAgICAgJ2s0JyxcbiAgICAgICdrZXJuaW5nJyxcbiAgICAgICdrZXlwb2ludHMnLFxuICAgICAgJ2tleXNwbGluZXMnLFxuICAgICAgJ2tleXRpbWVzJyxcbiAgICAgICdsYW5nJyxcbiAgICAgICdsZW5ndGhhZGp1c3QnLFxuICAgICAgJ2xldHRlci1zcGFjaW5nJyxcbiAgICAgICdrZXJuZWxtYXRyaXgnLFxuICAgICAgJ2tlcm5lbHVuaXRsZW5ndGgnLFxuICAgICAgJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgICAgICdsb2NhbCcsXG4gICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICdtYXJrZXJoZWlnaHQnLFxuICAgICAgJ21hcmtlcnVuaXRzJyxcbiAgICAgICdtYXJrZXJ3aWR0aCcsXG4gICAgICAnbWFza2NvbnRlbnR1bml0cycsXG4gICAgICAnbWFza3VuaXRzJyxcbiAgICAgICdtYXgnLFxuICAgICAgJ21hc2snLFxuICAgICAgJ21lZGlhJyxcbiAgICAgICdtZXRob2QnLFxuICAgICAgJ21vZGUnLFxuICAgICAgJ21pbicsXG4gICAgICAnbmFtZScsXG4gICAgICAnbnVtb2N0YXZlcycsXG4gICAgICAnb2Zmc2V0JyxcbiAgICAgICdvcGVyYXRvcicsXG4gICAgICAnb3BhY2l0eScsXG4gICAgICAnb3JkZXInLFxuICAgICAgJ29yaWVudCcsXG4gICAgICAnb3JpZW50YXRpb24nLFxuICAgICAgJ29yaWdpbicsXG4gICAgICAnb3ZlcmZsb3cnLFxuICAgICAgJ3BhaW50LW9yZGVyJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdwYXRobGVuZ3RoJyxcbiAgICAgICdwYXR0ZXJuY29udGVudHVuaXRzJyxcbiAgICAgICdwYXR0ZXJudHJhbnNmb3JtJyxcbiAgICAgICdwYXR0ZXJudW5pdHMnLFxuICAgICAgJ3BvaW50cycsXG4gICAgICAncHJlc2VydmVhbHBoYScsXG4gICAgICAncHJlc2VydmVhc3BlY3RyYXRpbycsXG4gICAgICAncHJpbWl0aXZldW5pdHMnLFxuICAgICAgJ3InLFxuICAgICAgJ3J4JyxcbiAgICAgICdyeScsXG4gICAgICAncmFkaXVzJyxcbiAgICAgICdyZWZ4JyxcbiAgICAgICdyZWZ5JyxcbiAgICAgICdyZXBlYXRjb3VudCcsXG4gICAgICAncmVwZWF0ZHVyJyxcbiAgICAgICdyZXN0YXJ0JyxcbiAgICAgICdyZXN1bHQnLFxuICAgICAgJ3JvdGF0ZScsXG4gICAgICAnc2NhbGUnLFxuICAgICAgJ3NlZWQnLFxuICAgICAgJ3NoYXBlLXJlbmRlcmluZycsXG4gICAgICAnc3BlY3VsYXJjb25zdGFudCcsXG4gICAgICAnc3BlY3VsYXJleHBvbmVudCcsXG4gICAgICAnc3ByZWFkbWV0aG9kJyxcbiAgICAgICdzdGFydG9mZnNldCcsXG4gICAgICAnc3RkZGV2aWF0aW9uJyxcbiAgICAgICdzdGl0Y2h0aWxlcycsXG4gICAgICAnc3RvcC1jb2xvcicsXG4gICAgICAnc3RvcC1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgICAgJ3N0cm9rZS1saW5lam9pbicsXG4gICAgICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgICAnc3R5bGUnLFxuICAgICAgJ3N1cmZhY2VzY2FsZScsXG4gICAgICAnc3lzdGVtbGFuZ3VhZ2UnLFxuICAgICAgJ3RhYmluZGV4JyxcbiAgICAgICd0YXJnZXR4JyxcbiAgICAgICd0YXJnZXR5JyxcbiAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAgICAgJ3RleHQtYW5jaG9yJyxcbiAgICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgJ3RleHQtcmVuZGVyaW5nJyxcbiAgICAgICd0ZXh0bGVuZ3RoJyxcbiAgICAgICd0eXBlJyxcbiAgICAgICd1MScsXG4gICAgICAndTInLFxuICAgICAgJ3VuaWNvZGUnLFxuICAgICAgJ3ZhbHVlcycsXG4gICAgICAndmlld2JveCcsXG4gICAgICAndmlzaWJpbGl0eScsXG4gICAgICAndmVyc2lvbicsXG4gICAgICAndmVydC1hZHYteScsXG4gICAgICAndmVydC1vcmlnaW4teCcsXG4gICAgICAndmVydC1vcmlnaW4teScsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ3dvcmQtc3BhY2luZycsXG4gICAgICAnd3JhcCcsXG4gICAgICAnd3JpdGluZy1tb2RlJyxcbiAgICAgICd4Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd5Y2hhbm5lbHNlbGVjdG9yJyxcbiAgICAgICd4JyxcbiAgICAgICd4MScsXG4gICAgICAneDInLFxuICAgICAgJ3htbG5zJyxcbiAgICAgICd5JyxcbiAgICAgICd5MScsXG4gICAgICAneTInLFxuICAgICAgJ3onLFxuICAgICAgJ3pvb21hbmRwYW4nXG4gICAgXSk7XG4gICAgdmFyIG1hdGhNbCA9IGZyZWV6ZShbXG4gICAgICAnYWNjZW50JyxcbiAgICAgICdhY2NlbnR1bmRlcicsXG4gICAgICAnYWxpZ24nLFxuICAgICAgJ2JldmVsbGVkJyxcbiAgICAgICdjbG9zZScsXG4gICAgICAnY29sdW1uc2FsaWduJyxcbiAgICAgICdjb2x1bW5saW5lcycsXG4gICAgICAnY29sdW1uc3BhbicsXG4gICAgICAnZGVub21hbGlnbicsXG4gICAgICAnZGVwdGgnLFxuICAgICAgJ2RpcicsXG4gICAgICAnZGlzcGxheScsXG4gICAgICAnZGlzcGxheXN0eWxlJyxcbiAgICAgICdlbmNvZGluZycsXG4gICAgICAnZmVuY2UnLFxuICAgICAgJ2ZyYW1lJyxcbiAgICAgICdoZWlnaHQnLFxuICAgICAgJ2hyZWYnLFxuICAgICAgJ2lkJyxcbiAgICAgICdsYXJnZW9wJyxcbiAgICAgICdsZW5ndGgnLFxuICAgICAgJ2xpbmV0aGlja25lc3MnLFxuICAgICAgJ2xzcGFjZScsXG4gICAgICAnbHF1b3RlJyxcbiAgICAgICdtYXRoYmFja2dyb3VuZCcsXG4gICAgICAnbWF0aGNvbG9yJyxcbiAgICAgICdtYXRoc2l6ZScsXG4gICAgICAnbWF0aHZhcmlhbnQnLFxuICAgICAgJ21heHNpemUnLFxuICAgICAgJ21pbnNpemUnLFxuICAgICAgJ21vdmFibGVsaW1pdHMnLFxuICAgICAgJ25vdGF0aW9uJyxcbiAgICAgICdudW1hbGlnbicsXG4gICAgICAnb3BlbicsXG4gICAgICAncm93YWxpZ24nLFxuICAgICAgJ3Jvd2xpbmVzJyxcbiAgICAgICdyb3dzcGFjaW5nJyxcbiAgICAgICdyb3dzcGFuJyxcbiAgICAgICdyc3BhY2UnLFxuICAgICAgJ3JxdW90ZScsXG4gICAgICAnc2NyaXB0bGV2ZWwnLFxuICAgICAgJ3NjcmlwdG1pbnNpemUnLFxuICAgICAgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJyxcbiAgICAgICdzZWxlY3Rpb24nLFxuICAgICAgJ3NlcGFyYXRvcicsXG4gICAgICAnc2VwYXJhdG9ycycsXG4gICAgICAnc3RyZXRjaHknLFxuICAgICAgJ3N1YnNjcmlwdHNoaWZ0JyxcbiAgICAgICdzdXBzY3JpcHRzaGlmdCcsXG4gICAgICAnc3ltbWV0cmljJyxcbiAgICAgICd2b2Zmc2V0JyxcbiAgICAgICd3aWR0aCcsXG4gICAgICAneG1sbnMnXG4gICAgXSk7XG4gICAgdmFyIHhtbCA9IGZyZWV6ZShbXG4gICAgICAneGxpbms6aHJlZicsXG4gICAgICAneG1sOmlkJyxcbiAgICAgICd4bGluazp0aXRsZScsXG4gICAgICAneG1sOnNwYWNlJyxcbiAgICAgICd4bWxuczp4bGluaydcbiAgICBdKTtcbiAgICB2YXIgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pO1xuICAgIHZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcd1xcV10qfFtcXHdcXFddKiU+L2dtKTtcbiAgICB2YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7XG4gICAgdmFyIEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTtcbiAgICB2YXIgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfGNpZHx4bXBwKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pKTtcbiAgICB2YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG4gICAgdmFyIEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyk7XG4gICAgdmFyIERPQ1RZUEVfTkFNRSA9IHNlYWwoL15odG1sJC9pKTtcbiAgICB2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbiAgICB9O1xuICAgIHZhciBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5ID0gZnVuY3Rpb24gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGRvY3VtZW50KSB7XG4gICAgICBpZiAoX3R5cGVvZih0cnVzdGVkVHlwZXMpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBzdWZmaXggPSBudWxsO1xuICAgICAgdmFyIEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICAgICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkge1xuICAgICAgICBzdWZmaXggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICAgICAgfVxuICAgICAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTChodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgICAgIHZhciB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuICAgICAgdmFyIERPTVB1cmlmeSA9IGZ1bmN0aW9uIERPTVB1cmlmeShyb290KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMi4zLjgnO1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgICAgfVxuICAgICAgdmFyIG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICB2YXIgRG9jdW1lbnRGcmFnbWVudCA9IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LCBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQsIE5vZGUgPSB3aW5kb3cuTm9kZSwgRWxlbWVudCA9IHdpbmRvdy5FbGVtZW50LCBOb2RlRmlsdGVyID0gd2luZG93Lk5vZGVGaWx0ZXIsIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCwgTmFtZWROb2RlTWFwID0gX3dpbmRvdyROYW1lZE5vZGVNYXAgPT09IHZvaWQgMCA/IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCA6IF93aW5kb3ckTmFtZWROb2RlTWFwLCBIVE1MRm9ybUVsZW1lbnQgPSB3aW5kb3cuSFRNTEZvcm1FbGVtZW50LCBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLCB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICAgICAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICAgICAgdmFyIGdldENoaWxkTm9kZXMgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2NoaWxkTm9kZXMnKTtcbiAgICAgIHZhciBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG4gICAgICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gICAgICB2YXIgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG4gICAgICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLCBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLCBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICAgICAgdmFyIGltcG9ydE5vZGUgPSBvcmlnaW5hbERvY3VtZW50LmltcG9ydE5vZGU7XG4gICAgICB2YXIgZG9jdW1lbnRNb2RlID0ge307XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudE1vZGUgPSBjbG9uZShkb2N1bWVudCkuZG9jdW1lbnRNb2RlID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDoge307XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICB9XG4gICAgICB2YXIgaG9va3MgPSB7fTtcbiAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IHR5cGVvZiBnZXRQYXJlbnROb2RlID09PSAnZnVuY3Rpb24nICYmIGltcGxlbWVudGF0aW9uICYmIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50TW9kZSAhPT0gOTtcbiAgICAgIHZhciBNVVNUQUNIRV9FWFBSJDEgPSBNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiQxID0gRVJCX0VYUFIsIERBVEFfQVRUUiQxID0gREFUQV9BVFRSLCBBUklBX0FUVFIkMSA9IEFSSUFfQVRUUiwgSVNfU0NSSVBUX09SX0RBVEEkMSA9IElTX1NDUklQVF9PUl9EQVRBLCBBVFRSX1dISVRFU1BBQ0UkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgICAgIHZhciBJU19BTExPV0VEX1VSSSQxID0gSVNfQUxMT1dFRF9VUkk7XG4gICAgICB2YXIgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGh0bWwkMSksIF90b0NvbnN1bWFibGVBcnJheShzdmckMSksIF90b0NvbnN1bWFibGVBcnJheShzdmdGaWx0ZXJzKSwgX3RvQ29uc3VtYWJsZUFycmF5KG1hdGhNbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRleHQpKSk7XG4gICAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGh0bWwpLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5KG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSh4bWwpKSk7XG4gICAgICB2YXIgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBPYmplY3Quc2VhbChPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgdGFnTmFtZUNoZWNrOiB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM6IHtcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG4gICAgICB2YXIgRk9SQklEX0FUVFIgPSBudWxsO1xuICAgICAgdmFyIEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG4gICAgICB2YXIgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcbiAgICAgIHZhciBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuICAgICAgdmFyIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuICAgICAgdmFyIFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG4gICAgICB2YXIgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICAgICAgdmFyIEZPUkNFX0JPRFkgPSBmYWxzZTtcbiAgICAgIHZhciBSRVRVUk5fRE9NID0gZmFsc2U7XG4gICAgICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuICAgICAgdmFyIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcbiAgICAgIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuICAgICAgdmFyIEtFRVBfQ09OVEVOVCA9IHRydWU7XG4gICAgICB2YXIgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgIHZhciBVU0VfUFJPRklMRVMgPSB7fTtcbiAgICAgIHZhciBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICAgICAgdmFyIERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ2Fubm90YXRpb24teG1sJyxcbiAgICAgICAgJ2F1ZGlvJyxcbiAgICAgICAgJ2NvbGdyb3VwJyxcbiAgICAgICAgJ2Rlc2MnLFxuICAgICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAgICdoZWFkJyxcbiAgICAgICAgJ2lmcmFtZScsXG4gICAgICAgICdtYXRoJyxcbiAgICAgICAgJ21pJyxcbiAgICAgICAgJ21uJyxcbiAgICAgICAgJ21vJyxcbiAgICAgICAgJ21zJyxcbiAgICAgICAgJ210ZXh0JyxcbiAgICAgICAgJ25vZW1iZWQnLFxuICAgICAgICAnbm9mcmFtZXMnLFxuICAgICAgICAnbm9zY3JpcHQnLFxuICAgICAgICAncGxhaW50ZXh0JyxcbiAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdzdmcnLFxuICAgICAgICAndGVtcGxhdGUnLFxuICAgICAgICAndGhlYWQnLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICAndmlkZW8nLFxuICAgICAgICAneG1wJ1xuICAgICAgXSk7XG4gICAgICB2YXIgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gICAgICB2YXIgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ2F1ZGlvJyxcbiAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgJ2ltZycsXG4gICAgICAgICdzb3VyY2UnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAndHJhY2snXG4gICAgICBdKTtcbiAgICAgIHZhciBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgICAgIHZhciBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnYWx0JyxcbiAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgJ2ZvcicsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdsYWJlbCcsXG4gICAgICAgICduYW1lJyxcbiAgICAgICAgJ3BhdHRlcm4nLFxuICAgICAgICAncGxhY2Vob2xkZXInLFxuICAgICAgICAncm9sZScsXG4gICAgICAgICdzdW1tYXJ5JyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ3htbG5zJ1xuICAgICAgXSk7XG4gICAgICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgICAgIHZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICAgIHZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgICAgIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgICAgIHZhciBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuICAgICAgdmFyIFBBUlNFUl9NRURJQV9UWVBFO1xuICAgICAgdmFyIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbXG4gICAgICAgICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnLFxuICAgICAgICAndGV4dC9odG1sJ1xuICAgICAgXTtcbiAgICAgIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gICAgICB2YXIgdHJhbnNmb3JtQ2FzZUZ1bmM7XG4gICAgICB2YXIgQ09ORklHID0gbnVsbDtcbiAgICAgIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICAgIHZhciBpc1JlZ2V4T3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzUmVnZXhPckZ1bmN0aW9uKHRlc3RWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGVzdFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHRlc3RWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICAgICAgfTtcbiAgICAgIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjZmcgfHwgX3R5cGVvZihjZmcpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNmZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNmZyA9IGNsb25lKGNmZyk7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgICAgICBBTExPV0VEX0FUVFIgPSAnQUxMT1dFRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUikgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICAgICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICAgICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gJ0ZPUkJJRF9DT05URU5UUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMpIDogREVGQVVMVF9GT1JCSURfQ09OVEVOVFM7XG4gICAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgICAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICAgICAgVVNFX1BST0ZJTEVTID0gJ1VTRV9QUk9GSUxFUycgaW4gY2ZnID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgICAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTtcbiAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gY2ZnLkFMTE9XX0RBVEFfQVRUUiAhPT0gZmFsc2U7XG4gICAgICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlO1xuICAgICAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlO1xuICAgICAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTtcbiAgICAgICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlO1xuICAgICAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7XG4gICAgICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTtcbiAgICAgICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlO1xuICAgICAgICBTQU5JVElaRV9ET00gPSBjZmcuU0FOSVRJWkVfRE9NICE9PSBmYWxzZTtcbiAgICAgICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7XG4gICAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlO1xuICAgICAgICBJU19BTExPV0VEX1VSSSQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQxO1xuICAgICAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7XG4gICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2spKSB7XG4gICAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIHR5cGVvZiBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIFBBUlNFUl9NRURJQV9UWVBFID0gU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG4gICAgICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIF90b0NvbnN1bWFibGVBcnJheSh0ZXh0KSk7XG4gICAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmckMSk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2Zyk7XG4gICAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5tYXRoTWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sJDEpO1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICAgICAgaWYgKEFMTE9XRURfQVRUUiA9PT0gREVGQVVMVF9BTExPV0VEX0FUVFIpIHtcbiAgICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgICAgIGlmIChGT1JCSURfQ09OVEVOVFMgPT09IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgICAgICBBTExPV0VEX1RBR1NbJyN0ZXh0J10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgW1xuICAgICAgICAgICAgJ2h0bWwnLFxuICAgICAgICAgICAgJ2hlYWQnLFxuICAgICAgICAgICAgJ2JvZHknXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICAgIGZyZWV6ZShjZmcpO1xuICAgICAgICB9XG4gICAgICAgIENPTkZJRyA9IGNmZztcbiAgICAgIH07XG4gICAgICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFtcbiAgICAgICAgJ21pJyxcbiAgICAgICAgJ21vJyxcbiAgICAgICAgJ21uJyxcbiAgICAgICAgJ21zJyxcbiAgICAgICAgJ210ZXh0J1xuICAgICAgXSk7XG4gICAgICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgW1xuICAgICAgICAnZm9yZWlnbm9iamVjdCcsXG4gICAgICAgICdkZXNjJyxcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgJ2Fubm90YXRpb24teG1sJ1xuICAgICAgXSk7XG4gICAgICB2YXIgQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgICAgICd0aXRsZScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdmb250JyxcbiAgICAgICAgJ2EnLFxuICAgICAgICAnc2NyaXB0J1xuICAgICAgXSk7XG4gICAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2ZyQxKTtcbiAgICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRmlsdGVycyk7XG4gICAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuICAgICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwkMSk7XG4gICAgICBhZGRUb1NldChBTExfTUFUSE1MX1RBR1MsIG1hdGhNbERpc2FsbG93ZWQpO1xuICAgICAgdmFyIF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBIVE1MX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICAgICAgdmFyIHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBCb29sZWFuKEFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHZhciBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgICAgICB2YXIgZG9jO1xuICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2U7XG4gICAgICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICAgIHJldHVybiBlbG0gaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKTtcbiAgICAgIH07XG4gICAgICB2YXIgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBfdHlwZW9mKE5vZGUpID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgX3R5cGVvZihvYmplY3QpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICAgIH07XG4gICAgICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgICAgIGlmICghaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ0V4cFRlc3QoL1tcXHUwMDgwLVxcdUZGRkZdLywgY3VycmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiYgIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgaWYgKCFGT1JCSURfVEFHU1t0YWdOYW1lXSAmJiBfYmFzaWNDdXN0b21FbGVtZW50VGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdGFnTmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodGFnTmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZENvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSksIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFfY2hlY2tWYWxpZE5hbWVzcGFjZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWQpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQxLCAnICcpO1xuICAgICAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIEVSQl9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkMSwgbGNOYW1lKSk7XG4gICAgICAgIGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQxLCBsY05hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgICAgICBpZiAoX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fCBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSk7XG4gICAgICAgIGVsc2UgaWYgKHJlZ0V4cFRlc3QoSVNfQUxMT1dFRF9VUkkkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJDEsICcnKSkpO1xuICAgICAgICBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKTtcbiAgICAgICAgZWxzZSBpZiAoQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgJiYgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJDEsICcnKSkpO1xuICAgICAgICBlbHNlIGlmICghdmFsdWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIF9iYXNpY0N1c3RvbUVsZW1lbnRUZXN0ID0gZnVuY3Rpb24gX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPiAwO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgbGNOYW1lO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgICAgICB9O1xuICAgICAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgICAgICB2YXIgX2F0dHIgPSBhdHRyLCBuYW1lID0gX2F0dHIubmFtZSwgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICAgIHZhbHVlID0gbmFtZSA9PT0gJ3ZhbHVlJyA/IGF0dHIudmFsdWUgOiBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgICAgIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKG5hbWUpO1xuICAgICAgICAgIHZhciBpbml0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVBdHRyaWJ1dGUnLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTtcbiAgICAgICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBpbml0VmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIHNoYWRvd05vZGU7XG4gICAgICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG4gICAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplU2hhZG93Tm9kZScsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIHZhciBpbXBvcnRlZE5vZGU7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZTtcbiAgICAgICAgdmFyIG9sZE5vZGU7XG4gICAgICAgIHZhciByZXR1cm5Ob2RlO1xuICAgICAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICAgICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgICB9XG4gICAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZGlydHkubm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdyb290IG5vZGUgaXMgZm9yYmlkZGVuIGFuZCBjYW5ub3QgYmUgc2FuaXRpemVkIGluLXBsYWNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IDEgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiYgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcbiAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgb2xkTm9kZSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG9sZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcbiAgICAgICAgaWYgKFdIT0xFX0RPQ1VNRU5UICYmIEFMTE9XRURfVEFHU1snIWRvY3R5cGUnXSAmJiBib2R5Lm93bmVyRG9jdW1lbnQgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSAmJiByZWdFeHBUZXN0KERPQ1RZUEVfTkFNRSwgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBNVVNUQUNIRV9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICAgICAgfTtcbiAgICAgIERPTVB1cmlmeS5zZXRDb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENPTkZJRyA9IG51bGw7XG4gICAgICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICghQ09ORklHKSB7XG4gICAgICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyh0YWcpO1xuICAgICAgICB2YXIgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gaG9va3NbZW50cnlQb2ludF0gfHwgW107XG4gICAgICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICAgIH07XG4gICAgICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgICAgIHJldHVybiBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgICBob29rc1tlbnRyeVBvaW50XSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBob29rcyA9IHt9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBET01QdXJpZnk7XG4gICAgfVxuICAgIHZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuICAgIGNvbnN0IGVhY2gkNCA9IFRvb2xzLmVhY2gsIHRyaW0gPSBUb29scy50cmltO1xuICAgIGNvbnN0IHF1ZXJ5UGFydHMgPSBbXG4gICAgICAnc291cmNlJyxcbiAgICAgICdwcm90b2NvbCcsXG4gICAgICAnYXV0aG9yaXR5JyxcbiAgICAgICd1c2VySW5mbycsXG4gICAgICAndXNlcicsXG4gICAgICAncGFzc3dvcmQnLFxuICAgICAgJ2hvc3QnLFxuICAgICAgJ3BvcnQnLFxuICAgICAgJ3JlbGF0aXZlJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdkaXJlY3RvcnknLFxuICAgICAgJ2ZpbGUnLFxuICAgICAgJ3F1ZXJ5JyxcbiAgICAgICdhbmNob3InXG4gICAgXTtcbiAgICBjb25zdCBERUZBVUxUX1BPUlRTID0ge1xuICAgICAgZnRwOiAyMSxcbiAgICAgIGh0dHA6IDgwLFxuICAgICAgaHR0cHM6IDQ0MyxcbiAgICAgIG1haWx0bzogMjVcbiAgICB9O1xuICAgIGNvbnN0IHNhZmVTdmdEYXRhVXJsRWxlbWVudHMgPSBbXG4gICAgICAnaW1nJyxcbiAgICAgICd2aWRlbydcbiAgICBdO1xuICAgIGNvbnN0IGJsb2NrU3ZnRGF0YVVyaXMgPSAoYWxsb3dTdmdEYXRhVXJscywgdGFnTmFtZSkgPT4ge1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYWxsb3dTdmdEYXRhVXJscykpIHtcbiAgICAgICAgcmV0dXJuICFhbGxvd1N2Z0RhdGFVcmxzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUodGFnTmFtZSkgPyAhY29udGFpbnMkMihzYWZlU3ZnRGF0YVVybEVsZW1lbnRzLCB0YWdOYW1lKSA6IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGVVcmkgPSBlbmNvZGVkVXJpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVyaSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlZFVyaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc0ludmFsaWRVcmkgPSAoc2V0dGluZ3MsIHVyaSwgdGFnTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZGVjb2RlZFVyaSA9IGRlY29kZVVyaSh1cmkpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBpZiAoc2V0dGluZ3MuYWxsb3dfc2NyaXB0X3VybHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgvKChqYXZhfHZiKXNjcmlwdHxtaHRtbCk6L2kudGVzdChkZWNvZGVkVXJpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYWxsb3dfaHRtbF9kYXRhX3VybHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgvXmRhdGE6aW1hZ2VcXC8vaS50ZXN0KGRlY29kZWRVcmkpKSB7XG4gICAgICAgIHJldHVybiBibG9ja1N2Z0RhdGFVcmlzKHNldHRpbmdzLmFsbG93X3N2Z19kYXRhX3VybHMsIHRhZ05hbWUpICYmIC9eZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3QoZGVjb2RlZFVyaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gL15kYXRhOi9pLnRlc3QoZGVjb2RlZFVyaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGFzcyBVUkkge1xuICAgICAgc3RhdGljIHBhcnNlRGF0YVVyaSh1cmkpIHtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGNvbnN0IHVyaUNvbXBvbmVudHMgPSBkZWNvZGVVUklDb21wb25lbnQodXJpKS5zcGxpdCgnLCcpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gL2RhdGE6KFteO10rKS8uZXhlYyh1cmlDb21wb25lbnRzWzBdKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICB0eXBlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGF0YTogdXJpQ29tcG9uZW50c1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGljIGlzRG9tU2FmZSh1cmksIGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRlY29kZWRVcmkgPSBFbnRpdGllcy5kZWNvZGUodXJpKS5yZXBsYWNlKC9bXFxzXFx1MDAwMC1cXHUwMDFGXSsvZywgJycpO1xuICAgICAgICAgIHJldHVybiAhaXNJbnZhbGlkVXJpKG9wdGlvbnMsIGRlY29kZWRVcmksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0aWMgZ2V0RG9jdW1lbnRCYXNlVXJsKGxvYykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBiYXNlVXJsO1xuICAgICAgICBpZiAobG9jLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCAmJiBsb2MucHJvdG9jb2wgIT09ICdmaWxlOicpIHtcbiAgICAgICAgICBiYXNlVXJsID0gKF9hID0gbG9jLmhyZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VVcmwgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3QgKyBsb2MucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW146XSs6XFwvXFwvXFwvP1teXFwvXStcXC8vLnRlc3QoYmFzZVVybCkpIHtcbiAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybC5yZXBsYWNlKC9bXFw/I10uKiQvLCAnJykucmVwbGFjZSgvW1xcL1xcXFxdW15cXC9dKyQvLCAnJyk7XG4gICAgICAgICAgaWYgKCEvW1xcL1xcXFxdJC8udGVzdChiYXNlVXJsKSkge1xuICAgICAgICAgICAgYmFzZVVybCArPSAnLyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgICAgfVxuICAgICAgY29uc3RydWN0b3IodXJsLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmRpcmVjdG9yeSA9ICcnO1xuICAgICAgICB1cmwgPSB0cmltKHVybCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgY29uc3QgYmFzZVVyaSA9IHNldHRpbmdzLmJhc2VfdXJpO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKC9eKFtcXHdcXC1dKyk6KFteXFwvXXsyfSkvaS50ZXN0KHVybCkgfHwgL15cXHMqIy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgc2VsZi5zb3VyY2UgPSB1cmw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUHJvdG9jb2xSZWxhdGl2ZSA9IHVybC5pbmRleE9mKCcvLycpID09PSAwO1xuICAgICAgICBpZiAodXJsLmluZGV4T2YoJy8nKSA9PT0gMCAmJiAhaXNQcm90b2NvbFJlbGF0aXZlKSB7XG4gICAgICAgICAgdXJsID0gKGJhc2VVcmkgPyBiYXNlVXJpLnByb3RvY29sIHx8ICdodHRwJyA6ICdodHRwJykgKyAnOi8vbWNlX2hvc3QnICsgdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL15bXFx3XFwtXSo6P1xcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgY29uc3QgYmFzZVVybCA9IGJhc2VVcmkgPyBiYXNlVXJpLnBhdGggOiBuZXcgVVJJKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpLmRpcmVjdG9yeTtcbiAgICAgICAgICBpZiAoKGJhc2VVcmkgPT09IG51bGwgfHwgYmFzZVVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZVVyaS5wcm90b2NvbCkgPT09ICcnKSB7XG4gICAgICAgICAgICB1cmwgPSAnLy9tY2VfaG9zdCcgKyBzZWxmLnRvQWJzUGF0aChiYXNlVXJsLCB1cmwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IC8oW14jP10qKShbIz9dPy4qKS8uZXhlYyh1cmwpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHVybCA9IChiYXNlVXJpICYmIGJhc2VVcmkucHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6Ly9tY2VfaG9zdCcgKyBzZWxmLnRvQWJzUGF0aChiYXNlVXJsLCBtYXRjaFsxXSkgKyBtYXRjaFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL0BAL2csICcobWNlX2F0KScpO1xuICAgICAgICBjb25zdCB1cmxNYXRjaCA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QFxcL10qKTo/KFteOkBcXC9dKikpP0ApPyhcXFtbYS16QS1aMC05Oi4lXStcXF18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLy5leGVjKHVybCk7XG4gICAgICAgIGlmICh1cmxNYXRjaCkge1xuICAgICAgICAgIGVhY2gkNChxdWVyeVBhcnRzLCAodiwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB1cmxNYXRjaFtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKG1jZV9hdFxcKS9nLCAnQEAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGZbdl0gPSBwYXJ0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVXJpKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLnByb3RvY29sKSB7XG4gICAgICAgICAgICBzZWxmLnByb3RvY29sID0gYmFzZVVyaS5wcm90b2NvbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLnVzZXJJbmZvKSB7XG4gICAgICAgICAgICBzZWxmLnVzZXJJbmZvID0gYmFzZVVyaS51c2VySW5mbztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxmLnBvcnQgJiYgc2VsZi5ob3N0ID09PSAnbWNlX2hvc3QnKSB7XG4gICAgICAgICAgICBzZWxmLnBvcnQgPSBiYXNlVXJpLnBvcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5ob3N0IHx8IHNlbGYuaG9zdCA9PT0gJ21jZV9ob3N0Jykge1xuICAgICAgICAgICAgc2VsZi5ob3N0ID0gYmFzZVVyaS5ob3N0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnNvdXJjZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3RvY29sUmVsYXRpdmUpIHtcbiAgICAgICAgICBzZWxmLnByb3RvY29sID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFBhdGgocGF0aCkge1xuICAgICAgICBjb25zdCBwYXRoTWF0Y2ggPSAvXiguKj8pXFwvPyhcXHcrKT8kLy5leGVjKHBhdGgpO1xuICAgICAgICBpZiAocGF0aE1hdGNoKSB7XG4gICAgICAgICAgdGhpcy5wYXRoID0gcGF0aE1hdGNoWzBdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0b3J5ID0gcGF0aE1hdGNoWzFdO1xuICAgICAgICAgIHRoaXMuZmlsZSA9IHBhdGhNYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICB0aGlzLmdldFVSSSgpO1xuICAgICAgfVxuICAgICAgdG9SZWxhdGl2ZSh1cmkpIHtcbiAgICAgICAgaWYgKHVyaSA9PT0gJy4vJykge1xuICAgICAgICAgIHJldHVybiB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVVcmkgPSBuZXcgVVJJKHVyaSwgeyBiYXNlX3VyaTogdGhpcyB9KTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLmhvc3QgIT09ICdtY2VfaG9zdCcgJiYgdGhpcy5ob3N0ICE9PSByZWxhdGl2ZVVyaS5ob3N0ICYmIHJlbGF0aXZlVXJpLmhvc3QgfHwgdGhpcy5wb3J0ICE9PSByZWxhdGl2ZVVyaS5wb3J0IHx8IHRoaXMucHJvdG9jb2wgIT09IHJlbGF0aXZlVXJpLnByb3RvY29sICYmIHJlbGF0aXZlVXJpLnByb3RvY29sICE9PSAnJykge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVyaS5nZXRVUkkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0dSA9IHRoaXMuZ2V0VVJJKCksIHV1ID0gcmVsYXRpdmVVcmkuZ2V0VVJJKCk7XG4gICAgICAgIGlmICh0dSA9PT0gdXUgfHwgdHUuY2hhckF0KHR1Lmxlbmd0aCAtIDEpID09PSAnLycgJiYgdHUuc3Vic3RyKDAsIHR1Lmxlbmd0aCAtIDEpID09PSB1dSkge1xuICAgICAgICAgIHJldHVybiB0dTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy50b1JlbFBhdGgodGhpcy5wYXRoLCByZWxhdGl2ZVVyaS5wYXRoKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVXJpLnF1ZXJ5KSB7XG4gICAgICAgICAgb3V0cHV0ICs9ICc/JyArIHJlbGF0aXZlVXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZVVyaS5hbmNob3IpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gJyMnICsgcmVsYXRpdmVVcmkuYW5jaG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgICB0b0Fic29sdXRlKHVyaSwgbm9Ib3N0KSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlVXJpID0gbmV3IFVSSSh1cmksIHsgYmFzZV91cmk6IHRoaXMgfSk7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVVyaS5nZXRVUkkobm9Ib3N0ICYmIHRoaXMuaXNTYW1lT3JpZ2luKGFic29sdXRlVXJpKSk7XG4gICAgICB9XG4gICAgICBpc1NhbWVPcmlnaW4odXJpKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3QgPT0gdXJpLmhvc3QgJiYgdGhpcy5wcm90b2NvbCA9PSB1cmkucHJvdG9jb2wpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3J0ID09IHVyaS5wb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGVmYXVsdFBvcnQgPSB0aGlzLnByb3RvY29sID8gREVGQVVMVF9QT1JUU1t0aGlzLnByb3RvY29sXSA6IG51bGw7XG4gICAgICAgICAgaWYgKGRlZmF1bHRQb3J0ICYmICh0aGlzLnBvcnQgfHwgZGVmYXVsdFBvcnQpID09ICh1cmkucG9ydCB8fCBkZWZhdWx0UG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0b1JlbFBhdGgoYmFzZSwgcGF0aCkge1xuICAgICAgICBsZXQgYnJlYWtQb2ludCA9IDAsIG91dCA9ICcnLCBpLCBsO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQmFzZSA9IGJhc2Uuc3Vic3RyaW5nKDAsIGJhc2UubGFzdEluZGV4T2YoJy8nKSkuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChub3JtYWxpemVkQmFzZS5sZW5ndGggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vcm1hbGl6ZWRCYXNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gaXRlbXMubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybWFsaXplZEJhc2UubGVuZ3RoIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gbm9ybWFsaXplZEJhc2UubGVuZ3RoIHx8IG5vcm1hbGl6ZWRCYXNlW2ldICE9PSBpdGVtc1tpXSkge1xuICAgICAgICAgICAgICBicmVha1BvaW50ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub3JtYWxpemVkQmFzZS5sZW5ndGggLSAoYnJlYWtQb2ludCAtIDEpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgb3V0ICs9ICcuLi8nO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGJyZWFrUG9pbnQgLSAxLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGJyZWFrUG9pbnQgLSAxKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8nICsgaXRlbXNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBpdGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIHRvQWJzUGF0aChiYXNlLCBwYXRoKSB7XG4gICAgICAgIGxldCBuYiA9IDA7XG4gICAgICAgIGNvbnN0IHRyID0gL1xcLyQvLnRlc3QocGF0aCkgPyAnLycgOiAnJztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJhc2UgPSBiYXNlLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCBiYXNlUGFydHMgPSBbXTtcbiAgICAgICAgZWFjaCQ0KG5vcm1hbGl6ZWRCYXNlLCBrID0+IHtcbiAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgYmFzZVBhcnRzLnB1c2goayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBub3JtYWxpemVkUGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChub3JtYWxpemVkUGF0aFtpXS5sZW5ndGggPT09IDAgfHwgbm9ybWFsaXplZFBhdGhbaV0gPT09ICcuJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub3JtYWxpemVkUGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmIrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmIgPiAwKSB7XG4gICAgICAgICAgICBuYi0tO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhQYXJ0cy5wdXNoKG5vcm1hbGl6ZWRQYXRoW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gYmFzZVBhcnRzLmxlbmd0aCAtIG5iO1xuICAgICAgICBsZXQgb3V0UGF0aDtcbiAgICAgICAgaWYgKGkgPD0gMCkge1xuICAgICAgICAgIG91dFBhdGggPSByZXZlcnNlKHBhdGhQYXJ0cykuam9pbignLycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dFBhdGggPSBiYXNlUGFydHMuc2xpY2UoMCwgaSkuam9pbignLycpICsgJy8nICsgcmV2ZXJzZShwYXRoUGFydHMpLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0UGF0aC5pbmRleE9mKCcvJykgIT09IDApIHtcbiAgICAgICAgICBvdXRQYXRoID0gJy8nICsgb3V0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHIgJiYgb3V0UGF0aC5sYXN0SW5kZXhPZignLycpICE9PSBvdXRQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXRQYXRoICs9IHRyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRQYXRoO1xuICAgICAgfVxuICAgICAgZ2V0VVJJKG5vUHJvdG9Ib3N0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2UgfHwgbm9Qcm90b0hvc3QpIHtcbiAgICAgICAgICBzID0gJyc7XG4gICAgICAgICAgaWYgKCFub1Byb3RvSG9zdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgcyArPSB0aGlzLnByb3RvY29sICsgJzovLyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzICs9ICcvLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51c2VySW5mbykge1xuICAgICAgICAgICAgICBzICs9IHRoaXMudXNlckluZm8gKyAnQCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICAgIHMgKz0gdGhpcy5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgICAgICAgICBzICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgcyArPSB0aGlzLnBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICAgICAgICBzICs9ICc/JyArIHRoaXMucXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFuY2hvcikge1xuICAgICAgICAgICAgcyArPSAnIycgKyB0aGlzLmFuY2hvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZFVybEF0dHJzID0gVG9vbHMubWFrZU1hcCgnc3JjLGhyZWYsZGF0YSxiYWNrZ3JvdW5kLGFjdGlvbixmb3JtYWN0aW9uLHBvc3Rlcix4bGluazpocmVmJyk7XG4gICAgY29uc3QgaW50ZXJuYWxFbGVtZW50QXR0ciA9ICdkYXRhLW1jZS10eXBlJztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IChub2RlLCBzZXR0aW5ncywgc2NoZW1hLCBldnQpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIGNvbnN0IHZhbGlkYXRlID0gc2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICBjb25zdCBzcGVjaWFsRWxlbWVudHMgPSBzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKCk7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVCAmJiAhc2V0dGluZ3MuYWxsb3dfY29uZGl0aW9uYWxfY29tbWVudHMgJiYgL15cXFtpZi9pLnRlc3QoKF9hID0gbm9kZS5ub2RlVmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSkge1xuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9ICcgJyArIG5vZGUubm9kZVZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGNUYWdOYW1lID0gKF9iID0gZXZ0ID09PSBudWxsIHx8IGV2dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZ0LnRhZ05hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UIHx8IGxjVGFnTmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKTtcbiAgICAgIGNvbnN0IGlzSW50ZXJuYWxFbGVtZW50ID0gaGFzJDEoZWxlbWVudCwgaW50ZXJuYWxFbGVtZW50QXR0cik7XG4gICAgICBjb25zdCBib2d1cyA9IGdldCQ5KGVsZW1lbnQsICdkYXRhLW1jZS1ib2d1cycpO1xuICAgICAgaWYgKCFpc0ludGVybmFsRWxlbWVudCAmJiBpc1N0cmluZyhib2d1cykpIHtcbiAgICAgICAgaWYgKGJvZ3VzID09PSAnYWxsJykge1xuICAgICAgICAgIHJlbW92ZSQ1KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBydWxlID0gc2NoZW1hLmdldEVsZW1lbnRSdWxlKGxjVGFnTmFtZSk7XG4gICAgICBpZiAodmFsaWRhdGUgJiYgIXJ1bGUpIHtcbiAgICAgICAgaWYgKGhhcyQyKHNwZWNpYWxFbGVtZW50cywgbGNUYWdOYW1lKSkge1xuICAgICAgICAgIHJlbW92ZSQ1KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShldnQpKSB7XG4gICAgICAgICAgZXZ0LmFsbG93ZWRUYWdzW2xjVGFnTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGUgJiYgcnVsZSAmJiAhaXNJbnRlcm5hbEVsZW1lbnQpIHtcbiAgICAgICAgZWFjaCRlKChfYyA9IHJ1bGUuYXR0cmlidXRlc0ZvcmNlZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sIGF0dHIgPT4ge1xuICAgICAgICAgIHNldCQzKGVsZW1lbnQsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSA9PT0gJ3skdWlkfScgPyBgbWNlXyR7IHVpZCsrIH1gIDogYXR0ci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoJGUoKF9kID0gcnVsZS5hdHRyaWJ1dGVzRGVmYXVsdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW10sIGF0dHIgPT4ge1xuICAgICAgICAgIGlmICghaGFzJDEoZWxlbWVudCwgYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgc2V0JDMoZWxlbWVudCwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlID09PSAneyR1aWR9JyA/IGBtY2VfJHsgdWlkKysgfWAgOiBhdHRyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVsZS5hdHRyaWJ1dGVzUmVxdWlyZWQgJiYgIWV4aXN0cyhydWxlLmF0dHJpYnV0ZXNSZXF1aXJlZCwgYXR0ciA9PiBoYXMkMShlbGVtZW50LCBhdHRyKSkpIHtcbiAgICAgICAgICB1bndyYXAoZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlLnJlbW92ZUVtcHR5QXR0cnMgJiYgaGFzTm9uZShlbGVtZW50KSkge1xuICAgICAgICAgIHVud3JhcChlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUub3V0cHV0TmFtZSAmJiBydWxlLm91dHB1dE5hbWUgIT09IGxjVGFnTmFtZSkge1xuICAgICAgICAgIG11dGF0ZShlbGVtZW50LCBydWxlLm91dHB1dE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRLZWVwQXR0cmlidXRlID0gKHNldHRpbmdzLCBzY2hlbWEsIHRhZ05hbWUsIGF0dHJOYW1lLCBhdHRyVmFsdWUpID0+ICEoYXR0ck5hbWUgaW4gZmlsdGVyZWRVcmxBdHRycyAmJiBpc0ludmFsaWRVcmkoc2V0dGluZ3MsIGF0dHJWYWx1ZSwgdGFnTmFtZSkpICYmICghc2V0dGluZ3MudmFsaWRhdGUgfHwgc2NoZW1hLmlzVmFsaWQodGFnTmFtZSwgYXR0ck5hbWUpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdkYXRhLScpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdhcmlhLScpKTtcbiAgICBjb25zdCBpc1JlcXVpcmVkQXR0cmlidXRlT2ZJbnRlcm5hbEVsZW1lbnQgPSAoZWxlLCBhdHRyTmFtZSkgPT4gZWxlLmhhc0F0dHJpYnV0ZShpbnRlcm5hbEVsZW1lbnRBdHRyKSAmJiAoYXR0ck5hbWUgPT09ICdpZCcgfHwgYXR0ck5hbWUgPT09ICdjbGFzcycgfHwgYXR0ck5hbWUgPT09ICdzdHlsZScpO1xuICAgIGNvbnN0IGlzQm9vbGVhbkF0dHJpYnV0ZSA9IChhdHRyTmFtZSwgc2NoZW1hKSA9PiBhdHRyTmFtZSBpbiBzY2hlbWEuZ2V0Qm9vbEF0dHJzKCk7XG4gICAgY29uc3QgZmlsdGVyQXR0cmlidXRlcyA9IChlbGUsIHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IGVsZTtcbiAgICAgIGZvciAobGV0IGkgPSBhdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgY29uc3QgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgaWYgKCFzaG91bGRLZWVwQXR0cmlidXRlKHNldHRpbmdzLCBzY2hlbWEsIGVsZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJOYW1lLCBhdHRyVmFsdWUpICYmICFpc1JlcXVpcmVkQXR0cmlidXRlT2ZJbnRlcm5hbEVsZW1lbnQoZWxlLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBlbGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyaWJ1dGUoYXR0ck5hbWUsIHNjaGVtYSkpIHtcbiAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwUHVyaWZ5ID0gKHNldHRpbmdzLCBzY2hlbWEpID0+IHtcbiAgICAgIGNvbnN0IHB1cmlmeSQxID0gcHVyaWZ5KCk7XG4gICAgICBwdXJpZnkkMS5hZGRIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgKGVsZSwgZXZ0KSA9PiB7XG4gICAgICAgIHByb2Nlc3NOb2RlKGVsZSwgc2V0dGluZ3MsIHNjaGVtYSwgZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgcHVyaWZ5JDEuYWRkSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgKGVsZSwgZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB7YXR0ck5hbWUsIGF0dHJWYWx1ZX0gPSBldnQ7XG4gICAgICAgIGV2dC5rZWVwQXR0ciA9IHNob3VsZEtlZXBBdHRyaWJ1dGUoc2V0dGluZ3MsIHNjaGVtYSwgdGFnTmFtZSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChldnQua2VlcEF0dHIpIHtcbiAgICAgICAgICBldnQuYWxsb3dlZEF0dHJpYnV0ZXNbYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoaXNCb29sZWFuQXR0cmlidXRlKGF0dHJOYW1lLCBzY2hlbWEpKSB7XG4gICAgICAgICAgICBldnQuYXR0clZhbHVlID0gYXR0ck5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXR0aW5ncy5hbGxvd19zdmdfZGF0YV91cmxzICYmIHN0YXJ0c1dpdGgoYXR0clZhbHVlLCAnZGF0YTppbWFnZS9zdmcreG1sJykpIHtcbiAgICAgICAgICAgIGV2dC5mb3JjZUtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZXF1aXJlZEF0dHJpYnV0ZU9mSW50ZXJuYWxFbGVtZW50KGVsZSwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgZXZ0LmZvcmNlS2VlcEF0dHIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwdXJpZnkkMTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFB1cmlmeUNvbmZpZyA9IChzZXR0aW5ncywgbWltZVR5cGUpID0+IHtcbiAgICAgIGNvbnN0IGJhc2VQdXJpZnlDb25maWcgPSB7XG4gICAgICAgIElOX1BMQUNFOiB0cnVlLFxuICAgICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUzogdHJ1ZSxcbiAgICAgICAgQUxMT1dFRF9UQUdTOiBbXG4gICAgICAgICAgJyNjb21tZW50JyxcbiAgICAgICAgICAnI2NkYXRhLXNlY3Rpb24nLFxuICAgICAgICAgICdib2R5J1xuICAgICAgICBdLFxuICAgICAgICBBTExPV0VEX0FUVFI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgY29uZmlnID0geyAuLi5iYXNlUHVyaWZ5Q29uZmlnIH07XG4gICAgICBjb25maWcuUEFSU0VSX01FRElBX1RZUEUgPSBtaW1lVHlwZTtcbiAgICAgIGlmIChzZXR0aW5ncy5hbGxvd19zY3JpcHRfdXJscykge1xuICAgICAgICBjb25maWcuQUxMT1dFRF9VUklfUkVHRVhQID0gLy4qLztcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYWxsb3dfaHRtbF9kYXRhX3VybHMpIHtcbiAgICAgICAgY29uZmlnLkFMTE9XRURfVVJJX1JFR0VYUCA9IC9eKD8hKFxcdytzY3JpcHR8bWh0bWwpOikvaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTYW5pdGl6ZXIgPSAoc2V0dGluZ3MsIHNjaGVtYSkgPT4ge1xuICAgICAgaWYgKHNldHRpbmdzLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnN0IHB1cmlmeSA9IHNldHVwUHVyaWZ5KHNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gKGJvZHksIG1pbWVUeXBlKSA9PiB7XG4gICAgICAgICAgcHVyaWZ5LnNhbml0aXplKGJvZHksIGdldFB1cmlmeUNvbmZpZyhzZXR0aW5ncywgbWltZVR5cGUpKTtcbiAgICAgICAgICBwdXJpZnkucmVtb3ZlZCA9IFtdO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChib2R5LCBfKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZUl0ZXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yKGJvZHksIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCk7XG4gICAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUobm9kZSwgc2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICAgICAgZmlsdGVyQXR0cmlidXRlcyhub2RlLCBzZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VNYXAgPSBUb29scy5tYWtlTWFwLCBleHRlbmQkMSA9IFRvb2xzLmV4dGVuZDtcbiAgICBjb25zdCB0cmFuc2ZlckNoaWxkcmVuID0gKHBhcmVudCwgbmF0aXZlUGFyZW50LCBzcGVjaWFsRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnQubmFtZTtcbiAgICAgIGNvbnN0IGlzU3BlY2lhbCA9IHBhcmVudE5hbWUgaW4gc3BlY2lhbEVsZW1lbnRzICYmIHBhcmVudE5hbWUgIT09ICd0aXRsZScgJiYgcGFyZW50TmFtZSAhPT0gJ3RleHRhcmVhJztcbiAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBuYXRpdmVQYXJlbnQuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IG5pID0gMCwgbmwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgbmkgPCBubDsgbmkrKykge1xuICAgICAgICBjb25zdCBuYXRpdmVDaGlsZCA9IGNoaWxkTm9kZXNbbmldO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBBc3ROb2RlKG5hdGl2ZUNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIG5hdGl2ZUNoaWxkLm5vZGVUeXBlKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuYXRpdmVDaGlsZC5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGZvciAobGV0IGFpID0gMCwgYWwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgYWkgPCBhbDsgYWkrKykge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbYWldO1xuICAgICAgICAgICAgY2hpbGQuYXR0cihhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkYShuYXRpdmVDaGlsZCkpIHtcbiAgICAgICAgICBjaGlsZC52YWx1ZSA9IG5hdGl2ZUNoaWxkLmRhdGE7XG4gICAgICAgICAgaWYgKGlzU3BlY2lhbCkge1xuICAgICAgICAgICAgY2hpbGQucmF3ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb21tZW50KG5hdGl2ZUNoaWxkKSB8fCBpc0NEYXRhKG5hdGl2ZUNoaWxkKSB8fCBpc1BpKG5hdGl2ZUNoaWxkKSkge1xuICAgICAgICAgIGNoaWxkLnZhbHVlID0gbmF0aXZlQ2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2ZlckNoaWxkcmVuKGNoaWxkLCBuYXRpdmVDaGlsZCwgc3BlY2lhbEVsZW1lbnRzKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWxrVHJlZSA9IChyb290LCBwcmVwcm9jZXNzb3JzLCBwb3N0cHJvY2Vzc29ycykgPT4ge1xuICAgICAgY29uc3QgdHJhdmVyc2VPcmRlciA9IFtdO1xuICAgICAgZm9yIChsZXQgbm9kZSA9IHJvb3QsIGxhc3ROb2RlID0gbm9kZTsgbm9kZTsgbGFzdE5vZGUgPSBub2RlLCBub2RlID0gbm9kZS53YWxrKCkpIHtcbiAgICAgICAgY29uc3QgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICBlYWNoJGUocHJlcHJvY2Vzc29ycywgcHJlcHJvY2VzcyA9PiBwcmVwcm9jZXNzKHRlbXBOb2RlKSk7XG4gICAgICAgIGlmIChpc051bGxhYmxlKHRlbXBOb2RlLnBhcmVudCkgJiYgdGVtcE5vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgICBub2RlID0gbGFzdE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhdmVyc2VPcmRlci5wdXNoKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHRyYXZlcnNlT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRyYXZlcnNlT3JkZXJbaV07XG4gICAgICAgIGVhY2gkZShwb3N0cHJvY2Vzc29ycywgcG9zdHByb2Nlc3MgPT4gcG9zdHByb2Nlc3Mobm9kZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2hpdGVzcGFjZUNsZWFuZXIgPSAocm9vdCwgc2NoZW1hLCBzZXR0aW5ncywgYXJncykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdGUgPSBzZXR0aW5ncy52YWxpZGF0ZTtcbiAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBzY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2hpdGVzcGFjZUVsZW1lbnRzID0gc2NoZW1hLmdldFdoaXRlc3BhY2VFbGVtZW50cygpO1xuICAgICAgY29uc3QgYmxvY2tFbGVtZW50cyA9IGV4dGVuZCQxKG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSxoZWFkLGh0bWwsYm9keSx0aXRsZSxtZXRhLHBhcmFtJyksIHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCkpO1xuICAgICAgY29uc3QgdGV4dFJvb3RCbG9ja0VsZW1lbnRzID0gZ2V0VGV4dFJvb3RCbG9ja0VsZW1lbnRzKHNjaGVtYSk7XG4gICAgICBjb25zdCBhbGxXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSsvZztcbiAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICBjb25zdCBlbmRXaGl0ZVNwYWNlUmVnRXhwID0gL1sgXFx0XFxyXFxuXSskLztcbiAgICAgIGNvbnN0IGhhc1doaXRlc3BhY2VQYXJlbnQgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChpc05vbk51bGxhYmxlKHRlbXBOb2RlKSkge1xuICAgICAgICAgIGlmICh0ZW1wTm9kZS5uYW1lIGluIHdoaXRlc3BhY2VFbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNUZXh0Um9vdEJsb2NrRW1wdHkgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IHRlbXBOb2RlID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGlzTm9uTnVsbGFibGUodGVtcE5vZGUpKSB7XG4gICAgICAgICAgaWYgKHRlbXBOb2RlLm5hbWUgaW4gdGV4dFJvb3RCbG9ja0VsZW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgdGVtcE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wTm9kZSA9IHRlbXBOb2RlLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlID0+IG5vZGUubmFtZSBpbiBibG9ja0VsZW1lbnRzIHx8IGlzVHJhbnNwYXJlbnRBc3RCbG9jayhzY2hlbWEsIG5vZGUpO1xuICAgICAgY29uc3QgaXNBdEVkZ2VPZkJsb2NrID0gKG5vZGUsIHN0YXJ0KSA9PiB7XG4gICAgICAgIGNvbnN0IG5laWdoYm91ciA9IHN0YXJ0ID8gbm9kZS5wcmV2IDogbm9kZS5uZXh0O1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShuZWlnaGJvdXIpIHx8IGlzTnVsbGFibGUobm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Jsb2NrKG5vZGUucGFyZW50KSAmJiAobm9kZS5wYXJlbnQgIT09IHJvb3QgfHwgYXJncy5pc1Jvb3RDb250ZW50ID09PSB0cnVlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcmVwcm9jZXNzID0gbm9kZSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIGlmICghaGFzV2hpdGVzcGFjZVBhcmVudChub2RlKSkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSAoX2EgPSBub2RlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoYWxsV2hpdGVTcGFjZVJlZ0V4cCwgJyAnKTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVCcmVha05vZGUobm9kZS5wcmV2LCBpc0Jsb2NrKSB8fCBpc0F0RWRnZU9mQmxvY2sobm9kZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShzdGFydFdoaXRlU3BhY2VSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcG9zdHByb2Nlc3MgPSBub2RlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudFJ1bGUgPSBzY2hlbWEuZ2V0RWxlbWVudFJ1bGUobm9kZS5uYW1lKTtcbiAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgZWxlbWVudFJ1bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTm9kZUVtcHR5ID0gaXNFbXB0eShzY2hlbWEsIG5vbkVtcHR5RWxlbWVudHMsIHdoaXRlc3BhY2VFbGVtZW50cywgbm9kZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFJ1bGUucGFkZEluRW1wdHlCbG9jayAmJiBpc05vZGVFbXB0eSAmJiBpc1RleHRSb290QmxvY2tFbXB0eShub2RlKSkge1xuICAgICAgICAgICAgICBwYWRkRW1wdHlOb2RlKHNldHRpbmdzLCBhcmdzLCBpc0Jsb2NrLCBub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFJ1bGUucmVtb3ZlRW1wdHkgJiYgaXNOb2RlRW1wdHkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudFJ1bGUucGFkZEVtcHR5ICYmIChpc05vZGVFbXB0eSB8fCBpc1BhZGRlZFdpdGhOYnNwKG5vZGUpKSkge1xuICAgICAgICAgICAgICBwYWRkRW1wdHlOb2RlKHNldHRpbmdzLCBhcmdzLCBpc0Jsb2NrLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKCFoYXNXaGl0ZXNwYWNlUGFyZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dCAmJiBpc0Jsb2NrKG5vZGUubmV4dCkgfHwgaXNBdEVkZ2VPZkJsb2NrKG5vZGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGVuZFdoaXRlU3BhY2VSZWdFeHAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcHJlcHJvY2VzcyxcbiAgICAgICAgcG9zdHByb2Nlc3NcbiAgICAgIF07XG4gICAgfTtcbiAgICBjb25zdCBnZXRSb290QmxvY2tOYW1lID0gKHNldHRpbmdzLCBhcmdzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBuYW1lID0gKF9hID0gYXJncy5mb3JjZWRfcm9vdF9ibG9jaykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2V0dGluZ3MuZm9yY2VkX3Jvb3RfYmxvY2s7XG4gICAgICBpZiAobmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAncCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IERvbVBhcnNlciA9IChzZXR0aW5ncyA9IHt9LCBzY2hlbWEgPSBTY2hlbWEoKSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUZpbHRlclJlZ2lzdHJ5ID0gY3JlYXRlJDgoKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUZpbHRlclJlZ2lzdHJ5ID0gY3JlYXRlJDgoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZFNldHRpbmdzID0ge1xuICAgICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgICAgcm9vdF9uYW1lOiAnYm9keScsXG4gICAgICAgIHNhbml0aXplOiB0cnVlLFxuICAgICAgICAuLi5zZXR0aW5nc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IHNhbml0aXplID0gZ2V0U2FuaXRpemVyKGRlZmF1bHRlZFNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgY29uc3QgcGFyc2VBbmRTYW5pdGl6ZVdpdGhDb250ZXh0ID0gKGh0bWwsIHJvb3ROYW1lLCBmb3JtYXQgPSAnaHRtbCcpID0+IHtcbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBmb3JtYXQgPT09ICd4aHRtbCcgPyAnYXBwbGljYXRpb24veGh0bWwreG1sJyA6ICd0ZXh0L2h0bWwnO1xuICAgICAgICBjb25zdCBpc1NwZWNpYWxSb290ID0gaGFzJDIoc2NoZW1hLmdldFNwZWNpYWxFbGVtZW50cygpLCByb290TmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGlzU3BlY2lhbFJvb3QgPyBgPCR7IHJvb3ROYW1lIH0+JHsgaHRtbCB9PC8keyByb290TmFtZSB9PmAgOiBodG1sO1xuICAgICAgICBjb25zdCB3cmFwcGVkSHRtbCA9IGZvcm1hdCA9PT0gJ3hodG1sJyA/IGA8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JHsgY29udGVudCB9PC9ib2R5PjwvaHRtbD5gIDogYDxib2R5PiR7IGNvbnRlbnQgfTwvYm9keT5gO1xuICAgICAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkSHRtbCwgbWltZVR5cGUpLmJvZHk7XG4gICAgICAgIHNhbml0aXplKGJvZHksIG1pbWVUeXBlKTtcbiAgICAgICAgcmV0dXJuIGlzU3BlY2lhbFJvb3QgPyBib2R5LmZpcnN0Q2hpbGQgOiBib2R5O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZE5vZGVGaWx0ZXIgPSBub2RlRmlsdGVyUmVnaXN0cnkuYWRkRmlsdGVyO1xuICAgICAgY29uc3QgZ2V0Tm9kZUZpbHRlcnMgPSBub2RlRmlsdGVyUmVnaXN0cnkuZ2V0RmlsdGVycztcbiAgICAgIGNvbnN0IHJlbW92ZU5vZGVGaWx0ZXIgPSBub2RlRmlsdGVyUmVnaXN0cnkucmVtb3ZlRmlsdGVyO1xuICAgICAgY29uc3QgYWRkQXR0cmlidXRlRmlsdGVyID0gYXR0cmlidXRlRmlsdGVyUmVnaXN0cnkuYWRkRmlsdGVyO1xuICAgICAgY29uc3QgZ2V0QXR0cmlidXRlRmlsdGVycyA9IGF0dHJpYnV0ZUZpbHRlclJlZ2lzdHJ5LmdldEZpbHRlcnM7XG4gICAgICBjb25zdCByZW1vdmVBdHRyaWJ1dGVGaWx0ZXIgPSBhdHRyaWJ1dGVGaWx0ZXJSZWdpc3RyeS5yZW1vdmVGaWx0ZXI7XG4gICAgICBjb25zdCBmaW5kSW52YWxpZENoaWxkcmVuID0gKG5vZGUsIGludmFsaWRDaGlsZHJlbikgPT4ge1xuICAgICAgICBpZiAoaXNJbnZhbGlkKHNjaGVtYSwgbm9kZSkpIHtcbiAgICAgICAgICBpbnZhbGlkQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzV3JhcHBhYmxlTm9kZSA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzSW50ZXJuYWxFbGVtZW50ID0gaXNTdHJpbmcobm9kZS5hdHRyKGludGVybmFsRWxlbWVudEF0dHIpKTtcbiAgICAgICAgY29uc3QgaXNJbmxpbmVFbGVtZW50ID0gbm9kZS50eXBlID09PSAxICYmICghaGFzJDIoYmxvY2tFbGVtZW50cywgbm9kZS5uYW1lKSAmJiAhaXNUcmFuc3BhcmVudEFzdEJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAzIHx8IGlzSW5saW5lRWxlbWVudCAmJiAhaXNJbnRlcm5hbEVsZW1lbnQ7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IChyb290Tm9kZSwgcm9vdEJsb2NrTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBibG9ja0VsZW1lbnRzID0gZXh0ZW5kJDEobWFrZU1hcCgnc2NyaXB0LHN0eWxlLGhlYWQsaHRtbCxib2R5LHRpdGxlLG1ldGEscGFyYW0nKSwgc2NoZW1hLmdldEJsb2NrRWxlbWVudHMoKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0V2hpdGVTcGFjZVJlZ0V4cCA9IC9eWyBcXHRcXHJcXG5dKy87XG4gICAgICAgIGNvbnN0IGVuZFdoaXRlU3BhY2VSZWdFeHAgPSAvWyBcXHRcXHJcXG5dKyQvO1xuICAgICAgICBsZXQgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQsIHJvb3RCbG9ja05vZGUgPSBudWxsO1xuICAgICAgICBjb25zdCB0cmltID0gcm9vdEJsb2NrID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIGlmIChyb290QmxvY2spIHtcbiAgICAgICAgICAgIG5vZGUgPSByb290QmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gKF9hID0gbm9kZS52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2Uoc3RhcnRXaGl0ZVNwYWNlUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gcm9vdEJsb2NrLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBub2RlLnZhbHVlID0gKF9iID0gbm9kZS52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxhY2UoZW5kV2hpdGVTcGFjZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzY2hlbWEuaXNWYWxpZENoaWxkKHJvb3ROb2RlLm5hbWUsIHJvb3RCbG9ja05hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgIGlmIChpc1dyYXBwYWJsZU5vZGUoYmxvY2tFbGVtZW50cywgbm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghcm9vdEJsb2NrTm9kZSkge1xuICAgICAgICAgICAgICByb290QmxvY2tOb2RlID0gbmV3IEFzdE5vZGUocm9vdEJsb2NrTmFtZSwgMSk7XG4gICAgICAgICAgICAgIHJvb3RCbG9ja05vZGUuYXR0cihkZWZhdWx0ZWRTZXR0aW5ncy5mb3JjZWRfcm9vdF9ibG9ja19hdHRycyk7XG4gICAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydChyb290QmxvY2tOb2RlLCBub2RlKTtcbiAgICAgICAgICAgICAgcm9vdEJsb2NrTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByb290QmxvY2tOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpbShyb290QmxvY2tOb2RlKTtcbiAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0cmltKHJvb3RCbG9ja05vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcnNlID0gKGh0bWwsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gZGVmYXVsdGVkU2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gKF9hID0gYXJncy5jb250ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0ZWRTZXR0aW5ncy5yb290X25hbWU7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZUFuZFNhbml0aXplV2l0aENvbnRleHQoaHRtbCwgcm9vdE5hbWUsIGFyZ3MuZm9ybWF0KTtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW4oc2NoZW1hLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgQXN0Tm9kZShyb290TmFtZSwgMTEpO1xuICAgICAgICB0cmFuc2ZlckNoaWxkcmVuKHJvb3ROb2RlLCBlbGVtZW50LCBzY2hlbWEuZ2V0U3BlY2lhbEVsZW1lbnRzKCkpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjb25zdCBbd2hpdGVzcGFjZVByZSwgd2hpdGVzcGFjZVBvc3RdID0gd2hpdGVzcGFjZUNsZWFuZXIocm9vdE5vZGUsIHNjaGVtYSwgZGVmYXVsdGVkU2V0dGluZ3MsIGFyZ3MpO1xuICAgICAgICBjb25zdCBpbnZhbGlkQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgaW52YWxpZEZpbmRlciA9IHZhbGlkYXRlID8gbm9kZSA9PiBmaW5kSW52YWxpZENoaWxkcmVuKG5vZGUsIGludmFsaWRDaGlsZHJlbikgOiBub29wO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ge1xuICAgICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXRjaEZpbmRlciA9IG5vZGUgPT4gbWF0Y2hOb2RlJDEoZ2V0Tm9kZUZpbHRlcnMoKSwgZ2V0QXR0cmlidXRlRmlsdGVycygpLCBub2RlLCBtYXRjaGVzKTtcbiAgICAgICAgd2Fsa1RyZWUocm9vdE5vZGUsIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUHJlLFxuICAgICAgICAgIG1hdGNoRmluZGVyXG4gICAgICAgIF0sIFtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zdCxcbiAgICAgICAgICBpbnZhbGlkRmluZGVyXG4gICAgICAgIF0pO1xuICAgICAgICBpbnZhbGlkQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICBpZiAodmFsaWRhdGUgJiYgaW52YWxpZENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoYXJncy5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHBhc3M6IHRvcExldmVsQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIGZhaWw6IG90aGVyQ2hpbGRyZW5cbiAgICAgICAgICAgIH0gPSBwYXJ0aXRpb24kMihpbnZhbGlkQ2hpbGRyZW4sIGNoaWxkID0+IGNoaWxkLnBhcmVudCA9PT0gcm9vdE5vZGUpO1xuICAgICAgICAgICAgY2xlYW5JbnZhbGlkTm9kZXMob3RoZXJDaGlsZHJlbiwgc2NoZW1hLCByb290Tm9kZSwgbWF0Y2hGaW5kZXIpO1xuICAgICAgICAgICAgYXJncy5pbnZhbGlkID0gdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhbkludmFsaWROb2RlcyhpbnZhbGlkQ2hpbGRyZW4sIHNjaGVtYSwgcm9vdE5vZGUsIG1hdGNoRmluZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdEJsb2NrTmFtZSA9IGdldFJvb3RCbG9ja05hbWUoZGVmYXVsdGVkU2V0dGluZ3MsIGFyZ3MpO1xuICAgICAgICBpZiAocm9vdEJsb2NrTmFtZSAmJiAocm9vdE5vZGUubmFtZSA9PT0gJ2JvZHknIHx8IGFyZ3MuaXNSb290Q29udGVudCkpIHtcbiAgICAgICAgICBhZGRSb290QmxvY2tzKHJvb3ROb2RlLCByb290QmxvY2tOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuaW52YWxpZCkge1xuICAgICAgICAgIHJ1bkZpbHRlcnMobWF0Y2hlcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgYWRkQXR0cmlidXRlRmlsdGVyLFxuICAgICAgICBnZXRBdHRyaWJ1dGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVBdHRyaWJ1dGVGaWx0ZXIsXG4gICAgICAgIGFkZE5vZGVGaWx0ZXIsXG4gICAgICAgIGdldE5vZGVGaWx0ZXJzLFxuICAgICAgICByZW1vdmVOb2RlRmlsdGVyLFxuICAgICAgICBwYXJzZVxuICAgICAgfTtcbiAgICAgIHJlZ2lzdGVyJDQoZXhwb3J0cywgZGVmYXVsdGVkU2V0dGluZ3MpO1xuICAgICAgcmVnaXN0ZXIkNShleHBvcnRzLCBkZWZhdWx0ZWRTZXR0aW5ncywgc2NoZW1hKTtcbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXJpYWxpemVDb250ZW50ID0gY29udGVudCA9PiBpc1RyZWVOb2RlKGNvbnRlbnQpID8gSHRtbFNlcmlhbGl6ZXIoeyB2YWxpZGF0ZTogZmFsc2UgfSkuc2VyaWFsaXplKGNvbnRlbnQpIDogY29udGVudDtcbiAgICBjb25zdCB3aXRoU2VyaWFsaXplZENvbnRlbnQgPSAoY29udGVudCwgZmlyZUV2ZW50LCBzYW5pdGl6ZSkgPT4ge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENvbnRlbnQgPSBzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpO1xuICAgICAgY29uc3QgZXZlbnRBcmdzID0gZmlyZUV2ZW50KHNlcmlhbGl6ZWRDb250ZW50KTtcbiAgICAgIGlmIChldmVudEFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXJncztcbiAgICAgIH0gZWxzZSBpZiAoaXNUcmVlTm9kZShjb250ZW50KSkge1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmNvbnRlbnQgIT09IHNlcmlhbGl6ZWRDb250ZW50KSB7XG4gICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBEb21QYXJzZXIoe1xuICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgc2FuaXRpemVcbiAgICAgICAgICB9KS5wYXJzZShldmVudEFyZ3MuY29udGVudCwgeyBjb250ZXh0OiBjb250ZW50Lm5hbWUgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmV2ZW50QXJncyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJvb3ROb2RlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZXZlbnRBcmdzLFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudEFyZ3M7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcmVQcm9jZXNzR2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChhcmdzLm5vX2V2ZW50cykge1xuICAgICAgICByZXR1cm4gUmVzdWx0LnZhbHVlKGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gZmlyZUJlZm9yZUdldENvbnRlbnQoZWRpdG9yLCBhcmdzKTtcbiAgICAgICAgaWYgKGV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybiBSZXN1bHQuZXJyb3IoZmlyZUdldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIC4uLmV2ZW50QXJnc1xuICAgICAgICAgIH0pLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBSZXN1bHQudmFsdWUoZXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcG9zdFByb2Nlc3NHZXRDb250ZW50ID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4ge1xuICAgICAgaWYgKGFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnRBcmdzID0gd2l0aFNlcmlhbGl6ZWRDb250ZW50KGNvbnRlbnQsIGNvbnRlbnQgPT4gZmlyZUdldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pLCBzaG91bGRTYW5pdGl6ZVhzcyhlZGl0b3IpKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEV2ZW50QXJncy5jb250ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJlUHJvY2Vzc1NldENvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50QXJncyA9IHdpdGhTZXJpYWxpemVkQ29udGVudChhcmdzLmNvbnRlbnQsIGNvbnRlbnQgPT4gZmlyZUJlZm9yZVNldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICBjb250ZW50XG4gICAgICAgIH0pLCBzaG91bGRTYW5pdGl6ZVhzcyhlZGl0b3IpKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50QXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGZpcmVTZXRDb250ZW50KGVkaXRvciwgcHJvY2Vzc2VkRXZlbnRBcmdzKTtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0LmVycm9yKHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZShwcm9jZXNzZWRFdmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc1NldENvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICBpZiAoIWFyZ3Mubm9fZXZlbnRzKSB7XG4gICAgICAgIGZpcmVTZXRDb250ZW50KGVkaXRvciwge1xuICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgY29udGVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdGFibGVNb2RlbCA9IChlbGVtZW50LCB3aWR0aCwgcm93cykgPT4gKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICB3aWR0aCxcbiAgICAgIHJvd3NcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZVJvdyA9IChlbGVtZW50LCBjZWxscykgPT4gKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjZWxsc1xuICAgIH0pO1xuICAgIGNvbnN0IGNlbGxQb3NpdGlvbiA9ICh4LCB5KSA9PiAoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9KTtcbiAgICBjb25zdCBnZXRTcGFuID0gKHRkLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiBnZXRPcHQodGQsIGtleSkuYmluZCh0b0ludCkuZ2V0T3IoMSk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsb3V0ID0gKHRhYmxlLCB4LCB5LCB0ciwgdGQpID0+IHtcbiAgICAgIGNvbnN0IHJvd3NwYW4gPSBnZXRTcGFuKHRkLCAncm93c3BhbicpO1xuICAgICAgY29uc3QgY29sc3BhbiA9IGdldFNwYW4odGQsICdjb2xzcGFuJyk7XG4gICAgICBjb25zdCByb3dzID0gdGFibGUucm93cztcbiAgICAgIGZvciAobGV0IHkyID0geTsgeTIgPCB5ICsgcm93c3BhbjsgeTIrKykge1xuICAgICAgICBpZiAoIXJvd3NbeTJdKSB7XG4gICAgICAgICAgcm93c1t5Ml0gPSB0YWJsZVJvdyhkZWVwJDEodHIpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgeDIgPSB4OyB4MiA8IHggKyBjb2xzcGFuOyB4MisrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbHMgPSByb3dzW3kyXS5jZWxscztcbiAgICAgICAgICBjZWxsc1t4Ml0gPSB5MiA9PT0geSAmJiB4MiA9PT0geCA/IHRkIDogc2hhbGxvdyQxKHRkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2VsbEV4aXN0cyA9ICh0YWJsZSwgeCwgeSkgPT4ge1xuICAgICAgY29uc3Qgcm93cyA9IHRhYmxlLnJvd3M7XG4gICAgICBjb25zdCBjZWxscyA9IHJvd3NbeV0gPyByb3dzW3ldLmNlbGxzIDogW107XG4gICAgICByZXR1cm4gISFjZWxsc1t4XTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXBDZWxsc1ggPSAodGFibGUsIHgsIHkpID0+IHtcbiAgICAgIHdoaWxlIChjZWxsRXhpc3RzKHRhYmxlLCB4LCB5KSkge1xuICAgICAgICB4Kys7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFdpZHRoID0gcm93cyA9PiB7XG4gICAgICByZXR1cm4gZm9sZGwocm93cywgKGFjYywgcm93KSA9PiB7XG4gICAgICAgIHJldHVybiByb3cuY2VsbHMubGVuZ3RoID4gYWNjID8gcm93LmNlbGxzLmxlbmd0aCA6IGFjYztcbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgY29uc3QgZmluZEVsZW1lbnRQb3MgPSAodGFibGUsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZS5yb3dzO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcm93c1t5XS5jZWxscztcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjZWxscy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgIGlmIChlcShjZWxsc1t4XSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGNlbGxQb3NpdGlvbih4LCB5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFJvd3MgPSAodGFibGUsIHN4LCBzeSwgZXgsIGV5KSA9PiB7XG4gICAgICBjb25zdCBuZXdSb3dzID0gW107XG4gICAgICBjb25zdCByb3dzID0gdGFibGUucm93cztcbiAgICAgIGZvciAobGV0IHkgPSBzeTsgeSA8PSBleTsgeSsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gcm93c1t5XS5jZWxscztcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBzeCA8IGV4ID8gY2VsbHMuc2xpY2Uoc3gsIGV4ICsgMSkgOiBjZWxscy5zbGljZShleCwgc3ggKyAxKTtcbiAgICAgICAgbmV3Um93cy5wdXNoKHRhYmxlUm93KHJvd3NbeV0uZWxlbWVudCwgc2xpY2UpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdSb3dzO1xuICAgIH07XG4gICAgY29uc3Qgc3ViVGFibGUgPSAodGFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpID0+IHtcbiAgICAgIGNvbnN0IHN4ID0gc3RhcnRQb3MueCwgc3kgPSBzdGFydFBvcy55O1xuICAgICAgY29uc3QgZXggPSBlbmRQb3MueCwgZXkgPSBlbmRQb3MueTtcbiAgICAgIGNvbnN0IG5ld1Jvd3MgPSBzeSA8IGV5ID8gZXh0cmFjdFJvd3ModGFibGUsIHN4LCBzeSwgZXgsIGV5KSA6IGV4dHJhY3RSb3dzKHRhYmxlLCBzeCwgZXksIGV4LCBzeSk7XG4gICAgICByZXR1cm4gdGFibGVNb2RlbCh0YWJsZS5lbGVtZW50LCBnZXRXaWR0aChuZXdSb3dzKSwgbmV3Um93cyk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVEb21UYWJsZSA9ICh0YWJsZSwgcm93cykgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gc2hhbGxvdyQxKHRhYmxlLmVsZW1lbnQpO1xuICAgICAgY29uc3QgdGFibGVCb2R5ID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ3Rib2R5Jyk7XG4gICAgICBhcHBlbmQodGFibGVCb2R5LCByb3dzKTtcbiAgICAgIGFwcGVuZCQxKHRhYmxlRWxlbWVudCwgdGFibGVCb2R5KTtcbiAgICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtb2RlbFJvd3NUb0RvbVJvd3MgPSB0YWJsZSA9PiB7XG4gICAgICByZXR1cm4gbWFwJDModGFibGUucm93cywgcm93ID0+IHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBtYXAkMyhyb3cuY2VsbHMsIGNlbGwgPT4ge1xuICAgICAgICAgIGNvbnN0IHRkID0gZGVlcCQxKGNlbGwpO1xuICAgICAgICAgIHJlbW92ZSRhKHRkLCAnY29sc3BhbicpO1xuICAgICAgICAgIHJlbW92ZSRhKHRkLCAncm93c3BhbicpO1xuICAgICAgICAgIHJldHVybiB0ZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyID0gc2hhbGxvdyQxKHJvdy5lbGVtZW50KTtcbiAgICAgICAgYXBwZW5kKHRyLCBjZWxscyk7XG4gICAgICAgIHJldHVybiB0cjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZnJvbURvbSA9IHRhYmxlRWxtID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlID0gdGFibGVNb2RlbChzaGFsbG93JDEodGFibGVFbG0pLCAwLCBbXSk7XG4gICAgICBlYWNoJGUoZGVzY2VuZGFudHModGFibGVFbG0sICd0cicpLCAodHIsIHkpID0+IHtcbiAgICAgICAgZWFjaCRlKGRlc2NlbmRhbnRzKHRyLCAndGQsdGgnKSwgKHRkLCB4KSA9PiB7XG4gICAgICAgICAgZmlsbG91dCh0YWJsZSwgc2tpcENlbGxzWCh0YWJsZSwgeCwgeSksIHksIHRyLCB0ZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFibGVNb2RlbCh0YWJsZS5lbGVtZW50LCBnZXRXaWR0aCh0YWJsZS5yb3dzKSwgdGFibGUucm93cyk7XG4gICAgfTtcbiAgICBjb25zdCB0b0RvbSA9IHRhYmxlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVEb21UYWJsZSh0YWJsZSwgbW9kZWxSb3dzVG9Eb21Sb3dzKHRhYmxlKSk7XG4gICAgfTtcbiAgICBjb25zdCBzdWJzZWN0aW9uID0gKHRhYmxlLCBzdGFydEVsZW1lbnQsIGVuZEVsZW1lbnQpID0+IHtcbiAgICAgIHJldHVybiBmaW5kRWxlbWVudFBvcyh0YWJsZSwgc3RhcnRFbGVtZW50KS5iaW5kKHN0YXJ0UG9zID0+IHtcbiAgICAgICAgcmV0dXJuIGZpbmRFbGVtZW50UG9zKHRhYmxlLCBlbmRFbGVtZW50KS5tYXAoZW5kUG9zID0+IHtcbiAgICAgICAgICByZXR1cm4gc3ViVGFibGUodGFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kUGFyZW50TGlzdENvbnRhaW5lciA9IHBhcmVudHMgPT4gZmluZCQyKHBhcmVudHMsIGVsbSA9PiBuYW1lKGVsbSkgPT09ICd1bCcgfHwgbmFtZShlbG0pID09PSAnb2wnKTtcbiAgICBjb25zdCBnZXRGdWxseVNlbGVjdGVkTGlzdFdyYXBwZXJzID0gKHBhcmVudHMsIHJuZykgPT4gZmluZCQyKHBhcmVudHMsIGVsbSA9PiBuYW1lKGVsbSkgPT09ICdsaScgJiYgaGFzQWxsQ29udGVudHNTZWxlY3RlZChlbG0sIHJuZykpLmZvbGQoY29uc3RhbnQoW10pLCBfbGkgPT4gZmluZFBhcmVudExpc3RDb250YWluZXIocGFyZW50cykubWFwKGxpc3RDb250ID0+IHtcbiAgICAgIGNvbnN0IGxpc3RFbG0gPSBTdWdhckVsZW1lbnQuZnJvbVRhZyhuYW1lKGxpc3RDb250KSk7XG4gICAgICBjb25zdCBsaXN0U3R5bGVzID0gZmlsdGVyJDQoZ2V0QWxsUmF3KGxpc3RDb250KSwgKF9zdHlsZSwgbmFtZSkgPT4gc3RhcnRzV2l0aChuYW1lLCAnbGlzdC1zdHlsZScpKTtcbiAgICAgIHNldEFsbChsaXN0RWxtLCBsaXN0U3R5bGVzKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGFnKCdsaScpLFxuICAgICAgICBsaXN0RWxtXG4gICAgICBdO1xuICAgIH0pLmdldE9yKFtdKSk7XG4gICAgY29uc3Qgd3JhcCA9IChpbm5lckVsbSwgZWxtcykgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlZCA9IGZvbGRsKGVsbXMsIChhY2MsIGVsbSkgPT4ge1xuICAgICAgICBhcHBlbmQkMShlbG0sIGFjYyk7XG4gICAgICAgIHJldHVybiBlbG07XG4gICAgICB9LCBpbm5lckVsbSk7XG4gICAgICByZXR1cm4gZWxtcy5sZW5ndGggPiAwID8gZnJvbUVsZW1lbnRzKFt3cmFwcGVkXSkgOiB3cmFwcGVkO1xuICAgIH07XG4gICAgY29uc3QgZGlyZWN0TGlzdFdyYXBwZXJzID0gY29tbW9uQW5jaG9yQ29udGFpbmVyID0+IHtcbiAgICAgIGlmIChpc0xpc3RJdGVtJDEoY29tbW9uQW5jaG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50KGNvbW1vbkFuY2hvckNvbnRhaW5lcikuZmlsdGVyKGlzTGlzdCkuZm9sZChjb25zdGFudChbXSksIGxpc3RFbG0gPT4gW1xuICAgICAgICAgIGNvbW1vbkFuY2hvckNvbnRhaW5lcixcbiAgICAgICAgICBsaXN0RWxtXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdChjb21tb25BbmNob3JDb250YWluZXIpID8gW2NvbW1vbkFuY2hvckNvbnRhaW5lcl0gOiBbXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFdyYXBFbGVtZW50cyA9IChyb290Tm9kZSwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBjb21tb25BbmNob3JDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKGNvbW1vbkFuY2hvckNvbnRhaW5lciwgcm9vdE5vZGUpO1xuICAgICAgY29uc3Qgd3JhcEVsZW1lbnRzID0gZmlsdGVyJDUocGFyZW50cywgaXNXcmFwRWxlbWVudCk7XG4gICAgICBjb25zdCBsaXN0V3JhcHBlcnMgPSBnZXRGdWxseVNlbGVjdGVkTGlzdFdyYXBwZXJzKHBhcmVudHMsIHJuZyk7XG4gICAgICBjb25zdCBhbGxXcmFwcGVycyA9IHdyYXBFbGVtZW50cy5jb25jYXQobGlzdFdyYXBwZXJzLmxlbmd0aCA/IGxpc3RXcmFwcGVycyA6IGRpcmVjdExpc3RXcmFwcGVycyhjb21tb25BbmNob3JDb250YWluZXIpKTtcbiAgICAgIHJldHVybiBtYXAkMyhhbGxXcmFwcGVycywgc2hhbGxvdyQxKTtcbiAgICB9O1xuICAgIGNvbnN0IGVtcHR5RnJhZ21lbnQgPSAoKSA9PiBmcm9tRWxlbWVudHMoW10pO1xuICAgIGNvbnN0IGdldEZyYWdtZW50RnJvbVJhbmdlID0gKHJvb3ROb2RlLCBybmcpID0+IHdyYXAoU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLmNsb25lQ29udGVudHMoKSksIGdldFdyYXBFbGVtZW50cyhyb290Tm9kZSwgcm5nKSk7XG4gICAgY29uc3QgZ2V0UGFyZW50VGFibGUgPSAocm9vdEVsbSwgY2VsbCkgPT4gYW5jZXN0b3IkMyhjZWxsLCAndGFibGUnLCBjdXJyeShlcSwgcm9vdEVsbSkpO1xuICAgIGNvbnN0IGdldFRhYmxlRnJhZ21lbnQgPSAocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxscykgPT4gZ2V0UGFyZW50VGFibGUocm9vdE5vZGUsIHNlbGVjdGVkVGFibGVDZWxsc1swXSkuYmluZCh0YWJsZUVsbSA9PiB7XG4gICAgICBjb25zdCBmaXJzdENlbGwgPSBzZWxlY3RlZFRhYmxlQ2VsbHNbMF07XG4gICAgICBjb25zdCBsYXN0Q2VsbCA9IHNlbGVjdGVkVGFibGVDZWxsc1tzZWxlY3RlZFRhYmxlQ2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBmdWxsVGFibGVNb2RlbCA9IGZyb21Eb20odGFibGVFbG0pO1xuICAgICAgcmV0dXJuIHN1YnNlY3Rpb24oZnVsbFRhYmxlTW9kZWwsIGZpcnN0Q2VsbCwgbGFzdENlbGwpLm1hcChzZWN0aW9uZWRUYWJsZU1vZGVsID0+IGZyb21FbGVtZW50cyhbdG9Eb20oc2VjdGlvbmVkVGFibGVNb2RlbCldKSk7XG4gICAgfSkuZ2V0T3JUaHVuayhlbXB0eUZyYWdtZW50KTtcbiAgICBjb25zdCBnZXRTZWxlY3Rpb25GcmFnbWVudCA9IChyb290Tm9kZSwgcmFuZ2VzKSA9PiByYW5nZXMubGVuZ3RoID4gMCAmJiByYW5nZXNbMF0uY29sbGFwc2VkID8gZW1wdHlGcmFnbWVudCgpIDogZ2V0RnJhZ21lbnRGcm9tUmFuZ2Uocm9vdE5vZGUsIHJhbmdlc1swXSk7XG4gICAgY29uc3QgcmVhZCQzID0gKHJvb3ROb2RlLCByYW5nZXMpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQ2VsbHMgPSBnZXRDZWxsc0Zyb21FbGVtZW50T3JSYW5nZXMocmFuZ2VzLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRDZWxscy5sZW5ndGggPiAwID8gZ2V0VGFibGVGcmFnbWVudChyb290Tm9kZSwgc2VsZWN0ZWRDZWxscykgOiBnZXRTZWxlY3Rpb25GcmFnbWVudChyb290Tm9kZSwgcmFuZ2VzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb2xsYXBzaWJsZVdoaXRlc3BhY2UgPSAodGV4dCwgaW5kZXgpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCB0ZXh0Lmxlbmd0aCAmJiBpc1doaXRlU3BhY2UodGV4dC5jaGFyQXQoaW5kZXgpKTtcbiAgICBjb25zdCBnZXRJbm5lclRleHQgPSBiaW4gPT4ge1xuICAgICAgcmV0dXJuIHRyaW0kMShiaW4uaW5uZXJUZXh0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbnRleHROb2RlTmFtZSA9IHBhcmVudEJsb2NrT3B0ID0+IHBhcmVudEJsb2NrT3B0Lm1hcChibG9jayA9PiBibG9jay5ub2RlTmFtZSkuZ2V0T3IoJ2RpdicpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZ2V0VGV4dENvbnRlbnQgPSBlZGl0b3IgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAocm5nID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrT3B0ID0gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChybmcuY29tbW9uQW5jZXN0b3JDb250YWluZXIsIGVkaXRvci5kb20uaXNCbG9jaykpO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBjb250ZXh0Tm9kZU5hbWUgPSBnZXRDb250ZXh0Tm9kZU5hbWUocGFyZW50QmxvY2tPcHQpO1xuICAgICAgY29uc3QgcmFuZ2VDb250ZW50Q2xvbmUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuY2xvbmVDb250ZW50cygpKTtcbiAgICAgIGNsZWFudXBCb2d1c0VsZW1lbnRzKHJhbmdlQ29udGVudENsb25lKTtcbiAgICAgIGNsZWFudXBJbnB1dE5hbWVzKHJhbmdlQ29udGVudENsb25lKTtcbiAgICAgIGNvbnN0IGJpbiA9IGVkaXRvci5kb20uYWRkKGJvZHksIGNvbnRleHROb2RlTmFtZSwge1xuICAgICAgICAnZGF0YS1tY2UtYm9ndXMnOiAnYWxsJyxcbiAgICAgICAgJ3N0eWxlJzogJ292ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IDA7J1xuICAgICAgfSwgcmFuZ2VDb250ZW50Q2xvbmUuZG9tKTtcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRJbm5lclRleHQoYmluKTtcbiAgICAgIGNvbnN0IG5vblJlbmRlcmVkVGV4dCA9IHRyaW0kMSgoX2EgPSBiaW4udGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIGVkaXRvci5kb20ucmVtb3ZlKGJpbik7XG4gICAgICBpZiAoaXNDb2xsYXBzaWJsZVdoaXRlc3BhY2Uobm9uUmVuZGVyZWRUZXh0LCAwKSB8fCBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShub25SZW5kZXJlZFRleHQsIG5vblJlbmRlcmVkVGV4dC5sZW5ndGggLSAxKSkge1xuICAgICAgICBjb25zdCBwYXJlbnRCbG9jayA9IHBhcmVudEJsb2NrT3B0LmdldE9yKGJvZHkpO1xuICAgICAgICBjb25zdCBwYXJlbnRCbG9ja1RleHQgPSBnZXRJbm5lclRleHQocGFyZW50QmxvY2spO1xuICAgICAgICBjb25zdCB0ZXh0SW5kZXggPSBwYXJlbnRCbG9ja1RleHQuaW5kZXhPZih0ZXh0KTtcbiAgICAgICAgaWYgKHRleHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBoYXNQcm9jZWVkaW5nU3BhY2UgPSBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShwYXJlbnRCbG9ja1RleHQsIHRleHRJbmRleCAtIDEpO1xuICAgICAgICAgIGNvbnN0IGhhc1RyYWlsaW5nU3BhY2UgPSBpc0NvbGxhcHNpYmxlV2hpdGVzcGFjZShwYXJlbnRCbG9ja1RleHQsIHRleHRJbmRleCArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gKGhhc1Byb2NlZWRpbmdTcGFjZSA/ICcgJyA6ICcnKSArIHRleHQgKyAoaGFzVHJhaWxpbmdTcGFjZSA/ICcgJyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgfSkuZ2V0T3IoJycpO1xuICAgIGNvbnN0IGdldFNlcmlhbGl6ZWRDb250ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgdG1wRWxtID0gZWRpdG9yLmRvbS5jcmVhdGUoJ2JvZHknKTtcbiAgICAgIGNvbnN0IHNlbCA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCk7XG4gICAgICBjb25zdCByYW5nZXMgPSBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgZ2V0UmFuZ2VzJDEoc2VsKSk7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGFyZ3MuY29udGV4dHVhbCA/IHJlYWQkMyhTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgcmFuZ2VzKS5kb20gOiBybmcuY2xvbmVDb250ZW50cygpO1xuICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIHRtcEVsbS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yLnNlbGVjdGlvbi5zZXJpYWxpemVyLnNlcmlhbGl6ZSh0bXBFbG0sIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgZXh0cmFjdFNlbGVjdGVkQ29udGVudCA9IChlZGl0b3IsIGFyZ3MpID0+IHtcbiAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXh0Q29udGVudChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldFNlcmlhbGl6ZWRDb250ZW50KGVkaXRvciwgYXJncyk7XG4gICAgICAgIGlmIChhcmdzLmZvcm1hdCA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSA/ICcnIDogY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBcmdzJDMgPSAoYXJncywgZm9ybWF0KSA9PiAoe1xuICAgICAgLi4uYXJncyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGdldDogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGdldElubmVyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDb250ZW50SW50ZXJuYWwgPSAoZWRpdG9yLCBmb3JtYXQsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdGVkQXJncyA9IHNldHVwQXJncyQzKGFyZ3MsIGZvcm1hdCk7XG4gICAgICByZXR1cm4gcHJlUHJvY2Vzc0dldENvbnRlbnQoZWRpdG9yLCBkZWZhdWx0ZWRBcmdzKS5mb2xkKGlkZW50aXR5LCB1cGRhdGVkQXJncyA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBleHRyYWN0U2VsZWN0ZWRDb250ZW50KGVkaXRvciwgdXBkYXRlZEFyZ3MpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgY29udGVudCwgdXBkYXRlZEFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IEtFRVAgPSAwLCBJTlNFUlQgPSAxLCBERUxFVEUgPSAyO1xuICAgIGNvbnN0IGRpZmYgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCArIDI7XG4gICAgICBjb25zdCB2RG93biA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGNvbnN0IHZVcCA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGNvbnN0IHNuYWtlID0gKHN0YXJ0LCBlbmQsIGRpYWcpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZGlhZ1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGJ1aWxkU2NyaXB0ID0gKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyLCBzY3JpcHQpID0+IHtcbiAgICAgICAgY29uc3QgbWlkZGxlID0gZ2V0TWlkZGxlU25ha2Uoc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpO1xuICAgICAgICBpZiAobWlkZGxlID09PSBudWxsIHx8IG1pZGRsZS5zdGFydCA9PT0gZW5kMSAmJiBtaWRkbGUuZGlhZyA9PT0gZW5kMSAtIGVuZDIgfHwgbWlkZGxlLmVuZCA9PT0gc3RhcnQxICYmIG1pZGRsZS5kaWFnID09PSBzdGFydDEgLSBzdGFydDIpIHtcbiAgICAgICAgICBsZXQgaSA9IHN0YXJ0MTtcbiAgICAgICAgICBsZXQgaiA9IHN0YXJ0MjtcbiAgICAgICAgICB3aGlsZSAoaSA8IGVuZDEgfHwgaiA8IGVuZDIpIHtcbiAgICAgICAgICAgIGlmIChpIDwgZW5kMSAmJiBqIDwgZW5kMiAmJiBsZWZ0W2ldID09PSByaWdodFtqXSkge1xuICAgICAgICAgICAgICBzY3JpcHQucHVzaChbXG4gICAgICAgICAgICAgICAgS0VFUCxcbiAgICAgICAgICAgICAgICBsZWZ0W2ldXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChlbmQxIC0gc3RhcnQxID4gZW5kMiAtIHN0YXJ0Mikge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5wdXNoKFtcbiAgICAgICAgICAgICAgICAgIERFTEVURSxcbiAgICAgICAgICAgICAgICAgIGxlZnRbaV1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnB1c2goW1xuICAgICAgICAgICAgICAgICAgSU5TRVJULFxuICAgICAgICAgICAgICAgICAgcmlnaHRbal1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVpbGRTY3JpcHQoc3RhcnQxLCBtaWRkbGUuc3RhcnQsIHN0YXJ0MiwgbWlkZGxlLnN0YXJ0IC0gbWlkZGxlLmRpYWcsIHNjcmlwdCk7XG4gICAgICAgICAgZm9yIChsZXQgaTIgPSBtaWRkbGUuc3RhcnQ7IGkyIDwgbWlkZGxlLmVuZDsgKytpMikge1xuICAgICAgICAgICAgc2NyaXB0LnB1c2goW1xuICAgICAgICAgICAgICBLRUVQLFxuICAgICAgICAgICAgICBsZWZ0W2kyXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1aWxkU2NyaXB0KG1pZGRsZS5lbmQsIGVuZDEsIG1pZGRsZS5lbmQgLSBtaWRkbGUuZGlhZywgZW5kMiwgc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGJ1aWxkU25ha2UgPSAoc3RhcnQsIGRpYWcsIGVuZDEsIGVuZDIpID0+IHtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAoZW5kIC0gZGlhZyA8IGVuZDIgJiYgZW5kIDwgZW5kMSAmJiBsZWZ0W2VuZF0gPT09IHJpZ2h0W2VuZCAtIGRpYWddKSB7XG4gICAgICAgICAgKytlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNuYWtlKHN0YXJ0LCBlbmQsIGRpYWcpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldE1pZGRsZVNuYWtlID0gKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSA9PiB7XG4gICAgICAgIGNvbnN0IG0gPSBlbmQxIC0gc3RhcnQxO1xuICAgICAgICBjb25zdCBuID0gZW5kMiAtIHN0YXJ0MjtcbiAgICAgICAgaWYgKG0gPT09IDAgfHwgbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gbSAtIG47XG4gICAgICAgIGNvbnN0IHN1bSA9IG4gKyBtO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoc3VtICUgMiA9PT0gMCA/IHN1bSA6IHN1bSArIDEpIC8gMjtcbiAgICAgICAgdkRvd25bMSArIG9mZnNldF0gPSBzdGFydDE7XG4gICAgICAgIHZVcFsxICsgb2Zmc2V0XSA9IGVuZDEgKyAxO1xuICAgICAgICBsZXQgZCwgaywgaSwgeCwgeTtcbiAgICAgICAgZm9yIChkID0gMDsgZCA8PSBvZmZzZXQ7ICsrZCkge1xuICAgICAgICAgIGZvciAoayA9IC1kOyBrIDw9IGQ7IGsgKz0gMikge1xuICAgICAgICAgICAgaSA9IGsgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gLWQgfHwgayAhPT0gZCAmJiB2RG93bltpIC0gMV0gPCB2RG93bltpICsgMV0pIHtcbiAgICAgICAgICAgICAgdkRvd25baV0gPSB2RG93bltpICsgMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2RG93bltpXSA9IHZEb3duW2kgLSAxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gdkRvd25baV07XG4gICAgICAgICAgICB5ID0geCAtIHN0YXJ0MSArIHN0YXJ0MiAtIGs7XG4gICAgICAgICAgICB3aGlsZSAoeCA8IGVuZDEgJiYgeSA8IGVuZDIgJiYgbGVmdFt4XSA9PT0gcmlnaHRbeV0pIHtcbiAgICAgICAgICAgICAgdkRvd25baV0gPSArK3g7XG4gICAgICAgICAgICAgICsreTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSAlIDIgIT09IDAgJiYgZGVsdGEgLSBkIDw9IGsgJiYgayA8PSBkZWx0YSArIGQpIHtcbiAgICAgICAgICAgICAgaWYgKHZVcFtpIC0gZGVsdGFdIDw9IHZEb3duW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU25ha2UodlVwW2kgLSBkZWx0YV0sIGsgKyBzdGFydDEgLSBzdGFydDIsIGVuZDEsIGVuZDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoayA9IGRlbHRhIC0gZDsgayA8PSBkZWx0YSArIGQ7IGsgKz0gMikge1xuICAgICAgICAgICAgaSA9IGsgKyBvZmZzZXQgLSBkZWx0YTtcbiAgICAgICAgICAgIGlmIChrID09PSBkZWx0YSAtIGQgfHwgayAhPT0gZGVsdGEgKyBkICYmIHZVcFtpICsgMV0gPD0gdlVwW2kgLSAxXSkge1xuICAgICAgICAgICAgICB2VXBbaV0gPSB2VXBbaSArIDFdIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZVcFtpXSA9IHZVcFtpIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gdlVwW2ldIC0gMTtcbiAgICAgICAgICAgIHkgPSB4IC0gc3RhcnQxICsgc3RhcnQyIC0gaztcbiAgICAgICAgICAgIHdoaWxlICh4ID49IHN0YXJ0MSAmJiB5ID49IHN0YXJ0MiAmJiBsZWZ0W3hdID09PSByaWdodFt5XSkge1xuICAgICAgICAgICAgICB2VXBbaV0gPSB4LS07XG4gICAgICAgICAgICAgIHktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWx0YSAlIDIgPT09IDAgJiYgLWQgPD0gayAmJiBrIDw9IGQpIHtcbiAgICAgICAgICAgICAgaWYgKHZVcFtpXSA8PSB2RG93bltpICsgZGVsdGFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU25ha2UodlVwW2ldLCBrICsgc3RhcnQxIC0gc3RhcnQyLCBlbmQxLCBlbmQyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JpcHQgPSBbXTtcbiAgICAgIGJ1aWxkU2NyaXB0KDAsIGxlZnQubGVuZ3RoLCAwLCByaWdodC5sZW5ndGgsIHNjcmlwdCk7XG4gICAgICByZXR1cm4gc2NyaXB0O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRPdXRlckh0bWwgPSBlbG0gPT4ge1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KGVsbSkpIHtcbiAgICAgICAgcmV0dXJuIGVsbS5vdXRlckhUTUw7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dCRhKGVsbSkpIHtcbiAgICAgICAgcmV0dXJuIEVudGl0aWVzLmVuY29kZVJhdyhlbG0uZGF0YSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQoZWxtKSkge1xuICAgICAgICByZXR1cm4gJzwhLS0nICsgZWxtLmRhdGEgKyAnLS0+JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUZyYWdtZW50ID0gaHRtbCA9PiB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGlmIChodG1sKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRBdCA9IChlbG0sIGh0bWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGNyZWF0ZUZyYWdtZW50KGh0bWwpO1xuICAgICAgaWYgKGVsbS5oYXNDaGlsZE5vZGVzKCkgJiYgaW5kZXggPCBlbG0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZWxtLmNoaWxkTm9kZXNbaW5kZXhdO1xuICAgICAgICBlbG0uaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCB0YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUF0ID0gKGVsbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChlbG0uaGFzQ2hpbGROb2RlcygpICYmIGluZGV4IDwgZWxtLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsbS5jaGlsZE5vZGVzW2luZGV4XTtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhcHBseURpZmYgPSAoZGlmZiwgZWxtKSA9PiB7XG4gICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgZWFjaCRlKGRpZmYsIGFjdGlvbiA9PiB7XG4gICAgICAgIGlmIChhY3Rpb25bMF0gPT09IEtFRVApIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PT0gSU5TRVJUKSB7XG4gICAgICAgICAgaW5zZXJ0QXQoZWxtLCBhY3Rpb25bMV0sIGluZGV4KTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PT0gREVMRVRFKSB7XG4gICAgICAgICAgcmVtb3ZlQXQoZWxtLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVhZCQyID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXIkNShtYXAkMyhmcm9tKGVsbS5jaGlsZE5vZGVzKSwgZ2V0T3V0ZXJIdG1sKSwgaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLmxlbmd0aCA+IDA7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHdyaXRlID0gKGZyYWdtZW50cywgZWxtKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50RnJhZ21lbnRzID0gbWFwJDMoZnJvbShlbG0uY2hpbGROb2RlcyksIGdldE91dGVySHRtbCk7XG4gICAgICBhcHBseURpZmYoZGlmZihjdXJyZW50RnJhZ21lbnRzLCBmcmFnbWVudHMpLCBlbG0pO1xuICAgICAgcmV0dXJuIGVsbTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGF6eVRlbXBEb2N1bWVudCA9IGNhY2hlZCgoKSA9PiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3VuZG8nKSk7XG4gICAgY29uc3QgaGFzSWZyYW1lcyA9IGh0bWwgPT4ge1xuICAgICAgcmV0dXJuIGh0bWwuaW5kZXhPZignPC9pZnJhbWU+JykgIT09IC0xO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlRnJhZ21lbnRlZExldmVsID0gZnJhZ21lbnRzID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdmcmFnbWVudGVkJyxcbiAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgYm9va21hcms6IG51bGwsXG4gICAgICAgIGJlZm9yZUJvb2ttYXJrOiBudWxsXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQ29tcGxldGVMZXZlbCA9IGNvbnRlbnQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvbXBsZXRlJyxcbiAgICAgICAgZnJhZ21lbnRzOiBudWxsLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBib29rbWFyazogbnVsbCxcbiAgICAgICAgYmVmb3JlQm9va21hcms6IG51bGxcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVGcm9tRWRpdG9yID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHJlYWQkMihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHRyaW1tZWRGcmFnbWVudHMgPSBiaW5kJDMoZnJhZ21lbnRzLCBodG1sID0+IHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW1JbnRlcm5hbChlZGl0b3Iuc2VyaWFsaXplciwgaHRtbCk7XG4gICAgICAgIHJldHVybiB0cmltbWVkLmxlbmd0aCA+IDAgPyBbdHJpbW1lZF0gOiBbXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29udGVudCA9IHRyaW1tZWRGcmFnbWVudHMuam9pbignJyk7XG4gICAgICByZXR1cm4gaGFzSWZyYW1lcyhjb250ZW50KSA/IGNyZWF0ZUZyYWdtZW50ZWRMZXZlbCh0cmltbWVkRnJhZ21lbnRzKSA6IGNyZWF0ZUNvbXBsZXRlTGV2ZWwoY29udGVudCk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseVRvRWRpdG9yID0gKGVkaXRvciwgbGV2ZWwsIGJlZm9yZSkgPT4ge1xuICAgICAgY29uc3QgYm9va21hcmsgPSBiZWZvcmUgPyBsZXZlbC5iZWZvcmVCb29rbWFyayA6IGxldmVsLmJvb2ttYXJrO1xuICAgICAgaWYgKGxldmVsLnR5cGUgPT09ICdmcmFnbWVudGVkJykge1xuICAgICAgICB3cml0ZShsZXZlbC5mcmFnbWVudHMsIGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNldENvbnRlbnQobGV2ZWwuY29udGVudCwge1xuICAgICAgICAgIGZvcm1hdDogJ3JhdycsXG4gICAgICAgICAgbm9fc2VsZWN0aW9uOiBpc05vbk51bGxhYmxlKGJvb2ttYXJrKSAmJiBpc1BhdGhCb29rbWFyayhib29rbWFyaykgPyAhYm9va21hcmsuaXNGYWtlQ2FyZXQgOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2ttYXJrKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRMZXZlbENvbnRlbnQgPSBsZXZlbCA9PiB7XG4gICAgICByZXR1cm4gbGV2ZWwudHlwZSA9PT0gJ2ZyYWdtZW50ZWQnID8gbGV2ZWwuZnJhZ21lbnRzLmpvaW4oJycpIDogbGV2ZWwuY29udGVudDtcbiAgICB9O1xuICAgIGNvbnN0IGdldENsZWFuTGV2ZWxDb250ZW50ID0gbGV2ZWwgPT4ge1xuICAgICAgY29uc3QgZWxtID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JvZHknLCBsYXp5VGVtcERvY3VtZW50KCkpO1xuICAgICAgc2V0JDEoZWxtLCBnZXRMZXZlbENvbnRlbnQobGV2ZWwpKTtcbiAgICAgIGVhY2gkZShkZXNjZW5kYW50cyhlbG0sICcqW2RhdGEtbWNlLWJvZ3VzXScpLCB1bndyYXApO1xuICAgICAgcmV0dXJuIGdldCQ2KGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNFcXVhbENvbnRlbnQgPSAobGV2ZWwxLCBsZXZlbDIpID0+IGdldExldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRMZXZlbENvbnRlbnQobGV2ZWwyKTtcbiAgICBjb25zdCBoYXNFcXVhbENsZWFuZWRDb250ZW50ID0gKGxldmVsMSwgbGV2ZWwyKSA9PiBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDEpID09PSBnZXRDbGVhbkxldmVsQ29udGVudChsZXZlbDIpO1xuICAgIGNvbnN0IGlzRXEkMSA9IChsZXZlbDEsIGxldmVsMikgPT4ge1xuICAgICAgaWYgKCFsZXZlbDEgfHwgIWxldmVsMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGhhc0VxdWFsQ29udGVudChsZXZlbDEsIGxldmVsMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzRXF1YWxDbGVhbmVkQ29udGVudChsZXZlbDEsIGxldmVsMik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzVW5sb2NrZWQgPSBsb2NrcyA9PiBsb2Nrcy5nZXQoKSA9PT0gMDtcblxuICAgIGNvbnN0IHNldFR5cGluZyA9ICh1bmRvTWFuYWdlciwgdHlwaW5nLCBsb2NrcykgPT4ge1xuICAgICAgaWYgKGlzVW5sb2NrZWQobG9ja3MpKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IHR5cGluZztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZyA9ICh1bmRvTWFuYWdlciwgbG9ja3MpID0+IHtcbiAgICAgIGlmICh1bmRvTWFuYWdlci50eXBpbmcpIHtcbiAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCBmYWxzZSwgbG9ja3MpO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGVuZFR5cGluZ0xldmVsSWdub3JlTG9ja3MgPSB1bmRvTWFuYWdlciA9PiB7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLnR5cGluZyA9IGZhbHNlO1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlJDEgPSAoZWRpdG9yLCBsb2NrcywgYmVmb3JlQm9va21hcmspID0+IHtcbiAgICAgIGlmIChpc1VubG9ja2VkKGxvY2tzKSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5zZXQoZ2V0VW5kb0Jvb2ttYXJrKGVkaXRvci5zZWxlY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFkZFVuZG9MZXZlbCQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudExldmVsID0gY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpO1xuICAgICAgY29uc3QgbmV3TGV2ZWwgPSBUb29scy5leHRlbmQobGV2ZWwgfHwge30sIGN1cnJlbnRMZXZlbCk7XG4gICAgICBpZiAoIWlzVW5sb2NrZWQobG9ja3MpIHx8IGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdExldmVsID0gdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKV07XG4gICAgICBpZiAoZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVBZGRVbmRvJywge1xuICAgICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgICBsYXN0TGV2ZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICAgICAgfSkuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobGFzdExldmVsICYmIGlzRXEkMShsYXN0TGV2ZWwsIG5ld0xldmVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXSkge1xuICAgICAgICBiZWZvcmVCb29rbWFyay5nZXQoKS5lYWNoKGJtID0+IHtcbiAgICAgICAgICB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpXS5iZWZvcmVCb29rbWFyayA9IGJtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1c3RvbVVuZG9SZWRvTGV2ZWxzID0gZ2V0Q3VzdG9tVW5kb1JlZG9MZXZlbHMoZWRpdG9yKTtcbiAgICAgIGlmIChjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggPiBjdXN0b21VbmRvUmVkb0xldmVscykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHVuZG9NYW5hZ2VyLmRhdGFbaV0gPSB1bmRvTWFuYWdlci5kYXRhW2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5kb01hbmFnZXIuZGF0YS5sZW5ndGgtLTtcbiAgICAgICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdMZXZlbC5ib29rbWFyayA9IGdldFVuZG9Cb29rbWFyayhlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIGlmIChpbmRleC5nZXQoKSA8IHVuZG9NYW5hZ2VyLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB1bmRvTWFuYWdlci5kYXRhLmxlbmd0aCA9IGluZGV4LmdldCgpICsgMTtcbiAgICAgIH1cbiAgICAgIHVuZG9NYW5hZ2VyLmRhdGEucHVzaChuZXdMZXZlbCk7XG4gICAgICBpbmRleC5zZXQodW5kb01hbmFnZXIuZGF0YS5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIGxldmVsOiBuZXdMZXZlbCxcbiAgICAgICAgbGFzdExldmVsLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgICAgfTtcbiAgICAgIGlmIChpbmRleC5nZXQoKSA+IDApIHtcbiAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ0FkZFVuZG8nLCBhcmdzKTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdjaGFuZ2UnLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWRkVW5kbycsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0xldmVsO1xuICAgIH07XG4gICAgY29uc3QgY2xlYXIkMSA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4ge1xuICAgICAgdW5kb01hbmFnZXIuZGF0YSA9IFtdO1xuICAgICAgaW5kZXguc2V0KDApO1xuICAgICAgdW5kb01hbmFnZXIudHlwaW5nID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ0NsZWFyVW5kb3MnKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhJDEgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKSA9PiB7XG4gICAgICBpZiAodW5kb01hbmFnZXIudHJhbnNhY3QoY2FsbGJhY2sxKSkge1xuICAgICAgICBjb25zdCBib29rbWFyayA9IHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCldLmJvb2ttYXJrO1xuICAgICAgICBjb25zdCBsYXN0TGV2ZWwgPSB1bmRvTWFuYWdlci5kYXRhW2luZGV4LmdldCgpIC0gMV07XG4gICAgICAgIGFwcGx5VG9FZGl0b3IoZWRpdG9yLCBsYXN0TGV2ZWwsIHRydWUpO1xuICAgICAgICBpZiAodW5kb01hbmFnZXIudHJhbnNhY3QoY2FsbGJhY2syKSkge1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLmRhdGFbaW5kZXguZ2V0KCkgLSAxXS5iZWZvcmVCb29rbWFyayA9IGJvb2ttYXJrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWRvJDEgPSAoZWRpdG9yLCBpbmRleCwgZGF0YSkgPT4ge1xuICAgICAgbGV0IGxldmVsO1xuICAgICAgaWYgKGluZGV4LmdldCgpIDwgZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGluZGV4LnNldChpbmRleC5nZXQoKSArIDEpO1xuICAgICAgICBsZXZlbCA9IGRhdGFbaW5kZXguZ2V0KCldO1xuICAgICAgICBhcHBseVRvRWRpdG9yKGVkaXRvciwgbGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1JlZG8nLCB7IGxldmVsIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH07XG4gICAgY29uc3QgdW5kbyQxID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGxvY2tzLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGxldmVsO1xuICAgICAgaWYgKHVuZG9NYW5hZ2VyLnR5cGluZykge1xuICAgICAgICB1bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgICAgdW5kb01hbmFnZXIudHlwaW5nID0gZmFsc2U7XG4gICAgICAgIHNldFR5cGluZyh1bmRvTWFuYWdlciwgZmFsc2UsIGxvY2tzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleC5nZXQoKSA+IDApIHtcbiAgICAgICAgaW5kZXguc2V0KGluZGV4LmdldCgpIC0gMSk7XG4gICAgICAgIGxldmVsID0gdW5kb01hbmFnZXIuZGF0YVtpbmRleC5nZXQoKV07XG4gICAgICAgIGFwcGx5VG9FZGl0b3IoZWRpdG9yLCBsZXZlbCwgdHJ1ZSk7XG4gICAgICAgIGVkaXRvci5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdVbmRvJywgeyBsZXZlbCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0JDEgPSB1bmRvTWFuYWdlciA9PiB7XG4gICAgICB1bmRvTWFuYWdlci5jbGVhcigpO1xuICAgICAgdW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNVbmRvJDEgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpID0+IGluZGV4LmdldCgpID4gMCB8fCB1bmRvTWFuYWdlci50eXBpbmcgJiYgdW5kb01hbmFnZXIuZGF0YVswXSAmJiAhaXNFcSQxKGNyZWF0ZUZyb21FZGl0b3IoZWRpdG9yKSwgdW5kb01hbmFnZXIuZGF0YVswXSk7XG4gICAgY29uc3QgaGFzUmVkbyQxID0gKHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gaW5kZXguZ2V0KCkgPCB1bmRvTWFuYWdlci5kYXRhLmxlbmd0aCAtIDEgJiYgIXVuZG9NYW5hZ2VyLnR5cGluZztcbiAgICBjb25zdCB0cmFuc2FjdCQxID0gKHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spID0+IHtcbiAgICAgIGVuZFR5cGluZyh1bmRvTWFuYWdlciwgbG9ja3MpO1xuICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICB1bmRvTWFuYWdlci5pZ25vcmUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgIH07XG4gICAgY29uc3QgaWdub3JlJDEgPSAobG9ja3MsIGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2Nrcy5zZXQobG9ja3MuZ2V0KCkgKyAxKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGxvY2tzLnNldChsb2Nrcy5nZXQoKSAtIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBhZGRWaXN1YWxJbnRlcm5hbCA9IChlZGl0b3IsIGVsbSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNjb3BlID0gaXNOb25OdWxsYWJsZShlbG0pID8gZWxtIDogZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGVhY2gkZShkb20uc2VsZWN0KCd0YWJsZSxhJywgc2NvcGUpLCBtYXRjaGVkRWxtID0+IHtcbiAgICAgICAgc3dpdGNoIChtYXRjaGVkRWxtLm5vZGVOYW1lKSB7XG4gICAgICAgIGNhc2UgJ1RBQkxFJzpcbiAgICAgICAgICBjb25zdCBjbHMgPSBnZXRWaXN1YWxBaWRzVGFibGVDbGFzcyhlZGl0b3IpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tLmdldEF0dHJpYihtYXRjaGVkRWxtLCAnYm9yZGVyJyk7XG4gICAgICAgICAgaWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICcwJykgJiYgZWRpdG9yLmhhc1Zpc3VhbCkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKG1hdGNoZWRFbG0sIGNscyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgaWYgKCFkb20uZ2V0QXR0cmliKG1hdGNoZWRFbG0sICdocmVmJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tLmdldEF0dHJpYihtYXRjaGVkRWxtLCAnbmFtZScpIHx8IG1hdGNoZWRFbG0uaWQ7XG4gICAgICAgICAgICBjb25zdCBjbHMgPSBnZXRWaXN1YWxBaWRzQW5jaG9yQ2xhc3MoZWRpdG9yKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBlZGl0b3IuaGFzVmlzdWFsKSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhtYXRjaGVkRWxtLCBjbHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKG1hdGNoZWRFbG0sIGNscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnVmlzdWFsQWlkJywge1xuICAgICAgICBlbGVtZW50OiBlbG0sXG4gICAgICAgIGhhc1Zpc3VhbDogZWRpdG9yLmhhc1Zpc3VhbFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG1ha2VQbGFpbkFkYXB0b3IgPSBlZGl0b3IgPT4gKHtcbiAgICAgIGluaXQ6IHsgYmluZEV2ZW50czogbm9vcCB9LFxuICAgICAgdW5kb01hbmFnZXI6IHtcbiAgICAgICAgYmVmb3JlQ2hhbmdlOiAobG9ja3MsIGJlZm9yZUJvb2ttYXJrKSA9PiBiZWZvcmVDaGFuZ2UkMShlZGl0b3IsIGxvY2tzLCBiZWZvcmVCb29rbWFyayksXG4gICAgICAgIGFkZDogKHVuZG9NYW5hZ2VyLCBpbmRleCwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrLCBsZXZlbCwgZXZlbnQpID0+IGFkZFVuZG9MZXZlbCQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCksXG4gICAgICAgIHVuZG86ICh1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KSA9PiB1bmRvJDEoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KSxcbiAgICAgICAgcmVkbzogKGluZGV4LCBkYXRhKSA9PiByZWRvJDEoZWRpdG9yLCBpbmRleCwgZGF0YSksXG4gICAgICAgIGNsZWFyOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBjbGVhciQxKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KSxcbiAgICAgICAgcmVzZXQ6IHVuZG9NYW5hZ2VyID0+IHJlc2V0JDEodW5kb01hbmFnZXIpLFxuICAgICAgICBoYXNVbmRvOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBoYXNVbmRvJDEoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpLFxuICAgICAgICBoYXNSZWRvOiAodW5kb01hbmFnZXIsIGluZGV4KSA9PiBoYXNSZWRvJDEodW5kb01hbmFnZXIsIGluZGV4KSxcbiAgICAgICAgdHJhbnNhY3Q6ICh1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSA9PiB0cmFuc2FjdCQxKHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spLFxuICAgICAgICBpZ25vcmU6IChsb2NrcywgY2FsbGJhY2spID0+IGlnbm9yZSQxKGxvY2tzLCBjYWxsYmFjayksXG4gICAgICAgIGV4dHJhOiAodW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4gZXh0cmEkMShlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpXG4gICAgICB9LFxuICAgICAgZm9ybWF0dGVyOiB7XG4gICAgICAgIG1hdGNoOiAobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gbWF0Y2gkMihlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICBtYXRjaEFsbDogKG5hbWVzLCB2YXJzKSA9PiBtYXRjaEFsbChlZGl0b3IsIG5hbWVzLCB2YXJzKSxcbiAgICAgICAgbWF0Y2hOb2RlOiAobm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcikgPT4gbWF0Y2hOb2RlKGVkaXRvciwgbm9kZSwgbmFtZSwgdmFycywgc2ltaWxhciksXG4gICAgICAgIGNhbkFwcGx5OiBuYW1lID0+IGNhbkFwcGx5KGVkaXRvciwgbmFtZSksXG4gICAgICAgIGNsb3Nlc3Q6IG5hbWVzID0+IGNsb3Nlc3QoZWRpdG9yLCBuYW1lcyksXG4gICAgICAgIGFwcGx5OiAobmFtZSwgdmFycywgbm9kZSkgPT4gYXBwbHlGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpLFxuICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiByZW1vdmVGb3JtYXQkMShlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICB0b2dnbGU6IChuYW1lLCB2YXJzLCBub2RlKSA9PiB0b2dnbGUoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSxcbiAgICAgICAgZm9ybWF0Q2hhbmdlZDogKHJlZ2lzdGVyZWRGb3JtYXRMaXN0ZW5lcnMsIGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKSA9PiBmb3JtYXRDaGFuZ2VkSW50ZXJuYWwoZWRpdG9yLCByZWdpc3RlcmVkRm9ybWF0TGlzdGVuZXJzLCBmb3JtYXRzLCBjYWxsYmFjaywgc2ltaWxhciwgdmFycylcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHtcbiAgICAgICAgZ2V0Q29udGVudDogYXJncyA9PiBnZXRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBhcmdzKSxcbiAgICAgICAgc2V0Q29udGVudDogKGNvbnRlbnQsIGFyZ3MpID0+IHNldENvbnRlbnRJbnRlcm5hbChlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpLFxuICAgICAgICBpbnNlcnRDb250ZW50OiAodmFsdWUsIGRldGFpbHMpID0+IGluc2VydEh0bWxBdENhcmV0KGVkaXRvciwgdmFsdWUsIGRldGFpbHMpLFxuICAgICAgICBhZGRWaXN1YWw6IGVsbSA9PiBhZGRWaXN1YWxJbnRlcm5hbChlZGl0b3IsIGVsbSlcbiAgICAgIH0sXG4gICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogKGZvcm1hdCwgYXJncykgPT4gZ2V0U2VsZWN0ZWRDb250ZW50SW50ZXJuYWwoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpIH0sXG4gICAgICBhdXRvY29tcGxldGVyOiB7XG4gICAgICAgIGFkZERlY29yYXRpb246IHJhbmdlID0+IGNyZWF0ZSQ5KGVkaXRvciwgcmFuZ2UpLFxuICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiAoKSA9PiByZW1vdmUkMihlZGl0b3IsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKVxuICAgICAgfSxcbiAgICAgIHJhdzogeyBnZXRNb2RlbDogKCkgPT4gT3B0aW9uYWwubm9uZSgpIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYWtlUnRjQWRhcHRvciA9IHJ0Y0VkaXRvciA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFycyA9IHZhcnMgPT4gaXNPYmplY3QodmFycykgPyB2YXJzIDoge307XG4gICAgICBjb25zdCB7aW5pdCwgdW5kb01hbmFnZXIsIGZvcm1hdHRlciwgZWRpdG9yLCBzZWxlY3Rpb24sIGF1dG9jb21wbGV0ZXIsIHJhd30gPSBydGNFZGl0b3I7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbml0OiB7IGJpbmRFdmVudHM6IGluaXQuYmluZEV2ZW50cyB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlLFxuICAgICAgICAgIGFkZDogdW5kb01hbmFnZXIuYWRkLFxuICAgICAgICAgIHVuZG86IHVuZG9NYW5hZ2VyLnVuZG8sXG4gICAgICAgICAgcmVkbzogdW5kb01hbmFnZXIucmVkbyxcbiAgICAgICAgICBjbGVhcjogdW5kb01hbmFnZXIuY2xlYXIsXG4gICAgICAgICAgcmVzZXQ6IHVuZG9NYW5hZ2VyLnJlc2V0LFxuICAgICAgICAgIGhhc1VuZG86IHVuZG9NYW5hZ2VyLmhhc1VuZG8sXG4gICAgICAgICAgaGFzUmVkbzogdW5kb01hbmFnZXIuaGFzUmVkbyxcbiAgICAgICAgICB0cmFuc2FjdDogKF91bmRvTWFuYWdlciwgX2xvY2tzLCBmbikgPT4gdW5kb01hbmFnZXIudHJhbnNhY3QoZm4pLFxuICAgICAgICAgIGlnbm9yZTogKF9sb2NrcywgY2FsbGJhY2spID0+IHVuZG9NYW5hZ2VyLmlnbm9yZShjYWxsYmFjayksXG4gICAgICAgICAgZXh0cmE6IChfdW5kb01hbmFnZXIsIF9pbmRleCwgY2FsbGJhY2sxLCBjYWxsYmFjazIpID0+IHVuZG9NYW5hZ2VyLmV4dHJhKGNhbGxiYWNrMSwgY2FsbGJhY2syKVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXR0ZXI6IHtcbiAgICAgICAgICBtYXRjaDogKG5hbWUsIHZhcnMsIF9ub2RlLCBzaW1pbGFyKSA9PiBmb3JtYXR0ZXIubWF0Y2gobmFtZSwgZGVmYXVsdFZhcnModmFycyksIHNpbWlsYXIpLFxuICAgICAgICAgIG1hdGNoQWxsOiBmb3JtYXR0ZXIubWF0Y2hBbGwsXG4gICAgICAgICAgbWF0Y2hOb2RlOiBmb3JtYXR0ZXIubWF0Y2hOb2RlLFxuICAgICAgICAgIGNhbkFwcGx5OiBuYW1lID0+IGZvcm1hdHRlci5jYW5BcHBseShuYW1lKSxcbiAgICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBmb3JtYXR0ZXIuY2xvc2VzdChuYW1lcyksXG4gICAgICAgICAgYXBwbHk6IChuYW1lLCB2YXJzLCBfbm9kZSkgPT4gZm9ybWF0dGVyLmFwcGx5KG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBfbm9kZSwgX3NpbWlsYXIpID0+IGZvcm1hdHRlci5yZW1vdmUobmFtZSwgZGVmYXVsdFZhcnModmFycykpLFxuICAgICAgICAgIHRvZ2dsZTogKG5hbWUsIHZhcnMsIF9ub2RlKSA9PiBmb3JtYXR0ZXIudG9nZ2xlKG5hbWUsIGRlZmF1bHRWYXJzKHZhcnMpKSxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiAoX3JmbCwgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGZvcm1hdHRlci5mb3JtYXRDaGFuZ2VkKGZvcm1hdHMsIGNhbGxiYWNrLCBzaW1pbGFyLCB2YXJzKVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBhcmdzID0+IGVkaXRvci5nZXRDb250ZW50KGFyZ3MpLFxuICAgICAgICAgIHNldENvbnRlbnQ6IChjb250ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb250ZW50OiBlZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKSxcbiAgICAgICAgICAgICAgaHRtbDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnRDb250ZW50OiAoY29udGVudCwgX2RldGFpbHMpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5pbnNlcnRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkVmlzdWFsOiBlZGl0b3IuYWRkVmlzdWFsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGlvbjogeyBnZXRDb250ZW50OiAoX2Zvcm1hdCwgYXJncykgPT4gc2VsZWN0aW9uLmdldENvbnRlbnQoYXJncykgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IGF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbixcbiAgICAgICAgICByZW1vdmVEZWNvcmF0aW9uOiBhdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcmF3OiB7IGdldE1vZGVsOiAoKSA9PiBPcHRpb25hbC5zb21lKHJhdy5nZXRSYXdNb2RlbCgpKSB9XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFrZU5vb3BBZGFwdG9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgbnVsID0gY29uc3RhbnQobnVsbCk7XG4gICAgICBjb25zdCBlbXB0eSA9IGNvbnN0YW50KCcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluaXQ6IHsgYmluZEV2ZW50czogbm9vcCB9LFxuICAgICAgICB1bmRvTWFuYWdlcjoge1xuICAgICAgICAgIGJlZm9yZUNoYW5nZTogbm9vcCxcbiAgICAgICAgICBhZGQ6IG51bCxcbiAgICAgICAgICB1bmRvOiBudWwsXG4gICAgICAgICAgcmVkbzogbnVsLFxuICAgICAgICAgIGNsZWFyOiBub29wLFxuICAgICAgICAgIHJlc2V0OiBub29wLFxuICAgICAgICAgIGhhc1VuZG86IG5ldmVyLFxuICAgICAgICAgIGhhc1JlZG86IG5ldmVyLFxuICAgICAgICAgIHRyYW5zYWN0OiBudWwsXG4gICAgICAgICAgaWdub3JlOiBub29wLFxuICAgICAgICAgIGV4dHJhOiBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjoge1xuICAgICAgICAgIG1hdGNoOiBuZXZlcixcbiAgICAgICAgICBtYXRjaEFsbDogY29uc3RhbnQoW10pLFxuICAgICAgICAgIG1hdGNoTm9kZTogY29uc3RhbnQodW5kZWZpbmVkKSxcbiAgICAgICAgICBjYW5BcHBseTogbmV2ZXIsXG4gICAgICAgICAgY2xvc2VzdDogZW1wdHksXG4gICAgICAgICAgYXBwbHk6IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlOiBub29wLFxuICAgICAgICAgIHRvZ2dsZTogbm9vcCxcbiAgICAgICAgICBmb3JtYXRDaGFuZ2VkOiBjb25zdGFudCh7IHVuYmluZDogbm9vcCB9KVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3I6IHtcbiAgICAgICAgICBnZXRDb250ZW50OiBlbXB0eSxcbiAgICAgICAgICBzZXRDb250ZW50OiBjb25zdGFudCh7XG4gICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIGh0bWw6ICcnXG4gICAgICAgICAgfSksXG4gICAgICAgICAgaW5zZXJ0Q29udGVudDogY29uc3RhbnQoJycpLFxuICAgICAgICAgIGFkZFZpc3VhbDogbm9vcFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Rpb246IHsgZ2V0Q29udGVudDogZW1wdHkgfSxcbiAgICAgICAgYXV0b2NvbXBsZXRlcjoge1xuICAgICAgICAgIGFkZERlY29yYXRpb246IG5vb3AsXG4gICAgICAgICAgcmVtb3ZlRGVjb3JhdGlvbjogbm9vcFxuICAgICAgICB9LFxuICAgICAgICByYXc6IHsgZ2V0TW9kZWw6IGNvbnN0YW50KE9wdGlvbmFsLm5vbmUoKSkgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUnRjID0gZWRpdG9yID0+IGhhcyQyKGVkaXRvci5wbHVnaW5zLCAncnRjJyk7XG4gICAgY29uc3QgZ2V0UnRjU2V0dXAgPSBlZGl0b3IgPT4gZ2V0JGEoZWRpdG9yLnBsdWdpbnMsICdydGMnKS5iaW5kKHJ0Y1BsdWdpbiA9PiBPcHRpb25hbC5mcm9tKHJ0Y1BsdWdpbi5zZXR1cCkpO1xuICAgIGNvbnN0IHNldHVwJHMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yQ2FzdCA9IGVkaXRvcjtcbiAgICAgIHJldHVybiBnZXRSdGNTZXR1cChlZGl0b3IpLmZvbGQoKCkgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZVBsYWluQWRhcHRvcihlZGl0b3IpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSwgc2V0dXAgPT4ge1xuICAgICAgICBlZGl0b3JDYXN0LnJ0Y0luc3RhbmNlID0gbWFrZU5vb3BBZGFwdG9yKCk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHNldHVwKCkudGhlbihydGNFZGl0b3IgPT4ge1xuICAgICAgICAgIGVkaXRvckNhc3QucnRjSW5zdGFuY2UgPSBtYWtlUnRjQWRhcHRvcihydGNFZGl0b3IpO1xuICAgICAgICAgIHJldHVybiBydGNFZGl0b3IucnRjLmlzUmVtb3RlO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrID0gZWRpdG9yID0+IGVkaXRvci5ydGNJbnN0YW5jZSA/IGVkaXRvci5ydGNJbnN0YW5jZSA6IG1ha2VQbGFpbkFkYXB0b3IoZWRpdG9yKTtcbiAgICBjb25zdCBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBydGNJbnN0YW5jZSA9IGVkaXRvci5ydGNJbnN0YW5jZTtcbiAgICAgIGlmICghcnRjSW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IFJUQyBpbnN0YW5jZSBub3QgeWV0IGluaXRpYWxpemVkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ0Y0luc3RhbmNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmVmb3JlQ2hhbmdlID0gKGVkaXRvciwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZShsb2NrcywgYmVmb3JlQm9va21hcmspO1xuICAgIH07XG4gICAgY29uc3QgYWRkVW5kb0xldmVsID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5hZGQodW5kb01hbmFnZXIsIGluZGV4LCBsb2NrcywgYmVmb3JlQm9va21hcmssIGxldmVsLCBldmVudCk7XG4gICAgY29uc3QgdW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBsb2NrcywgaW5kZXgpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIudW5kbyh1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KTtcbiAgICBjb25zdCByZWRvID0gKGVkaXRvciwgaW5kZXgsIGRhdGEpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVkbyhpbmRleCwgZGF0YSk7XG4gICAgY29uc3QgY2xlYXIgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgaW5kZXgpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIuY2xlYXIodW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKGVkaXRvciwgdW5kb01hbmFnZXIpID0+IHtcbiAgICAgIGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikudW5kb01hbmFnZXIucmVzZXQodW5kb01hbmFnZXIpO1xuICAgIH07XG4gICAgY29uc3QgaGFzVW5kbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNVbmRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgaGFzUmVkbyA9IChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCkgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5oYXNSZWRvKHVuZG9NYW5hZ2VyLCBpbmRleCk7XG4gICAgY29uc3QgdHJhbnNhY3QgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KHVuZG9NYW5hZ2VyLCBsb2NrcywgY2FsbGJhY2spO1xuICAgIGNvbnN0IGlnbm9yZSA9IChlZGl0b3IsIGxvY2tzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5pZ25vcmUobG9ja3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhID0gKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS51bmRvTWFuYWdlci5leHRyYSh1bmRvTWFuYWdlciwgaW5kZXgsIGNhbGxiYWNrMSwgY2FsbGJhY2syKTtcbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoRm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcikgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIubWF0Y2gobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgY29uc3QgbWF0Y2hBbGxGb3JtYXRzID0gKGVkaXRvciwgbmFtZXMsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLm1hdGNoQWxsKG5hbWVzLCB2YXJzKTtcbiAgICBjb25zdCBtYXRjaE5vZGVGb3JtYXQgPSAoZWRpdG9yLCBub2RlLCBuYW1lLCB2YXJzLCBzaW1pbGFyKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5tYXRjaE5vZGUobm9kZSwgbmFtZSwgdmFycywgc2ltaWxhcik7XG4gICAgY29uc3QgY2FuQXBwbHlGb3JtYXQgPSAoZWRpdG9yLCBuYW1lKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5jYW5BcHBseShuYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0Rm9ybWF0ID0gKGVkaXRvciwgbmFtZXMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmNsb3Nlc3QobmFtZXMpO1xuICAgIGNvbnN0IGFwcGx5Rm9ybWF0ID0gKGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSkgPT4ge1xuICAgICAgZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5mb3JtYXR0ZXIuYXBwbHkobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci5yZW1vdmUobmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVGb3JtYXQgPSAoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKSA9PiB7XG4gICAgICBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmZvcm1hdHRlci50b2dnbGUobmFtZSwgdmFycywgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXRDaGFuZ2VkID0gKGVkaXRvciwgcmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZm9ybWF0dGVyLmZvcm1hdENoYW5nZWQocmVnaXN0ZXJlZEZvcm1hdExpc3RlbmVycywgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpO1xuICAgIGNvbnN0IGdldENvbnRlbnQkMiA9IChlZGl0b3IsIGFyZ3MpID0+IGdldFJ0Y0luc3RhbmNlV2l0aEZhbGxiYWNrKGVkaXRvcikuZWRpdG9yLmdldENvbnRlbnQoYXJncyk7XG4gICAgY29uc3Qgc2V0Q29udGVudCQyID0gKGVkaXRvciwgY29udGVudCwgYXJncykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3Iuc2V0Q29udGVudChjb250ZW50LCBhcmdzKTtcbiAgICBjb25zdCBpbnNlcnRDb250ZW50JDEgPSAoZWRpdG9yLCB2YWx1ZSwgZGV0YWlscykgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRmFsbGJhY2soZWRpdG9yKS5lZGl0b3IuaW5zZXJ0Q29udGVudCh2YWx1ZSwgZGV0YWlscyk7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRDb250ZW50ID0gKGVkaXRvciwgZm9ybWF0LCBhcmdzKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLnNlbGVjdGlvbi5nZXRDb250ZW50KGZvcm1hdCwgYXJncyk7XG4gICAgY29uc3QgYWRkVmlzdWFsJDEgPSAoZWRpdG9yLCBlbG0pID0+IGdldFJ0Y0luc3RhbmNlV2l0aEVycm9yKGVkaXRvcikuZWRpdG9yLmFkZFZpc3VhbChlbG0pO1xuICAgIGNvbnN0IGJpbmRFdmVudHMgPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5pbml0LmJpbmRFdmVudHMoKTtcbiAgICBjb25zdCBhZGRBdXRvY29tcGxldGVyRGVjb3JhdGlvbiA9IChlZGl0b3IsIHJhbmdlKSA9PiBnZXRSdGNJbnN0YW5jZVdpdGhFcnJvcihlZGl0b3IpLmF1dG9jb21wbGV0ZXIuYWRkRGVjb3JhdGlvbihyYW5nZSk7XG4gICAgY29uc3QgcmVtb3ZlQXV0b2NvbXBsZXRlckRlY29yYXRpb24gPSBlZGl0b3IgPT4gZ2V0UnRjSW5zdGFuY2VXaXRoRXJyb3IoZWRpdG9yKS5hdXRvY29tcGxldGVyLnJlbW92ZURlY29yYXRpb24oKTtcblxuICAgIGNvbnN0IGdldENvbnRlbnQkMSA9IChlZGl0b3IsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPyBhcmdzLmZvcm1hdCA6ICdodG1sJztcbiAgICAgIHJldHVybiBnZXRTZWxlY3RlZENvbnRlbnQoZWRpdG9yLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVFbXB0eSA9IHRleHQgPT4ge1xuICAgICAgaWYgKHRleHQuZG9tLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmUkNSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHRleHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2Fsa1Bhc3RCb29rbWFyayA9IChub2RlLCBzdGFydCkgPT4gbm9kZS5maWx0ZXIoZWxtID0+IEJvb2ttYXJrTWFuYWdlci5pc0Jvb2ttYXJrTm9kZShlbG0uZG9tKSkuYmluZChzdGFydCA/IG5leHRTaWJsaW5nIDogcHJldlNpYmxpbmcpO1xuICAgIGNvbnN0IG1lcmdlJDEgPSAob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSA9PiB7XG4gICAgICBjb25zdCBvdXRlckVsbSA9IG91dGVyLmRvbTtcbiAgICAgIGNvbnN0IGlubmVyRWxtID0gaW5uZXIuZG9tO1xuICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gc3RhcnQgPyBvdXRlckVsbS5sZW5ndGggOiBpbm5lckVsbS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMob3V0ZXJFbG0sIGlubmVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGlubmVyRWxtLCBvbGRMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VUZXh0Tm9kZXMoaW5uZXJFbG0sIG91dGVyRWxtLCBmYWxzZSwgIXN0YXJ0KTtcbiAgICAgICAgcm5nLnNldEVuZChpbm5lckVsbSwgb2xkTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVRleHRJZlJlcXVpcmVkID0gKGlubmVyLCBzdGFydCkgPT4ge1xuICAgICAgcGFyZW50KGlubmVyKS5lYWNoKHJvb3QgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5uZXIuZG9tO1xuICAgICAgICBpZiAoc3RhcnQgJiYgbmVlZHNUb0JlTmJzcExlZnQocm9vdCwgQ2FyZXRQb3NpdGlvbih0ZXh0LCAwKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQWZ0ZXIodGV4dCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0ICYmIG5lZWRzVG9CZU5ic3BSaWdodChyb290LCBDYXJldFBvc2l0aW9uKHRleHQsIHRleHQubGVuZ3RoKSkpIHtcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlQmVmb3JlKHRleHQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZUFuZE5vcm1hbGl6ZVRleHQgPSAob3V0ZXJOb2RlLCBpbm5lck5vZGUsIHJuZywgc3RhcnQpID0+IHtcbiAgICAgIG91dGVyTm9kZS5iaW5kKG91dGVyID0+IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplciA9IHN0YXJ0ID8gbm9ybWFsaXplV2hpdGVzcGFjZUJlZm9yZSA6IG5vcm1hbGl6ZVdoaXRlc3BhY2VBZnRlcjtcbiAgICAgICAgbm9ybWFsaXplcihvdXRlci5kb20sIHN0YXJ0ID8gb3V0ZXIuZG9tLmxlbmd0aCA6IDApO1xuICAgICAgICByZXR1cm4gaW5uZXJOb2RlLmZpbHRlcihpc1RleHQkYikubWFwKGlubmVyID0+IG1lcmdlJDEob3V0ZXIsIGlubmVyLCBybmcsIHN0YXJ0KSk7XG4gICAgICB9KS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXJUZXh0Tm9kZSA9IHdhbGtQYXN0Qm9va21hcmsoaW5uZXJOb2RlLCBzdGFydCkub3IoaW5uZXJOb2RlKS5maWx0ZXIoaXNUZXh0JGIpO1xuICAgICAgICByZXR1cm4gaW5uZXJUZXh0Tm9kZS5tYXAoaW5uZXIgPT4gbm9ybWFsaXplVGV4dElmUmVxdWlyZWQoaW5uZXIsIHN0YXJ0KSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJuZ1NldENvbnRlbnQgPSAocm5nLCBmcmFnbWVudCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQuZmlyc3RDaGlsZCkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IE9wdGlvbmFsLmZyb20oZnJhZ21lbnQubGFzdENoaWxkKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgICAgcm5nLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBybmcuaW5zZXJ0Tm9kZShmcmFnbWVudCk7XG4gICAgICBjb25zdCBwcmV2VGV4dCA9IGZpcnN0Q2hpbGQuYmluZChwcmV2U2libGluZykuZmlsdGVyKGlzVGV4dCRiKS5iaW5kKHJlbW92ZUVtcHR5KTtcbiAgICAgIGNvbnN0IG5leHRUZXh0ID0gbGFzdENoaWxkLmJpbmQobmV4dFNpYmxpbmcpLmZpbHRlcihpc1RleHQkYikuYmluZChyZW1vdmVFbXB0eSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQocHJldlRleHQsIGZpcnN0Q2hpbGQsIHJuZywgdHJ1ZSk7XG4gICAgICBtZXJnZUFuZE5vcm1hbGl6ZVRleHQobmV4dFRleHQsIGxhc3RDaGlsZCwgcm5nLCBmYWxzZSk7XG4gICAgICBybmcuY29sbGFwc2UoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXBBcmdzJDIgPSAoYXJncywgY29udGVudCkgPT4gKHtcbiAgICAgIGZvcm1hdDogJ2h0bWwnLFxuICAgICAgLi4uYXJncyxcbiAgICAgIHNldDogdHJ1ZSxcbiAgICAgIHNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhbkNvbnRlbnQgPSAoZWRpdG9yLCBhcmdzKSA9PiB7XG4gICAgICBpZiAoYXJncy5mb3JtYXQgIT09ICdyYXcnKSB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRCbG9jayA9IGVkaXRvci5kb20uZ2V0UGFyZW50KHJuZy5jb21tb25BbmNlc3RvckNvbnRhaW5lciwgZWRpdG9yLmRvbS5pc0Jsb2NrKTtcbiAgICAgICAgY29uc3QgY29udGV4dEFyZ3MgPSBjb250ZXh0QmxvY2sgPyB7IGNvbnRleHQ6IGNvbnRleHRCbG9jay5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIH0gOiB7fTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGVkaXRvci5wYXJzZXIucGFyc2UoYXJncy5jb250ZW50LCB7XG4gICAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIC4uLmNvbnRleHRBcmdzLFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiBmYWxzZSB9LCBlZGl0b3Iuc2NoZW1hKS5zZXJpYWxpemUobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJncy5jb250ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudCQxID0gKGVkaXRvciwgY29udGVudCwgYXJncyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRBcmdzID0gc2V0dXBBcmdzJDIoYXJncywgY29udGVudCk7XG4gICAgICBwcmVQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGRlZmF1bHRlZEFyZ3MpLmVhY2godXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29udGVudCA9IGNsZWFuQ29udGVudChlZGl0b3IsIHVwZGF0ZWRBcmdzKTtcbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgcm5nU2V0Q29udGVudChybmcsIHJuZy5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoY2xlYW5lZENvbnRlbnQpKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIHJuZyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIGNsZWFuZWRDb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlRnJvbUNhbGxiYWNrTWFwID0gKGNhbGxiYWNrTWFwLCBzZWxlY3RvciwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChoYXMkMihjYWxsYmFja01hcCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IG5ld0NhbGxiYWNrcyA9IGZpbHRlciQ1KGNhbGxiYWNrTWFwW3NlbGVjdG9yXSwgY2IgPT4gY2IgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKG5ld0NhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgY2FsbGJhY2tNYXBbc2VsZWN0b3JdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrTWFwW3NlbGVjdG9yXSA9IG5ld0NhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIFNlbGVjdG9yQ2hhbmdlZCA9IChkb20sIGVkaXRvcikgPT4ge1xuICAgICAgbGV0IHNlbGVjdG9yQ2hhbmdlZERhdGE7XG4gICAgICBsZXQgY3VycmVudFNlbGVjdG9ycztcbiAgICAgIGNvbnN0IGZpbmRNYXRjaGluZ05vZGUgPSAoc2VsZWN0b3IsIG5vZGVzKSA9PiBmaW5kJDIobm9kZXMsIG5vZGUgPT4gZG9tLmlzKG5vZGUsIHNlbGVjdG9yKSk7XG4gICAgICBjb25zdCBnZXRQYXJlbnRzID0gZWxlbSA9PiBkb20uZ2V0UGFyZW50cyhlbGVtLCB1bmRlZmluZWQsIGRvbS5nZXRSb290KCkpO1xuICAgICAgY29uc3Qgc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZERhdGEgPSB7fTtcbiAgICAgICAgY3VycmVudFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gZS5lbGVtZW50O1xuICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSBnZXRQYXJlbnRzKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICBlYWNoJGQoc2VsZWN0b3JDaGFuZ2VkRGF0YSwgKGNhbGxiYWNrcywgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIGZpbmRNYXRjaGluZ05vZGUoc2VsZWN0b3IsIHBhcmVudHMpLmVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudFNlbGVjdG9yc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICBlYWNoJGUoY2FsbGJhY2tzLCBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0b3JzW3NlbGVjdG9yXSA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbGVjdG9yXSA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVhY2gkZChjdXJyZW50U2VsZWN0b3JzLCAoY2FsbGJhY2tzLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2VsZWN0b3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICBkZWxldGUgY3VycmVudFNlbGVjdG9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICAgIGVhY2gkZShjYWxsYmFja3MsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgcGFyZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZDogKHNlbGVjdG9yLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGlmICghc2VsZWN0b3JDaGFuZ2VkRGF0YSkge1xuICAgICAgICAgICAgc2V0dXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzZWxlY3RvckNoYW5nZWREYXRhW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgZmluZE1hdGNoaW5nTm9kZShzZWxlY3RvciwgZ2V0UGFyZW50cyhlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpKS5lYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3RvcnNbc2VsZWN0b3JdID0gc2VsZWN0b3JDaGFuZ2VkRGF0YVtzZWxlY3Rvcl07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuYmluZDogKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxldGVGcm9tQ2FsbGJhY2tNYXAoc2VsZWN0b3JDaGFuZ2VkRGF0YSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgZGVsZXRlRnJvbUNhbGxiYWNrTWFwKGN1cnJlbnRTZWxlY3RvcnMsIHNlbGVjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNBdHRhY2hlZFRvRG9tID0gbm9kZSA9PiB7XG4gICAgICByZXR1cm4gISEobm9kZSAmJiBub2RlLm93bmVyRG9jdW1lbnQpICYmIGNvbnRhaW5zKFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUub3duZXJEb2N1bWVudCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRSYW5nZSA9IHJuZyA9PiB7XG4gICAgICBpZiAoIXJuZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNBdHRhY2hlZFRvRG9tKHJuZy5zdGFydENvbnRhaW5lcikgJiYgaXNBdHRhY2hlZFRvRG9tKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRWRpdG9yU2VsZWN0aW9uID0gKGRvbSwgd2luLCBzZXJpYWxpemVyLCBlZGl0b3IpID0+IHtcbiAgICAgIGxldCBzZWxlY3RlZFJhbmdlO1xuICAgICAgbGV0IGV4cGxpY2l0UmFuZ2U7XG4gICAgICBjb25zdCB7c2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZH0gPSBTZWxlY3RvckNoYW5nZWQoZG9tLCBlZGl0b3IpO1xuICAgICAgY29uc3Qgc2V0Q3Vyc29yTG9jYXRpb24gPSAobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUobm9kZSkgJiYgaXNOb25OdWxsYWJsZShvZmZzZXQpKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgcm5nLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgICAgIGNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlRW5kUG9pbnQoZG9tLCBybmcsIGVkaXRvci5nZXRCb2R5KCksIHRydWUpO1xuICAgICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q29udGVudCA9IGFyZ3MgPT4gZ2V0Q29udGVudCQxKGVkaXRvciwgYXJncyk7XG4gICAgICBjb25zdCBzZXRDb250ZW50ID0gKGNvbnRlbnQsIGFyZ3MpID0+IHNldENvbnRlbnQkMShlZGl0b3IsIGNvbnRlbnQsIGFyZ3MpO1xuICAgICAgY29uc3QgZ2V0U3RhcnQkMSA9IHJlYWwgPT4gZ2V0U3RhcnQoZWRpdG9yLmdldEJvZHkoKSwgZ2V0Um5nJDEoKSwgcmVhbCk7XG4gICAgICBjb25zdCBnZXRFbmQgPSByZWFsID0+IGdldEVuZCQxKGVkaXRvci5nZXRCb2R5KCksIGdldFJuZyQxKCksIHJlYWwpO1xuICAgICAgY29uc3QgZ2V0Qm9va21hcmsgPSAodHlwZSwgbm9ybWFsaXplZCkgPT4gYm9va21hcmtNYW5hZ2VyLmdldEJvb2ttYXJrKHR5cGUsIG5vcm1hbGl6ZWQpO1xuICAgICAgY29uc3QgbW92ZVRvQm9va21hcmsgPSBib29rbWFyayA9PiBib29rbWFya01hbmFnZXIubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgY29uc3Qgc2VsZWN0JDEgPSAobm9kZSwgY29udGVudCkgPT4ge1xuICAgICAgICBzZWxlY3QoZG9tLCBub2RlLCBjb250ZW50KS5lYWNoKHNldFJuZyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBnZXRSbmckMSgpLCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgaWYgKCFybmcgfHwgcm5nLml0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJuZy5jb21wYXJlRW5kUG9pbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHJuZy5jb21wYXJlRW5kUG9pbnRzKCdTdGFydFRvRW5kJywgcm5nKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXNlbCB8fCBybmcuY29sbGFwc2VkO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldFJuZyQxKCk7XG4gICAgICAgIGNvbnN0IGZha2VTZWxlY3RlZEVsZW1lbnRzID0gZWRpdG9yLmdldEJvZHkoKS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tY2Utc2VsZWN0ZWQ9XCIxXCJdJyk7XG4gICAgICAgIGlmIChmYWtlU2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmFsbChmYWtlU2VsZWN0ZWRFbGVtZW50cywgZWwgPT4gZG9tLmlzRWRpdGFibGUoZWwucGFyZW50RWxlbWVudCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgIHJldHVybiBkb20uaXNFZGl0YWJsZShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkb20uaXNFZGl0YWJsZShybmcuc3RhcnRDb250YWluZXIpICYmIGRvbS5pc0VkaXRhYmxlKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29sbGFwc2UgPSB0b1N0YXJ0ID0+IHtcbiAgICAgICAgY29uc3Qgcm5nID0gZ2V0Um5nJDEoKTtcbiAgICAgICAgcm5nLmNvbGxhcHNlKCEhdG9TdGFydCk7XG4gICAgICAgIHNldFJuZyhybmcpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFNlbCA9ICgpID0+IHdpbi5nZXRTZWxlY3Rpb24gPyB3aW4uZ2V0U2VsZWN0aW9uKCkgOiB3aW4uZG9jdW1lbnQuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgZ2V0Um5nJDEgPSAoKSA9PiB7XG4gICAgICAgIGxldCBybmc7XG4gICAgICAgIGNvbnN0IHRyeUNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IChob3csIHNvdXJjZVJhbmdlLCBkZXN0aW5hdGlvblJhbmdlKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoaG93LCBkZXN0aW5hdGlvblJhbmdlKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShlZGl0b3IuYm9va21hcmspICYmICFoYXNGb2N1cyhlZGl0b3IpKSB7XG4gICAgICAgICAgY29uc3QgYm9va21hcmsgPSBnZXRSbmcoZWRpdG9yKTtcbiAgICAgICAgICBpZiAoYm9va21hcmsuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBib29rbWFyay5tYXAociA9PiBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgW3JdKVswXSkuZ2V0T3IoZG9jLmNyZWF0ZVJhbmdlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGdldFNlbCgpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgIWlzUmVzdHJpY3RlZE5vZGUoc2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIHJuZyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcm5nID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBybmcgPSBwcm9jZXNzUmFuZ2VzKGVkaXRvciwgW3JuZ10pWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJuZykge1xuICAgICAgICAgIHJuZyA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvY3VtZW50JDEocm5nLnN0YXJ0Q29udGFpbmVyKSAmJiBybmcuY29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZWxtID0gZG9tLmdldFJvb3QoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQoZWxtLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGVsbSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkUmFuZ2UgJiYgZXhwbGljaXRSYW5nZSkge1xuICAgICAgICAgIGlmICh0cnlDb21wYXJlQm91bmRhcnlQb2ludHMocm5nLlNUQVJUX1RPX1NUQVJULCBybmcsIHNlbGVjdGVkUmFuZ2UpID09PSAwICYmIHRyeUNvbXBhcmVCb3VuZGFyeVBvaW50cyhybmcuRU5EX1RPX0VORCwgcm5nLCBzZWxlY3RlZFJhbmdlKSA9PT0gMCkge1xuICAgICAgICAgICAgcm5nID0gZXhwbGljaXRSYW5nZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0ZWRSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBleHBsaWNpdFJhbmdlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRSbmcgPSAocm5nLCBmb3J3YXJkKSA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZFJhbmdlKHJuZykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsID0gZ2V0U2VsKCk7XG4gICAgICAgIGNvbnN0IGV2dCA9IGVkaXRvci5kaXNwYXRjaCgnU2V0U2VsZWN0aW9uUmFuZ2UnLCB7XG4gICAgICAgICAgcmFuZ2U6IHJuZyxcbiAgICAgICAgICBmb3J3YXJkXG4gICAgICAgIH0pO1xuICAgICAgICBybmcgPSBldnQucmFuZ2U7XG4gICAgICAgIGlmIChzZWwpIHtcbiAgICAgICAgICBleHBsaWNpdFJhbmdlID0gcm5nO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9yd2FyZCA9PT0gZmFsc2UgJiYgc2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKHJuZy5lbmRDb250YWluZXIsIHJuZy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgc2VsLmV4dGVuZChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGVkUmFuZ2UgPSBzZWwucmFuZ2VDb3VudCA+IDAgPyBzZWwuZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkICYmIHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm5nLmVuZENvbnRhaW5lciAmJiAoc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsLnNldEJhc2VBbmRFeHRlbnQpKSB7XG4gICAgICAgICAgaWYgKHJuZy5lbmRPZmZzZXQgLSBybmcuc3RhcnRPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgICBpZiAocm5nLnN0YXJ0Q29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gcm5nLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbcm5nLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBzZWwuc2V0QmFzZUFuZEV4dGVudChybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCwgcm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbC5hbmNob3JOb2RlICE9PSBybmcuc3RhcnRDb250YWluZXIgfHwgc2VsLmZvY3VzTm9kZSAhPT0gcm5nLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgc2VsLnNldEJhc2VBbmRFeHRlbnQobm9kZSwgMCwgbm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWZ0ZXJTZXRTZWxlY3Rpb25SYW5nZScsIHtcbiAgICAgICAgICByYW5nZTogcm5nLFxuICAgICAgICAgIGZvcndhcmRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0Tm9kZSA9IGVsbSA9PiB7XG4gICAgICAgIHNldENvbnRlbnQoZG9tLmdldE91dGVySFRNTChlbG0pKTtcbiAgICAgICAgcmV0dXJuIGVsbTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXROb2RlJDEgPSAoKSA9PiBnZXROb2RlKGVkaXRvci5nZXRCb2R5KCksIGdldFJuZyQxKCkpO1xuICAgICAgY29uc3QgZ2V0U2VsZWN0ZWRCbG9ja3MkMSA9IChzdGFydEVsbSwgZW5kRWxtKSA9PiBnZXRTZWxlY3RlZEJsb2Nrcyhkb20sIGdldFJuZyQxKCksIHN0YXJ0RWxtLCBlbmRFbG0pO1xuICAgICAgY29uc3QgaXNGb3J3YXJkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWwgPT09IG51bGwgfHwgc2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWwuZm9jdXNOb2RlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhYW5jaG9yTm9kZSB8fCAhZm9jdXNOb2RlIHx8IGlzUmVzdHJpY3RlZE5vZGUoYW5jaG9yTm9kZSkgfHwgaXNSZXN0cmljdGVkTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGNvbnN0IGZvY3VzUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYW5jaG9yUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgYW5jaG9yUmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgZm9jdXNSYW5nZS5zZXRTdGFydChmb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgZm9jdXNSYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmNob3JSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMoYW5jaG9yUmFuZ2UuU1RBUlRfVE9fU1RBUlQsIGZvY3VzUmFuZ2UpIDw9IDA7XG4gICAgICB9O1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBybmcgPSBnZXRSbmckMSgpO1xuICAgICAgICBjb25zdCBzZWwgPSBnZXRTZWwoKTtcbiAgICAgICAgaWYgKCFoYXNNdWx0aXBsZVJhbmdlcyhzZWwpICYmIGhhc0FueVJhbmdlcyhlZGl0b3IpKSB7XG4gICAgICAgICAgY29uc3Qgbm9ybVJuZyA9IG5vcm1hbGl6ZSQyKGRvbSwgcm5nKTtcbiAgICAgICAgICBub3JtUm5nLmVhY2gobm9ybVJuZyA9PiB7XG4gICAgICAgICAgICBzZXRSbmcobm9ybVJuZywgaXNGb3J3YXJkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBub3JtUm5nLmdldE9yKHJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZWxlY3RvckNoYW5nZWQgPSAoc2VsZWN0b3IsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZFdpdGhVbmJpbmQoc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0U2Nyb2xsQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyO1xuICAgICAgICBsZXQgbm9kZSA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgIGlmIChub2RlLnNjcm9sbEhlaWdodCA+IG5vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICBjb25zdCBzY3JvbGxJbnRvVmlldyA9IChlbG0sIGFsaWduVG9Ub3ApID0+IHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoZWxtKSkge1xuICAgICAgICAgIHNjcm9sbEVsZW1lbnRJbnRvVmlldyhlZGl0b3IsIGVsbSwgYWxpZ25Ub1RvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsUmFuZ2VJbnRvVmlldyhlZGl0b3IsIGdldFJuZyQxKCksIGFsaWduVG9Ub3ApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcGxhY2VDYXJldEF0ID0gKGNsaWVudFgsIGNsaWVudFkpID0+IHNldFJuZyhmcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSwgZWRpdG9yLmdldERvYygpKSk7XG4gICAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldFJuZyQxKCk7XG4gICAgICAgIHJldHVybiBybmcuY29sbGFwc2VkID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpLmdldENsaWVudFJlY3RzKClbMF0gOiBybmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgd2luID0gc2VsZWN0ZWRSYW5nZSA9IGV4cGxpY2l0UmFuZ2UgPSBudWxsO1xuICAgICAgICBjb250cm9sU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBleHBhbmQgPSAob3B0aW9ucyA9IHsgdHlwZTogJ3dvcmQnIH0pID0+IHNldFJuZyhSYW5nZVV0aWxzKGRvbSkuZXhwYW5kKGdldFJuZyQxKCksIG9wdGlvbnMpKTtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSB7XG4gICAgICAgIGRvbSxcbiAgICAgICAgd2luLFxuICAgICAgICBzZXJpYWxpemVyLFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIGV4cGFuZCxcbiAgICAgICAgY29sbGFwc2UsXG4gICAgICAgIHNldEN1cnNvckxvY2F0aW9uLFxuICAgICAgICBnZXRDb250ZW50LFxuICAgICAgICBzZXRDb250ZW50LFxuICAgICAgICBnZXRCb29rbWFyayxcbiAgICAgICAgbW92ZVRvQm9va21hcmssXG4gICAgICAgIHNlbGVjdDogc2VsZWN0JDEsXG4gICAgICAgIGlzQ29sbGFwc2VkLFxuICAgICAgICBpc0VkaXRhYmxlLFxuICAgICAgICBpc0ZvcndhcmQsXG4gICAgICAgIHNldE5vZGUsXG4gICAgICAgIGdldE5vZGU6IGdldE5vZGUkMSxcbiAgICAgICAgZ2V0U2VsLFxuICAgICAgICBzZXRSbmcsXG4gICAgICAgIGdldFJuZzogZ2V0Um5nJDEsXG4gICAgICAgIGdldFN0YXJ0OiBnZXRTdGFydCQxLFxuICAgICAgICBnZXRFbmQsXG4gICAgICAgIGdldFNlbGVjdGVkQmxvY2tzOiBnZXRTZWxlY3RlZEJsb2NrcyQxLFxuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIHNlbGVjdG9yQ2hhbmdlZCxcbiAgICAgICAgc2VsZWN0b3JDaGFuZ2VkV2l0aFVuYmluZCxcbiAgICAgICAgZ2V0U2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBzY3JvbGxJbnRvVmlldyxcbiAgICAgICAgcGxhY2VDYXJldEF0LFxuICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgICBjb25zdCBib29rbWFya01hbmFnZXIgPSBCb29rbWFya01hbmFnZXIoZXhwb3J0cyk7XG4gICAgICBjb25zdCBjb250cm9sU2VsZWN0aW9uID0gQ29udHJvbFNlbGVjdGlvbihleHBvcnRzLCBlZGl0b3IpO1xuICAgICAgZXhwb3J0cy5ib29rbWFya01hbmFnZXIgPSBib29rbWFya01hbmFnZXI7XG4gICAgICBleHBvcnRzLmNvbnRyb2xTZWxlY3Rpb24gPSBjb250cm9sU2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyJDMgPSAoaHRtbFBhcnNlciwgc2V0dGluZ3MsIGRvbSkgPT4ge1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXRhYmluZGV4JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIG5vZGUuYXR0cigndGFiaW5kZXgnLCBub2RlLmF0dHIoJ2RhdGEtbWNlLXRhYmluZGV4JykpO1xuICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignc3JjLGhyZWYsc3R5bGUnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOYW1lID0gJ2RhdGEtbWNlLScgKyBuYW1lO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXIgPSBzZXR0aW5ncy51cmxfY29udmVydGVyO1xuICAgICAgICBjb25zdCB1cmxDb252ZXJ0ZXJTY29wZSA9IHNldHRpbmdzLnVybF9jb252ZXJ0ZXJfc2NvcGU7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IG5vZGUuYXR0cihpbnRlcm5hbE5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIobmFtZSwgdmFsdWUubGVuZ3RoID4gMCA/IHZhbHVlIDogbnVsbCk7XG4gICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlLmF0dHIobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRvbS5zZXJpYWxpemVTdHlsZShkb20ucGFyc2VTdHlsZSh2YWx1ZSksIG5vZGUubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybENvbnZlcnRlcikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHVybENvbnZlcnRlci5jYWxsKHVybENvbnZlcnRlclNjb3BlLCB2YWx1ZSwgbmFtZSwgbm9kZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2NsYXNzJywgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyg/Ol58XFxzKW1jZS1pdGVtLVxcdysoPyFcXFMpL2csICcnKTtcbiAgICAgICAgICAgIG5vZGUuYXR0cignY2xhc3MnLCB2YWx1ZS5sZW5ndGggPiAwID8gdmFsdWUgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ2RhdGEtbWNlLXR5cGUnLCAobm9kZXMsIG5hbWUsIGFyZ3MpID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGUuYXR0cignZGF0YS1tY2UtdHlwZScpID09PSAnYm9va21hcmsnICYmICFhcmdzLmNsZWFudXApIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gT3B0aW9uYWwuZnJvbShub2RlLmZpcnN0Q2hpbGQpLmV4aXN0cyhmaXJzdENoaWxkID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gIWlzWndzcCQxKChfYSA9IGZpcnN0Q2hpbGQudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIG5vZGUudW53cmFwKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ25vc2NyaXB0Jywgbm9kZXMgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBFbnRpdGllcy5kZWNvZGUoKF9hID0gbm9kZS52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3NjcmlwdCxzdHlsZScsIChub2RlcywgbmFtZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRyaW0gPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyg8IS0tXFxbQ0RBVEFcXFt8XFxdXFxdLS0+KS9nLCAnXFxuJykucmVwbGFjZSgvXltcXHJcXG5dKnxbXFxyXFxuXSokL2csICcnKS5yZXBsYWNlKC9eXFxzKigoPCEtLSk/KFxccypcXC9cXC8pP1xccyo8IVxcW0NEQVRBXFxbfCg8IS0tXFxzKik/XFwvXFwqXFxzKjwhXFxbQ0RBVEFcXFtcXHMqXFwqXFwvfChcXC9cXC8pP1xccyo8IS0tfFxcL1xcKlxccyo8IS0tXFxzKlxcKlxcLylcXHMqW1xcclxcbl0qL2dpLCAnJykucmVwbGFjZSgvXFxzKihcXC9cXCpcXHMqXFxdXFxdPlxccypcXCpcXC8oLS0+KT98XFxzKlxcL1xcL1xccypcXF1cXF0+KC0tPik/fFxcL1xcL1xccyooLS0+KT98XFxdXFxdPnxcXC9cXCpcXHMqLS0+XFxzKlxcKlxcL3xcXHMqLS0+XFxzKilcXHMqJC9nLCAnJyk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAoX2EgPSBmaXJzdENoaWxkID09PSBudWxsIHx8IGZpcnN0Q2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0Q2hpbGQudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuYXR0cigndHlwZScpO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKCd0eXBlJywgdHlwZSA9PT0gJ21jZS1uby90eXBlJyA/IG51bGwgOiB0eXBlLnJlcGxhY2UoL15tY2VcXC0vLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVsZW1lbnRfZm9ybWF0ID09PSAneGh0bWwnICYmIGZpcnN0Q2hpbGQgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmaXJzdENoaWxkLnZhbHVlID0gJy8vIDwhW0NEQVRBW1xcbicgKyB0cmltKHZhbHVlKSArICdcXG4vLyBdXT4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZWxlbWVudF9mb3JtYXQgPT09ICd4aHRtbCcgJiYgZmlyc3RDaGlsZCAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZpcnN0Q2hpbGQudmFsdWUgPSAnPCEtLVxcbicgKyB0cmltKHZhbHVlKSArICdcXG4tLT4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJyNjb21tZW50Jywgbm9kZXMgPT4ge1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgaWYgKHNldHRpbmdzLnByZXNlcnZlX2NkYXRhICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuaW5kZXhPZignW0NEQVRBWycpKSA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJyNjZGF0YSc7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSA0O1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IGRvbS5kZWNvZGUodmFsdWUucmVwbGFjZSgvXlxcW0NEQVRBXFxbfFxcXVxcXSQvZywgJycpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuaW5kZXhPZignbWNlOnByb3RlY3RlZCAnKSkgPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9ICcjdGV4dCc7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSAzO1xuICAgICAgICAgICAgbm9kZS5yYXcgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHVuZXNjYXBlKHZhbHVlKS5zdWJzdHIoMTQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3htbDpuYW1lc3BhY2UsaW5wdXQnLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gNykge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbnB1dCcgJiYgIW5vZGUuYXR0cigndHlwZScpKSB7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cigndHlwZScsICd0ZXh0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGh0bWxQYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdkYXRhLW1jZS10eXBlJywgbm9kZXMgPT4ge1xuICAgICAgICBlYWNoJGUobm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLmF0dHIoJ2RhdGEtbWNlLXR5cGUnKSA9PT0gJ2Zvcm1hdC1jYXJldCcpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzRW1wdHkoaHRtbFBhcnNlci5zY2hlbWEuZ2V0Tm9uRW1wdHlFbGVtZW50cygpKSkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS51bndyYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignZGF0YS1tY2Utc3JjLGRhdGEtbWNlLWhyZWYsZGF0YS1tY2Utc3R5bGUsJyArICdkYXRhLW1jZS1zZWxlY3RlZCxkYXRhLW1jZS1leHBhbmRvLGRhdGEtbWNlLWJsb2NrLCcgKyAnZGF0YS1tY2UtdHlwZSxkYXRhLW1jZS1yZXNpemUsZGF0YS1tY2UtcGxhY2Vob2xkZXInLCAobm9kZXMsIG5hbWUpID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBub2Rlc1tpXS5hdHRyKG5hbWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZXR0aW5ncy5yZW1vdmVfdHJhaWxpbmdfYnJzKSB7XG4gICAgICAgIGFkZE5vZGVGaWx0ZXIoc2V0dGluZ3MsIGh0bWxQYXJzZXIsIGh0bWxQYXJzZXIuc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRyaW1UcmFpbGluZ0JyID0gcm9vdE5vZGUgPT4ge1xuICAgICAgY29uc3QgaXNCciA9IG5vZGUgPT4ge1xuICAgICAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5uYW1lKSA9PT0gJ2JyJztcbiAgICAgIH07XG4gICAgICBjb25zdCBick5vZGUxID0gcm9vdE5vZGUubGFzdENoaWxkO1xuICAgICAgaWYgKGlzQnIoYnJOb2RlMSkpIHtcbiAgICAgICAgY29uc3QgYnJOb2RlMiA9IGJyTm9kZTEucHJldjtcbiAgICAgICAgaWYgKGlzQnIoYnJOb2RlMikpIHtcbiAgICAgICAgICBick5vZGUxLnJlbW92ZSgpO1xuICAgICAgICAgIGJyTm9kZTIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcHJlUHJvY2VzcyQxID0gKGVkaXRvciwgbm9kZSwgYXJncykgPT4ge1xuICAgICAgbGV0IG9sZERvYztcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBsZXQgY2xvbmVkTm9kZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgY29uc3QgaW1wbCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICAgICAgaWYgKGltcGwuY3JlYXRlSFRNTERvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGRvYyA9IGltcGwuY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgICAgICAgVG9vbHMuZWFjaChjbG9uZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScgPyBjbG9uZWROb2RlLmNoaWxkTm9kZXMgOiBbY2xvbmVkTm9kZV0sIG5vZGUgPT4ge1xuICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGRvYy5pbXBvcnROb2RlKG5vZGUsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbG9uZWROb2RlLm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICBjbG9uZWROb2RlID0gZG9jLmJvZHkuZmlyc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9uZWROb2RlID0gZG9jLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgb2xkRG9jID0gZG9tLmRvYztcbiAgICAgICAgZG9tLmRvYyA9IGRvYztcbiAgICAgIH1cbiAgICAgIGZpcmVQcmVQcm9jZXNzKGVkaXRvciwge1xuICAgICAgICAuLi5hcmdzLFxuICAgICAgICBub2RlOiBjbG9uZWROb2RlXG4gICAgICB9KTtcbiAgICAgIGlmIChvbGREb2MpIHtcbiAgICAgICAgZG9tLmRvYyA9IG9sZERvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWROb2RlO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkRmlyZUV2ZW50ID0gKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUoZWRpdG9yKSAmJiBlZGl0b3IuaGFzRXZlbnRMaXN0ZW5lcnMoJ1ByZVByb2Nlc3MnKSAmJiAhYXJncy5ub19ldmVudHM7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzJDEgPSAoZWRpdG9yLCBub2RlLCBhcmdzKSA9PiB7XG4gICAgICByZXR1cm4gc2hvdWxkRmlyZUV2ZW50KGVkaXRvciwgYXJncykgPyBwcmVQcm9jZXNzJDEoZWRpdG9yLCBub2RlLCBhcmdzKSA6IG5vZGU7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFRlbXBBdHRyID0gKGh0bWxQYXJzZXIsIHRlbXBBdHRycywgbmFtZSkgPT4ge1xuICAgICAgaWYgKFRvb2xzLmluQXJyYXkodGVtcEF0dHJzLCBuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgaHRtbFBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIobmFtZSwgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgbm9kZXNbaV0uYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wQXR0cnMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzID0gKGVkaXRvciwgYXJncywgY29udGVudCkgPT4ge1xuICAgICAgaWYgKCFhcmdzLm5vX2V2ZW50cyAmJiBlZGl0b3IpIHtcbiAgICAgICAgY29uc3Qgb3V0QXJncyA9IGZpcmVQb3N0UHJvY2VzcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRBcmdzLmNvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEh0bWxGcm9tTm9kZSA9IChkb20sIG5vZGUsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGh0bWwgPSB0cmltJDEoYXJncy5nZXRJbm5lciA/IG5vZGUuaW5uZXJIVE1MIDogZG9tLmdldE91dGVySFRNTChub2RlKSk7XG4gICAgICByZXR1cm4gYXJncy5zZWxlY3Rpb24gfHwgaXNXc1ByZXNlcnZlRWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSkgPyBodG1sIDogVG9vbHMudHJpbShodG1sKTtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlSHRtbCA9IChodG1sUGFyc2VyLCBodG1sLCBhcmdzKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZXJBcmdzID0gYXJncy5zZWxlY3Rpb24gPyB7XG4gICAgICAgIGZvcmNlZF9yb290X2Jsb2NrOiBmYWxzZSxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgfSA6IGFyZ3M7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGh0bWxQYXJzZXIucGFyc2UoaHRtbCwgcGFyc2VyQXJncyk7XG4gICAgICB0cmltVHJhaWxpbmdCcihyb290Tm9kZSk7XG4gICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBzZXJpYWxpemVOb2RlID0gKHNldHRpbmdzLCBzY2hlbWEsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGh0bWxTZXJpYWxpemVyID0gSHRtbFNlcmlhbGl6ZXIoc2V0dGluZ3MsIHNjaGVtYSk7XG4gICAgICByZXR1cm4gaHRtbFNlcmlhbGl6ZXIuc2VyaWFsaXplKG5vZGUpO1xuICAgIH07XG4gICAgY29uc3QgdG9IdG1sID0gKGVkaXRvciwgc2V0dGluZ3MsIHNjaGVtYSwgcm9vdE5vZGUsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzZXJpYWxpemVOb2RlKHNldHRpbmdzLCBzY2hlbWEsIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhlZGl0b3IsIGFyZ3MsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgY29uc3QgRG9tU2VyaWFsaXplckltcGwgPSAoc2V0dGluZ3MsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgdGVtcEF0dHJzID0gWydkYXRhLW1jZS1zZWxlY3RlZCddO1xuICAgICAgY29uc3QgZGVmYXVsdGVkU2V0dGluZ3MgPSB7XG4gICAgICAgIGVudGl0eV9lbmNvZGluZzogJ25hbWVkJyxcbiAgICAgICAgcmVtb3ZlX3RyYWlsaW5nX2JyczogdHJ1ZSxcbiAgICAgICAgcGFkX2VtcHR5X3dpdGhfYnI6IGZhbHNlLFxuICAgICAgICAuLi5zZXR0aW5nc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvciAmJiBlZGl0b3IuZG9tID8gZWRpdG9yLmRvbSA6IERPTVV0aWxzLkRPTTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvciAmJiBlZGl0b3Iuc2NoZW1hID8gZWRpdG9yLnNjaGVtYSA6IFNjaGVtYShkZWZhdWx0ZWRTZXR0aW5ncyk7XG4gICAgICBjb25zdCBodG1sUGFyc2VyID0gRG9tUGFyc2VyKGRlZmF1bHRlZFNldHRpbmdzLCBzY2hlbWEpO1xuICAgICAgcmVnaXN0ZXIkMyhodG1sUGFyc2VyLCBkZWZhdWx0ZWRTZXR0aW5ncywgZG9tKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IChub2RlLCBwYXJzZXJBcmdzID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICBmb3JtYXQ6ICdodG1sJyxcbiAgICAgICAgICAuLi5wYXJzZXJBcmdzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBwcm9jZXNzJDEoZWRpdG9yLCBub2RlLCBhcmdzKTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGdldEh0bWxGcm9tTm9kZShkb20sIHRhcmdldE5vZGUsIGFyZ3MpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IHBhcnNlSHRtbChodG1sUGFyc2VyLCBodG1sLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3MuZm9ybWF0ID09PSAndHJlZScgPyByb290Tm9kZSA6IHRvSHRtbChlZGl0b3IsIGRlZmF1bHRlZFNldHRpbmdzLCBzY2hlbWEsIHJvb3ROb2RlLCBhcmdzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGFkZE5vZGVGaWx0ZXI6IGh0bWxQYXJzZXIuYWRkTm9kZUZpbHRlcixcbiAgICAgICAgYWRkQXR0cmlidXRlRmlsdGVyOiBodG1sUGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcixcbiAgICAgICAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgIGFkZFJ1bGVzOiBzY2hlbWEuYWRkVmFsaWRFbGVtZW50cyxcbiAgICAgICAgc2V0UnVsZXM6IHNjaGVtYS5zZXRWYWxpZEVsZW1lbnRzLFxuICAgICAgICBhZGRUZW1wQXR0cjogY3VycnkoYWRkVGVtcEF0dHIsIGh0bWxQYXJzZXIsIHRlbXBBdHRycyksXG4gICAgICAgIGdldFRlbXBBdHRyczogY29uc3RhbnQodGVtcEF0dHJzKSxcbiAgICAgICAgZ2V0Tm9kZUZpbHRlcnM6IGh0bWxQYXJzZXIuZ2V0Tm9kZUZpbHRlcnMsXG4gICAgICAgIGdldEF0dHJpYnV0ZUZpbHRlcnM6IGh0bWxQYXJzZXIuZ2V0QXR0cmlidXRlRmlsdGVycyxcbiAgICAgICAgcmVtb3ZlTm9kZUZpbHRlcjogaHRtbFBhcnNlci5yZW1vdmVOb2RlRmlsdGVyLFxuICAgICAgICByZW1vdmVBdHRyaWJ1dGVGaWx0ZXI6IGh0bWxQYXJzZXIucmVtb3ZlQXR0cmlidXRlRmlsdGVyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBEb21TZXJpYWxpemVyID0gKHNldHRpbmdzLCBlZGl0b3IpID0+IHtcbiAgICAgIGNvbnN0IGRvbVNlcmlhbGl6ZXIgPSBEb21TZXJpYWxpemVySW1wbChzZXR0aW5ncywgZWRpdG9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtYTogZG9tU2VyaWFsaXplci5zY2hlbWEsXG4gICAgICAgIGFkZE5vZGVGaWx0ZXI6IGRvbVNlcmlhbGl6ZXIuYWRkTm9kZUZpbHRlcixcbiAgICAgICAgYWRkQXR0cmlidXRlRmlsdGVyOiBkb21TZXJpYWxpemVyLmFkZEF0dHJpYnV0ZUZpbHRlcixcbiAgICAgICAgc2VyaWFsaXplOiBkb21TZXJpYWxpemVyLnNlcmlhbGl6ZSxcbiAgICAgICAgYWRkUnVsZXM6IGRvbVNlcmlhbGl6ZXIuYWRkUnVsZXMsXG4gICAgICAgIHNldFJ1bGVzOiBkb21TZXJpYWxpemVyLnNldFJ1bGVzLFxuICAgICAgICBhZGRUZW1wQXR0cjogZG9tU2VyaWFsaXplci5hZGRUZW1wQXR0cixcbiAgICAgICAgZ2V0VGVtcEF0dHJzOiBkb21TZXJpYWxpemVyLmdldFRlbXBBdHRycyxcbiAgICAgICAgZ2V0Tm9kZUZpbHRlcnM6IGRvbVNlcmlhbGl6ZXIuZ2V0Tm9kZUZpbHRlcnMsXG4gICAgICAgIGdldEF0dHJpYnV0ZUZpbHRlcnM6IGRvbVNlcmlhbGl6ZXIuZ2V0QXR0cmlidXRlRmlsdGVycyxcbiAgICAgICAgcmVtb3ZlTm9kZUZpbHRlcjogZG9tU2VyaWFsaXplci5yZW1vdmVOb2RlRmlsdGVyLFxuICAgICAgICByZW1vdmVBdHRyaWJ1dGVGaWx0ZXI6IGRvbVNlcmlhbGl6ZXIucmVtb3ZlQXR0cmlidXRlRmlsdGVyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBkZWZhdWx0Rm9ybWF0JDEgPSAnaHRtbCc7XG4gICAgY29uc3Qgc2V0dXBBcmdzJDEgPSAoYXJncywgZm9ybWF0KSA9PiAoe1xuICAgICAgLi4uYXJncyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGdldDogdHJ1ZSxcbiAgICAgIGdldElubmVyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudCA9IChlZGl0b3IsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPyBhcmdzLmZvcm1hdCA6IGRlZmF1bHRGb3JtYXQkMTtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZEFyZ3MgPSBzZXR1cEFyZ3MkMShhcmdzLCBmb3JtYXQpO1xuICAgICAgcmV0dXJuIHByZVByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgZGVmYXVsdGVkQXJncykuZm9sZChpZGVudGl0eSwgdXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudCQyKGVkaXRvciwgdXBkYXRlZEFyZ3MpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NHZXRDb250ZW50KGVkaXRvciwgY29udGVudCwgdXBkYXRlZEFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRGb3JtYXQgPSAnaHRtbCc7XG4gICAgY29uc3Qgc2V0dXBBcmdzID0gKGFyZ3MsIGNvbnRlbnQpID0+ICh7XG4gICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgICAuLi5hcmdzLFxuICAgICAgc2V0OiB0cnVlLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGNvbnN0IHNldENvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBhcmdzID0ge30pID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRlZEFyZ3MgPSBzZXR1cEFyZ3MoYXJncywgY29udGVudCk7XG4gICAgICByZXR1cm4gcHJlUHJvY2Vzc1NldENvbnRlbnQoZWRpdG9yLCBkZWZhdWx0ZWRBcmdzKS5tYXAodXBkYXRlZEFyZ3MgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXRDb250ZW50JDIoZWRpdG9yLCB1cGRhdGVkQXJncy5jb250ZW50LCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHBvc3RQcm9jZXNzU2V0Q29udGVudChlZGl0b3IsIHJlc3VsdC5odG1sLCB1cGRhdGVkQXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICAgIH0pLmdldE9yKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVkT3B0aW9ucyA9ICgnYXV0b3Jlc2l6ZV9vbl9pbml0LGNvbnRlbnRfZWRpdGFibGVfc3RhdGUscGFkZF9lbXB0eV93aXRoX2JyLGJsb2NrX2VsZW1lbnRzLCcgKyAnYm9vbGVhbl9hdHRyaWJ1dGVzLGVkaXRvcl9kZXNlbGVjdG9yLGVkaXRvcl9zZWxlY3RvcixlbGVtZW50cyxmaWxlX2Jyb3dzZXJfY2FsbGJhY2tfdHlwZXMsZmlsZXBpY2tlcl92YWxpZGF0b3JfaGFuZGxlciwnICsgJ2ZvcmNlX2hleF9zdHlsZV9jb2xvcnMsZm9yY2VfcF9uZXdsaW5lcyxnZWNrb19zcGVsbGNoZWNrLGltYWdlc19kYXRhaW1nX2ZpbHRlcixtZWRpYV9zY3JpcHRzLG1vZGUsbW92ZV9jYXJldF9iZWZvcmVfb25fZW50ZXJfZWxlbWVudHMsJyArICdub25fZW1wdHlfZWxlbWVudHMsc2VsZl9jbG9zaW5nX2VsZW1lbnRzLHNob3J0X2VuZGVkX2VsZW1lbnRzLHNwZWNpYWwsc3BlbGxjaGVja2VyX3NlbGVjdF9sYW5ndWFnZXMsc3BlbGxjaGVja2VyX3doaXRlbGlzdCwnICsgJ3RhYl9mb2N1cyx0YWJmb2N1c19lbGVtZW50cyx0YWJsZV9yZXNwb25zaXZlX3dpZHRoLHRleHRfYmxvY2tfZWxlbWVudHMsdGV4dF9pbmxpbmVfZWxlbWVudHMsdG9vbGJhcl9kcmF3ZXIsdHlwZXMsdmFsaWRhdGUsd2hpdGVzcGFjZV9lbGVtZW50cywnICsgJ3Bhc3RlX2VuYWJsZV9kZWZhdWx0X2ZpbHRlcnMscGFzdGVfZmlsdGVyX2Ryb3AscGFzdGVfd29yZF92YWxpZF9lbGVtZW50cyxwYXN0ZV9yZXRhaW5fc3R5bGVfcHJvcGVydGllcyxwYXN0ZV9jb252ZXJ0X3dvcmRfZmFrZV9saXN0cycpLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSAndGVtcGxhdGVfY2RhdGVfY2xhc3Nlcyx0ZW1wbGF0ZV9tZGF0ZV9jbGFzc2VzLHRlbXBsYXRlX3NlbGVjdGVkX2NvbnRlbnRfY2xhc3Nlcyx0ZW1wbGF0ZV9wcmV2aWV3X3JlcGxhY2VfdmFsdWVzLHRlbXBsYXRlX3JlcGxhY2VfdmFsdWVzLHRlbXBsYXRlcyx0ZW1wbGF0ZV9jZGF0ZV9mb3JtYXQsdGVtcGxhdGVfbWRhdGVfZm9ybWF0Jy5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IHJlbW92ZWRQbHVnaW5zID0gJ2JiY29kZSxjb2xvcnBpY2tlcixjb250ZXh0bWVudSxmdWxscGFnZSxsZWdhY3lvdXRwdXQsc3BlbGxjaGVja2VyLHRleHRjb2xvcicuc3BsaXQoJywnKTtcbiAgICBjb25zdCBkZXByZWNhdGVkUGx1Z2lucyA9IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RlbXBsYXRlJyxcbiAgICAgICAgcmVwbGFjZWRXaXRoOiAnQWR2YW5jZWQgVGVtcGxhdGUnXG4gICAgICB9LFxuICAgICAgeyBuYW1lOiAncnRjJyB9XG4gICAgXTtcbiAgICBjb25zdCBnZXRNYXRjaGluZ09wdGlvbnMgPSAob3B0aW9ucywgc2VhcmNoaW5nRm9yKSA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nTmFtZXMgPSBmaWx0ZXIkNShzZWFyY2hpbmdGb3IsIHNldHRpbmcgPT4gaGFzJDIob3B0aW9ucywgc2V0dGluZykpO1xuICAgICAgcmV0dXJuIHNvcnQoc2V0dGluZ05hbWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFJlbW92ZWRPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBzZXR0aW5nTmFtZXMgPSBnZXRNYXRjaGluZ09wdGlvbnMob3B0aW9ucywgcmVtb3ZlZE9wdGlvbnMpO1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gb3B0aW9ucy5mb3JjZWRfcm9vdF9ibG9jaztcbiAgICAgIGlmIChmb3JjZWRSb290QmxvY2sgPT09IGZhbHNlIHx8IGZvcmNlZFJvb3RCbG9jayA9PT0gJycpIHtcbiAgICAgICAgc2V0dGluZ05hbWVzLnB1c2goJ2ZvcmNlZF9yb290X2Jsb2NrIChmYWxzZSBvbmx5KScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnQoc2V0dGluZ05hbWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldERlcHJlY2F0ZWRPcHRpb25zID0gb3B0aW9ucyA9PiBnZXRNYXRjaGluZ09wdGlvbnMob3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGdldE1hdGNoaW5nUGx1Z2lucyA9IChvcHRpb25zLCBzZWFyY2hpbmdGb3IpID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpbnMgPSBUb29scy5tYWtlTWFwKG9wdGlvbnMucGx1Z2lucywgJyAnKTtcbiAgICAgIGNvbnN0IGhhc1BsdWdpbiA9IHBsdWdpbiA9PiBoYXMkMihwbHVnaW5zLCBwbHVnaW4pO1xuICAgICAgY29uc3QgcGx1Z2luTmFtZXMgPSBmaWx0ZXIkNShzZWFyY2hpbmdGb3IsIGhhc1BsdWdpbik7XG4gICAgICByZXR1cm4gc29ydChwbHVnaW5OYW1lcyk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSZW1vdmVkUGx1Z2lucyA9IG9wdGlvbnMgPT4gZ2V0TWF0Y2hpbmdQbHVnaW5zKG9wdGlvbnMsIHJlbW92ZWRQbHVnaW5zKTtcbiAgICBjb25zdCBnZXREZXByZWNhdGVkUGx1Z2lucyA9IG9wdGlvbnMgPT4gZ2V0TWF0Y2hpbmdQbHVnaW5zKG9wdGlvbnMsIGRlcHJlY2F0ZWRQbHVnaW5zLm1hcChlbnRyeSA9PiBlbnRyeS5uYW1lKSk7XG4gICAgY29uc3QgbG9nUmVtb3ZlZFdhcm5pbmdzID0gKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZW1vdmVkT3B0aW9ucyA9IGdldFJlbW92ZWRPcHRpb25zKHJhd09wdGlvbnMpO1xuICAgICAgY29uc3QgcmVtb3ZlZFBsdWdpbnMgPSBnZXRSZW1vdmVkUGx1Z2lucyhub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICBjb25zdCBoYXNSZW1vdmVkUGx1Z2lucyA9IHJlbW92ZWRQbHVnaW5zLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBoYXNSZW1vdmVkT3B0aW9ucyA9IHJlbW92ZWRPcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBpc0xlZ2FjeU1vYmlsZVRoZW1lID0gbm9ybWFsaXplZE9wdGlvbnMudGhlbWUgPT09ICdtb2JpbGUnO1xuICAgICAgaWYgKGhhc1JlbW92ZWRQbHVnaW5zIHx8IGhhc1JlbW92ZWRPcHRpb25zIHx8IGlzTGVnYWN5TW9iaWxlVGhlbWUpIHtcbiAgICAgICAgY29uc3QgbGlzdEpvaW5lciA9ICdcXG4tICc7XG4gICAgICAgIGNvbnN0IHRoZW1lc01lc3NhZ2UgPSBpc0xlZ2FjeU1vYmlsZVRoZW1lID8gYFxcblxcblRoZW1lczokeyBsaXN0Sm9pbmVyIH1tb2JpbGVgIDogJyc7XG4gICAgICAgIGNvbnN0IHBsdWdpbnNNZXNzYWdlID0gaGFzUmVtb3ZlZFBsdWdpbnMgPyBgXFxuXFxuUGx1Z2luczokeyBsaXN0Sm9pbmVyIH0keyByZW1vdmVkUGx1Z2lucy5qb2luKGxpc3RKb2luZXIpIH1gIDogJyc7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNNZXNzYWdlID0gaGFzUmVtb3ZlZE9wdGlvbnMgPyBgXFxuXFxuT3B0aW9uczokeyBsaXN0Sm9pbmVyIH0keyByZW1vdmVkT3B0aW9ucy5qb2luKGxpc3RKb2luZXIpIH1gIDogJyc7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGZvbGxvd2luZyBkZXByZWNhdGVkIGZlYXR1cmVzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBhbmQgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVGlueU1DRSA2LjAuIFRoZXNlIGZlYXR1cmVzIHdpbGwgbm8gbG9uZ2VyIHdvcmsgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIFRpbnlNQ0UgY29uZmlndXJhdGlvbi4gJyArICdTZWUgaHR0cHM6Ly93d3cudGlueS5jbG91ZC9kb2NzL3RpbnltY2UvNi9taWdyYXRpb24tZnJvbS01eC8gZm9yIG1vcmUgaW5mb3JtYXRpb24uJyArIHRoZW1lc01lc3NhZ2UgKyBwbHVnaW5zTWVzc2FnZSArIG9wdGlvbnNNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFBsdWdpbkRlc2NyaXB0aW9uID0gbmFtZSA9PiBmaW5kJDIoZGVwcmVjYXRlZFBsdWdpbnMsIGVudHJ5ID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpLmZvbGQoKCkgPT4gbmFtZSwgZW50cnkgPT4ge1xuICAgICAgaWYgKGVudHJ5LnJlcGxhY2VkV2l0aCkge1xuICAgICAgICByZXR1cm4gYCR7IG5hbWUgfSwgcmVwbGFjZWQgYnkgJHsgZW50cnkucmVwbGFjZWRXaXRoIH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbG9nRGVwcmVjYXRlZFdhcm5pbmdzID0gKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IGdldERlcHJlY2F0ZWRPcHRpb25zKHJhd09wdGlvbnMpO1xuICAgICAgY29uc3QgZGVwcmVjYXRlZFBsdWdpbnMgPSBnZXREZXByZWNhdGVkUGx1Z2lucyhub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICBjb25zdCBoYXNEZXByZWNhdGVkUGx1Z2lucyA9IGRlcHJlY2F0ZWRQbHVnaW5zLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBoYXNEZXByZWNhdGVkT3B0aW9ucyA9IGRlcHJlY2F0ZWRPcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoaGFzRGVwcmVjYXRlZFBsdWdpbnMgfHwgaGFzRGVwcmVjYXRlZE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGlzdEpvaW5lciA9ICdcXG4tICc7XG4gICAgICAgIGNvbnN0IHBsdWdpbnNNZXNzYWdlID0gaGFzRGVwcmVjYXRlZFBsdWdpbnMgPyBgXFxuXFxuUGx1Z2luczokeyBsaXN0Sm9pbmVyIH0keyBkZXByZWNhdGVkUGx1Z2lucy5tYXAoZ2V0UGx1Z2luRGVzY3JpcHRpb24pLmpvaW4obGlzdEpvaW5lcikgfWAgOiAnJztcbiAgICAgICAgY29uc3Qgb3B0aW9uc01lc3NhZ2UgPSBoYXNEZXByZWNhdGVkT3B0aW9ucyA/IGBcXG5cXG5PcHRpb25zOiR7IGxpc3RKb2luZXIgfSR7IGRlcHJlY2F0ZWRPcHRpb25zLmpvaW4obGlzdEpvaW5lcikgfWAgOiAnJztcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZm9sbG93aW5nIGRlcHJlY2F0ZWQgZmVhdHVyZXMgYXJlIGN1cnJlbnRseSBlbmFibGVkIGJ1dCB3aWxsIGJlIHJlbW92ZWQgc29vbi4nICsgcGx1Z2luc01lc3NhZ2UgKyBvcHRpb25zTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2dXYXJuaW5ncyA9IChyYXdPcHRpb25zLCBub3JtYWxpemVkT3B0aW9ucykgPT4ge1xuICAgICAgbG9nUmVtb3ZlZFdhcm5pbmdzKHJhd09wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgIGxvZ0RlcHJlY2F0ZWRXYXJuaW5ncyhyYXdPcHRpb25zLCBub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQ4ID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IHJlc3RvcmVPcmlnaW5hbFN0eWxlcyA9IGVkaXRvciA9PiB7XG4gICAgICBET00kOC5zZXRTdHlsZShlZGl0b3IuaWQsICdkaXNwbGF5JywgZWRpdG9yLm9yZ0Rpc3BsYXkpO1xuICAgIH07XG4gICAgY29uc3Qgc2FmZURlc3Ryb3kgPSB4ID0+IE9wdGlvbmFsLmZyb20oeCkuZWFjaCh4ID0+IHguZGVzdHJveSgpKTtcbiAgICBjb25zdCBjbGVhckRvbVJlZmVyZW5jZXMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWQgPSBlZGl0b3I7XG4gICAgICBlZC5jb250ZW50QXJlYUNvbnRhaW5lciA9IGVkLmZvcm1FbGVtZW50ID0gZWQuY29udGFpbmVyID0gZWQuZWRpdG9yQ29udGFpbmVyID0gbnVsbDtcbiAgICAgIGVkLmJvZHlFbGVtZW50ID0gZWQuY29udGVudERvY3VtZW50ID0gZWQuY29udGVudFdpbmRvdyA9IG51bGw7XG4gICAgICBlZC5pZnJhbWVFbGVtZW50ID0gZWQudGFyZ2V0RWxtID0gbnVsbDtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRvbSA9IHNlbGVjdGlvbi5kb207XG4gICAgICAgIGVkLnNlbGVjdGlvbiA9IHNlbGVjdGlvbi53aW4gPSBzZWxlY3Rpb24uZG9tID0gZG9tLmRvYyA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXN0b3JlRm9ybSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBmb3JtID0gZWRpdG9yLmZvcm1FbGVtZW50O1xuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgaWYgKGZvcm0uX21jZU9sZFN1Ym1pdCkge1xuICAgICAgICAgIGZvcm0uc3VibWl0ID0gZm9ybS5fbWNlT2xkU3VibWl0O1xuICAgICAgICAgIGRlbGV0ZSBmb3JtLl9tY2VPbGRTdWJtaXQ7XG4gICAgICAgIH1cbiAgICAgICAgRE9NJDgudW5iaW5kKGZvcm0sICdzdWJtaXQgcmVzZXQnLCBlZGl0b3IuZm9ybUV2ZW50RGVsZWdhdGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICBjb25zdCB7X3NlbGVjdGlvbk92ZXJyaWRlcywgZWRpdG9yVXBsb2FkfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgIGVkaXRvci5zYXZlKHsgaXNfcmVtb3Zpbmc6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBlZGl0b3IudW5iaW5kQWxsTmF0aXZlRXZlbnRzKCk7XG4gICAgICAgIGlmIChlZGl0b3IuaGFzSGlkZGVuSW5wdXQgJiYgaXNOb25OdWxsYWJsZShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgRE9NJDgucmVtb3ZlKGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZpcmVSZW1vdmUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIucmVtb3ZlKGVkaXRvcik7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSAmJiBib2R5KSB7XG4gICAgICAgICAgcmVzdG9yZU9yaWdpbmFsU3R5bGVzKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmlyZURldGFjaChlZGl0b3IpO1xuICAgICAgICBET00kOC5yZW1vdmUoZWRpdG9yLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgc2FmZURlc3Ryb3koX3NlbGVjdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHNhZmVEZXN0cm95KGVkaXRvclVwbG9hZCk7XG4gICAgICAgIGVkaXRvci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZXN0cm95ID0gKGVkaXRvciwgYXV0b21hdGljKSA9PiB7XG4gICAgICBjb25zdCB7c2VsZWN0aW9uLCBkb219ID0gZWRpdG9yO1xuICAgICAgaWYgKGVkaXRvci5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhdXRvbWF0aWMgJiYgIWVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhdXRvbWF0aWMpIHtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIub2ZmKCdiZWZvcmV1bmxvYWQnLCBlZGl0b3IuX2JlZm9yZVVubG9hZCk7XG4gICAgICAgIGlmIChlZGl0b3IudGhlbWUgJiYgZWRpdG9yLnRoZW1lLmRlc3Ryb3kpIHtcbiAgICAgICAgICBlZGl0b3IudGhlbWUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVEZXN0cm95KHNlbGVjdGlvbik7XG4gICAgICAgIHNhZmVEZXN0cm95KGRvbSk7XG4gICAgICB9XG4gICAgICByZXN0b3JlRm9ybShlZGl0b3IpO1xuICAgICAgY2xlYXJEb21SZWZlcmVuY2VzKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgQ3JlYXRlSWNvbk1hbmFnZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsb29rdXAgPSB7fTtcbiAgICAgIGNvbnN0IGFkZCA9IChpZCwgaWNvblBhY2spID0+IHtcbiAgICAgICAgbG9va3VwW2lkXSA9IGljb25QYWNrO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldCA9IGlkID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFtpZF0pIHtcbiAgICAgICAgICByZXR1cm4gbG9va3VwW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBpY29uczoge30gfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhcyA9IGlkID0+IGhhcyQyKGxvb2t1cCwgaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkLFxuICAgICAgICBnZXQsXG4gICAgICAgIGhhc1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEljb25NYW5hZ2VyID0gQ3JlYXRlSWNvbk1hbmFnZXIoKTtcblxuICAgIGNvbnN0IE1vZGVsTWFuYWdlciA9IEFkZE9uTWFuYWdlci5Nb2RlbE1hbmFnZXI7XG5cbiAgICBjb25zdCBnZXRQcm9wID0gKHByb3BOYW1lLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IHJhd0VsbSA9IGVsbS5kb207XG4gICAgICByZXR1cm4gcmF3RWxtW3Byb3BOYW1lXTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENvbXB1dGVkU2l6ZVByb3AgPSAocHJvcE5hbWUsIGVsbSkgPT4gcGFyc2VJbnQoZ2V0JDcoZWxtLCBwcm9wTmFtZSksIDEwKTtcbiAgICBjb25zdCBnZXRDbGllbnRXaWR0aCA9IGN1cnJ5KGdldFByb3AsICdjbGllbnRXaWR0aCcpO1xuICAgIGNvbnN0IGdldENsaWVudEhlaWdodCA9IGN1cnJ5KGdldFByb3AsICdjbGllbnRIZWlnaHQnKTtcbiAgICBjb25zdCBnZXRNYXJnaW5Ub3AgPSBjdXJyeShnZXRDb21wdXRlZFNpemVQcm9wLCAnbWFyZ2luLXRvcCcpO1xuICAgIGNvbnN0IGdldE1hcmdpbkxlZnQgPSBjdXJyeShnZXRDb21wdXRlZFNpemVQcm9wLCAnbWFyZ2luLWxlZnQnKTtcbiAgICBjb25zdCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBlbG0gPT4gZWxtLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc0luc2lkZUVsZW1lbnRDb250ZW50QXJlYSA9IChib2R5RWxtLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRXaWR0aCA9IGdldENsaWVudFdpZHRoKGJvZHlFbG0pO1xuICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gZ2V0Q2xpZW50SGVpZ2h0KGJvZHlFbG0pO1xuICAgICAgcmV0dXJuIGNsaWVudFggPj0gMCAmJiBjbGllbnRZID49IDAgJiYgY2xpZW50WCA8PSBjbGllbnRXaWR0aCAmJiBjbGllbnRZIDw9IGNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zcG9zZSA9IChpbmxpbmUsIGVsbSwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbG0pO1xuICAgICAgY29uc3QgZGVsdGFYID0gaW5saW5lID8gY2xpZW50UmVjdC5sZWZ0ICsgZWxtLmRvbS5jbGllbnRMZWZ0ICsgZ2V0TWFyZ2luTGVmdChlbG0pIDogMDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IGlubGluZSA/IGNsaWVudFJlY3QudG9wICsgZWxtLmRvbS5jbGllbnRUb3AgKyBnZXRNYXJnaW5Ub3AoZWxtKSA6IDA7XG4gICAgICBjb25zdCB4ID0gY2xpZW50WCAtIGRlbHRhWDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gZGVsdGFZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGlzWFlJbkNvbnRlbnRBcmVhID0gKGVkaXRvciwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgY29uc3QgYm9keUVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgdGFyZ2V0RWxtID0gZWRpdG9yLmlubGluZSA/IGJvZHlFbG0gOiBkb2N1bWVudEVsZW1lbnQoYm9keUVsbSk7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkUG9pbnQgPSB0cmFuc3Bvc2UoZWRpdG9yLmlubGluZSwgdGFyZ2V0RWxtLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgIHJldHVybiBpc0luc2lkZUVsZW1lbnRDb250ZW50QXJlYSh0YXJnZXRFbG0sIHRyYW5zcG9zZWRQb2ludC54LCB0cmFuc3Bvc2VkUG9pbnQueSk7XG4gICAgfTtcbiAgICBjb25zdCBmcm9tRG9tU2FmZSA9IG5vZGUgPT4gT3B0aW9uYWwuZnJvbShub2RlKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xuICAgIGNvbnN0IGlzRWRpdG9yQXR0YWNoZWRUb0RvbSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCByYXdDb250YWluZXIgPSBlZGl0b3IuaW5saW5lID8gZWRpdG9yLmdldEJvZHkoKSA6IGVkaXRvci5nZXRDb250ZW50QXJlYUNvbnRhaW5lcigpO1xuICAgICAgcmV0dXJuIGZyb21Eb21TYWZlKHJhd0NvbnRhaW5lcikubWFwKGluQm9keSkuZ2V0T3IoZmFsc2UpO1xuICAgIH07XG5cbiAgICB2YXIgTm90aWZpY2F0aW9uTWFuYWdlckltcGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZW1lIGRpZCBub3QgcHJvdmlkZSBhIE5vdGlmaWNhdGlvbk1hbmFnZXIgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbjogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgY2xvc2U6IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGdldEFyZ3M6IHVuaW1wbGVtZW50ZWRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IE5vdGlmaWNhdGlvbk1hbmFnZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IFtdO1xuICAgICAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gZWRpdG9yLnRoZW1lO1xuICAgICAgICByZXR1cm4gdGhlbWUgJiYgdGhlbWUuZ2V0Tm90aWZpY2F0aW9uTWFuYWdlckltcGwgPyB0aGVtZS5nZXROb3RpZmljYXRpb25NYW5hZ2VySW1wbCgpIDogTm90aWZpY2F0aW9uTWFuYWdlckltcGwoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRUb3BOb3RpZmljYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5vdGlmaWNhdGlvbnNbMF0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRXF1YWwgPSAoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS50eXBlID09PSBiLnR5cGUgJiYgYS50ZXh0ID09PSBiLnRleHQgJiYgIWEucHJvZ3Jlc3NCYXIgJiYgIWEudGltZW91dCAmJiAhYi5wcm9ncmVzc0JhciAmJiAhYi50aW1lb3V0O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGVhY2gkZShub3RpZmljYXRpb25zLCBub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbi5yZXBvc2l0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZE5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb24pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsb3NlTm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uID0+IHtcbiAgICAgICAgZmluZEluZGV4JDIobm90aWZpY2F0aW9ucywgb3RoZXJOb3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIHJldHVybiBvdGhlck5vdGlmaWNhdGlvbiA9PT0gbm90aWZpY2F0aW9uO1xuICAgICAgICB9KS5lYWNoKGluZGV4ID0+IHtcbiAgICAgICAgICBub3RpZmljYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wZW4gPSAoc3BlYywgZmlyZUV2ZW50ID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLnJlbW92ZWQgfHwgIWlzRWRpdG9yQXR0YWNoZWRUb0RvbShlZGl0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJlRXZlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZU9wZW5Ob3RpZmljYXRpb24nLCB7IG5vdGlmaWNhdGlvbjogc3BlYyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZCQyKG5vdGlmaWNhdGlvbnMsIG5vdGlmaWNhdGlvbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzRXF1YWwoZ2V0SW1wbGVtZW50YXRpb24oKS5nZXRBcmdzKG5vdGlmaWNhdGlvbiksIHNwZWMpO1xuICAgICAgICB9KS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZWRpdG9yTWFuYWdlci5zZXRBY3RpdmUoZWRpdG9yKTtcbiAgICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBnZXRJbXBsZW1lbnRhdGlvbigpLm9wZW4oc3BlYywgKCkgPT4ge1xuICAgICAgICAgICAgY2xvc2VOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgICAgIGdldFRvcE5vdGlmaWNhdGlvbigpLmZvbGQoKCkgPT4gZWRpdG9yLmZvY3VzKCksIHRvcCA9PiBmb2N1cyQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRvcC5nZXRFbCgpKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ09wZW5Ob3RpZmljYXRpb24nLCB7IG5vdGlmaWNhdGlvbjogeyAuLi5ub3RpZmljYXRpb24gfSB9KTtcbiAgICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgZ2V0VG9wTm90aWZpY2F0aW9uKCkuZWFjaChub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgIGdldEltcGxlbWVudGF0aW9uKCkuY2xvc2Uobm90aWZpY2F0aW9uKTtcbiAgICAgICAgICBjbG9zZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICAgICAgICAgIHJlcG9zaXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Tm90aWZpY2F0aW9ucyA9IGNvbnN0YW50KG5vdGlmaWNhdGlvbnMpO1xuICAgICAgY29uc3QgcmVnaXN0ZXJFdmVudHMgPSBlZGl0b3IgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ1NraW5Mb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VydmljZU1lc3NhZ2UgPSBnZXRTZXJ2aWNlTWVzc2FnZShlZGl0b3IpO1xuICAgICAgICAgIGlmIChzZXJ2aWNlTWVzc2FnZSkge1xuICAgICAgICAgICAgb3Blbih7XG4gICAgICAgICAgICAgIHRleHQ6IHNlcnZpY2VNZXNzYWdlLFxuICAgICAgICAgICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLm9uKCdzaG93IFJlc2l6ZUVkaXRvciBSZXNpemVXaW5kb3cgTm9kZUNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgICBlYWNoJGUobm90aWZpY2F0aW9ucy5zbGljZSgpLCBub3RpZmljYXRpb24gPT4ge1xuICAgICAgICAgICAgZ2V0SW1wbGVtZW50YXRpb24oKS5jbG9zZShub3RpZmljYXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZWdpc3RlckV2ZW50cyhlZGl0b3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbixcbiAgICAgICAgY2xvc2UsXG4gICAgICAgIGdldE5vdGlmaWNhdGlvbnNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IFBsdWdpbk1hbmFnZXIgPSBBZGRPbk1hbmFnZXIuUGx1Z2luTWFuYWdlcjtcblxuICAgIGNvbnN0IFRoZW1lTWFuYWdlciA9IEFkZE9uTWFuYWdlci5UaGVtZU1hbmFnZXI7XG5cbiAgICB2YXIgV2luZG93TWFuYWdlckltcGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCB1bmltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZW1lIGRpZCBub3QgcHJvdmlkZSBhIFdpbmRvd01hbmFnZXIgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BlbjogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgb3BlblVybDogdW5pbXBsZW1lbnRlZCxcbiAgICAgICAgYWxlcnQ6IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGNvbmZpcm06IHVuaW1wbGVtZW50ZWQsXG4gICAgICAgIGNsb3NlOiB1bmltcGxlbWVudGVkXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBXaW5kb3dNYW5hZ2VyID0gZWRpdG9yID0+IHtcbiAgICAgIGxldCBkaWFsb2dzID0gW107XG4gICAgICBjb25zdCBnZXRJbXBsZW1lbnRhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBlZGl0b3IudGhlbWU7XG4gICAgICAgIHJldHVybiB0aGVtZSAmJiB0aGVtZS5nZXRXaW5kb3dNYW5hZ2VySW1wbCA/IHRoZW1lLmdldFdpbmRvd01hbmFnZXJJbXBsKCkgOiBXaW5kb3dNYW5hZ2VySW1wbCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZ1bmNCaW5kID0gKHNjb3BlLCBmKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBmID8gZi5hcHBseShzY29wZSwgYXJncykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgZmlyZU9wZW5FdmVudCA9IGRpYWxvZyA9PiB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnT3BlbldpbmRvdycsIHsgZGlhbG9nIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpcmVDbG9zZUV2ZW50ID0gZGlhbG9nID0+IHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdDbG9zZVdpbmRvdycsIHsgZGlhbG9nIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFkZERpYWxvZyA9IGRpYWxvZyA9PiB7XG4gICAgICAgIGRpYWxvZ3MucHVzaChkaWFsb2cpO1xuICAgICAgICBmaXJlT3BlbkV2ZW50KGRpYWxvZyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xvc2VEaWFsb2cgPSBkaWFsb2cgPT4ge1xuICAgICAgICBmaXJlQ2xvc2VFdmVudChkaWFsb2cpO1xuICAgICAgICBkaWFsb2dzID0gZmlsdGVyJDUoZGlhbG9ncywgb3RoZXJEaWFsb2cgPT4ge1xuICAgICAgICAgIHJldHVybiBvdGhlckRpYWxvZyAhPT0gZGlhbG9nO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpYWxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRUb3BEaWFsb2cgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGRpYWxvZ3NbZGlhbG9ncy5sZW5ndGggLSAxXSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RvcmVTZWxlY3Rpb25BbmRPcGVuRGlhbG9nID0gb3BlbkRpYWxvZyA9PiB7XG4gICAgICAgIGVkaXRvci5lZGl0b3JNYW5hZ2VyLnNldEFjdGl2ZShlZGl0b3IpO1xuICAgICAgICBzdG9yZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IudWkuc2hvdygpO1xuICAgICAgICBjb25zdCBkaWFsb2cgPSBvcGVuRGlhbG9nKCk7XG4gICAgICAgIGFkZERpYWxvZyhkaWFsb2cpO1xuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9wZW4gPSAoYXJncywgcGFyYW1zKSA9PiB7XG4gICAgICAgIHJldHVybiBzdG9yZVNlbGVjdGlvbkFuZE9wZW5EaWFsb2coKCkgPT4gZ2V0SW1wbGVtZW50YXRpb24oKS5vcGVuKGFyZ3MsIHBhcmFtcywgY2xvc2VEaWFsb2cpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvcGVuVXJsID0gYXJncyA9PiB7XG4gICAgICAgIHJldHVybiBzdG9yZVNlbGVjdGlvbkFuZE9wZW5EaWFsb2coKCkgPT4gZ2V0SW1wbGVtZW50YXRpb24oKS5vcGVuVXJsKGFyZ3MsIGNsb3NlRGlhbG9nKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgYWxlcnQgPSAobWVzc2FnZSwgY2FsbGJhY2ssIHNjb3BlKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd01hbmFnZXJJbXBsID0gZ2V0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgICAgd2luZG93TWFuYWdlckltcGwuYWxlcnQobWVzc2FnZSwgZnVuY0JpbmQoc2NvcGUgPyBzY29wZSA6IHdpbmRvd01hbmFnZXJJbXBsLCBjYWxsYmFjaykpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbmZpcm0gPSAobWVzc2FnZSwgY2FsbGJhY2ssIHNjb3BlKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd01hbmFnZXJJbXBsID0gZ2V0SW1wbGVtZW50YXRpb24oKTtcbiAgICAgICAgd2luZG93TWFuYWdlckltcGwuY29uZmlybShtZXNzYWdlLCBmdW5jQmluZChzY29wZSA/IHNjb3BlIDogd2luZG93TWFuYWdlckltcGwsIGNhbGxiYWNrKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIGdldFRvcERpYWxvZygpLmVhY2goZGlhbG9nID0+IHtcbiAgICAgICAgICBnZXRJbXBsZW1lbnRhdGlvbigpLmNsb3NlKGRpYWxvZyk7XG4gICAgICAgICAgY2xvc2VEaWFsb2coZGlhbG9nKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIGVhY2gkZShkaWFsb2dzLCBkaWFsb2cgPT4ge1xuICAgICAgICAgIGdldEltcGxlbWVudGF0aW9uKCkuY2xvc2UoZGlhbG9nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZW4sXG4gICAgICAgIG9wZW5VcmwsXG4gICAgICAgIGFsZXJ0LFxuICAgICAgICBjb25maXJtLFxuICAgICAgICBjbG9zZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGlzcGxheU5vdGlmaWNhdGlvbiA9IChlZGl0b3IsIG1lc3NhZ2UpID0+IHtcbiAgICAgIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICB0ZXh0OiBtZXNzYWdlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3BsYXlFcnJvciA9IChlZGl0b3IsIG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChlZGl0b3IuX3NraW5Mb2FkZWQpIHtcbiAgICAgICAgZGlzcGxheU5vdGlmaWNhdGlvbihlZGl0b3IsIG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLm9uKCdTa2luTG9hZGVkJywgKCkgPT4ge1xuICAgICAgICAgIGRpc3BsYXlOb3RpZmljYXRpb24oZWRpdG9yLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGxvYWRFcnJvciA9IChlZGl0b3IsIG1lc3NhZ2UpID0+IHtcbiAgICAgIGRpc3BsYXlFcnJvcihlZGl0b3IsIEkxOG4udHJhbnNsYXRlKFtcbiAgICAgICAgJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2U6IHswfScsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIF0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ0Vycm9yID0gKGVkaXRvciwgZXJyb3JUeXBlLCBtc2cpID0+IHtcbiAgICAgIGZpcmVFcnJvcihlZGl0b3IsIGVycm9yVHlwZSwgeyBtZXNzYWdlOiBtc2cgfSk7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVMb2FkRXJyb3IgPSAodHlwZSwgdXJsLCBuYW1lKSA9PiBuYW1lID8gYEZhaWxlZCB0byBsb2FkICR7IHR5cGUgfTogJHsgbmFtZSB9IGZyb20gdXJsICR7IHVybCB9YCA6IGBGYWlsZWQgdG8gbG9hZCAkeyB0eXBlIH0gdXJsOiAkeyB1cmwgfWA7XG4gICAgY29uc3QgcGx1Z2luTG9hZEVycm9yID0gKGVkaXRvciwgdXJsLCBuYW1lKSA9PiB7XG4gICAgICBsb2dFcnJvcihlZGl0b3IsICdQbHVnaW5Mb2FkRXJyb3InLCBjcmVhdGVMb2FkRXJyb3IoJ3BsdWdpbicsIHVybCwgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgaWNvbnNMb2FkRXJyb3IgPSAoZWRpdG9yLCB1cmwsIG5hbWUpID0+IHtcbiAgICAgIGxvZ0Vycm9yKGVkaXRvciwgJ0ljb25zTG9hZEVycm9yJywgY3JlYXRlTG9hZEVycm9yKCdpY29ucycsIHVybCwgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgbGFuZ3VhZ2VMb2FkRXJyb3IgPSAoZWRpdG9yLCB1cmwsIG5hbWUpID0+IHtcbiAgICAgIGxvZ0Vycm9yKGVkaXRvciwgJ0xhbmd1YWdlTG9hZEVycm9yJywgY3JlYXRlTG9hZEVycm9yKCdsYW5ndWFnZScsIHVybCwgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgdGhlbWVMb2FkRXJyb3IgPSAoZWRpdG9yLCB1cmwsIG5hbWUpID0+IHtcbiAgICAgIGxvZ0Vycm9yKGVkaXRvciwgJ1RoZW1lTG9hZEVycm9yJywgY3JlYXRlTG9hZEVycm9yKCd0aGVtZScsIHVybCwgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgbW9kZWxMb2FkRXJyb3IgPSAoZWRpdG9yLCB1cmwsIG5hbWUpID0+IHtcbiAgICAgIGxvZ0Vycm9yKGVkaXRvciwgJ01vZGVsTG9hZEVycm9yJywgY3JlYXRlTG9hZEVycm9yKCdtb2RlbCcsIHVybCwgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgcGx1Z2luSW5pdEVycm9yID0gKGVkaXRvciwgbmFtZSwgZXJyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gSTE4bi50cmFuc2xhdGUoW1xuICAgICAgICAnRmFpbGVkIHRvIGluaXRpYWxpemUgcGx1Z2luOiB7MH0nLFxuICAgICAgICBuYW1lXG4gICAgICBdKTtcbiAgICAgIGZpcmVFcnJvcihlZGl0b3IsICdQbHVnaW5Mb2FkRXJyb3InLCB7IG1lc3NhZ2UgfSk7XG4gICAgICBpbml0RXJyb3IobWVzc2FnZSwgZXJyKTtcbiAgICAgIGRpc3BsYXlFcnJvcihlZGl0b3IsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgY29uc3QgaW5pdEVycm9yID0gKG1lc3NhZ2UsIC4uLngpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcbiAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCAuLi54KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLCAuLi54KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRDc3NTa2luTmFtZSA9IHVybCA9PiAvXlthLXowLTlcXC1dKyQvaS50ZXN0KHVybCk7XG4gICAgY29uc3QgZ2V0Q29udGVudENzc1VybHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVRvVXJscyhlZGl0b3IsIGdldENvbnRlbnRDc3MoZWRpdG9yKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRGb250Q3NzVXJscyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtVG9VcmxzKGVkaXRvciwgZ2V0Rm9udENzcyhlZGl0b3IpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYW5zZm9ybVRvVXJscyA9IChlZGl0b3IsIGNzc0xpbmtzKSA9PiB7XG4gICAgICBjb25zdCBza2luVXJsID0gZWRpdG9yLmVkaXRvck1hbmFnZXIuYmFzZVVSTCArICcvc2tpbnMvY29udGVudCc7XG4gICAgICBjb25zdCBzdWZmaXggPSBlZGl0b3IuZWRpdG9yTWFuYWdlci5zdWZmaXg7XG4gICAgICBjb25zdCBjb250ZW50Q3NzRmlsZSA9IGBjb250ZW50JHsgc3VmZml4IH0uY3NzYDtcbiAgICAgIHJldHVybiBtYXAkMyhjc3NMaW5rcywgdXJsID0+IHtcbiAgICAgICAgaWYgKGlzQ29udGVudENzc1NraW5OYW1lKHVybCkgJiYgIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICByZXR1cm4gYCR7IHNraW5VcmwgfS8keyB1cmwgfS8keyBjb250ZW50Q3NzRmlsZSB9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmRvY3VtZW50QmFzZVVSSS50b0Fic29sdXRlKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kQ29udGVudENzc0Zyb21TZXR0aW5ncyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuY29udGVudENTUyA9IGVkaXRvci5jb250ZW50Q1NTLmNvbmNhdChnZXRDb250ZW50Q3NzVXJscyhlZGl0b3IpLCBnZXRGb250Q3NzVXJscyhlZGl0b3IpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0QWxsSW1hZ2VzID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBlbG0gPyBmcm9tKGVsbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJykpIDogW107XG4gICAgfTtcbiAgICBjb25zdCBJbWFnZVNjYW5uZXIgPSAodXBsb2FkU3RhdHVzLCBibG9iQ2FjaGUpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZFByb21pc2VzID0ge307XG4gICAgICBjb25zdCBmaW5kQWxsID0gKGVsbSwgcHJlZGljYXRlID0gYWx3YXlzKSA9PiB7XG4gICAgICAgIGNvbnN0IGltYWdlcyA9IGZpbHRlciQ1KGdldEFsbEltYWdlcyhlbG0pLCBpbWcgPT4ge1xuICAgICAgICAgIGNvbnN0IHNyYyA9IGltZy5zcmM7XG4gICAgICAgICAgaWYgKGltZy5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLWJvZ3VzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltZy5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWNlLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzcmMgfHwgc3JjID09PSBFbnYudHJhbnNwYXJlbnRTcmMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgoc3JjLCAnYmxvYjonKSkge1xuICAgICAgICAgICAgcmV0dXJuICF1cGxvYWRTdGF0dXMuaXNVcGxvYWRlZChzcmMpICYmIHByZWRpY2F0ZShpbWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzcmMsICdkYXRhOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKGltZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gbWFwJDMoaW1hZ2VzLCBpbWcgPT4ge1xuICAgICAgICAgIGNvbnN0IGltYWdlU3JjID0gaW1nLnNyYztcbiAgICAgICAgICBpZiAoaGFzJDIoY2FjaGVkUHJvbWlzZXMsIGltYWdlU3JjKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2VzW2ltYWdlU3JjXS50aGVuKGltYWdlSW5mbyA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1N0cmluZyhpbWFnZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlSW5mbztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltZyxcbiAgICAgICAgICAgICAgICAgIGJsb2JJbmZvOiBpbWFnZUluZm8uYmxvYkluZm9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvbWlzZSA9IGltYWdlVG9CbG9iSW5mbyhibG9iQ2FjaGUsIGltYWdlU3JjKS50aGVuKGJsb2JJbmZvID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlZFByb21pc2VzW2ltYWdlU3JjXTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgIGJsb2JJbmZvXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWRQcm9taXNlc1tpbWFnZVNyY107XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGVkUHJvbWlzZXNbaW1hZ2VTcmNdID0gbmV3UHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgZmluZEFsbCB9O1xuICAgIH07XG5cbiAgICBjb25zdCBVcGxvYWRTdGF0dXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBQRU5ESU5HID0gMSwgVVBMT0FERUQgPSAyO1xuICAgICAgbGV0IGJsb2JVcmlTdGF0dXNlcyA9IHt9O1xuICAgICAgY29uc3QgY3JlYXRlU3RhdHVzID0gKHN0YXR1cywgcmVzdWx0VXJpKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHJlc3VsdFVyaVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhc0Jsb2JVcmkgPSBibG9iVXJpID0+IHtcbiAgICAgICAgcmV0dXJuIGJsb2JVcmkgaW4gYmxvYlVyaVN0YXR1c2VzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldFJlc3VsdFVyaSA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQucmVzdWx0VXJpIDogbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1BlbmRpbmcgPSBibG9iVXJpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhc0Jsb2JVcmkoYmxvYlVyaSkgPyBibG9iVXJpU3RhdHVzZXNbYmxvYlVyaV0uc3RhdHVzID09PSBQRU5ESU5HIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNVcGxvYWRlZCA9IGJsb2JVcmkgPT4ge1xuICAgICAgICByZXR1cm4gaGFzQmxvYlVyaShibG9iVXJpKSA/IGJsb2JVcmlTdGF0dXNlc1tibG9iVXJpXS5zdGF0dXMgPT09IFVQTE9BREVEIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgbWFya1BlbmRpbmcgPSBibG9iVXJpID0+IHtcbiAgICAgICAgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldID0gY3JlYXRlU3RhdHVzKFBFTkRJTkcsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG1hcmtVcGxvYWRlZCA9IChibG9iVXJpLCByZXN1bHRVcmkpID0+IHtcbiAgICAgICAgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldID0gY3JlYXRlU3RhdHVzKFVQTE9BREVELCByZXN1bHRVcmkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUZhaWxlZCA9IGJsb2JVcmkgPT4ge1xuICAgICAgICBkZWxldGUgYmxvYlVyaVN0YXR1c2VzW2Jsb2JVcmldO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGJsb2JVcmlTdGF0dXNlcyA9IHt9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc0Jsb2JVcmksXG4gICAgICAgIGdldFJlc3VsdFVyaSxcbiAgICAgICAgaXNQZW5kaW5nLFxuICAgICAgICBpc1VwbG9hZGVkLFxuICAgICAgICBtYXJrUGVuZGluZyxcbiAgICAgICAgbWFya1VwbG9hZGVkLFxuICAgICAgICByZW1vdmVGYWlsZWQsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgc2VlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJuZCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUpLnRvU3RyaW5nKDM2KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiAncycgKyBub3cudG9TdHJpbmcoMzYpICsgcm5kKCkgKyBybmQoKSArIHJuZCgpO1xuICAgIH07XG4gICAgY29uc3QgdXVpZCA9IHByZWZpeCA9PiB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgY291bnQrKyArIHNlZWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgQmxvYkNhY2hlID0gKCkgPT4ge1xuICAgICAgbGV0IGNhY2hlID0gW107XG4gICAgICBjb25zdCBtaW1lVG9FeHQgPSBtaW1lID0+IHtcbiAgICAgICAgY29uc3QgbWltZXMgPSB7XG4gICAgICAgICAgJ2ltYWdlL2pwZWcnOiAnanBnJyxcbiAgICAgICAgICAnaW1hZ2UvanBnJzogJ2pwZycsXG4gICAgICAgICAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAgICAgICAgICdpbWFnZS9wbmcnOiAncG5nJyxcbiAgICAgICAgICAnaW1hZ2UvYXBuZyc6ICdhcG5nJyxcbiAgICAgICAgICAnaW1hZ2UvYXZpZic6ICdhdmlmJyxcbiAgICAgICAgICAnaW1hZ2Uvc3ZnK3htbCc6ICdzdmcnLFxuICAgICAgICAgICdpbWFnZS93ZWJwJzogJ3dlYnAnLFxuICAgICAgICAgICdpbWFnZS9ibXAnOiAnYm1wJyxcbiAgICAgICAgICAnaW1hZ2UvdGlmZic6ICd0aWZmJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWltZXNbbWltZS50b0xvd2VyQ2FzZSgpXSB8fCAnZGF0JztcbiAgICAgIH07XG4gICAgICBjb25zdCBjcmVhdGUgPSAobywgYmxvYiwgYmFzZTY0LCBuYW1lLCBmaWxlbmFtZSkgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcobykpIHtcbiAgICAgICAgICBjb25zdCBpZCA9IG87XG4gICAgICAgICAgcmV0dXJuIHRvQmxvYkluZm8oe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICBibG9iOiBibG9iLFxuICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvKSkge1xuICAgICAgICAgIHJldHVybiB0b0Jsb2JJbmZvKG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnB1dCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB0b0Jsb2JJbmZvID0gbyA9PiB7XG4gICAgICAgIGlmICghby5ibG9iIHx8ICFvLmJhc2U2NCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvYiBhbmQgYmFzZTY0IHJlcHJlc2VudGF0aW9ucyBvZiB0aGUgaW1hZ2UgYXJlIHJlcXVpcmVkIGZvciBCbG9iSW5mbyB0byBiZSBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBvLmlkIHx8IHV1aWQoJ2Jsb2JpZCcpO1xuICAgICAgICBjb25zdCBuYW1lID0gby5uYW1lIHx8IGlkO1xuICAgICAgICBjb25zdCBibG9iID0gby5ibG9iO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBjb25zdGFudChpZCksXG4gICAgICAgICAgbmFtZTogY29uc3RhbnQobmFtZSksXG4gICAgICAgICAgZmlsZW5hbWU6IGNvbnN0YW50KG8uZmlsZW5hbWUgfHwgbmFtZSArICcuJyArIG1pbWVUb0V4dChibG9iLnR5cGUpKSxcbiAgICAgICAgICBibG9iOiBjb25zdGFudChibG9iKSxcbiAgICAgICAgICBiYXNlNjQ6IGNvbnN0YW50KG8uYmFzZTY0KSxcbiAgICAgICAgICBibG9iVXJpOiBjb25zdGFudChvLmJsb2JVcmkgfHwgVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSksXG4gICAgICAgICAgdXJpOiBjb25zdGFudChvLnVyaSlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCBhZGQgPSBibG9iSW5mbyA9PiB7XG4gICAgICAgIGlmICghZ2V0KGJsb2JJbmZvLmlkKCkpKSB7XG4gICAgICAgICAgY2FjaGUucHVzaChibG9iSW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kRmlyc3QgPSBwcmVkaWNhdGUgPT4gZmluZCQyKGNhY2hlLCBwcmVkaWNhdGUpLmdldE9yVW5kZWZpbmVkKCk7XG4gICAgICBjb25zdCBnZXQgPSBpZCA9PiBmaW5kRmlyc3QoY2FjaGVkQmxvYkluZm8gPT4gY2FjaGVkQmxvYkluZm8uaWQoKSA9PT0gaWQpO1xuICAgICAgY29uc3QgZ2V0QnlVcmkgPSBibG9iVXJpID0+IGZpbmRGaXJzdChibG9iSW5mbyA9PiBibG9iSW5mby5ibG9iVXJpKCkgPT09IGJsb2JVcmkpO1xuICAgICAgY29uc3QgZ2V0QnlEYXRhID0gKGJhc2U2NCwgdHlwZSkgPT4gZmluZEZpcnN0KGJsb2JJbmZvID0+IGJsb2JJbmZvLmJhc2U2NCgpID09PSBiYXNlNjQgJiYgYmxvYkluZm8uYmxvYigpLnR5cGUgPT09IHR5cGUpO1xuICAgICAgY29uc3QgcmVtb3ZlQnlVcmkgPSBibG9iVXJpID0+IHtcbiAgICAgICAgY2FjaGUgPSBmaWx0ZXIkNShjYWNoZSwgYmxvYkluZm8gPT4ge1xuICAgICAgICAgIGlmIChibG9iSW5mby5ibG9iVXJpKCkgPT09IGJsb2JVcmkpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYkluZm8uYmxvYlVyaSgpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgIGVhY2gkZShjYWNoZSwgY2FjaGVkQmxvYkluZm8gPT4ge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoY2FjaGVkQmxvYkluZm8uYmxvYlVyaSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhY2hlID0gW107XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBhZGQsXG4gICAgICAgIGdldCxcbiAgICAgICAgZ2V0QnlVcmksXG4gICAgICAgIGdldEJ5RGF0YSxcbiAgICAgICAgZmluZEZpcnN0LFxuICAgICAgICByZW1vdmVCeVVyaSxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgVXBsb2FkZXIgPSAodXBsb2FkU3RhdHVzLCBzZXR0aW5ncykgPT4ge1xuICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2VzID0ge307XG4gICAgICBjb25zdCBwYXRoSm9pbiA9IChwYXRoMSwgcGF0aDIpID0+IHtcbiAgICAgICAgaWYgKHBhdGgxKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGgxLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLycgKyBwYXRoMi5yZXBsYWNlKC9eXFwvLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoMjtcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWZhdWx0SGFuZGxlciA9IChibG9iSW5mbywgcHJvZ3Jlc3MpID0+IG5ldyBQcm9taXNlKChzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHNldHRpbmdzLnVybCk7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBzZXR0aW5ncy5jcmVkZW50aWFscztcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZSA9PiB7XG4gICAgICAgICAgcHJvZ3Jlc3MoZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgZmFpbHVyZSgnSW1hZ2UgdXBsb2FkIGZhaWxlZCBkdWUgdG8gYSBYSFIgVHJhbnNwb3J0IGVycm9yLiBDb2RlOiAnICsgeGhyLnN0YXR1cyk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIGZhaWx1cmUoJ0hUVFAgRXJyb3I6ICcgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgaWYgKCFqc29uIHx8ICFpc1N0cmluZyhqc29uLmxvY2F0aW9uKSkge1xuICAgICAgICAgICAgZmFpbHVyZSgnSW52YWxpZCBKU09OOiAnICsgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1Y2Nlc3MocGF0aEpvaW4oc2V0dGluZ3MuYmFzZVBhdGgsIGpzb24ubG9jYXRpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgYmxvYkluZm8uYmxvYigpLCBibG9iSW5mby5maWxlbmFtZSgpKTtcbiAgICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB1cGxvYWRIYW5kbGVyID0gaXNGdW5jdGlvbihzZXR0aW5ncy5oYW5kbGVyKSA/IHNldHRpbmdzLmhhbmRsZXIgOiBkZWZhdWx0SGFuZGxlcjtcbiAgICAgIGNvbnN0IG5vVXBsb2FkID0gKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVyU3VjY2VzcyA9IChibG9iSW5mbywgdXJsKSA9PiAoe1xuICAgICAgICB1cmwsXG4gICAgICAgIGJsb2JJbmZvLFxuICAgICAgICBzdGF0dXM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGFuZGxlckZhaWx1cmUgPSAoYmxvYkluZm8sIGVycm9yKSA9PiAoe1xuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBibG9iSW5mbyxcbiAgICAgICAgc3RhdHVzOiBmYWxzZSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzb2x2ZVBlbmRpbmcgPSAoYmxvYlVyaSwgcmVzdWx0KSA9PiB7XG4gICAgICAgIFRvb2xzLmVhY2gocGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldLCByZXNvbHZlID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgcGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVwbG9hZEJsb2JJbmZvID0gKGJsb2JJbmZvLCBoYW5kbGVyLCBvcGVuTm90aWZpY2F0aW9uKSA9PiB7XG4gICAgICAgIHVwbG9hZFN0YXR1cy5tYXJrUGVuZGluZyhibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgbGV0IG5vdGlmaWNhdGlvbjtcbiAgICAgICAgICBsZXQgcHJvZ3Jlc3M7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlTm90aWZpY2F0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBub29wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHVybCA9PiB7XG4gICAgICAgICAgICAgIGNsb3NlTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICAgIHVwbG9hZFN0YXR1cy5tYXJrVXBsb2FkZWQoYmxvYkluZm8uYmxvYlVyaSgpLCB1cmwpO1xuICAgICAgICAgICAgICByZXNvbHZlUGVuZGluZyhibG9iSW5mby5ibG9iVXJpKCksIGhhbmRsZXJTdWNjZXNzKGJsb2JJbmZvLCB1cmwpKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShoYW5kbGVyU3VjY2VzcyhibG9iSW5mbywgdXJsKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZSA9IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY2xvc2VOb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgICAgdXBsb2FkU3RhdHVzLnJlbW92ZUZhaWxlZChibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICAgICAgICByZXNvbHZlUGVuZGluZyhibG9iSW5mby5ibG9iVXJpKCksIGhhbmRsZXJGYWlsdXJlKGJsb2JJbmZvLCBlcnJvcikpO1xuICAgICAgICAgICAgICByZXNvbHZlKGhhbmRsZXJGYWlsdXJlKGJsb2JJbmZvLCBlcnJvcikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gcGVyY2VudCA9PiB7XG4gICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCB8fCBwZXJjZW50ID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIE9wdGlvbmFsLmZyb20obm90aWZpY2F0aW9uKS5vclRodW5rKCgpID0+IE9wdGlvbmFsLmZyb20ob3Blbk5vdGlmaWNhdGlvbikubWFwKGFwcGx5JDEpKS5lYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IG47XG4gICAgICAgICAgICAgICAgbi5wcm9ncmVzc0Jhci52YWx1ZShwZXJjZW50KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGFuZGxlcihibG9iSW5mbywgcHJvZ3Jlc3MpLnRoZW4oc3VjY2VzcywgZXJyID0+IHtcbiAgICAgICAgICAgICAgZmFpbHVyZShpc1N0cmluZyhlcnIpID8geyBtZXNzYWdlOiBlcnIgfSA6IGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmVzb2x2ZShoYW5kbGVyRmFpbHVyZShibG9iSW5mbywgZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzRGVmYXVsdEhhbmRsZXIgPSBoYW5kbGVyID0+IGhhbmRsZXIgPT09IGRlZmF1bHRIYW5kbGVyO1xuICAgICAgY29uc3QgcGVuZGluZ1VwbG9hZEJsb2JJbmZvID0gYmxvYkluZm8gPT4ge1xuICAgICAgICBjb25zdCBibG9iVXJpID0gYmxvYkluZm8uYmxvYlVyaSgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldID0gcGVuZGluZ1Byb21pc2VzW2Jsb2JVcmldIHx8IFtdO1xuICAgICAgICAgIHBlbmRpbmdQcm9taXNlc1tibG9iVXJpXS5wdXNoKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGxvYWRCbG9icyA9IChibG9iSW5mb3MsIG9wZW5Ob3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgYmxvYkluZm9zID0gVG9vbHMuZ3JlcChibG9iSW5mb3MsIGJsb2JJbmZvID0+ICF1cGxvYWRTdGF0dXMuaXNVcGxvYWRlZChibG9iSW5mby5ibG9iVXJpKCkpKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFRvb2xzLm1hcChibG9iSW5mb3MsIGJsb2JJbmZvID0+IHVwbG9hZFN0YXR1cy5pc1BlbmRpbmcoYmxvYkluZm8uYmxvYlVyaSgpKSA/IHBlbmRpbmdVcGxvYWRCbG9iSW5mbyhibG9iSW5mbykgOiB1cGxvYWRCbG9iSW5mbyhibG9iSW5mbywgdXBsb2FkSGFuZGxlciwgb3Blbk5vdGlmaWNhdGlvbikpKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGxvYWQgPSAoYmxvYkluZm9zLCBvcGVuTm90aWZpY2F0aW9uKSA9PiAhc2V0dGluZ3MudXJsICYmIGlzRGVmYXVsdEhhbmRsZXIodXBsb2FkSGFuZGxlcikgPyBub1VwbG9hZCgpIDogdXBsb2FkQmxvYnMoYmxvYkluZm9zLCBvcGVuTm90aWZpY2F0aW9uKTtcbiAgICAgIHJldHVybiB7IHVwbG9hZCB9O1xuICAgIH07XG5cbiAgICBjb25zdCBvcGVuTm90aWZpY2F0aW9uID0gZWRpdG9yID0+ICgpID0+IGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgdGV4dDogZWRpdG9yLnRyYW5zbGF0ZSgnSW1hZ2UgdXBsb2FkaW5nLi4uJyksXG4gICAgICB0eXBlOiAnaW5mbycsXG4gICAgICB0aW1lb3V0OiAtMSxcbiAgICAgIHByb2dyZXNzQmFyOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlVXBsb2FkZXIgPSAoZWRpdG9yLCB1cGxvYWRTdGF0dXMpID0+IFVwbG9hZGVyKHVwbG9hZFN0YXR1cywge1xuICAgICAgdXJsOiBnZXRJbWFnZVVwbG9hZFVybChlZGl0b3IpLFxuICAgICAgYmFzZVBhdGg6IGdldEltYWdlVXBsb2FkQmFzZVBhdGgoZWRpdG9yKSxcbiAgICAgIGNyZWRlbnRpYWxzOiBnZXRJbWFnZXNVcGxvYWRDcmVkZW50aWFscyhlZGl0b3IpLFxuICAgICAgaGFuZGxlcjogZ2V0SW1hZ2VzVXBsb2FkSGFuZGxlcihlZGl0b3IpXG4gICAgfSk7XG4gICAgY29uc3QgSW1hZ2VVcGxvYWRlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB1cGxvYWRTdGF0dXMgPSBVcGxvYWRTdGF0dXMoKTtcbiAgICAgIGNvbnN0IHVwbG9hZGVyID0gY3JlYXRlVXBsb2FkZXIoZWRpdG9yLCB1cGxvYWRTdGF0dXMpO1xuICAgICAgcmV0dXJuIHsgdXBsb2FkOiAoYmxvYkluZm9zLCBzaG93Tm90aWZpY2F0aW9uID0gdHJ1ZSkgPT4gdXBsb2FkZXIudXBsb2FkKGJsb2JJbmZvcywgc2hvd05vdGlmaWNhdGlvbiA/IG9wZW5Ob3RpZmljYXRpb24oZWRpdG9yKSA6IHVuZGVmaW5lZCkgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNFbXB0eUZvclBhZGRpbmcgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiBlZGl0b3IuZG9tLmlzRW1wdHkoZWxlbWVudC5kb20pICYmIGlzTm9uTnVsbGFibGUoZWRpdG9yLnNjaGVtYS5nZXRUZXh0QmxvY2tFbGVtZW50cygpW25hbWUoZWxlbWVudCldKTtcbiAgICBjb25zdCBhZGRQYWRkaW5nVG9FbXB0eSA9IGVkaXRvciA9PiBlbGVtZW50ID0+IHtcbiAgICAgIGlmIChpc0VtcHR5Rm9yUGFkZGluZyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgICAgIGFwcGVuZCQxKGVsZW1lbnQsIFN1Z2FyRWxlbWVudC5mcm9tSHRtbCgnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiIC8+JykpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgRWRpdG9yVXBsb2FkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJsb2JDYWNoZSA9IEJsb2JDYWNoZSgpO1xuICAgICAgbGV0IHVwbG9hZGVyLCBpbWFnZVNjYW5uZXI7XG4gICAgICBjb25zdCB1cGxvYWRTdGF0dXMgPSBVcGxvYWRTdGF0dXMoKTtcbiAgICAgIGNvbnN0IHVybEZpbHRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGFsaXZlR3VhcmQgPSBjYWxsYmFjayA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhY2hlSW52YWxpZGF0b3IgPSB1cmwgPT4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgcmVwbGFjZVN0cmluZyA9IChjb250ZW50LCBzZWFyY2gsIHJlcGxhY2UpID0+IHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGluZGV4ID0gY29udGVudC5pbmRleE9mKHNlYXJjaCwgaW5kZXgpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlICsgY29udGVudC5zdWJzdHIoaW5kZXggKyBzZWFyY2gubGVuZ3RoKTtcbiAgICAgICAgICAgIGluZGV4ICs9IHJlcGxhY2UubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlSW1hZ2VVcmwgPSAoY29udGVudCwgdGFyZ2V0VXJsLCByZXBsYWNlbWVudFVybCkgPT4ge1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudFN0cmluZyA9IGBzcmM9XCIkeyByZXBsYWNlbWVudFVybCB9XCIkeyByZXBsYWNlbWVudFVybCA9PT0gRW52LnRyYW5zcGFyZW50U3JjID8gJyBkYXRhLW1jZS1wbGFjZWhvbGRlcj1cIjFcIicgOiAnJyB9YDtcbiAgICAgICAgY29udGVudCA9IHJlcGxhY2VTdHJpbmcoY29udGVudCwgYHNyYz1cIiR7IHRhcmdldFVybCB9XCJgLCByZXBsYWNlbWVudFN0cmluZyk7XG4gICAgICAgIGNvbnRlbnQgPSByZXBsYWNlU3RyaW5nKGNvbnRlbnQsICdkYXRhLW1jZS1zcmM9XCInICsgdGFyZ2V0VXJsICsgJ1wiJywgJ2RhdGEtbWNlLXNyYz1cIicgKyByZXBsYWNlbWVudFVybCArICdcIicpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXBsYWNlVXJsSW5VbmRvU3RhY2sgPSAodGFyZ2V0VXJsLCByZXBsYWNlbWVudFVybCkgPT4ge1xuICAgICAgICBlYWNoJGUoZWRpdG9yLnVuZG9NYW5hZ2VyLmRhdGEsIGxldmVsID0+IHtcbiAgICAgICAgICBpZiAobGV2ZWwudHlwZSA9PT0gJ2ZyYWdtZW50ZWQnKSB7XG4gICAgICAgICAgICBsZXZlbC5mcmFnbWVudHMgPSBtYXAkMyhsZXZlbC5mcmFnbWVudHMsIGZyYWdtZW50ID0+IHJlcGxhY2VJbWFnZVVybChmcmFnbWVudCwgdGFyZ2V0VXJsLCByZXBsYWNlbWVudFVybCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXZlbC5jb250ZW50ID0gcmVwbGFjZUltYWdlVXJsKGxldmVsLmNvbnRlbnQsIHRhcmdldFVybCwgcmVwbGFjZW1lbnRVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVwbGFjZUltYWdlVXJpSW5WaWV3ID0gKGltYWdlLCByZXN1bHRVcmkpID0+IHtcbiAgICAgICAgY29uc3Qgc3JjID0gZWRpdG9yLmNvbnZlcnRVUkwocmVzdWx0VXJpLCAnc3JjJyk7XG4gICAgICAgIHJlcGxhY2VVcmxJblVuZG9TdGFjayhpbWFnZS5zcmMsIHJlc3VsdFVyaSk7XG4gICAgICAgIHNldEFsbCQxKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGltYWdlKSwge1xuICAgICAgICAgICdzcmMnOiBzaG91bGRSZXVzZUZpbGVOYW1lKGVkaXRvcikgPyBjYWNoZUludmFsaWRhdG9yKHJlc3VsdFVyaSkgOiByZXN1bHRVcmksXG4gICAgICAgICAgJ2RhdGEtbWNlLXNyYyc6IHNyY1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1cGxvYWRJbWFnZXMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdXBsb2FkZXIpIHtcbiAgICAgICAgICB1cGxvYWRlciA9IGNyZWF0ZVVwbG9hZGVyKGVkaXRvciwgdXBsb2FkU3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbkZvckltYWdlcygpLnRoZW4oYWxpdmVHdWFyZChpbWFnZUluZm9zID0+IHtcbiAgICAgICAgICBjb25zdCBibG9iSW5mb3MgPSBtYXAkMyhpbWFnZUluZm9zLCBpbWFnZUluZm8gPT4gaW1hZ2VJbmZvLmJsb2JJbmZvKTtcbiAgICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkKGJsb2JJbmZvcywgb3Blbk5vdGlmaWNhdGlvbihlZGl0b3IpKS50aGVuKGFsaXZlR3VhcmQocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlc1RvUmVtb3ZlID0gW107XG4gICAgICAgICAgICBsZXQgc2hvdWxkRGlzcGF0Y2hDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbWFwJDMocmVzdWx0LCAodXBsb2FkSW5mbywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge2Jsb2JJbmZvLCBpbWFnZX0gPSBpbWFnZUluZm9zW2luZGV4XTtcbiAgICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKHVwbG9hZEluZm8uc3RhdHVzICYmIHNob3VsZFJlcGxhY2VCbG9iVXJpcyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZEluZm8udXJsICYmICFjb250YWlucyQxKGltYWdlLnNyYywgdXBsb2FkSW5mby51cmwpKSB7XG4gICAgICAgICAgICAgICAgICBzaG91bGREaXNwYXRjaENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJsb2JDYWNoZS5yZW1vdmVCeVVyaShpbWFnZS5zcmMpO1xuICAgICAgICAgICAgICAgIGlmIChpc1J0YyhlZGl0b3IpKSA7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZUltYWdlVXJpSW5WaWV3KGltYWdlLCB1cGxvYWRJbmZvLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVwbG9hZEluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBsb2FkSW5mby5lcnJvci5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VVcmxJblVuZG9TdGFjayhpbWFnZS5zcmMsIEVudi50cmFuc3BhcmVudFNyYyk7XG4gICAgICAgICAgICAgICAgICBpbWFnZXNUb1JlbW92ZS5wdXNoKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGxvYWRFcnJvcihlZGl0b3IsIHVwbG9hZEluZm8uZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBpbWFnZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHVwbG9hZEluZm8uc3RhdHVzLFxuICAgICAgICAgICAgICAgIHVwbG9hZFVyaTogdXBsb2FkSW5mby51cmwsXG4gICAgICAgICAgICAgICAgYmxvYkluZm8sXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW1hZ2VzVG9SZW1vdmUubGVuZ3RoID4gMCAmJiAhaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVhY2gkZShmcm9tRG9tJDEoaW1hZ2VzVG9SZW1vdmUpLCBzdWdhckVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T3B0ID0gcGFyZW50KHN1Z2FyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICByZW1vdmUkNShzdWdhckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgcGFyZW50T3B0LmVhY2goYWRkUGFkZGluZ1RvRW1wdHkoZWRpdG9yKSk7XG4gICAgICAgICAgICAgICAgICBibG9iQ2FjaGUucmVtb3ZlQnlVcmkoc3VnYXJFbGVtZW50LmRvbS5zcmMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkRGlzcGF0Y2hDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmRpc3BhdGNoQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdXBsb2FkSW1hZ2VzQXV0byA9ICgpID0+IGlzQXV0b21hdGljVXBsb2Fkc0VuYWJsZWQoZWRpdG9yKSA/IHVwbG9hZEltYWdlcygpIDogUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICAgIGNvbnN0IGlzVmFsaWREYXRhVXJpSW1hZ2UgPSBpbWdFbG0gPT4gZm9yYWxsKHVybEZpbHRlcnMsIGZpbHRlciA9PiBmaWx0ZXIoaW1nRWxtKSk7XG4gICAgICBjb25zdCBhZGRGaWx0ZXIgPSBmaWx0ZXIgPT4ge1xuICAgICAgICB1cmxGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzY2FuRm9ySW1hZ2VzID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWltYWdlU2Nhbm5lcikge1xuICAgICAgICAgIGltYWdlU2Nhbm5lciA9IEltYWdlU2Nhbm5lcih1cGxvYWRTdGF0dXMsIGJsb2JDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlU2Nhbm5lci5maW5kQWxsKGVkaXRvci5nZXRCb2R5KCksIGlzVmFsaWREYXRhVXJpSW1hZ2UpLnRoZW4oYWxpdmVHdWFyZChyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gZmlsdGVyJDUocmVzdWx0LCByZXN1bHRJdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhyZXN1bHRJdGVtKSkge1xuICAgICAgICAgICAgICBkaXNwbGF5RXJyb3IoZWRpdG9yLCByZXN1bHRJdGVtKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRJdGVtLnVyaVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNSdGMoZWRpdG9yKSkgOyBlbHNlIHtcbiAgICAgICAgICAgIGVhY2gkZShmaWx0ZXJlZFJlc3VsdCwgcmVzdWx0SXRlbSA9PiB7XG4gICAgICAgICAgICAgIHJlcGxhY2VVcmxJblVuZG9TdGFjayhyZXN1bHRJdGVtLmltYWdlLnNyYywgcmVzdWx0SXRlbS5ibG9iSW5mby5ibG9iVXJpKCkpO1xuICAgICAgICAgICAgICByZXN1bHRJdGVtLmltYWdlLnNyYyA9IHJlc3VsdEl0ZW0uYmxvYkluZm8uYmxvYlVyaSgpO1xuICAgICAgICAgICAgICByZXN1bHRJdGVtLmltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc3JjJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgYmxvYkNhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgdXBsb2FkU3RhdHVzLmRlc3Ryb3koKTtcbiAgICAgICAgaW1hZ2VTY2FubmVyID0gdXBsb2FkZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlcGxhY2VCbG9iVXJpcyA9IGNvbnRlbnQgPT4ge1xuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9zcmM9XCIoYmxvYjpbXlwiXSspXCIvZywgKG1hdGNoLCBibG9iVXJpKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0VXJpID0gdXBsb2FkU3RhdHVzLmdldFJlc3VsdFVyaShibG9iVXJpKTtcbiAgICAgICAgICBpZiAocmVzdWx0VXJpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NyYz1cIicgKyByZXN1bHRVcmkgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgYmxvYkluZm8gPSBibG9iQ2FjaGUuZ2V0QnlVcmkoYmxvYlVyaSk7XG4gICAgICAgICAgaWYgKCFibG9iSW5mbykge1xuICAgICAgICAgICAgYmxvYkluZm8gPSBmb2xkbChlZGl0b3IuZWRpdG9yTWFuYWdlci5nZXQoKSwgKHJlc3VsdCwgZWRpdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZWRpdG9yLmVkaXRvclVwbG9hZCAmJiBlZGl0b3IuZWRpdG9yVXBsb2FkLmJsb2JDYWNoZS5nZXRCeVVyaShibG9iVXJpKTtcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9iSW5mbykge1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGJsb2JJbmZvLmJsb2IoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3JjPVwiZGF0YTonICsgYmxvYi50eXBlICsgJztiYXNlNjQsJyArIGJsb2JJbmZvLmJhc2U2NCgpICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ1NldENvbnRlbnQnLCAoKSA9PiB7XG4gICAgICAgIGlmIChpc0F1dG9tYXRpY1VwbG9hZHNFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgICB1cGxvYWRJbWFnZXNBdXRvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbkZvckltYWdlcygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignUmF3U2F2ZUNvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgZS5jb250ZW50ID0gcmVwbGFjZUJsb2JVcmlzKGUuY29udGVudCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignR2V0Q29udGVudCcsIGUgPT4ge1xuICAgICAgICBpZiAoZS5zb3VyY2VfdmlldyB8fCBlLmZvcm1hdCA9PT0gJ3JhdycgfHwgZS5mb3JtYXQgPT09ICd0cmVlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLmNvbnRlbnQgPSByZXBsYWNlQmxvYlVyaXMoZS5jb250ZW50KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdQb3N0UmVuZGVyJywgKCkgPT4ge1xuICAgICAgICBlZGl0b3IucGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ2ltZycsIGltYWdlcyA9PiB7XG4gICAgICAgICAgZWFjaCRlKGltYWdlcywgaW1nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGltZy5hdHRyKCdzcmMnKTtcbiAgICAgICAgICAgIGlmICghc3JjIHx8IGJsb2JDYWNoZS5nZXRCeVVyaShzcmMpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFVyaSA9IHVwbG9hZFN0YXR1cy5nZXRSZXN1bHRVcmkoc3JjKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRVcmkpIHtcbiAgICAgICAgICAgICAgaW1nLmF0dHIoJ3NyYycsIHJlc3VsdFVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBibG9iQ2FjaGUsXG4gICAgICAgIGFkZEZpbHRlcixcbiAgICAgICAgdXBsb2FkSW1hZ2VzLFxuICAgICAgICB1cGxvYWRJbWFnZXNBdXRvLFxuICAgICAgICBzY2FuRm9ySW1hZ2VzLFxuICAgICAgICBkZXN0cm95XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBnZXQkMSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IGVkaXRvci5zY2hlbWEudHlwZTtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSB7XG4gICAgICAgIHZhbGlnbnRvcDogW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGQsdGgnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHZlcnRpY2FsQWxpZ246ICd0b3AnIH1cbiAgICAgICAgICB9XSxcbiAgICAgICAgdmFsaWdubWlkZGxlOiBbe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZCx0aCcsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdmVydGljYWxBbGlnbjogJ21pZGRsZScgfVxuICAgICAgICAgIH1dLFxuICAgICAgICB2YWxpZ25ib3R0b206IFt7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RkLHRoJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyB9XG4gICAgICAgICAgfV0sXG4gICAgICAgIGFsaWdubGVmdDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLmltYWdlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc2VzOiAnYWxpZ24tbGVmdCcsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdmaWd1cmUscCxoMSxoMixoMyxoNCxoNSxoNix0ZCx0aCx0cixkaXYsdWwsb2wsbGkscHJlJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0QWxpZ246ICdsZWZ0JyB9LFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBwcmV2aWV3OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWcsYXVkaW8sdmlkZW8nLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczogeyBmbG9hdDogJ2xlZnQnIH0sXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICd0YWJsZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICcwcHgnLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25mb3JtYXQ6IHRhYmxlID0+IHtcbiAgICAgICAgICAgICAgZG9tLnNldFN0eWxlKHRhYmxlLCAnZmxvYXQnLCBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICcubWNlLXByZXZpZXctb2JqZWN0LFtkYXRhLWVwaG94LWVtYmVkLWlyaV0nLFxuICAgICAgICAgICAgY2VGYWxzZU92ZXJyaWRlOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGVzOiB7IGZsb2F0OiAnbGVmdCcgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgYWxpZ25jZW50ZXI6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZSxwLGgxLGgyLGgzLGg0LGg1LGg2LHRkLHRoLHRyLGRpdix1bCxvbCxsaSxwcmUnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHRBbGlnbjogJ2NlbnRlcicgfSxcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLmltYWdlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBjbGFzc2VzOiAnYWxpZ24tY2VudGVyJyxcbiAgICAgICAgICAgIGNlRmFsc2VPdmVycmlkZTogdHJ1ZSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ltZyxhdWRpbyx2aWRlbycsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RhYmxlJyxcbiAgICAgICAgICAgIGNvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLm1jZS1wcmV2aWV3LW9iamVjdCcsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2RhdGEtZXBob3gtZW1iZWQtaXJpXScsXG4gICAgICAgICAgICBjZUZhbHNlT3ZlcnJpZGU6IHRydWUsXG4gICAgICAgICAgICBzdHlsZXM6IHtcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJ2F1dG8nLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFsaWducmlnaHQ6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZS5pbWFnZScsXG4gICAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2xhc3NlczogJ2FsaWduLXJpZ2h0JyxcbiAgICAgICAgICAgIGNlRmFsc2VPdmVycmlkZTogdHJ1ZSxcbiAgICAgICAgICAgIHByZXZpZXc6ICdmb250LWZhbWlseSBmb250LXNpemUnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2ZpZ3VyZSxwLGgxLGgyLGgzLGg0LGg1LGg2LHRkLHRoLHRyLGRpdix1bCxvbCxsaSxwcmUnLFxuICAgICAgICAgICAgc3R5bGVzOiB7IHRleHRBbGlnbjogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXG4gICAgICAgICAgICBwcmV2aWV3OiAnZm9udC1mYW1pbHkgZm9udC1zaXplJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdpbWcsYXVkaW8sdmlkZW8nLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczogeyBmbG9hdDogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGFibGUnLFxuICAgICAgICAgICAgY29sbGFwc2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzBweCcsXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZm9ybWF0OiB0YWJsZSA9PiB7XG4gICAgICAgICAgICAgIGRvbS5zZXRTdHlsZSh0YWJsZSwgJ2Zsb2F0JywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnLm1jZS1wcmV2aWV3LW9iamVjdCxbZGF0YS1lcGhveC1lbWJlZC1pcmldJyxcbiAgICAgICAgICAgIGNlRmFsc2VPdmVycmlkZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlczogeyBmbG9hdDogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgcHJldmlldzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFsaWduanVzdGlmeTogW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZmlndXJlLHAsaDEsaDIsaDMsaDQsaDUsaDYsdGQsdGgsdHIsZGl2LHVsLG9sLGxpLHByZScsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdGV4dEFsaWduOiAnanVzdGlmeScgfSxcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlldzogJ2ZvbnQtZmFtaWx5IGZvbnQtc2l6ZSdcbiAgICAgICAgICB9XSxcbiAgICAgICAgYm9sZDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ3N0cm9uZycsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgIHN0eWxlczogeyBmb250V2VpZ2h0OiAnYm9sZCcgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnYicsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpdGFsaWM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdlbScsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgIHN0eWxlczogeyBmb250U3R5bGU6ICdpdGFsaWMnIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlubGluZTogJ2knLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdW5kZXJsaW5lOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgICBzdHlsZXM6IHsgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnIH0sXG4gICAgICAgICAgICBleGFjdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5saW5lOiAndScsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgcHJlc2VydmVfYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgICAnc3R5bGUnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNwYW4gPSB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICAgIHN0eWxlczogeyB0ZXh0RGVjb3JhdGlvbjogJ2xpbmUtdGhyb3VnaCcgfSxcbiAgICAgICAgICAgIGV4YWN0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBzdHJpa2UgPSB7XG4gICAgICAgICAgICBpbmxpbmU6ICdzdHJpa2UnLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgcyA9IHtcbiAgICAgICAgICAgIGlubGluZTogJ3MnLFxuICAgICAgICAgICAgcmVtb3ZlOiAnYWxsJyxcbiAgICAgICAgICAgIHByZXNlcnZlX2F0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgICAgJ3N0eWxlJ1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHNjaGVtYVR5cGUgIT09ICdodG1sNCcgPyBbXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIHN0cmlrZVxuICAgICAgICAgIF0gOiBbXG4gICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHN0cmlrZVxuICAgICAgICAgIF07XG4gICAgICAgIH0pKCksXG4gICAgICAgIGZvcmVjb2xvcjoge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIHN0eWxlczogeyBjb2xvcjogJyV2YWx1ZScgfSxcbiAgICAgICAgICBsaW5rczogdHJ1ZSxcbiAgICAgICAgICByZW1vdmVfc2ltaWxhcjogdHJ1ZSxcbiAgICAgICAgICBjbGVhcl9jaGlsZF9zdHlsZXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgaGlsaXRlY29sb3I6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICBzdHlsZXM6IHsgYmFja2dyb3VuZENvbG9yOiAnJXZhbHVlJyB9LFxuICAgICAgICAgIGxpbmtzOiB0cnVlLFxuICAgICAgICAgIHJlbW92ZV9zaW1pbGFyOiB0cnVlLFxuICAgICAgICAgIGNsZWFyX2NoaWxkX3N0eWxlczogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmb250bmFtZToge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIHRvZ2dsZTogZmFsc2UsXG4gICAgICAgICAgc3R5bGVzOiB7IGZvbnRGYW1pbHk6ICcldmFsdWUnIH0sXG4gICAgICAgICAgY2xlYXJfY2hpbGRfc3R5bGVzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGZvbnRzaXplOiB7XG4gICAgICAgICAgaW5saW5lOiAnc3BhbicsXG4gICAgICAgICAgdG9nZ2xlOiBmYWxzZSxcbiAgICAgICAgICBzdHlsZXM6IHsgZm9udFNpemU6ICcldmFsdWUnIH0sXG4gICAgICAgICAgY2xlYXJfY2hpbGRfc3R5bGVzOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVoZWlnaHQ6IHtcbiAgICAgICAgICBzZWxlY3RvcjogJ2gxLGgyLGgzLGg0LGg1LGg2LHAsbGksdGQsdGgsZGl2JyxcbiAgICAgICAgICBzdHlsZXM6IHsgbGluZUhlaWdodDogJyV2YWx1ZScgfVxuICAgICAgICB9LFxuICAgICAgICBmb250c2l6ZV9jbGFzczoge1xuICAgICAgICAgIGlubGluZTogJ3NwYW4nLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6ICcldmFsdWUnIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2txdW90ZToge1xuICAgICAgICAgIGJsb2NrOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgd3JhcHBlcjogdHJ1ZSxcbiAgICAgICAgICByZW1vdmU6ICdhbGwnXG4gICAgICAgIH0sXG4gICAgICAgIHN1YnNjcmlwdDogeyBpbmxpbmU6ICdzdWInIH0sXG4gICAgICAgIHN1cGVyc2NyaXB0OiB7IGlubGluZTogJ3N1cCcgfSxcbiAgICAgICAgY29kZTogeyBpbmxpbmU6ICdjb2RlJyB9LFxuICAgICAgICBsaW5rOiB7XG4gICAgICAgICAgaW5saW5lOiAnYScsXG4gICAgICAgICAgc2VsZWN0b3I6ICdhJyxcbiAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgIGRlZXA6IHRydWUsXG4gICAgICAgICAgb25tYXRjaDogKG5vZGUsIF9mbXQsIF9pdGVtTmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaGFzQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmZvcm1hdDogKGVsbSwgX2ZtdCwgdmFycykgPT4ge1xuICAgICAgICAgICAgVG9vbHMuZWFjaCh2YXJzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBkb20uc2V0QXR0cmliKGVsbSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxhbmc6IHtcbiAgICAgICAgICBpbmxpbmU6ICdzcGFuJyxcbiAgICAgICAgICBjbGVhcl9jaGlsZF9zdHlsZXM6IHRydWUsXG4gICAgICAgICAgcmVtb3ZlX3NpbWlsYXI6IHRydWUsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2xhbmcnOiAnJXZhbHVlJyxcbiAgICAgICAgICAgICdkYXRhLW1jZS1sYW5nJzogdmFycyA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHZhcnMgPT09IG51bGwgfHwgdmFycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFycy5jdXN0b21WYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZWZvcm1hdDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYixzdHJvbmcsZW0saSxmb250LHUsc3RyaWtlLHMsc3ViLHN1cCxkZm4sY29kZSxzYW1wLGtiZCx2YXIsY2l0ZSxtYXJrLHEsZGVsLGlucyxzbWFsbCcsXG4gICAgICAgICAgICByZW1vdmU6ICdhbGwnLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tfZXhwYW5kOiB0cnVlLFxuICAgICAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdzcGFuJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICAgJ2NsYXNzJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZTogJ2VtcHR5JyxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGRlZXA6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnKicsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXG4gICAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICAgICdjbGFzcydcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzcGxpdDogZmFsc2UsXG4gICAgICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIFRvb2xzLmVhY2goJ3AgaDEgaDIgaDMgaDQgaDUgaDYgZGl2IGFkZHJlc3MgcHJlIGR0IGRkIHNhbXAnLnNwbGl0KC9cXHMvKSwgbmFtZSA9PiB7XG4gICAgICAgIGZvcm1hdHNbbmFtZV0gPSB7XG4gICAgICAgICAgYmxvY2s6IG5hbWUsXG4gICAgICAgICAgcmVtb3ZlOiAnYWxsJ1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9O1xuXG4gICAgY29uc3QgZ2VuZXJpY0Jhc2UgPSB7XG4gICAgICByZW1vdmVfc2ltaWxhcjogdHJ1ZSxcbiAgICAgIGluaGVyaXQ6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjZWxsQmFzZSA9IHtcbiAgICAgIHNlbGVjdG9yOiAndGQsdGgnLFxuICAgICAgLi4uZ2VuZXJpY0Jhc2VcbiAgICB9O1xuICAgIGNvbnN0IGNlbGxGb3JtYXRzID0ge1xuICAgICAgdGFibGVjZWxsYmFja2dyb3VuZGNvbG9yOiB7XG4gICAgICAgIHN0eWxlczogeyBiYWNrZ3JvdW5kQ29sb3I6ICcldmFsdWUnIH0sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjZWxsdmVydGljYWxhbGlnbjoge1xuICAgICAgICBzdHlsZXM6IHsgJ3ZlcnRpY2FsLWFsaWduJzogJyV2YWx1ZScgfSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNlbGxib3JkZXJjb2xvcjoge1xuICAgICAgICBzdHlsZXM6IHsgYm9yZGVyQ29sb3I6ICcldmFsdWUnIH0sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9LFxuICAgICAgdGFibGVjZWxsY2xhc3M6IHtcbiAgICAgICAgY2xhc3NlczogWycldmFsdWUnXSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNsYXNzOiB7XG4gICAgICAgIHNlbGVjdG9yOiAndGFibGUnLFxuICAgICAgICBjbGFzc2VzOiBbJyV2YWx1ZSddLFxuICAgICAgICAuLi5nZW5lcmljQmFzZVxuICAgICAgfSxcbiAgICAgIHRhYmxlY2VsbGJvcmRlcnN0eWxlOiB7XG4gICAgICAgIHN0eWxlczogeyBib3JkZXJTdHlsZTogJyV2YWx1ZScgfSxcbiAgICAgICAgLi4uY2VsbEJhc2VcbiAgICAgIH0sXG4gICAgICB0YWJsZWNlbGxib3JkZXJ3aWR0aDoge1xuICAgICAgICBzdHlsZXM6IHsgYm9yZGVyV2lkdGg6ICcldmFsdWUnIH0sXG4gICAgICAgIC4uLmNlbGxCYXNlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXQgPSBjb25zdGFudChjZWxsRm9ybWF0cyk7XG5cbiAgICBjb25zdCBGb3JtYXRSZWdpc3RyeSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRzID0ge307XG4gICAgICBjb25zdCBnZXQkMiA9IG5hbWUgPT4gaXNOb25OdWxsYWJsZShuYW1lKSA/IGZvcm1hdHNbbmFtZV0gOiBmb3JtYXRzO1xuICAgICAgY29uc3QgaGFzID0gbmFtZSA9PiBoYXMkMihmb3JtYXRzLCBuYW1lKTtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIGZvcm1hdCkgPT4ge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIGlmICghaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgIGVhY2gkZChuYW1lLCAoZm9ybWF0LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyKG5hbWUsIGZvcm1hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5JDEoZm9ybWF0KSkge1xuICAgICAgICAgICAgICBmb3JtYXQgPSBbZm9ybWF0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhY2gkZShmb3JtYXQsIGZvcm1hdCA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChmb3JtYXQuZGVlcCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQuZGVlcCA9ICFpc1NlbGVjdG9yRm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1hdC5zcGxpdCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQuc3BsaXQgPSAhaXNTZWxlY3RvckZvcm1hdChmb3JtYXQpIHx8IGlzSW5saW5lRm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1hdC5yZW1vdmUpICYmIGlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSAmJiAhaXNJbmxpbmVGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdC5yZW1vdmUgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0b3JGb3JtYXQoZm9ybWF0KSAmJiBpc0lubGluZUZvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0Lm1peGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQuYmxvY2tfZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZm9ybWF0LmNsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0LmNsYXNzZXMgPSBmb3JtYXQuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5yZWdpc3RlciA9IG5hbWUgPT4ge1xuICAgICAgICBpZiAobmFtZSAmJiBmb3JtYXRzW25hbWVdKSB7XG4gICAgICAgICAgZGVsZXRlIGZvcm1hdHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9O1xuICAgICAgcmVnaXN0ZXIoZ2V0JDEoZWRpdG9yKSk7XG4gICAgICByZWdpc3RlcihnZXQoKSk7XG4gICAgICByZWdpc3RlcihnZXRGb3JtYXRzKGVkaXRvcikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBnZXQkMixcbiAgICAgICAgaGFzLFxuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgdW5yZWdpc3RlclxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZWFjaCQzID0gVG9vbHMuZWFjaDtcbiAgICBjb25zdCBkb20gPSBET01VdGlscy5ET007XG4gICAgY29uc3QgaXNQcmV2aWV3SXRlbSA9IGl0ZW0gPT4gaXNOb25OdWxsYWJsZShpdGVtKSAmJiBpc09iamVjdChpdGVtKTtcbiAgICBjb25zdCBwYXJzZWRTZWxlY3RvclRvSHRtbCA9IChhbmNlc3RyeSwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBlZGl0b3IgJiYgZWRpdG9yLnNjaGVtYSB8fCBTY2hlbWEoe30pO1xuICAgICAgY29uc3QgZGVjb3JhdGUgPSAoZWxtLCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhlbG0sIGl0ZW0uY2xhc3Nlcy5qb2luKCcgJykpO1xuICAgICAgICB9XG4gICAgICAgIGRvbS5zZXRBdHRyaWJzKGVsbSwgaXRlbS5hdHRycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY3JlYXRlRWxlbWVudCA9IHNJdGVtID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGlzU3RyaW5nKHNJdGVtKSA/IHtcbiAgICAgICAgICBuYW1lOiBzSXRlbSxcbiAgICAgICAgICBjbGFzc2VzOiBbXSxcbiAgICAgICAgICBhdHRyczoge31cbiAgICAgICAgfSA6IHNJdGVtO1xuICAgICAgICBjb25zdCBlbG0gPSBkb20uY3JlYXRlKGl0ZW0ubmFtZSk7XG4gICAgICAgIGRlY29yYXRlKGVsbSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBlbG07XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0UmVxdWlyZWRQYXJlbnQgPSAoZWxtLCBjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZWxtUnVsZSA9IHNjaGVtYS5nZXRFbGVtZW50UnVsZShlbG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGNvbnN0IHBhcmVudHNSZXF1aXJlZCA9IGVsbVJ1bGUgPT09IG51bGwgfHwgZWxtUnVsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxtUnVsZS5wYXJlbnRzUmVxdWlyZWQ7XG4gICAgICAgIGlmIChwYXJlbnRzUmVxdWlyZWQgJiYgcGFyZW50c1JlcXVpcmVkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY29udGFpbnMkMihwYXJlbnRzUmVxdWlyZWQsIGNhbmRpZGF0ZSkgPyBjYW5kaWRhdGUgOiBwYXJlbnRzUmVxdWlyZWRbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgd3JhcEluSHRtbCA9IChlbG0sIGFuY2VzdG9ycywgc2libGluZ3MpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENhbmRpZGF0ZTtcbiAgICAgICAgY29uc3QgYW5jZXN0b3IgPSBhbmNlc3RvcnNbMF07XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yTmFtZSA9IGlzUHJldmlld0l0ZW0oYW5jZXN0b3IpID8gYW5jZXN0b3IubmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50UmVxdWlyZWQgPSBnZXRSZXF1aXJlZFBhcmVudChlbG0sIGFuY2VzdG9yTmFtZSk7XG4gICAgICAgIGlmIChwYXJlbnRSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChhbmNlc3Rvck5hbWUgPT09IHBhcmVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBwYXJlbnRDYW5kaWRhdGUgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZSgxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Q2FuZGlkYXRlID0gcGFyZW50UmVxdWlyZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgcGFyZW50Q2FuZGlkYXRlID0gYW5jZXN0b3I7XG4gICAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzaWJsaW5ncykge1xuICAgICAgICAgIHJldHVybiBlbG07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50Q2FuZGlkYXRlID8gY3JlYXRlRWxlbWVudChwYXJlbnRDYW5kaWRhdGUpIDogZG9tLmNyZWF0ZSgnZGl2Jyk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICBpZiAoc2libGluZ3MpIHtcbiAgICAgICAgICBUb29scy5lYWNoKHNpYmxpbmdzLCBzaWJsaW5nID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmdFbG0gPSBjcmVhdGVFbGVtZW50KHNpYmxpbmcpO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzaWJsaW5nRWxtLCBlbG0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmdzID0gaXNQcmV2aWV3SXRlbShwYXJlbnRDYW5kaWRhdGUpID8gcGFyZW50Q2FuZGlkYXRlLnNpYmxpbmdzIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3JhcEluSHRtbChwYXJlbnQsIGFuY2VzdG9ycywgcGFyZW50U2libGluZ3MpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9tLmNyZWF0ZSgnZGl2Jyk7XG4gICAgICBpZiAoYW5jZXN0cnkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBpdGVtID0gYW5jZXN0cnlbMF07XG4gICAgICAgIGNvbnN0IGVsbSA9IGNyZWF0ZUVsZW1lbnQoaXRlbSk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gaXNQcmV2aWV3SXRlbShpdGVtKSA/IGl0ZW0uc2libGluZ3MgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdyYXBJbkh0bWwoZWxtLCBhbmNlc3RyeS5zbGljZSgxKSwgc2libGluZ3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlU2VsZWN0b3JJdGVtID0gaXRlbSA9PiB7XG4gICAgICBpdGVtID0gVG9vbHMudHJpbShpdGVtKTtcbiAgICAgIGxldCB0YWdOYW1lID0gJ2Rpdic7XG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIG5hbWU6IHRhZ05hbWUsXG4gICAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgICBhdHRyczoge30sXG4gICAgICAgIHNlbGVjdG9yOiBpdGVtXG4gICAgICB9O1xuICAgICAgaWYgKGl0ZW0gIT09ICcqJykge1xuICAgICAgICB0YWdOYW1lID0gaXRlbS5yZXBsYWNlKC8oPzooWyNcXC5dfDo6PykoW1xcd1xcLV0rKXwoXFxbKShbXlxcXV0rKVxcXT8pL2csICgkMCwgJDEsICQyLCAkMywgJDQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKCQxKSB7XG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBvYmouYXR0cnMuaWQgPSAkMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgb2JqLmNsYXNzZXMucHVzaCgkMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIGlmIChUb29scy5pbkFycmF5KCdjaGVja2VkIGRpc2FibGVkIGVuYWJsZWQgcmVhZC1vbmx5IHJlcXVpcmVkJy5zcGxpdCgnICcpLCAkMikgIT09IC0xKSB7XG4gICAgICAgICAgICAgIG9iai5hdHRyc1skMl0gPSAkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJDMgPT09ICdbJykge1xuICAgICAgICAgICAgY29uc3QgbSA9ICQ0Lm1hdGNoKC8oW1xcd1xcLV0rKSg/OlxcPVxcXCIoW15cXFwiXSspKT8vKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgIG9iai5hdHRyc1ttWzFdXSA9IG1bMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvYmoubmFtZSA9IHRhZ05hbWUgfHwgJ2Rpdic7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgY29uc3QgcGFyc2VTZWxlY3RvciA9IHNlbGVjdG9yID0+IHtcbiAgICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc3BsaXQoL1xccyosXFxzKi8pWzBdO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9cXHMqKH5cXCt8fnxcXCt8PilcXHMqL2csICckMScpO1xuICAgICAgcmV0dXJuIFRvb2xzLm1hcChzZWxlY3Rvci5zcGxpdCgvKD86PnxcXHMrKD8hW15cXFtcXF1dK1xcXSkpLyksIGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFRvb2xzLm1hcChpdGVtLnNwbGl0KC8oPzp+XFwrfH58XFwrKS8pLCBwYXJzZVNlbGVjdG9ySXRlbSk7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNpYmxpbmdzLnBvcCgpO1xuICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgb2JqLnNpYmxpbmdzID0gc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldENzc1RleHQgPSAoZWRpdG9yLCBmb3JtYXQpID0+IHtcbiAgICAgIGxldCBwcmV2aWV3Q3NzID0gJyc7XG4gICAgICBsZXQgcHJldmlld1N0eWxlcyA9IGdldFByZXZpZXdTdHlsZXMoZWRpdG9yKTtcbiAgICAgIGlmIChwcmV2aWV3U3R5bGVzID09PSAnJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1vdmVWYXJzID0gdmFsID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwucmVwbGFjZSgvJShcXHcrKS9nLCAnJykgOiAnJztcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKG5hbWUsIGVsbSkgPT4ge1xuICAgICAgICByZXR1cm4gZG9tLmdldFN0eWxlKGVsbSAhPT0gbnVsbCAmJiBlbG0gIT09IHZvaWQgMCA/IGVsbSA6IGVkaXRvci5nZXRCb2R5KCksIG5hbWUsIHRydWUpO1xuICAgICAgfTtcbiAgICAgIGlmIChpc1N0cmluZyhmb3JtYXQpKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHMgPSBlZGl0b3IuZm9ybWF0dGVyLmdldChmb3JtYXQpO1xuICAgICAgICBpZiAoIWZvcm1hdHMpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0c1swXTtcbiAgICAgIH1cbiAgICAgIGlmICgncHJldmlldycgaW4gZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBmb3JtYXQucHJldmlldztcbiAgICAgICAgaWYgKHByZXZpZXcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpZXdTdHlsZXMgPSBwcmV2aWV3IHx8IHByZXZpZXdTdHlsZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBuYW1lID0gZm9ybWF0LmJsb2NrIHx8IGZvcm1hdC5pbmxpbmUgfHwgJ3NwYW4nO1xuICAgICAgbGV0IHByZXZpZXdGcmFnO1xuICAgICAgY29uc3QgaXRlbXMgPSBwYXJzZVNlbGVjdG9yKGZvcm1hdC5zZWxlY3Rvcik7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIWl0ZW1zWzBdLm5hbWUpIHtcbiAgICAgICAgICBpdGVtc1swXS5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gZm9ybWF0LnNlbGVjdG9yO1xuICAgICAgICBwcmV2aWV3RnJhZyA9IHBhcnNlZFNlbGVjdG9yVG9IdG1sKGl0ZW1zLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmlld0ZyYWcgPSBwYXJzZWRTZWxlY3RvclRvSHRtbChbbmFtZV0sIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aWV3RWxtID0gZG9tLnNlbGVjdChuYW1lLCBwcmV2aWV3RnJhZylbMF0gfHwgcHJldmlld0ZyYWcuZmlyc3RDaGlsZDtcbiAgICAgIGVhY2gkMyhmb3JtYXQuc3R5bGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZW1vdmVWYXJzKHZhbHVlKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZG9tLnNldFN0eWxlKHByZXZpZXdFbG0sIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYWNoJDMoZm9ybWF0LmF0dHJpYnV0ZXMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHJlbW92ZVZhcnModmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmliKHByZXZpZXdFbG0sIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYWNoJDMoZm9ybWF0LmNsYXNzZXMsIHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZW1vdmVWYXJzKHZhbHVlKTtcbiAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3MocHJldmlld0VsbSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKHByZXZpZXdFbG0sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2goJ1ByZXZpZXdGb3JtYXRzJyk7XG4gICAgICBkb20uc2V0U3R5bGVzKHByZXZpZXdGcmFnLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBsZWZ0OiAtNjU1MzVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmdldEJvZHkoKS5hcHBlbmRDaGlsZChwcmV2aWV3RnJhZyk7XG4gICAgICBjb25zdCByYXdQYXJlbnRGb250U2l6ZSA9IGdldENvbXB1dGVkU3R5bGUoJ2ZvbnRTaXplJyk7XG4gICAgICBjb25zdCBwYXJlbnRGb250U2l6ZSA9IC9weCQvLnRlc3QocmF3UGFyZW50Rm9udFNpemUpID8gcGFyc2VJbnQocmF3UGFyZW50Rm9udFNpemUsIDEwKSA6IDA7XG4gICAgICBlYWNoJDMocHJldmlld1N0eWxlcy5zcGxpdCgnICcpLCBuYW1lID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZShuYW1lLCBwcmV2aWV3RWxtKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kLWNvbG9yJyAmJiAvdHJhbnNwYXJlbnR8cmdiYVxccypcXChbXildKyxcXHMqMFxcKS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldENvbXB1dGVkU3R5bGUobmFtZSk7XG4gICAgICAgICAgaWYgKHJnYmFUb0hleFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gJyNmZmZmZmYnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgaWYgKHJnYmFUb0hleFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gJyMwMDAwMDAnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnZm9udC1zaXplJykge1xuICAgICAgICAgIGlmICgvZW18JSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50Rm9udFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbnVtVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSAvICgvJSQvLnRlc3QodmFsdWUpID8gMTAwIDogMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bVZhbHVlICogcGFyZW50Rm9udFNpemUgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2JvcmRlcicgJiYgdmFsdWUpIHtcbiAgICAgICAgICBwcmV2aWV3Q3NzICs9ICdwYWRkaW5nOjAgMnB4Oyc7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlld0NzcyArPSBuYW1lICsgJzonICsgdmFsdWUgKyAnOyc7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnQWZ0ZXJQcmV2aWV3Rm9ybWF0cycpO1xuICAgICAgZG9tLnJlbW92ZShwcmV2aWV3RnJhZyk7XG4gICAgICByZXR1cm4gcHJldmlld0NzcztcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuYWRkU2hvcnRjdXQoJ21ldGErYicsICcnLCAnQm9sZCcpO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK2knLCAnJywgJ0l0YWxpYycpO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK3UnLCAnJywgJ1VuZGVybGluZScpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNjsgaSsrKSB7XG4gICAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKycgKyBpLCAnJywgW1xuICAgICAgICAgICdGb3JtYXRCbG9jaycsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ2gnICsgaVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKzcnLCAnJywgW1xuICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ3AnXG4gICAgICBdKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnYWNjZXNzKzgnLCAnJywgW1xuICAgICAgICAnRm9ybWF0QmxvY2snLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ2RpdidcbiAgICAgIF0pO1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdhY2Nlc3MrOScsICcnLCBbXG4gICAgICAgICdGb3JtYXRCbG9jaycsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnYWRkcmVzcydcbiAgICAgIF0pO1xuICAgIH07XG5cbiAgICBjb25zdCBGb3JtYXR0ZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IEZvcm1hdFJlZ2lzdHJ5KGVkaXRvcik7XG4gICAgICBjb25zdCBmb3JtYXRDaGFuZ2VTdGF0ZSA9IENlbGwoe30pO1xuICAgICAgc2V0dXAkcihlZGl0b3IpO1xuICAgICAgc2V0dXAkdShlZGl0b3IpO1xuICAgICAgaWYgKCFpc1J0YyhlZGl0b3IpKSB7XG4gICAgICAgIHNldHVwJHQoZm9ybWF0Q2hhbmdlU3RhdGUsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZvcm1hdHMuZ2V0LFxuICAgICAgICBoYXM6IGZvcm1hdHMuaGFzLFxuICAgICAgICByZWdpc3RlcjogZm9ybWF0cy5yZWdpc3RlcixcbiAgICAgICAgdW5yZWdpc3RlcjogZm9ybWF0cy51bnJlZ2lzdGVyLFxuICAgICAgICBhcHBseTogKG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgICAgICBhcHBseUZvcm1hdChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiB7XG4gICAgICAgICAgcmVtb3ZlRm9ybWF0KGVkaXRvciwgbmFtZSwgdmFycywgbm9kZSwgc2ltaWxhcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogKG5hbWUsIHZhcnMsIG5vZGUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoZWRpdG9yLCBuYW1lLCB2YXJzLCBub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2g6IChuYW1lLCB2YXJzLCBub2RlLCBzaW1pbGFyKSA9PiBtYXRjaEZvcm1hdChlZGl0b3IsIG5hbWUsIHZhcnMsIG5vZGUsIHNpbWlsYXIpLFxuICAgICAgICBjbG9zZXN0OiBuYW1lcyA9PiBjbG9zZXN0Rm9ybWF0KGVkaXRvciwgbmFtZXMpLFxuICAgICAgICBtYXRjaEFsbDogKG5hbWVzLCB2YXJzKSA9PiBtYXRjaEFsbEZvcm1hdHMoZWRpdG9yLCBuYW1lcywgdmFycyksXG4gICAgICAgIG1hdGNoTm9kZTogKG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpID0+IG1hdGNoTm9kZUZvcm1hdChlZGl0b3IsIG5vZGUsIG5hbWUsIHZhcnMsIHNpbWlsYXIpLFxuICAgICAgICBjYW5BcHBseTogbmFtZSA9PiBjYW5BcHBseUZvcm1hdChlZGl0b3IsIG5hbWUpLFxuICAgICAgICBmb3JtYXRDaGFuZ2VkOiAoZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpID0+IGZvcm1hdENoYW5nZWQoZWRpdG9yLCBmb3JtYXRDaGFuZ2VTdGF0ZSwgZm9ybWF0cywgY2FsbGJhY2ssIHNpbWlsYXIsIHZhcnMpLFxuICAgICAgICBnZXRDc3NUZXh0OiBjdXJyeShnZXRDc3NUZXh0LCBlZGl0b3IpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBzaG91bGRJZ25vcmVDb21tYW5kID0gY21kID0+IHtcbiAgICAgIHN3aXRjaCAoY21kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ3VuZG8nOlxuICAgICAgY2FzZSAncmVkbyc6XG4gICAgICBjYXNlICdtY2Vmb2N1cyc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJFdmVudHMgPSAoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MpID0+IHtcbiAgICAgIGNvbnN0IGlzRmlyc3RUeXBlZENoYXJhY3RlciA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgYWRkTm9uVHlwaW5nVW5kb0xldmVsID0gZSA9PiB7XG4gICAgICAgIHNldFR5cGluZyh1bmRvTWFuYWdlciwgZmFsc2UsIGxvY2tzKTtcbiAgICAgICAgdW5kb01hbmFnZXIuYWRkKHt9LCBlKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmFkZCgpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0JlZm9yZUV4ZWNDb21tYW5kJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGUuY29tbWFuZDtcbiAgICAgICAgaWYgKCFzaG91bGRJZ25vcmVDb21tYW5kKGNtZCkpIHtcbiAgICAgICAgICBlbmRUeXBpbmcodW5kb01hbmFnZXIsIGxvY2tzKTtcbiAgICAgICAgICB1bmRvTWFuYWdlci5iZWZvcmVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0V4ZWNDb21tYW5kJywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGUuY29tbWFuZDtcbiAgICAgICAgaWYgKCFzaG91bGRJZ25vcmVDb21tYW5kKGNtZCkpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdPYmplY3RSZXNpemVTdGFydCBjdXQnLCAoKSA9PiB7XG4gICAgICAgIHVuZG9NYW5hZ2VyLmJlZm9yZUNoYW5nZSgpO1xuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ1NhdmVDb250ZW50IE9iamVjdFJlc2l6ZWQgYmx1cicsIGFkZE5vblR5cGluZ1VuZG9MZXZlbCk7XG4gICAgICBlZGl0b3Iub24oJ2RyYWdlbmQnLCBhZGROb25UeXBpbmdVbmRvTGV2ZWwpO1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGUgPT4ge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc01ldGEgPSBFbnYub3MuaXNNYWNPUygpICYmIGUua2V5ID09PSAnTWV0YSc7XG4gICAgICAgIGlmIChrZXlDb2RlID49IDMzICYmIGtleUNvZGUgPD0gMzYgfHwga2V5Q29kZSA+PSAzNyAmJiBrZXlDb2RlIDw9IDQwIHx8IGtleUNvZGUgPT09IDQ1IHx8IGUuY3RybEtleSB8fCBpc01ldGEpIHtcbiAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoKTtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gNDYgfHwga2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuZ2V0KCkgJiYgdW5kb01hbmFnZXIudHlwaW5nICYmICFpc0VxJDEoY3JlYXRlRnJvbUVkaXRvcihlZGl0b3IpLCB1bmRvTWFuYWdlci5kYXRhWzBdKSkge1xuICAgICAgICAgIGlmICghZWRpdG9yLmlzRGlydHkoKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNldERpcnR5KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1R5cGluZ1VuZG8nKTtcbiAgICAgICAgICBpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuc2V0KGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPj0gMzMgJiYga2V5Q29kZSA8PSAzNiB8fCBrZXlDb2RlID49IDM3ICYmIGtleUNvZGUgPD0gNDAgfHwga2V5Q29kZSA9PT0gNDUpIHtcbiAgICAgICAgICBpZiAodW5kb01hbmFnZXIudHlwaW5nKSB7XG4gICAgICAgICAgICBhZGROb25UeXBpbmdVbmRvTGV2ZWwoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RLZXkgPSBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IGUubWV0YUtleTtcbiAgICAgICAgaWYgKChrZXlDb2RlIDwgMTYgfHwga2V5Q29kZSA+IDIwKSAmJiBrZXlDb2RlICE9PSAyMjQgJiYga2V5Q29kZSAhPT0gOTEgJiYgIXVuZG9NYW5hZ2VyLnR5cGluZyAmJiAhbW9kS2V5KSB7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgICAgc2V0VHlwaW5nKHVuZG9NYW5hZ2VyLCB0cnVlLCBsb2Nrcyk7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYWRkKHt9LCBlKTtcbiAgICAgICAgICBpc0ZpcnN0VHlwZWRDaGFyYWN0ZXIuc2V0KHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNPbmx5TWV0YU9yQ3RybE1vZGlmaWVyID0gRW52Lm9zLmlzTWFjT1MoKSA/IGUubWV0YUtleSA6IGUuY3RybEtleSAmJiAhZS5hbHRLZXk7XG4gICAgICAgIGlmIChoYXNPbmx5TWV0YU9yQ3RybE1vZGlmaWVyKSB7XG4gICAgICAgICAgdW5kb01hbmFnZXIuYmVmb3JlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnR5cGluZykge1xuICAgICAgICAgIGFkZE5vblR5cGluZ1VuZG9MZXZlbChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBpc0luc2VydFJlcGxhY2VtZW50VGV4dCA9IGV2ZW50ID0+IGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydFJlcGxhY2VtZW50VGV4dCc7XG4gICAgICBjb25zdCBpc0luc2VydFRleHREYXRhTnVsbCA9IGV2ZW50ID0+IGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydFRleHQnICYmIGV2ZW50LmRhdGEgPT09IG51bGw7XG4gICAgICBjb25zdCBpc0luc2VydEZyb21QYXN0ZU9yRHJvcCA9IGV2ZW50ID0+IGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21QYXN0ZScgfHwgZXZlbnQuaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbURyb3AnO1xuICAgICAgZWRpdG9yLm9uKCdpbnB1dCcsIGUgPT4ge1xuICAgICAgICBpZiAoZS5pbnB1dFR5cGUgJiYgKGlzSW5zZXJ0UmVwbGFjZW1lbnRUZXh0KGUpIHx8IGlzSW5zZXJ0VGV4dERhdGFOdWxsKGUpIHx8IGlzSW5zZXJ0RnJvbVBhc3RlT3JEcm9wKGUpKSkge1xuICAgICAgICAgIGFkZE5vblR5cGluZ1VuZG9MZXZlbChlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ0FkZFVuZG8gVW5kbyBSZWRvIENsZWFyVW5kb3MnLCBlID0+IHtcbiAgICAgICAgaWYgKCFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdtZXRhK3onLCAnJywgJ1VuZG8nKTtcbiAgICAgIGVkaXRvci5hZGRTaG9ydGN1dCgnbWV0YSt5LG1ldGErc2hpZnQreicsICcnLCAnUmVkbycpO1xuICAgIH07XG5cbiAgICBjb25zdCBVbmRvTWFuYWdlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBiZWZvcmVCb29rbWFyayA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IGxvY2tzID0gQ2VsbCgwKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gQ2VsbCgwKTtcbiAgICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0ge1xuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgdHlwaW5nOiBmYWxzZSxcbiAgICAgICAgYmVmb3JlQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgYmVmb3JlQ2hhbmdlKGVkaXRvciwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiAobGV2ZWwsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGFkZFVuZG9MZXZlbChlZGl0b3IsIHVuZG9NYW5hZ2VyLCBpbmRleCwgbG9ja3MsIGJlZm9yZUJvb2ttYXJrLCBsZXZlbCwgZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwYXRjaENoYW5nZTogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZXREaXJ0eSh0cnVlKTtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGNyZWF0ZUZyb21FZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgICBsZXZlbC5ib29rbWFyayA9IGdldFVuZG9Cb29rbWFyayhlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgbGFzdExldmVsOiBnZXQkYih1bmRvTWFuYWdlci5kYXRhLCBpbmRleC5nZXQoKSkuZ2V0T3JVbmRlZmluZWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHVuZG8oZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVkbzogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWRvKGVkaXRvciwgaW5kZXgsIHVuZG9NYW5hZ2VyLmRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICAgIGNsZWFyKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICByZXNldChlZGl0b3IsIHVuZG9NYW5hZ2VyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzVW5kbzogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBoYXNVbmRvKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzUmVkbzogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBoYXNSZWRvKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNhY3Q6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgICByZXR1cm4gdHJhbnNhY3QoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgaWdub3JlOiBjYWxsYmFjayA9PiB7XG4gICAgICAgICAgaWdub3JlKGVkaXRvciwgbG9ja3MsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0cmE6IChjYWxsYmFjazEsIGNhbGxiYWNrMikgPT4ge1xuICAgICAgICAgIGV4dHJhKGVkaXRvciwgdW5kb01hbmFnZXIsIGluZGV4LCBjYWxsYmFjazEsIGNhbGxiYWNrMik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgcmVnaXN0ZXJFdmVudHMoZWRpdG9yLCB1bmRvTWFuYWdlciwgbG9ja3MpO1xuICAgICAgfVxuICAgICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoZWRpdG9yKTtcbiAgICAgIHJldHVybiB1bmRvTWFuYWdlcjtcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9uVHlwaW5nS2V5Y29kZXMgPSBbXG4gICAgICA5LFxuICAgICAgMjcsXG4gICAgICBWSy5IT01FLFxuICAgICAgVksuRU5ELFxuICAgICAgMTksXG4gICAgICAyMCxcbiAgICAgIDQ0LFxuICAgICAgMTQ0LFxuICAgICAgMTQ1LFxuICAgICAgMzMsXG4gICAgICAzNCxcbiAgICAgIDQ1LFxuICAgICAgMTYsXG4gICAgICAxNyxcbiAgICAgIDE4LFxuICAgICAgOTEsXG4gICAgICA5MixcbiAgICAgIDkzLFxuICAgICAgVksuRE9XTixcbiAgICAgIFZLLlVQLFxuICAgICAgVksuTEVGVCxcbiAgICAgIFZLLlJJR0hUXG4gICAgXS5jb25jYXQoRW52LmJyb3dzZXIuaXNGaXJlZm94KCkgPyBbMjI0XSA6IFtdKTtcbiAgICBjb25zdCBwbGFjZWhvbGRlckF0dHIgPSAnZGF0YS1tY2UtcGxhY2Vob2xkZXInO1xuICAgIGNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IGUgPT4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5dXAnO1xuICAgIGNvbnN0IGlzRGVsZXRlRXZlbnQgPSBlID0+IHtcbiAgICAgIGNvbnN0IGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICByZXR1cm4ga2V5Q29kZSA9PT0gVksuQkFDS1NQQUNFIHx8IGtleUNvZGUgPT09IFZLLkRFTEVURTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTm9uVHlwaW5nS2V5Ym9hcmRFdmVudCA9IGUgPT4ge1xuICAgICAgaWYgKGlzS2V5Ym9hcmRFdmVudChlKSkge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICByZXR1cm4gIWlzRGVsZXRlRXZlbnQoZSkgJiYgKFZLLm1ldGFLZXlQcmVzc2VkKGUpIHx8IGUuYWx0S2V5IHx8IGtleUNvZGUgPj0gMTEyICYmIGtleUNvZGUgPD0gMTIzIHx8IGNvbnRhaW5zJDIobm9uVHlwaW5nS2V5Y29kZXMsIGtleUNvZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzVHlwaW5nS2V5Ym9hcmRFdmVudCA9IGUgPT4gaXNLZXlib2FyZEV2ZW50KGUpICYmICEoaXNEZWxldGVFdmVudChlKSB8fCBlLnR5cGUgPT09ICdrZXl1cCcgJiYgZS5rZXlDb2RlID09PSAyMjkpO1xuICAgIGNvbnN0IGlzVmlzdWFsbHlFbXB0eSA9IChkb20sIHJvb3RFbG0sIGZvcmNlZFJvb3RCbG9jaykgPT4ge1xuICAgICAgaWYgKGlzRW1wdHkkMihTdWdhckVsZW1lbnQuZnJvbURvbShyb290RWxtKSwgZmFsc2UpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IHJvb3RFbG0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIGlmICghZmlyc3RFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9tLmdldFN0eWxlKHJvb3RFbG0uZmlyc3RFbGVtZW50Q2hpbGQsICdwYWRkaW5nLWxlZnQnKSB8fCBkb20uZ2V0U3R5bGUocm9vdEVsbS5maXJzdEVsZW1lbnRDaGlsZCwgJ3BhZGRpbmctcmlnaHQnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2VkUm9vdEJsb2NrID09PSBmaXJzdEVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkcSA9IGVkaXRvciA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgcm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChfYSA9IGdldFBsYWNlaG9sZGVyKGVkaXRvcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgY29uc3QgdXBkYXRlUGxhY2Vob2xkZXIgPSAoZSwgaW5pdGlhbCkgPT4ge1xuICAgICAgICBpZiAoaXNOb25UeXBpbmdLZXlib2FyZEV2ZW50KGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSBpc1R5cGluZ0tleWJvYXJkRXZlbnQoZSkgPyBmYWxzZSA6IGlzVmlzdWFsbHlFbXB0eShkb20sIGJvZHksIHJvb3RCbG9jayk7XG4gICAgICAgIGNvbnN0IGlzUGxhY2Vob2xkZXJTaG93biA9IGRvbS5nZXRBdHRyaWIoYm9keSwgcGxhY2Vob2xkZXJBdHRyKSAhPT0gJyc7XG4gICAgICAgIGlmIChpc1BsYWNlaG9sZGVyU2hvd24gIT09IHNob3dQbGFjZWhvbGRlciB8fCBpbml0aWFsKSB7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihib2R5LCBwbGFjZWhvbGRlckF0dHIsIHNob3dQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogbnVsbCk7XG4gICAgICAgICAgZG9tLnNldEF0dHJpYihib2R5LCAnYXJpYS1wbGFjZWhvbGRlcicsIHNob3dQbGFjZWhvbGRlciA/IHBsYWNlaG9sZGVyIDogbnVsbCk7XG4gICAgICAgICAgZmlyZVBsYWNlaG9sZGVyVG9nZ2xlKGVkaXRvciwgc2hvd1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICBlZGl0b3Iub24oc2hvd1BsYWNlaG9sZGVyID8gJ2tleWRvd24nIDogJ2tleXVwJywgdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGVkaXRvci5vZmYoc2hvd1BsYWNlaG9sZGVyID8gJ2tleXVwJyA6ICdrZXlkb3duJywgdXBkYXRlUGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzTm90RW1wdHkocGxhY2Vob2xkZXIpKSB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsIGUgPT4ge1xuICAgICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyKGUsIHRydWUpO1xuICAgICAgICAgIGVkaXRvci5vbignY2hhbmdlIFNldENvbnRlbnQgRXhlY0NvbW1hbmQnLCB1cGRhdGVQbGFjZWhvbGRlcik7XG4gICAgICAgICAgZWRpdG9yLm9uKCdwYXN0ZScsIGUgPT4gRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHVwZGF0ZVBsYWNlaG9sZGVyKGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBibG9ja1Bvc2l0aW9uID0gKGJsb2NrLCBwb3NpdGlvbikgPT4gKHtcbiAgICAgIGJsb2NrLFxuICAgICAgcG9zaXRpb25cbiAgICB9KTtcbiAgICBjb25zdCBibG9ja0JvdW5kYXJ5ID0gKGZyb20sIHRvKSA9PiAoe1xuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0QmxvY2tQb3NpdGlvbiA9IChyb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCByb290RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdE5vZGUpO1xuICAgICAgY29uc3QgY29udGFpbmVyRWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKTtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQyKHJvb3RFbG0sIGNvbnRhaW5lckVsbSkubWFwKGJsb2NrID0+IGJsb2NrUG9zaXRpb24oYmxvY2ssIHBvcykpO1xuICAgIH07XG4gICAgY29uc3QgaXNEaWZmZXJlbnRCbG9ja3MgPSBibG9ja0JvdW5kYXJ5ID0+ICFlcShibG9ja0JvdW5kYXJ5LmZyb20uYmxvY2ssIGJsb2NrQm91bmRhcnkudG8uYmxvY2spO1xuICAgIGNvbnN0IGdldENsb3Nlc3RIb3N0ID0gKHJvb3QsIHNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBub2RlID0+IGVxKG5vZGUsIHJvb3QpO1xuICAgICAgY29uc3QgaXNIb3N0ID0gbm9kZSA9PiBpc1RhYmxlQ2VsbCQyKG5vZGUpIHx8IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKG5vZGUuZG9tKTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDQoc2NvcGUsIGlzSG9zdCwgaXNSb290KS5maWx0ZXIoaXNFbGVtZW50JDcpLmdldE9yKHJvb3QpO1xuICAgIH07XG4gICAgY29uc3QgaGFzU2FtZUhvc3QgPSAocm9vdE5vZGUsIGJsb2NrQm91bmRhcnkpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSk7XG4gICAgICByZXR1cm4gZXEoZ2V0Q2xvc2VzdEhvc3Qocm9vdCwgYmxvY2tCb3VuZGFyeS5mcm9tLmJsb2NrKSwgZ2V0Q2xvc2VzdEhvc3Qocm9vdCwgYmxvY2tCb3VuZGFyeS50by5ibG9jaykpO1xuICAgIH07XG4gICAgY29uc3QgaXNFZGl0YWJsZSQxID0gYmxvY2tCb3VuZGFyeSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoYmxvY2tCb3VuZGFyeS5mcm9tLmJsb2NrLmRvbSkgPT09IGZhbHNlICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihibG9ja0JvdW5kYXJ5LnRvLmJsb2NrLmRvbSkgPT09IGZhbHNlO1xuICAgIGNvbnN0IGhhc1ZhbGlkQmxvY2tzID0gYmxvY2tCb3VuZGFyeSA9PiB7XG4gICAgICBjb25zdCBpc1ZhbGlkQmxvY2sgPSBibG9jayA9PiBpc1RleHRCbG9jayQyKGJsb2NrKSB8fCBoYXNCbG9ja0F0dHIoYmxvY2suZG9tKTtcbiAgICAgIHJldHVybiBpc1ZhbGlkQmxvY2soYmxvY2tCb3VuZGFyeS5mcm9tLmJsb2NrKSAmJiBpc1ZhbGlkQmxvY2soYmxvY2tCb3VuZGFyeS50by5ibG9jayk7XG4gICAgfTtcbiAgICBjb25zdCBza2lwTGFzdEJyID0gKHJvb3ROb2RlLCBmb3J3YXJkLCBibG9ja1Bvc2l0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNCciQ2KGJsb2NrUG9zaXRpb24ucG9zaXRpb24uZ2V0Tm9kZSgpKSAmJiAhaXNFbXB0eSQyKGJsb2NrUG9zaXRpb24uYmxvY2spKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbkluKGZhbHNlLCBibG9ja1Bvc2l0aW9uLmJsb2NrLmRvbSkuYmluZChsYXN0UG9zaXRpb25JbkJsb2NrID0+IHtcbiAgICAgICAgICBpZiAobGFzdFBvc2l0aW9uSW5CbG9jay5pc0VxdWFsKGJsb2NrUG9zaXRpb24ucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVBvc2l0aW9uKGZvcndhcmQsIHJvb3ROb2RlLCBsYXN0UG9zaXRpb25JbkJsb2NrKS5iaW5kKHRvID0+IGdldEJsb2NrUG9zaXRpb24ocm9vdE5vZGUsIHRvKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGJsb2NrUG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuZ2V0T3IoYmxvY2tQb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmxvY2tQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlYWRGcm9tUmFuZ2UgPSAocm9vdE5vZGUsIGZvcndhcmQsIHJuZykgPT4ge1xuICAgICAgY29uc3QgZnJvbUJsb2NrUG9zID0gZ2V0QmxvY2tQb3NpdGlvbihyb290Tm9kZSwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpKTtcbiAgICAgIGNvbnN0IHRvQmxvY2tQb3MgPSBmcm9tQmxvY2tQb3MuYmluZChibG9ja1BvcyA9PiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdE5vZGUsIGJsb2NrUG9zLnBvc2l0aW9uKS5iaW5kKHRvID0+IGdldEJsb2NrUG9zaXRpb24ocm9vdE5vZGUsIHRvKS5tYXAoYmxvY2tQb3MgPT4gc2tpcExhc3RCcihyb290Tm9kZSwgZm9yd2FyZCwgYmxvY2tQb3MpKSkpO1xuICAgICAgcmV0dXJuIGxpZnQyKGZyb21CbG9ja1BvcywgdG9CbG9ja1BvcywgYmxvY2tCb3VuZGFyeSkuZmlsdGVyKGJsb2NrQm91bmRhcnkgPT4gaXNEaWZmZXJlbnRCbG9ja3MoYmxvY2tCb3VuZGFyeSkgJiYgaGFzU2FtZUhvc3Qocm9vdE5vZGUsIGJsb2NrQm91bmRhcnkpICYmIGlzRWRpdGFibGUkMShibG9ja0JvdW5kYXJ5KSAmJiBoYXNWYWxpZEJsb2NrcyhibG9ja0JvdW5kYXJ5KSk7XG4gICAgfTtcbiAgICBjb25zdCByZWFkJDEgPSAocm9vdE5vZGUsIGZvcndhcmQsIHJuZykgPT4gcm5nLmNvbGxhcHNlZCA/IHJlYWRGcm9tUmFuZ2Uocm9vdE5vZGUsIGZvcndhcmQsIHJuZykgOiBPcHRpb25hbC5ub25lKCk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlblVudGlsQmxvY2tCb3VuZGFyeSA9IGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW4kMShibG9jayk7XG4gICAgICByZXR1cm4gZmluZEluZGV4JDIoY2hpbGRyZW4sIGlzQmxvY2skMikuZm9sZChjb25zdGFudChjaGlsZHJlbiksIGluZGV4ID0+IGNoaWxkcmVuLnNsaWNlKDAsIGluZGV4KSk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0Q2hpbGRyZW4gPSBibG9jayA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuVW50aWxCbG9ja0JvdW5kYXJ5KGJsb2NrKTtcbiAgICAgIGVhY2gkZShjaGlsZHJlbiwgcmVtb3ZlJDUpO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRW1wdHlSb290ID0gKHJvb3ROb2RlLCBibG9jaykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKGJsb2NrLCByb290Tm9kZSk7XG4gICAgICByZXR1cm4gZmluZCQyKHBhcmVudHMucmV2ZXJzZSgpLCBlbGVtZW50ID0+IGlzRW1wdHkkMihlbGVtZW50KSkuZWFjaChyZW1vdmUkNSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5QmVmb3JlID0gZWwgPT4gZmlsdGVyJDUocHJldlNpYmxpbmdzKGVsKSwgZWwgPT4gIWlzRW1wdHkkMihlbCkpLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBuZXN0ZWRCbG9ja01lcmdlID0gKHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2ssIGluc2VydGlvblBvaW50KSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQyKHRvQmxvY2spKSB7XG4gICAgICAgIGZpbGxXaXRoUGFkZGluZ0JyKHRvQmxvY2spO1xuICAgICAgICByZXR1cm4gZmlyc3RQb3NpdGlvbkluKHRvQmxvY2suZG9tKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VtcHR5QmVmb3JlKGluc2VydGlvblBvaW50KSAmJiBpc0VtcHR5JDIoZnJvbUJsb2NrKSkge1xuICAgICAgICBiZWZvcmUkMyhpbnNlcnRpb25Qb2ludCwgU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zaXRpb24gPSBwcmV2UG9zaXRpb24odG9CbG9jay5kb20sIENhcmV0UG9zaXRpb24uYmVmb3JlKGluc2VydGlvblBvaW50LmRvbSkpO1xuICAgICAgZWFjaCRlKGV4dHJhY3RDaGlsZHJlbihmcm9tQmxvY2spLCBjaGlsZCA9PiB7XG4gICAgICAgIGJlZm9yZSQzKGluc2VydGlvblBvaW50LCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUVtcHR5Um9vdChyb290Tm9kZSwgZnJvbUJsb2NrKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IHNpZGVsb25nQmxvY2tNZXJnZSA9IChyb290Tm9kZSwgZnJvbUJsb2NrLCB0b0Jsb2NrKSA9PiB7XG4gICAgICBpZiAoaXNFbXB0eSQyKHRvQmxvY2spKSB7XG4gICAgICAgIGlmIChpc0VtcHR5JDIoZnJvbUJsb2NrKSkge1xuICAgICAgICAgIGNvbnN0IGdldElubGluZVRvQmxvY2tEZXNjZW5kYW50cyA9IGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlbHBlciA9IChub2RlLCBlbGVtZW50cykgPT4gZmlyc3RDaGlsZChub2RlKS5mb2xkKCgpID0+IGVsZW1lbnRzLCBjaGlsZCA9PiBpc0lubGluZSQxKGNoaWxkKSA/IGhlbHBlcihjaGlsZCwgZWxlbWVudHMuY29uY2F0KHNoYWxsb3ckMShjaGlsZCkpKSA6IGVsZW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIoZWwsIFtdKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IG5ld0Zyb21CbG9ja0Rlc2NlbmRhbnRzID0gZm9sZHIoZ2V0SW5saW5lVG9CbG9ja0Rlc2NlbmRhbnRzKHRvQmxvY2spLCAoZWxlbWVudCwgZGVzY2VuZGFudCkgPT4ge1xuICAgICAgICAgICAgd3JhcCQyKGVsZW1lbnQsIGRlc2NlbmRhbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gICAgICAgICAgfSwgY3JlYXRlUGFkZGluZ0JyKCkpO1xuICAgICAgICAgIGVtcHR5KGZyb21CbG9jayk7XG4gICAgICAgICAgYXBwZW5kJDEoZnJvbUJsb2NrLCBuZXdGcm9tQmxvY2tEZXNjZW5kYW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlJDUodG9CbG9jayk7XG4gICAgICAgIHJldHVybiBmaXJzdFBvc2l0aW9uSW4oZnJvbUJsb2NrLmRvbSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGxhc3RQb3NpdGlvbkluKHRvQmxvY2suZG9tKTtcbiAgICAgIGVhY2gkZShleHRyYWN0Q2hpbGRyZW4oZnJvbUJsb2NrKSwgY2hpbGQgPT4ge1xuICAgICAgICBhcHBlbmQkMSh0b0Jsb2NrLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUVtcHR5Um9vdChyb290Tm9kZSwgZnJvbUJsb2NrKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRJbnNlcnRpb25Qb2ludCA9ICh0b0Jsb2NrLCBibG9jaykgPT4ge1xuICAgICAgY29uc3QgcGFyZW50c0FuZFNlbGYkMSA9IHBhcmVudHNBbmRTZWxmKGJsb2NrLCB0b0Jsb2NrKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHBhcmVudHNBbmRTZWxmJDFbcGFyZW50c0FuZFNlbGYkMS5sZW5ndGggLSAxXSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbnNlcnRpb25Qb2ludCA9IChmcm9tQmxvY2ssIHRvQmxvY2spID0+IGNvbnRhaW5zKHRvQmxvY2ssIGZyb21CbG9jaykgPyBmaW5kSW5zZXJ0aW9uUG9pbnQodG9CbG9jaywgZnJvbUJsb2NrKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICBjb25zdCB0cmltQnIgPSAoZmlyc3QsIGJsb2NrKSA9PiB7XG4gICAgICBwb3NpdGlvbkluKGZpcnN0LCBibG9jay5kb20pLmJpbmQocG9zaXRpb24gPT4gT3B0aW9uYWwuZnJvbShwb3NpdGlvbi5nZXROb2RlKCkpKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pLmZpbHRlcihpc0JyJDUpLmVhY2gocmVtb3ZlJDUpO1xuICAgIH07XG4gICAgY29uc3QgbWVyZ2VCbG9ja0ludG8gPSAocm9vdE5vZGUsIGZyb21CbG9jaywgdG9CbG9jaykgPT4ge1xuICAgICAgdHJpbUJyKHRydWUsIGZyb21CbG9jayk7XG4gICAgICB0cmltQnIoZmFsc2UsIHRvQmxvY2spO1xuICAgICAgcmV0dXJuIGdldEluc2VydGlvblBvaW50KGZyb21CbG9jaywgdG9CbG9jaykuZm9sZChjdXJyeShzaWRlbG9uZ0Jsb2NrTWVyZ2UsIHJvb3ROb2RlLCBmcm9tQmxvY2ssIHRvQmxvY2spLCBjdXJyeShuZXN0ZWRCbG9ja01lcmdlLCByb290Tm9kZSwgZnJvbUJsb2NrLCB0b0Jsb2NrKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXJnZUJsb2NrcyA9IChyb290Tm9kZSwgZm9yd2FyZCwgYmxvY2sxLCBibG9jazIpID0+IGZvcndhcmQgPyBtZXJnZUJsb2NrSW50byhyb290Tm9kZSwgYmxvY2syLCBibG9jazEpIDogbWVyZ2VCbG9ja0ludG8ocm9vdE5vZGUsIGJsb2NrMSwgYmxvY2syKTtcblxuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ5ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcmVhZCQxKHJvb3ROb2RlLmRvbSwgZm9yd2FyZCwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkubWFwKGJsb2NrQm91bmRhcnkgPT4gKCkgPT4ge1xuICAgICAgICBtZXJnZUJsb2Nrcyhyb290Tm9kZSwgZm9yd2FyZCwgYmxvY2tCb3VuZGFyeS5mcm9tLmJsb2NrLCBibG9ja0JvdW5kYXJ5LnRvLmJsb2NrKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZVJhbmdlTWVyZ2VCbG9ja3MgPSAocm9vdE5vZGUsIHNlbGVjdGlvbikgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIGxpZnQyKGdldFBhcmVudEJsb2NrJDIocm9vdE5vZGUsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5zdGFydENvbnRhaW5lcikpLCBnZXRQYXJlbnRCbG9jayQyKHJvb3ROb2RlLCBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuZW5kQ29udGFpbmVyKSksIChibG9jazEsIGJsb2NrMikgPT4ge1xuICAgICAgICBpZiAoIWVxKGJsb2NrMSwgYmxvY2syKSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgbWVyZ2VCbG9ja3Mocm9vdE5vZGUsIHRydWUsIGJsb2NrMSwgYmxvY2syKS5lYWNoKHBvcyA9PiB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9KS5nZXRPcihPcHRpb25hbC5ub25lKCkpO1xuICAgIH07XG4gICAgY29uc3QgaXNSYXdOb2RlSW5UYWJsZSA9IChyb290LCByYXdOb2RlKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocmF3Tm9kZSk7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBjdXJyeShlcSwgcm9vdCk7XG4gICAgICByZXR1cm4gYW5jZXN0b3IkNChub2RlLCBpc1RhYmxlQ2VsbCQyLCBpc1Jvb3QpLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JblRhYmxlID0gKHJvb3QsIHJuZykgPT4gaXNSYXdOb2RlSW5UYWJsZShyb290LCBybmcuc3RhcnRDb250YWluZXIpIHx8IGlzUmF3Tm9kZUluVGFibGUocm9vdCwgcm5nLmVuZENvbnRhaW5lcik7XG4gICAgY29uc3QgaXNFdmVyeXRoaW5nU2VsZWN0ZWQgPSAocm9vdCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBub1ByZXZpb3VzID0gcHJldlBvc2l0aW9uKHJvb3QuZG9tLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZykpLmlzTm9uZSgpO1xuICAgICAgY29uc3Qgbm9OZXh0ID0gbmV4dFBvc2l0aW9uKHJvb3QuZG9tLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpKS5pc05vbmUoKTtcbiAgICAgIHJldHVybiAhaXNTZWxlY3Rpb25JblRhYmxlKHJvb3QsIHJuZykgJiYgbm9QcmV2aW91cyAmJiBub05leHQ7XG4gICAgfTtcbiAgICBjb25zdCBlbXB0eUVkaXRvciA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgIGVkaXRvci5zZXRDb250ZW50KCcnKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVSYW5nZSQyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgcmV0dXJuIGlzRXZlcnl0aGluZ1NlbGVjdGVkKHJvb3ROb2RlLCBybmcpID8gZW1wdHlFZGl0b3IoZWRpdG9yKSA6IGRlbGV0ZVJhbmdlTWVyZ2VCbG9ja3Mocm9vdE5vZGUsIGVkaXRvci5zZWxlY3Rpb24pO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDggPSAoZWRpdG9yLCBfZm9yd2FyZCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gT3B0aW9uYWwubm9uZSgpIDogZGVsZXRlUmFuZ2UkMihlZGl0b3IpO1xuXG4gICAgY29uc3Qgc2hvd0NhcmV0ID0gKGRpcmVjdGlvbiwgZWRpdG9yLCBub2RlLCBiZWZvcmUsIHNjcm9sbEludG9WaWV3KSA9PiBPcHRpb25hbC5mcm9tKGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLnNob3dDYXJldChkaXJlY3Rpb24sIG5vZGUsIGJlZm9yZSwgc2Nyb2xsSW50b1ZpZXcpKTtcbiAgICBjb25zdCBnZXROb2RlUmFuZ2UgPSBub2RlID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgc2VsZWN0Tm9kZSA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBlZGl0b3IuZGlzcGF0Y2goJ0JlZm9yZU9iamVjdFNlbGVjdGVkJywgeyB0YXJnZXQ6IG5vZGUgfSk7XG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZ2V0Tm9kZVJhbmdlKG5vZGUpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckNhcmV0QXRSYW5nZSA9IChlZGl0b3IsIHJhbmdlLCBzY3JvbGxJbnRvVmlldykgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFJhbmdlID0gbm9ybWFsaXplUmFuZ2UoMSwgZWRpdG9yLmdldEJvZHkoKSwgcmFuZ2UpO1xuICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQobm9ybWFsaXplZFJhbmdlKTtcbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb25Ob2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICBpZiAoaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQoY2FyZXRQb3NpdGlvbk5vZGUpKSB7XG4gICAgICAgIHJldHVybiBzaG93Q2FyZXQoMSwgZWRpdG9yLCBjYXJldFBvc2l0aW9uTm9kZSwgIWNhcmV0UG9zaXRpb24uaXNBdEVuZCgpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uQmVmb3JlTm9kZSA9IGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSh0cnVlKTtcbiAgICAgIGlmIChpc0lubGluZUZha2VDYXJldFRhcmdldChjYXJldFBvc2l0aW9uQmVmb3JlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHNob3dDYXJldCgxLCBlZGl0b3IsIGNhcmV0UG9zaXRpb25CZWZvcmVOb2RlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VSb290ID0gZ2V0Q29udGVudEVkaXRhYmxlUm9vdCQxKGVkaXRvci5kb20uZ2V0Um9vdCgpLCBjYXJldFBvc2l0aW9uLmdldE5vZGUoKSk7XG4gICAgICBpZiAoaXNJbmxpbmVGYWtlQ2FyZXRUYXJnZXQoY2VSb290KSkge1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KDEsIGVkaXRvciwgY2VSb290LCBmYWxzZSwgc2Nyb2xsSW50b1ZpZXcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclJhbmdlQ2FyZXQgPSAoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpID0+IHJhbmdlLmNvbGxhcHNlZCA/IHJlbmRlckNhcmV0QXRSYW5nZShlZGl0b3IsIHJhbmdlLCBzY3JvbGxJbnRvVmlldykuZ2V0T3IocmFuZ2UpIDogcmFuZ2U7XG5cbiAgICBjb25zdCBpc0JlZm9yZUJvdW5kYXJ5ID0gcG9zID0+IGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UocG9zKSB8fCBpc0JlZm9yZU1lZGlhKHBvcyk7XG4gICAgY29uc3QgaXNBZnRlckJvdW5kYXJ5ID0gcG9zID0+IGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZShwb3MpIHx8IGlzQWZ0ZXJNZWRpYShwb3MpO1xuICAgIGNvbnN0IHRyaW1FbXB0eVRleHROb2RlID0gKGRvbSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpICYmIG5vZGUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZUNvbnRlbnRBbmRTaG93Q2FyZXQgPSAoZWRpdG9yLCByYW5nZSwgbm9kZSwgZGlyZWN0aW9uLCBmb3J3YXJkLCBwZWVrQ2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCBwZWVrQ2FyZXRQb3NpdGlvbi5nZXROb2RlKCFmb3J3YXJkKSwgZm9yd2FyZCwgdHJ1ZSkuZWFjaChjYXJldFJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgIGNvbnN0IGRlbGV0ZVJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5zZXRFbmQoY2FyZXRSYW5nZS5zdGFydENvbnRhaW5lciwgY2FyZXRSYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnNldFN0YXJ0KGNhcmV0UmFuZ2UuZW5kQ29udGFpbmVyLCBjYXJldFJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZVJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhjYXJldFJhbmdlKTtcbiAgICAgIH0pO1xuICAgICAgdHJpbUVtcHR5VGV4dE5vZGUoZWRpdG9yLmRvbSwgbm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVCb3VuZGFyeVRleHQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpZiAoIWlzVGV4dCRhKHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IEhEaXJlY3Rpb24uRm9yd2FyZHMgOiBIRGlyZWN0aW9uLkJhY2t3YXJkcztcbiAgICAgIGNvbnN0IGNhcmV0V2Fsa2VyID0gQ2FyZXRXYWxrZXIoZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBnZXROZXh0UG9zRm4gPSBjdXJyeShnZXRWaXN1YWxDYXJldFBvc2l0aW9uLCBmb3J3YXJkID8gY2FyZXRXYWxrZXIubmV4dCA6IGNhcmV0V2Fsa2VyLnByZXYpO1xuICAgICAgY29uc3QgaXNCZWZvcmVGbiA9IGZvcndhcmQgPyBpc0JlZm9yZUJvdW5kYXJ5IDogaXNBZnRlckJvdW5kYXJ5O1xuICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IGdldE5vcm1hbGl6ZWRSYW5nZUVuZFBvaW50KGRpcmVjdGlvbiwgZWRpdG9yLmdldEJvZHkoKSwgcmFuZ2UpO1xuICAgICAgY29uc3QgbmV4dENhcmV0UG9zaXRpb24gPSBnZXROZXh0UG9zRm4oY2FyZXRQb3NpdGlvbik7XG4gICAgICBjb25zdCBub3JtYWxpemVkTmV4dENhcmV0UG9zaXRpb24gPSBuZXh0Q2FyZXRQb3NpdGlvbiA/IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIG5leHRDYXJldFBvc2l0aW9uKSA6IG5leHRDYXJldFBvc2l0aW9uO1xuICAgICAgaWYgKCFub3JtYWxpemVkTmV4dENhcmV0UG9zaXRpb24gfHwgIWlzTW92ZUluc2lkZVNhbWVCbG9jayhjYXJldFBvc2l0aW9uLCBub3JtYWxpemVkTmV4dENhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQmVmb3JlRm4obm9ybWFsaXplZE5leHRDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiBkZWxldGVDb250ZW50QW5kU2hvd0NhcmV0KGVkaXRvciwgcmFuZ2UsIGNhcmV0UG9zaXRpb24uZ2V0Tm9kZSgpLCBkaXJlY3Rpb24sIGZvcndhcmQsIG5vcm1hbGl6ZWROZXh0Q2FyZXRQb3NpdGlvbikpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVla0NhcmV0UG9zaXRpb24gPSBnZXROZXh0UG9zRm4obm9ybWFsaXplZE5leHRDYXJldFBvc2l0aW9uKTtcbiAgICAgIGlmIChwZWVrQ2FyZXRQb3NpdGlvbiAmJiBpc0JlZm9yZUZuKHBlZWtDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICBpZiAoaXNNb3ZlSW5zaWRlU2FtZUJsb2NrKG5vcm1hbGl6ZWROZXh0Q2FyZXRQb3NpdGlvbiwgcGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoKCkgPT4gZGVsZXRlQ29udGVudEFuZFNob3dDYXJldChlZGl0b3IsIHJhbmdlLCBjYXJldFBvc2l0aW9uLmdldE5vZGUoKSwgZGlyZWN0aW9uLCBmb3J3YXJkLCBwZWVrQ2FyZXRQb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDcgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBkZWxldGVCb3VuZGFyeVRleHQoZWRpdG9yLCBmb3J3YXJkKTtcblxuICAgIGNvbnN0IGdldEVkZ2VDZWZQb3NpdGlvbiA9IChlZGl0b3IsIGF0U3RhcnQpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmV0dXJuIGF0U3RhcnQgPyBmaXJzdFBvc2l0aW9uSW4ocm9vdCkuZmlsdGVyKGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UpIDogbGFzdFBvc2l0aW9uSW4ocm9vdCkuZmlsdGVyKGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NlZkF0RWRnZVNlbGVjdGVkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gIXJuZy5jb2xsYXBzZWQgJiYgKGdldEVkZ2VDZWZQb3NpdGlvbihlZGl0b3IsIHRydWUpLmV4aXN0cyhwb3MgPT4gcG9zLmlzRXF1YWwoQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpKSkgfHwgZ2V0RWRnZUNlZlBvc2l0aW9uKGVkaXRvciwgZmFsc2UpLmV4aXN0cyhwb3MgPT4gcG9zLmlzRXF1YWwoQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSkpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNDb21wb3VuZEVsZW1lbnQgPSBub2RlID0+IGlzTm9uTnVsbGFibGUobm9kZSkgJiYgKGlzVGFibGVDZWxsJDIoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpIHx8IGlzTGlzdEl0ZW0kMShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSkpO1xuICAgIGNvbnN0IERlbGV0ZUFjdGlvbiA9IEFkdC5nZW5lcmF0ZShbXG4gICAgICB7IHJlbW92ZTogWydlbGVtZW50J10gfSxcbiAgICAgIHsgbW92ZVRvRWxlbWVudDogWydlbGVtZW50J10gfSxcbiAgICAgIHsgbW92ZVRvUG9zaXRpb246IFsncG9zaXRpb24nXSB9XG4gICAgXSk7XG4gICAgY29uc3QgaXNBdENvbnRlbnRFZGl0YWJsZUJsb2NrQ2FyZXQgPSAoZm9yd2FyZCwgZnJvbSkgPT4ge1xuICAgICAgY29uc3QgZWxtID0gZnJvbS5nZXROb2RlKCFmb3J3YXJkKTtcbiAgICAgIGNvbnN0IGNhcmV0TG9jYXRpb24gPSBmb3J3YXJkID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgcmV0dXJuIGlzRWxlbWVudCQ2KGVsbSkgJiYgZWxtLmdldEF0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSA9PT0gY2FyZXRMb2NhdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IGlzRGVsZXRlRnJvbUNlZkRpZmZlcmVudEJsb2NrcyA9IChyb290LCBmb3J3YXJkLCBmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgaW5TYW1lQmxvY2sgPSBlbG0gPT4gaXNJbmxpbmUkMShTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pKSAmJiAhaXNJblNhbWVCbG9jayhmcm9tLCB0bywgcm9vdCk7XG4gICAgICByZXR1cm4gZ2V0UmVsYXRpdmVDZWZFbG0oIWZvcndhcmQsIGZyb20pLmZvbGQoKCkgPT4gZ2V0UmVsYXRpdmVDZWZFbG0oZm9yd2FyZCwgdG8pLmZvbGQobmV2ZXIsIGluU2FtZUJsb2NrKSwgaW5TYW1lQmxvY2spO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlRW1wdHlCbG9ja09yTW92ZVRvQ2VmID0gKHJvb3QsIGZvcndhcmQsIGZyb20sIHRvKSA9PiB7XG4gICAgICBjb25zdCB0b0NlZkVsbSA9IHRvLmdldE5vZGUoIWZvcndhcmQpO1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDIoU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGZyb20uZ2V0Tm9kZSgpKSkubWFwKGJsb2NrRWxtID0+IGlzRW1wdHkkMihibG9ja0VsbSkgPyBEZWxldGVBY3Rpb24ucmVtb3ZlKGJsb2NrRWxtLmRvbSkgOiBEZWxldGVBY3Rpb24ubW92ZVRvRWxlbWVudCh0b0NlZkVsbSkpLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ubW92ZVRvRWxlbWVudCh0b0NlZkVsbSkpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRDZWZQb3NpdGlvbiA9IChyb290LCBmb3J3YXJkLCBmcm9tKSA9PiBmcm9tUG9zaXRpb24oZm9yd2FyZCwgcm9vdCwgZnJvbSkuYmluZCh0byA9PiB7XG4gICAgICBpZiAoaXNDb21wb3VuZEVsZW1lbnQodG8uZ2V0Tm9kZSgpKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlbGV0ZUZyb21DZWZEaWZmZXJlbnRCbG9ja3Mocm9vdCwgZm9yd2FyZCwgZnJvbSwgdG8pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKHRvLmdldE5vZGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUVtcHR5QmxvY2tPck1vdmVUb0NlZihyb290LCBmb3J3YXJkLCBmcm9tLCB0byk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYih0by5nZXROb2RlKHRydWUpKSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlRW1wdHlCbG9ja09yTW92ZVRvQ2VmKHJvb3QsIGZvcndhcmQsIGZyb20sIHRvKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9yd2FyZCAmJiBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UoZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHRvKSk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UoZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHRvKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZUJsb2NrQWN0aW9uID0gKGZvcndhcmQsIGVsbSkgPT4ge1xuICAgICAgaWYgKGlzTnVsbGFibGUoZWxtKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihlbG0ubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5tb3ZlVG9FbGVtZW50KGVsbS5uZXh0U2libGluZykpO1xuICAgICAgfSBlbHNlIGlmICghZm9yd2FyZCAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoZWxtLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQoZWxtLnByZXZpb3VzU2libGluZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNraXBNb3ZlVG9BY3Rpb25Gcm9tSW5saW5lQ2VmVG9Db250ZW50ID0gKHJvb3QsIGZyb20sIGRlbGV0ZUFjdGlvbikgPT4gZGVsZXRlQWN0aW9uLmZvbGQoZWxtID0+IE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLnJlbW92ZShlbG0pKSwgZWxtID0+IE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb0VsZW1lbnQoZWxtKSksIHRvID0+IHtcbiAgICAgIGlmIChpc0luU2FtZUJsb2NrKGZyb20sIHRvLCByb290KSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoRGVsZXRlQWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHRvKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29udGVudEVkaXRhYmxlQWN0aW9uID0gKHJvb3QsIGZvcndhcmQsIGZyb20pID0+IHtcbiAgICAgIGlmIChpc0F0Q29udGVudEVkaXRhYmxlQmxvY2tDYXJldChmb3J3YXJkLCBmcm9tKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q29udGVudEVkaXRhYmxlQmxvY2tBY3Rpb24oZm9yd2FyZCwgZnJvbS5nZXROb2RlKCFmb3J3YXJkKSkub3JUaHVuaygoKSA9PiBmaW5kQ2VmUG9zaXRpb24ocm9vdCwgZm9yd2FyZCwgZnJvbSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDZWZQb3NpdGlvbihyb290LCBmb3J3YXJkLCBmcm9tKS5iaW5kKGRlbGV0ZUFjdGlvbiA9PiBza2lwTW92ZVRvQWN0aW9uRnJvbUlubGluZUNlZlRvQ29udGVudChyb290LCBmcm9tLCBkZWxldGVBY3Rpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlYWQgPSAocm9vdCwgZm9yd2FyZCwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUmFuZ2UgPSBub3JtYWxpemVSYW5nZShmb3J3YXJkID8gMSA6IC0xLCByb290LCBybmcpO1xuICAgICAgY29uc3QgZnJvbSA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQobm9ybWFsaXplZFJhbmdlKTtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCk7XG4gICAgICBpZiAoIWZvcndhcmQgJiYgaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGZyb20pKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKERlbGV0ZUFjdGlvbi5yZW1vdmUoZnJvbS5nZXROb2RlKHRydWUpKSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShEZWxldGVBY3Rpb24ucmVtb3ZlKGZyb20uZ2V0Tm9kZSgpKSk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2UoZnJvbSkgJiYgaXNBZnRlckJyKHJvb3RFbGVtZW50LCBmcm9tKSkge1xuICAgICAgICByZXR1cm4gZmluZFByZXZpb3VzQnIocm9vdEVsZW1lbnQsIGZyb20pLm1hcChiciA9PiBEZWxldGVBY3Rpb24ucmVtb3ZlKGJyLmdldE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkICYmIGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZShmcm9tKSAmJiBpc0JlZm9yZUJyJDEocm9vdEVsZW1lbnQsIGZyb20pKSB7XG4gICAgICAgIHJldHVybiBmaW5kTmV4dEJyKHJvb3RFbGVtZW50LCBmcm9tKS5tYXAoYnIgPT4gRGVsZXRlQWN0aW9uLnJlbW92ZShici5nZXROb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRDb250ZW50RWRpdGFibGVBY3Rpb24ocm9vdCwgZm9yd2FyZCwgZnJvbSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRlbGV0ZUVsZW1lbnQkMSA9IChlZGl0b3IsIGZvcndhcmQpID0+IGVsZW1lbnQgPT4ge1xuICAgICAgZWRpdG9yLl9zZWxlY3Rpb25PdmVycmlkZXMuaGlkZUZha2VDYXJldCgpO1xuICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9FbGVtZW50ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5iZWZvcmUoZWxlbWVudCkgOiBDYXJldFBvc2l0aW9uLmFmdGVyKGVsZW1lbnQpO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVUb1Bvc2l0aW9uID0gZWRpdG9yID0+IHBvcyA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhwb3MudG9SYW5nZSgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0QW5jZXN0b3JDZSA9IChlZGl0b3IsIG5vZGUpID0+IE9wdGlvbmFsLmZyb20oZ2V0Q29udGVudEVkaXRhYmxlUm9vdCQxKGVkaXRvci5nZXRCb2R5KCksIG5vZGUpKTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGVDYXJldCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgcmV0dXJuIGdldEFuY2VzdG9yQ2UoZWRpdG9yLCBzZWxlY3RlZE5vZGUpLmZpbHRlcihpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIpLmZvbGQoKCkgPT4gcmVhZChlZGl0b3IuZ2V0Qm9keSgpLCBmb3J3YXJkLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKS5tYXAoZGVsZXRlQWN0aW9uID0+ICgpID0+IGRlbGV0ZUFjdGlvbi5mb2xkKGRlbGV0ZUVsZW1lbnQkMShlZGl0b3IsIGZvcndhcmQpLCBtb3ZlVG9FbGVtZW50KGVkaXRvciwgZm9yd2FyZCksIG1vdmVUb1Bvc2l0aW9uKGVkaXRvcikpKSwgKCkgPT4gT3B0aW9uYWwuc29tZShub29wKSk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVPZmZzY3JlZW5TZWxlY3Rpb24gPSByb290RWxlbWVudCA9PiB7XG4gICAgICBlYWNoJGUoZGVzY2VuZGFudHMocm9vdEVsZW1lbnQsICcubWNlLW9mZnNjcmVlbi1zZWxlY3Rpb24nKSwgcmVtb3ZlJDUpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlUmFuZ2UgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoc2VsZWN0ZWROb2RlKSAmJiAhaXNUYWJsZUNlbGwkMyhzZWxlY3RlZE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGhhc0NlZkFuY2VzdG9yID0gZ2V0QW5jZXN0b3JDZShlZGl0b3IsIHNlbGVjdGVkTm9kZS5wYXJlbnROb2RlKS5maWx0ZXIoaXNDb250ZW50RWRpdGFibGVGYWxzZSRiKTtcbiAgICAgICAgcmV0dXJuIGhhc0NlZkFuY2VzdG9yLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlT2Zmc2NyZWVuU2VsZWN0aW9uKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgICAgICBkZWxldGVFbGVtZW50JDIoZWRpdG9yLCBmb3J3YXJkLCBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSkpO1xuICAgICAgICAgIHBhZGRFbXB0eUJvZHkoZWRpdG9yKTtcbiAgICAgICAgfSksICgpID0+IE9wdGlvbmFsLnNvbWUobm9vcCkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2VmQXRFZGdlU2VsZWN0ZWQoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlUmFuZ2VDb250ZW50cyhlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCksIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgcGFkZEVtcHR5RWxlbWVudCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgY2VSb290ID0gZ2V0Q29udGVudEVkaXRhYmxlUm9vdCQxKGVkaXRvci5nZXRCb2R5KCksIHNlbGVjdGlvbi5nZXROb2RlKCkpO1xuICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKGNlUm9vdCkgJiYgZG9tLmlzQmxvY2soY2VSb290KSAmJiBkb20uaXNFbXB0eShjZVJvb3QpKSB7XG4gICAgICAgIGNvbnN0IGJyID0gZG9tLmNyZWF0ZSgnYnInLCB7ICdkYXRhLW1jZS1ib2d1cyc6ICcxJyB9KTtcbiAgICAgICAgZG9tLnNldEhUTUwoY2VSb290LCAnJyk7XG4gICAgICAgIGNlUm9vdC5hcHBlbmRDaGlsZChicik7XG4gICAgICAgIHNlbGVjdGlvbi5zZXRSbmcoQ2FyZXRQb3NpdGlvbi5iZWZvcmUoYnIpLnRvUmFuZ2UoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ2ID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFja3NwYWNlRGVsZXRlQ2FyZXQoZWRpdG9yLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiYWNrc3BhY2VEZWxldGVSYW5nZShlZGl0b3IsIGZvcndhcmQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkZWxldGVDYXJldCQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgZnJvbVBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICByZXR1cm4gZnJvbVBvc2l0aW9uKGZvcndhcmQsIGVkaXRvci5nZXRCb2R5KCksIGZyb21Qb3MpLmZpbHRlcihwb3MgPT4gZm9yd2FyZCA/IGlzQmVmb3JlSW1hZ2VCbG9jayhwb3MpIDogaXNBZnRlckltYWdlQmxvY2socG9zKSkuYmluZChwb3MgPT4gZ2V0Q2hpbGROb2RlQXRSZWxhdGl2ZU9mZnNldChmb3J3YXJkID8gMCA6IC0xLCBwb3MpKS5tYXAoZWxtID0+ICgpID0+IGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KGVsbSkpO1xuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgPyBkZWxldGVDYXJldCQyKGVkaXRvciwgZm9yd2FyZCkgOiBPcHRpb25hbC5ub25lKCk7XG5cbiAgICBjb25zdCBpc1RleHQkMiA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciA9IG5vZGUgPT4gaXNUZXh0JDIobm9kZSkgJiYgbm9kZS5kYXRhWzBdID09PSBaV1NQJDE7XG4gICAgY29uc3QgZW5kc1dpdGhDYXJldENvbnRhaW5lciA9IG5vZGUgPT4gaXNUZXh0JDIobm9kZSkgJiYgbm9kZS5kYXRhW25vZGUuZGF0YS5sZW5ndGggLSAxXSA9PT0gWldTUCQxO1xuICAgIGNvbnN0IGNyZWF0ZVp3c3AgPSBub2RlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRvYyA9IChfYSA9IG5vZGUub3duZXJEb2N1bWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKFpXU1AkMSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmUkMSA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGlzVGV4dCQyKG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICBpZiAoZW5kc1dpdGhDYXJldENvbnRhaW5lcihub2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wcmV2aW91c1NpYmxpbmcuYXBwZW5kRGF0YShaV1NQJDEpO1xuICAgICAgICAgIHJldHVybiBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1RleHQkMihub2RlKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5pbnNlcnREYXRhKDAsIFpXU1AkMSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVad3NwKG5vZGUpO1xuICAgICAgICAoX2EgPSBub2RlLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgbm9kZSk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QWZ0ZXIkMSA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmIChpc1RleHQkMihub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICBpZiAoc3RhcnRzV2l0aENhcmV0Q29udGFpbmVyKG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5uZXh0U2libGluZy5pbnNlcnREYXRhKDAsIFpXU1AkMSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JDIobm9kZSkpIHtcbiAgICAgICAgaWYgKGVuZHNXaXRoQ2FyZXRDb250YWluZXIobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmFwcGVuZERhdGEoWldTUCQxKTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGNyZWF0ZVp3c3Aobm9kZSk7XG4gICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgKF9hID0gbm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChfYiA9IG5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lID0gKGJlZm9yZSwgbm9kZSkgPT4gYmVmb3JlID8gaW5zZXJ0QmVmb3JlJDEobm9kZSkgOiBpbnNlcnRBZnRlciQxKG5vZGUpO1xuICAgIGNvbnN0IGluc2VydElubGluZUJlZm9yZSA9IGN1cnJ5KGluc2VydElubGluZSwgdHJ1ZSk7XG4gICAgY29uc3QgaW5zZXJ0SW5saW5lQWZ0ZXIgPSBjdXJyeShpbnNlcnRJbmxpbmUsIGZhbHNlKTtcblxuICAgIGNvbnN0IGluc2VydElubGluZVBvcyA9IChwb3MsIGJlZm9yZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKHBvcy5jb250YWluZXIoKSkpIHtcbiAgICAgICAgcmV0dXJuIGluc2VydElubGluZShiZWZvcmUsIHBvcy5jb250YWluZXIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5zZXJ0SW5saW5lKGJlZm9yZSwgcG9zLmdldE5vZGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1Bvc0NhcmV0Q29udGFpbmVyID0gKHBvcywgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0Tm9kZSA9IGNhcmV0LmdldCgpO1xuICAgICAgcmV0dXJuIGNhcmV0Tm9kZSAmJiBwb3MuY29udGFpbmVyKCkgPT09IGNhcmV0Tm9kZSAmJiBpc0NhcmV0Q29udGFpbmVySW5saW5lKGNhcmV0Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJDYXJldCA9IChjYXJldCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLmZvbGQoZWxlbWVudCA9PiB7XG4gICAgICByZW1vdmUkMyhjYXJldC5nZXQoKSk7XG4gICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lQmVmb3JlKGVsZW1lbnQpO1xuICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbih0ZXh0LCB0ZXh0Lmxlbmd0aCAtIDEpKTtcbiAgICB9LCBlbGVtZW50ID0+IGZpcnN0UG9zaXRpb25JbihlbGVtZW50KS5tYXAocG9zID0+IHtcbiAgICAgIGlmICghaXNQb3NDYXJldENvbnRhaW5lcihwb3MsIGNhcmV0KSkge1xuICAgICAgICByZW1vdmUkMyhjYXJldC5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBpbnNlcnRJbmxpbmVQb3MocG9zLCB0cnVlKTtcbiAgICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgICByZXR1cm4gQ2FyZXRQb3NpdGlvbih0ZXh0LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjYXJldC5nZXQoKTtcbiAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24obm9kZSwgMSk7XG4gICAgICB9XG4gICAgfSksIGVsZW1lbnQgPT4gbGFzdFBvc2l0aW9uSW4oZWxlbWVudCkubWFwKHBvcyA9PiB7XG4gICAgICBpZiAoIWlzUG9zQ2FyZXRDb250YWluZXIocG9zLCBjYXJldCkpIHtcbiAgICAgICAgcmVtb3ZlJDMoY2FyZXQuZ2V0KCkpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5zZXJ0SW5saW5lUG9zKHBvcywgZmFsc2UpO1xuICAgICAgICBjYXJldC5zZXQodGV4dCk7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKHRleHQsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gY2FyZXQuZ2V0KCk7XG4gICAgICAgIHJldHVybiBDYXJldFBvc2l0aW9uKG5vZGUsIG5vZGUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSksIGVsZW1lbnQgPT4ge1xuICAgICAgcmVtb3ZlJDMoY2FyZXQuZ2V0KCkpO1xuICAgICAgY29uc3QgdGV4dCA9IGluc2VydElubGluZUFmdGVyKGVsZW1lbnQpO1xuICAgICAgY2FyZXQuc2V0KHRleHQpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbih0ZXh0LCAxKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBldmFsdWF0ZVVudGlsID0gKGZucywgYXJncykgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0LmlzU29tZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgTG9jYXRpb24gPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBiZWZvcmU6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IHN0YXJ0OiBbJ2VsZW1lbnQnXSB9LFxuICAgICAgeyBlbmQ6IFsnZWxlbWVudCddIH0sXG4gICAgICB7IGFmdGVyOiBbJ2VsZW1lbnQnXSB9XG4gICAgXSk7XG4gICAgY29uc3QgcmVzY29wZSQxID0gKHJvb3ROb2RlLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGdldFBhcmVudEJsb2NrJDMobm9kZSwgcm9vdE5vZGUpO1xuICAgICAgcmV0dXJuIHBhcmVudEJsb2NrID8gcGFyZW50QmxvY2sgOiByb290Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGJlZm9yZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUZvcndhcmRzKHBvcyk7XG4gICAgICBjb25zdCBzY29wZSA9IHJlc2NvcGUkMShyb290Tm9kZSwgblBvcy5jb250YWluZXIoKSk7XG4gICAgICByZXR1cm4gZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHNjb3BlLCBuUG9zKS5mb2xkKCgpID0+IG5leHRQb3NpdGlvbihzY29wZSwgblBvcykuYmluZChjdXJyeShmaW5kUm9vdElubGluZSwgaXNJbmxpbmVUYXJnZXQsIHNjb3BlKSkubWFwKGlubGluZSA9PiBMb2NhdGlvbi5iZWZvcmUoaW5saW5lKSksIE9wdGlvbmFsLm5vbmUpO1xuICAgIH07XG4gICAgY29uc3QgaXNOb3RJbnNpZGVGb3JtYXRDYXJldENvbnRhaW5lciA9IChyb290Tm9kZSwgZWxtKSA9PiBnZXRQYXJlbnRDYXJldENvbnRhaW5lcihyb290Tm9kZSwgZWxtKSA9PT0gbnVsbDtcbiAgICBjb25zdCBmaW5kSW5zaWRlUm9vdElubGluZSA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4gZmluZFJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpLmZpbHRlcihjdXJyeShpc05vdEluc2lkZUZvcm1hdENhcmV0Q29udGFpbmVyLCByb290Tm9kZSkpO1xuICAgIGNvbnN0IHN0YXJ0JDEgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IG5Qb3MgPSBub3JtYWxpemVCYWNrd2FyZHMocG9zKTtcbiAgICAgIHJldHVybiBmaW5kSW5zaWRlUm9vdElubGluZShpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIG5Qb3MpLmJpbmQoaW5saW5lID0+IHtcbiAgICAgICAgY29uc3QgcHJldlBvcyA9IHByZXZQb3NpdGlvbihpbmxpbmUsIG5Qb3MpO1xuICAgICAgICByZXR1cm4gcHJldlBvcy5pc05vbmUoKSA/IE9wdGlvbmFsLnNvbWUoTG9jYXRpb24uc3RhcnQoaW5saW5lKSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGVuZCA9IChpc0lubGluZVRhcmdldCwgcm9vdE5vZGUsIHBvcykgPT4ge1xuICAgICAgY29uc3QgblBvcyA9IG5vcm1hbGl6ZUZvcndhcmRzKHBvcyk7XG4gICAgICByZXR1cm4gZmluZEluc2lkZVJvb3RJbmxpbmUoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBuUG9zKS5iaW5kKGlubGluZSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBuZXh0UG9zaXRpb24oaW5saW5lLCBuUG9zKTtcbiAgICAgICAgcmV0dXJuIG5leHRQb3MuaXNOb25lKCkgPyBPcHRpb25hbC5zb21lKExvY2F0aW9uLmVuZChpbmxpbmUpKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYWZ0ZXIgPSAoaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IG5Qb3MgPSBub3JtYWxpemVCYWNrd2FyZHMocG9zKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gcmVzY29wZSQxKHJvb3ROb2RlLCBuUG9zLmNvbnRhaW5lcigpKTtcbiAgICAgIHJldHVybiBmaW5kUm9vdElubGluZShpc0lubGluZVRhcmdldCwgc2NvcGUsIG5Qb3MpLmZvbGQoKCkgPT4gcHJldlBvc2l0aW9uKHNjb3BlLCBuUG9zKS5iaW5kKGN1cnJ5KGZpbmRSb290SW5saW5lLCBpc0lubGluZVRhcmdldCwgc2NvcGUpKS5tYXAoaW5saW5lID0+IExvY2F0aW9uLmFmdGVyKGlubGluZSkpLCBPcHRpb25hbC5ub25lKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRMb2NhdGlvbiA9IGxvY2F0aW9uID0+ICFpc1J0bChnZXRFbGVtZW50KGxvY2F0aW9uKSk7XG4gICAgY29uc3QgcmVhZExvY2F0aW9uID0gKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgcG9zKSA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IGV2YWx1YXRlVW50aWwoW1xuICAgICAgICBiZWZvcmUsXG4gICAgICAgIHN0YXJ0JDEsXG4gICAgICAgIGVuZCxcbiAgICAgICAgYWZ0ZXJcbiAgICAgIF0sIFtcbiAgICAgICAgaXNJbmxpbmVUYXJnZXQsXG4gICAgICAgIHJvb3ROb2RlLFxuICAgICAgICBwb3NcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLmZpbHRlcihpc1ZhbGlkTG9jYXRpb24pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RWxlbWVudCA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoaWRlbnRpdHksIGlkZW50aXR5LCBpZGVudGl0eSwgaWRlbnRpdHkpO1xuICAgIGNvbnN0IGdldE5hbWUgPSBsb2NhdGlvbiA9PiBsb2NhdGlvbi5mb2xkKGNvbnN0YW50KCdiZWZvcmUnKSwgY29uc3RhbnQoJ3N0YXJ0JyksIGNvbnN0YW50KCdlbmQnKSwgY29uc3RhbnQoJ2FmdGVyJykpO1xuICAgIGNvbnN0IG91dHNpZGUgPSBsb2NhdGlvbiA9PiBsb2NhdGlvbi5mb2xkKExvY2F0aW9uLmJlZm9yZSwgTG9jYXRpb24uYmVmb3JlLCBMb2NhdGlvbi5hZnRlciwgTG9jYXRpb24uYWZ0ZXIpO1xuICAgIGNvbnN0IGluc2lkZSA9IGxvY2F0aW9uID0+IGxvY2F0aW9uLmZvbGQoTG9jYXRpb24uc3RhcnQsIExvY2F0aW9uLnN0YXJ0LCBMb2NhdGlvbi5lbmQsIExvY2F0aW9uLmVuZCk7XG4gICAgY29uc3QgaXNFcSA9IChsb2NhdGlvbjEsIGxvY2F0aW9uMikgPT4gZ2V0TmFtZShsb2NhdGlvbjEpID09PSBnZXROYW1lKGxvY2F0aW9uMikgJiYgZ2V0RWxlbWVudChsb2NhdGlvbjEpID09PSBnZXRFbGVtZW50KGxvY2F0aW9uMik7XG4gICAgY29uc3QgYmV0d2VlbklubGluZXMgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tLCB0bywgbG9jYXRpb24pID0+IGxpZnQyKGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSksIGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgdG8pLCAoZnJvbUlubGluZSwgdG9JbmxpbmUpID0+IHtcbiAgICAgIGlmIChmcm9tSW5saW5lICE9PSB0b0lubGluZSAmJiBoYXNTYW1lUGFyZW50QmxvY2socm9vdE5vZGUsIGZyb21JbmxpbmUsIHRvSW5saW5lKSkge1xuICAgICAgICByZXR1cm4gTG9jYXRpb24uYWZ0ZXIoZm9yd2FyZCA/IGZyb21JbmxpbmUgOiB0b0lubGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG4gICAgfSkuZ2V0T3IobG9jYXRpb24pO1xuICAgIGNvbnN0IHNraXBOb01vdmVtZW50ID0gKGZyb21Mb2NhdGlvbiwgdG9Mb2NhdGlvbikgPT4gZnJvbUxvY2F0aW9uLmZvbGQoYWx3YXlzLCBmcm9tTG9jYXRpb24gPT4gIWlzRXEoZnJvbUxvY2F0aW9uLCB0b0xvY2F0aW9uKSk7XG4gICAgY29uc3QgZmluZExvY2F0aW9uVHJhdmVyc2UgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tTG9jYXRpb24sIHBvcykgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIHBvcyk7XG4gICAgICBjb25zdCB0byA9IGZyb21Qb3NpdGlvbihmb3J3YXJkLCByb290Tm9kZSwgZnJvbSkubWFwKGN1cnJ5KG5vcm1hbGl6ZVBvc2l0aW9uLCBmb3J3YXJkKSk7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRvLmZvbGQoKCkgPT4gZnJvbUxvY2F0aW9uLm1hcChvdXRzaWRlKSwgdG8gPT4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgdG8pLm1hcChjdXJyeShiZXR3ZWVuSW5saW5lcywgZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBmcm9tLCB0bykpLmZpbHRlcihjdXJyeShza2lwTm9Nb3ZlbWVudCwgZnJvbUxvY2F0aW9uKSkpO1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLmZpbHRlcihpc1ZhbGlkTG9jYXRpb24pO1xuICAgIH07XG4gICAgY29uc3QgZmluZExvY2F0aW9uU2ltcGxlID0gKGZvcndhcmQsIGxvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uZm9sZChjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLnN0YXJ0KSwgT3B0aW9uYWwubm9uZSwgY29tcG9zZShPcHRpb25hbC5zb21lLCBMb2NhdGlvbi5hZnRlciksIE9wdGlvbmFsLm5vbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmZvbGQoT3B0aW9uYWwubm9uZSwgY29tcG9zZShPcHRpb25hbC5zb21lLCBMb2NhdGlvbi5iZWZvcmUpLCBPcHRpb25hbC5ub25lLCBjb21wb3NlKE9wdGlvbmFsLnNvbWUsIExvY2F0aW9uLmVuZCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZExvY2F0aW9uJDEgPSAoZm9yd2FyZCwgaXNJbmxpbmVUYXJnZXQsIHJvb3ROb2RlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGZyb20gPSBub3JtYWxpemVQb3NpdGlvbihmb3J3YXJkLCBwb3MpO1xuICAgICAgY29uc3QgZnJvbUxvY2F0aW9uID0gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSk7XG4gICAgICByZXR1cm4gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbSkuYmluZChjdXJyeShmaW5kTG9jYXRpb25TaW1wbGUsIGZvcndhcmQpKS5vclRodW5rKCgpID0+IGZpbmRMb2NhdGlvblRyYXZlcnNlKGZvcndhcmQsIGlzSW5saW5lVGFyZ2V0LCByb290Tm9kZSwgZnJvbUxvY2F0aW9uLCBwb3MpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzU2VsZWN0aW9uTW9kaWZ5QXBpID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCkubW9kaWZ5KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVSZWwgPSAoZm9yd2FyZCwgc2VsZWN0aW9uLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgIHNlbGVjdGlvbi5zZXRSbmcoQ2FyZXRQb3NpdGlvbihwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSArIGRlbHRhKS50b1JhbmdlKCkpO1xuICAgICAgc2VsZWN0aW9uLmdldFNlbCgpLm1vZGlmeSgnbW92ZScsIGZvcndhcmQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLCAnd29yZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlQnlXb3JkID0gKGZvcndhcmQsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IHBvcyA9IGZvcndhcmQgPyBDYXJldFBvc2l0aW9uLmZyb21SYW5nZUVuZChybmcpIDogQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgaWYgKCFoYXNTZWxlY3Rpb25Nb2RpZnlBcGkoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgaXNCZWZvcmVJbmxpbmUocG9zKSkge1xuICAgICAgICByZXR1cm4gbW92ZVJlbCh0cnVlLCBlZGl0b3Iuc2VsZWN0aW9uLCBwb3MpO1xuICAgICAgfSBlbHNlIGlmICghZm9yd2FyZCAmJiBpc0FmdGVySW5saW5lKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVSZWwoZmFsc2UsIGVkaXRvci5zZWxlY3Rpb24sIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBCcmVha1R5cGU7XG4gICAgKGZ1bmN0aW9uIChCcmVha1R5cGUpIHtcbiAgICAgIEJyZWFrVHlwZVtCcmVha1R5cGVbJ0JyJ10gPSAwXSA9ICdCcic7XG4gICAgICBCcmVha1R5cGVbQnJlYWtUeXBlWydCbG9jayddID0gMV0gPSAnQmxvY2snO1xuICAgICAgQnJlYWtUeXBlW0JyZWFrVHlwZVsnV3JhcCddID0gMl0gPSAnV3JhcCc7XG4gICAgICBCcmVha1R5cGVbQnJlYWtUeXBlWydFb2wnXSA9IDNdID0gJ0VvbCc7XG4gICAgfShCcmVha1R5cGUgfHwgKEJyZWFrVHlwZSA9IHt9KSkpO1xuICAgIGNvbnN0IGZsaXAgPSAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpID0+IGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5CYWNrd2FyZHMgPyByZXZlcnNlKHBvc2l0aW9ucykgOiBwb3NpdGlvbnM7XG4gICAgY29uc3Qgd2FsayQxID0gKGRpcmVjdGlvbiwgY2FyZXRXYWxrZXIsIHBvcykgPT4gZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkZvcndhcmRzID8gY2FyZXRXYWxrZXIubmV4dChwb3MpIDogY2FyZXRXYWxrZXIucHJldihwb3MpO1xuICAgIGNvbnN0IGdldEJyZWFrVHlwZSA9IChzY29wZSwgZGlyZWN0aW9uLCBjdXJyZW50UG9zLCBuZXh0UG9zKSA9PiB7XG4gICAgICBpZiAoaXNCciQ2KG5leHRQb3MuZ2V0Tm9kZShkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uRm9yd2FyZHMpKSkge1xuICAgICAgICByZXR1cm4gQnJlYWtUeXBlLkJyO1xuICAgICAgfSBlbHNlIGlmIChpc0luU2FtZUJsb2NrKGN1cnJlbnRQb3MsIG5leHRQb3MpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gQnJlYWtUeXBlLkJsb2NrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJyZWFrVHlwZS5XcmFwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWwgPSAocHJlZGljYXRlLCBkaXJlY3Rpb24sIHNjb3BlLCBzdGFydCkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihzY29wZSk7XG4gICAgICBsZXQgY3VycmVudFBvcyA9IHN0YXJ0O1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgICB3aGlsZSAoY3VycmVudFBvcykge1xuICAgICAgICBjb25zdCBuZXh0UG9zID0gd2FsayQxKGRpcmVjdGlvbiwgY2FyZXRXYWxrZXIsIGN1cnJlbnRQb3MpO1xuICAgICAgICBpZiAoIW5leHRQb3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCciQ2KG5leHRQb3MuZ2V0Tm9kZShmYWxzZSkpKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5Gb3J3YXJkcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiBmbGlwKGRpcmVjdGlvbiwgcG9zaXRpb25zKS5jb25jYXQoW25leHRQb3NdKSxcbiAgICAgICAgICAgICAgYnJlYWtUeXBlOiBCcmVha1R5cGUuQnIsXG4gICAgICAgICAgICAgIGJyZWFrQXQ6IE9wdGlvbmFsLnNvbWUobmV4dFBvcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uczogZmxpcChkaXJlY3Rpb24sIHBvc2l0aW9ucyksXG4gICAgICAgICAgICAgIGJyZWFrVHlwZTogQnJlYWtUeXBlLkJyLFxuICAgICAgICAgICAgICBicmVha0F0OiBPcHRpb25hbC5zb21lKG5leHRQb3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5leHRQb3MuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICBjdXJyZW50UG9zID0gbmV4dFBvcztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZGljYXRlKGN1cnJlbnRQb3MsIG5leHRQb3MpKSB7XG4gICAgICAgICAgY29uc3QgYnJlYWtUeXBlID0gZ2V0QnJlYWtUeXBlKHNjb3BlLCBkaXJlY3Rpb24sIGN1cnJlbnRQb3MsIG5leHRQb3MpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IGZsaXAoZGlyZWN0aW9uLCBwb3NpdGlvbnMpLFxuICAgICAgICAgICAgYnJlYWtUeXBlLFxuICAgICAgICAgICAgYnJlYWtBdDogT3B0aW9uYWwuc29tZShuZXh0UG9zKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2gobmV4dFBvcyk7XG4gICAgICAgIGN1cnJlbnRQb3MgPSBuZXh0UG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb25zOiBmbGlwKGRpcmVjdGlvbiwgcG9zaXRpb25zKSxcbiAgICAgICAgYnJlYWtUeXBlOiBCcmVha1R5cGUuRW9sLFxuICAgICAgICBicmVha0F0OiBPcHRpb25hbC5ub25lKClcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRBZGphY2VudExpbmVQb3NpdGlvbnMgPSAoZGlyZWN0aW9uLCBnZXRQb3NpdGlvbnNVbnRpbEJyZWFrLCBzY29wZSwgc3RhcnQpID0+IGdldFBvc2l0aW9uc1VudGlsQnJlYWsoc2NvcGUsIHN0YXJ0KS5icmVha0F0Lm1hcChwb3MgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gZ2V0UG9zaXRpb25zVW50aWxCcmVhayhzY29wZSwgcG9zKS5wb3NpdGlvbnM7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBIRGlyZWN0aW9uLkJhY2t3YXJkcyA/IHBvc2l0aW9ucy5jb25jYXQocG9zKSA6IFtwb3NdLmNvbmNhdChwb3NpdGlvbnMpO1xuICAgIH0pLmdldE9yKFtdKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbkZyb21Qb2ludCA9IChwb3NpdGlvbnMsIHgpID0+IGZvbGRsKHBvc2l0aW9ucywgKGFjYywgbmV3UG9zKSA9PiBhY2MuZm9sZCgoKSA9PiBPcHRpb25hbC5zb21lKG5ld1BvcyksIGxhc3RQb3MgPT4gbGlmdDIoaGVhZChsYXN0UG9zLmdldENsaWVudFJlY3RzKCkpLCBoZWFkKG5ld1Bvcy5nZXRDbGllbnRSZWN0cygpKSwgKGxhc3RSZWN0LCBuZXdSZWN0KSA9PiB7XG4gICAgICBjb25zdCBsYXN0RGlzdCA9IE1hdGguYWJzKHggLSBsYXN0UmVjdC5sZWZ0KTtcbiAgICAgIGNvbnN0IG5ld0Rpc3QgPSBNYXRoLmFicyh4IC0gbmV3UmVjdC5sZWZ0KTtcbiAgICAgIHJldHVybiBuZXdEaXN0IDw9IGxhc3REaXN0ID8gbmV3UG9zIDogbGFzdFBvcztcbiAgICB9KS5vcihhY2MpKSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbiA9IChwb3NpdGlvbnMsIHBvcykgPT4gaGVhZChwb3MuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZCh0YXJnZXRSZWN0ID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50KHBvc2l0aW9ucywgdGFyZ2V0UmVjdC5sZWZ0KSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUgPSBjdXJyeShnZXRQb3NpdGlvbnNVbnRpbCwgQ2FyZXRQb3NpdGlvbi5pc0Fib3ZlLCAtMSk7XG4gICAgY29uc3QgZ2V0UG9zaXRpb25zVW50aWxOZXh0TGluZSA9IGN1cnJ5KGdldFBvc2l0aW9uc1VudGlsLCBDYXJldFBvc2l0aW9uLmlzQmVsb3csIDEpO1xuICAgIGNvbnN0IGdldFBvc2l0aW9uc0Fib3ZlID0gY3VycnkoZ2V0QWRqYWNlbnRMaW5lUG9zaXRpb25zLCAtMSwgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUpO1xuICAgIGNvbnN0IGdldFBvc2l0aW9uc0JlbG93ID0gY3VycnkoZ2V0QWRqYWNlbnRMaW5lUG9zaXRpb25zLCAxLCBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lKTtcbiAgICBjb25zdCBpc0F0Rmlyc3RMaW5lID0gKHNjb3BlLCBwb3MpID0+IGdldFBvc2l0aW9uc1VudGlsUHJldmlvdXNMaW5lKHNjb3BlLCBwb3MpLmJyZWFrQXQuaXNOb25lKCk7XG4gICAgY29uc3QgaXNBdExhc3RMaW5lID0gKHNjb3BlLCBwb3MpID0+IGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoc2NvcGUsIHBvcykuYnJlYWtBdC5pc05vbmUoKTtcbiAgICBjb25zdCBnZXRGaXJzdExpbmVQb3NpdGlvbnMgPSBzY29wZSA9PiBmaXJzdFBvc2l0aW9uSW4oc2NvcGUpLm1hcChwb3MgPT4gW3Bvc10uY29uY2F0KGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoc2NvcGUsIHBvcykucG9zaXRpb25zKSkuZ2V0T3IoW10pO1xuICAgIGNvbnN0IGdldExhc3RMaW5lUG9zaXRpb25zID0gc2NvcGUgPT4gbGFzdFBvc2l0aW9uSW4oc2NvcGUpLm1hcChwb3MgPT4gZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUoc2NvcGUsIHBvcykucG9zaXRpb25zLmNvbmNhdChwb3MpKS5nZXRPcihbXSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFBvc2l0aW9uQWJvdmUgPSAoc2NvcGUsIHBvcykgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb24oZ2V0UG9zaXRpb25zQWJvdmUoc2NvcGUsIHBvcyksIHBvcyk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFBvc2l0aW9uQmVsb3cgPSAoc2NvcGUsIHBvcykgPT4gZmluZENsb3Nlc3RIb3Jpem9udGFsUG9zaXRpb24oZ2V0UG9zaXRpb25zQmVsb3coc2NvcGUsIHBvcyksIHBvcyk7XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDQgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RMZWZ0JDEgPSAoY2xpZW50UmVjdCwgY2xpZW50WCkgPT4gTWF0aC5hYnMoY2xpZW50UmVjdC5sZWZ0IC0gY2xpZW50WCk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JlY3RSaWdodCQxID0gKGNsaWVudFJlY3QsIGNsaWVudFgpID0+IE1hdGguYWJzKGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBpc05vZGVDbGllbnRSZWN0ID0gcmVjdCA9PiBoYXNOb25OdWxsYWJsZUtleShyZWN0LCAnbm9kZScpO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0Q2xpZW50UmVjdCA9IChjbGllbnRSZWN0cywgY2xpZW50WCkgPT4gcmVkdWNlKGNsaWVudFJlY3RzLCAob2xkQ2xpZW50UmVjdCwgY2xpZW50UmVjdCkgPT4ge1xuICAgICAgY29uc3Qgb2xkRGlzdGFuY2UgPSBNYXRoLm1pbihkaXN0YW5jZVRvUmVjdExlZnQkMShvbGRDbGllbnRSZWN0LCBjbGllbnRYKSwgZGlzdGFuY2VUb1JlY3RSaWdodCQxKG9sZENsaWVudFJlY3QsIGNsaWVudFgpKTtcbiAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5taW4oZGlzdGFuY2VUb1JlY3RMZWZ0JDEoY2xpZW50UmVjdCwgY2xpZW50WCksIGRpc3RhbmNlVG9SZWN0UmlnaHQkMShjbGllbnRSZWN0LCBjbGllbnRYKSk7XG4gICAgICBpZiAobmV3RGlzdGFuY2UgPT09IG9sZERpc3RhbmNlICYmIGlzTm9kZUNsaWVudFJlY3QoY2xpZW50UmVjdCkgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZSQ0KGNsaWVudFJlY3Qubm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFJlY3Q7XG4gICAgICB9XG4gICAgICBpZiAobmV3RGlzdGFuY2UgPCBvbGREaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvbGRDbGllbnRSZWN0O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0Tm9kZUNsaWVudFJlY3RzID0gbm9kZSA9PiB7XG4gICAgICBjb25zdCB0b0FycmF5V2l0aE5vZGUgPSBjbGllbnRSZWN0cyA9PiB7XG4gICAgICAgIHJldHVybiBtYXAkMyhjbGllbnRSZWN0cywgcmVjdCA9PiB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGNsb25lJDEocmVjdCk7XG4gICAgICAgICAgY2xpZW50UmVjdC5ub2RlID0gbm9kZTtcbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0b0FycmF5V2l0aE5vZGUobm9kZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0JGEobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgcm5nID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJuZy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgcm5nLnNldEVuZChub2RlLCBub2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXlXaXRoTm9kZShybmcuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRDbGllbnRSZWN0cyA9IG5vZGVzID0+IGJpbmQkMyhub2RlcywgZ2V0Tm9kZUNsaWVudFJlY3RzKTtcblxuICAgIHZhciBWRGlyZWN0aW9uO1xuICAgIChmdW5jdGlvbiAoVkRpcmVjdGlvbikge1xuICAgICAgVkRpcmVjdGlvbltWRGlyZWN0aW9uWydVcCddID0gLTFdID0gJ1VwJztcbiAgICAgIFZEaXJlY3Rpb25bVkRpcmVjdGlvblsnRG93biddID0gMV0gPSAnRG93bic7XG4gICAgfShWRGlyZWN0aW9uIHx8IChWRGlyZWN0aW9uID0ge30pKSk7XG4gICAgY29uc3QgZmluZFVudGlsID0gKGRpcmVjdGlvbiwgcm9vdCwgcHJlZGljYXRlRm4sIG5vZGUpID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBmaW5kTm9kZShjdXJyZW50Tm9kZSwgZGlyZWN0aW9uLCBpc0VkaXRhYmxlQ2FyZXRDYW5kaWRhdGUkMSwgcm9vdCkpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZUZuKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2Fsa1VudGlsID0gKGRpcmVjdGlvbiwgaXNBYm92ZUZuLCBpc0JlZmxvd0ZuLCByb290LCBwcmVkaWNhdGVGbiwgY2FyZXRQb3NpdGlvbikgPT4ge1xuICAgICAgbGV0IGxpbmUgPSAwO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBjb25zdCBhZGQgPSBub2RlID0+IHtcbiAgICAgICAgbGV0IGNsaWVudFJlY3RzID0gZ2V0Q2xpZW50UmVjdHMoW25vZGVdKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICBjbGllbnRSZWN0cyA9IGNsaWVudFJlY3RzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2xpZW50UmVjdCA9IGNsaWVudFJlY3RzW2ldO1xuICAgICAgICAgIGlmIChpc0JlZmxvd0ZuKGNsaWVudFJlY3QsIHRhcmdldENsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIGlzQWJvdmVGbihjbGllbnRSZWN0LCBsYXN0JDIocmVzdWx0KSkpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xpZW50UmVjdC5saW5lID0gbGluZTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlRm4oY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaChjbGllbnRSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgY29uc3QgdGFyZ2V0Q2xpZW50UmVjdCA9IGxhc3QkMihjYXJldFBvc2l0aW9uLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgaWYgKCF0YXJnZXRDbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgIGZpbmRVbnRpbChkaXJlY3Rpb24sIHJvb3QsIGFkZCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3QgYWJvdmVMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA+IGxpbmVOdW1iZXI7XG4gICAgY29uc3QgaXNMaW5lTnVtYmVyID0gKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpID0+IGNsaWVudFJlY3QubGluZSA9PT0gbGluZU51bWJlcjtcbiAgICBjb25zdCB1cFVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLlVwLCBpc0Fib3ZlJDEsIGlzQmVsb3ckMSk7XG4gICAgY29uc3QgZG93blVudGlsID0gY3Vycnkod2Fsa1VudGlsLCBWRGlyZWN0aW9uLkRvd24sIGlzQmVsb3ckMSwgaXNBYm92ZSQxKTtcbiAgICBjb25zdCBnZXRMYXN0Q2xpZW50UmVjdCA9IGNhcmV0UG9zaXRpb24gPT4ge1xuICAgICAgcmV0dXJuIGxhc3QkMihjYXJldFBvc2l0aW9uLmdldENsaWVudFJlY3RzKCkpO1xuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb25zVW50aWwgPSAoZGlyZWN0aW9uLCByb290LCBwcmVkaWNhdGVGbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihyb290KTtcbiAgICAgIGxldCB3YWxrRm47XG4gICAgICBsZXQgaXNCZWxvd0ZuO1xuICAgICAgbGV0IGlzQWJvdmVGbjtcbiAgICAgIGxldCBjYXJldFBvc2l0aW9uO1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBsZXQgbGluZSA9IDA7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgIHdhbGtGbiA9IGNhcmV0V2Fsa2VyLm5leHQ7XG4gICAgICAgIGlzQmVsb3dGbiA9IGlzQmVsb3ckMTtcbiAgICAgICAgaXNBYm92ZUZuID0gaXNBYm92ZSQxO1xuICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5hZnRlcihub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGtGbiA9IGNhcmV0V2Fsa2VyLnByZXY7XG4gICAgICAgIGlzQmVsb3dGbiA9IGlzQWJvdmUkMTtcbiAgICAgICAgaXNBYm92ZUZuID0gaXNCZWxvdyQxO1xuICAgICAgICBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5iZWZvcmUobm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gZ2V0TGFzdENsaWVudFJlY3QoY2FyZXRQb3NpdGlvbik7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICghY2FyZXRQb3NpdGlvbi5pc1Zpc2libGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QgPSBnZXRMYXN0Q2xpZW50UmVjdChjYXJldFBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGlzQWJvdmVGbihyZWN0LCB0YXJnZXRDbGllbnRSZWN0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiBpc0JlbG93Rm4ocmVjdCwgbGFzdCQyKHJlc3VsdCkpKSB7XG4gICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBjbG9uZSQxKHJlY3QpO1xuICAgICAgICBjbGllbnRSZWN0LnBvc2l0aW9uID0gY2FyZXRQb3NpdGlvbjtcbiAgICAgICAgY2xpZW50UmVjdC5saW5lID0gbGluZTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZUZuKGNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjbGllbnRSZWN0KTtcbiAgICAgIH0gd2hpbGUgKGNhcmV0UG9zaXRpb24gPSB3YWxrRm4oY2FyZXRQb3NpdGlvbikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWJvdmVMaW5lID0gbGluZU51bWJlciA9PiBjbGllbnRSZWN0ID0+IGFib3ZlTGluZU51bWJlcihsaW5lTnVtYmVyLCBjbGllbnRSZWN0KTtcbiAgICBjb25zdCBpc0xpbmUgPSBsaW5lTnVtYmVyID0+IGNsaWVudFJlY3QgPT4gaXNMaW5lTnVtYmVyKGxpbmVOdW1iZXIsIGNsaWVudFJlY3QpO1xuXG4gICAgY29uc3QgbW92ZVRvUmFuZ2UgPSAoZWRpdG9yLCBybmcpID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBzY3JvbGxSYW5nZUludG9WaWV3KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJSYW5nZUNhcmV0T3B0ID0gKGVkaXRvciwgcmFuZ2UsIHNjcm9sbEludG9WaWV3KSA9PiBPcHRpb25hbC5zb21lKHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCByYW5nZSwgc2Nyb2xsSW50b1ZpZXcpKTtcbiAgICBjb25zdCBtb3ZlSG9yaXpvbnRhbGx5ID0gKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSwgaXNCZWZvcmUsIGlzQWZ0ZXIsIGlzRWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgZm9yd2FyZHMgPSBkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uRm9yd2FyZHM7XG4gICAgICBjb25zdCBjYXJldFdhbGtlciA9IENhcmV0V2Fsa2VyKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3QgZ2V0TmV4dFBvc0ZuID0gY3VycnkoZ2V0VmlzdWFsQ2FyZXRQb3NpdGlvbiwgZm9yd2FyZHMgPyBjYXJldFdhbGtlci5uZXh0IDogY2FyZXRXYWxrZXIucHJldik7XG4gICAgICBjb25zdCBpc0JlZm9yZUZuID0gZm9yd2FyZHMgPyBpc0JlZm9yZSA6IGlzQWZ0ZXI7XG4gICAgICBpZiAoIXJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICBjb25zdCBub2RlID0gZ2V0U2VsZWN0ZWROb2RlKHJhbmdlKTtcbiAgICAgICAgaWYgKGlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgIHJldHVybiBzaG93Q2FyZXQoZGlyZWN0aW9uLCBlZGl0b3IsIG5vZGUsIGRpcmVjdGlvbiA9PT0gSERpcmVjdGlvbi5CYWNrd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NlZkF0RWRnZVNlbGVjdGVkKGVkaXRvcikpIHtcbiAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICBuZXdSYW5nZS5jb2xsYXBzZShkaXJlY3Rpb24gPT09IEhEaXJlY3Rpb24uQmFja3dhcmRzKTtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShuZXdSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBnZXROb3JtYWxpemVkUmFuZ2VFbmRQb2ludChkaXJlY3Rpb24sIGVkaXRvci5nZXRCb2R5KCksIHJhbmdlKTtcbiAgICAgIGlmIChpc0JlZm9yZUZuKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3ROb2RlKGVkaXRvciwgY2FyZXRQb3NpdGlvbi5nZXROb2RlKCFmb3J3YXJkcykpO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRDYXJldFBvc2l0aW9uID0gZ2V0TmV4dFBvc0ZuKGNhcmV0UG9zaXRpb24pO1xuICAgICAgY29uc3QgcmFuZ2VJc0luQ29udGFpbmVyQmxvY2sgPSBpc1JhbmdlSW5DYXJldENvbnRhaW5lckJsb2NrKHJhbmdlKTtcbiAgICAgIGlmICghbmV4dENhcmV0UG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlSXNJbkNvbnRhaW5lckJsb2NrID8gT3B0aW9uYWwuc29tZShyYW5nZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0Q2FyZXRQb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmRzLCBuZXh0Q2FyZXRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoaXNCZWZvcmVGbihuZXh0Q2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgbmV4dENhcmV0UG9zaXRpb24uZ2V0Tm9kZSghZm9yd2FyZHMpLCBmb3J3YXJkcywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVla0NhcmV0UG9zaXRpb24gPSBnZXROZXh0UG9zRm4obmV4dENhcmV0UG9zaXRpb24pO1xuICAgICAgaWYgKHBlZWtDYXJldFBvc2l0aW9uICYmIGlzQmVmb3JlRm4ocGVla0NhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGlmIChpc01vdmVJbnNpZGVTYW1lQmxvY2sobmV4dENhcmV0UG9zaXRpb24sIHBlZWtDYXJldFBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBzaG93Q2FyZXQoZGlyZWN0aW9uLCBlZGl0b3IsIHBlZWtDYXJldFBvc2l0aW9uLmdldE5vZGUoIWZvcndhcmRzKSwgZm9yd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhbmdlSXNJbkNvbnRhaW5lckJsb2NrKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSYW5nZUNhcmV0T3B0KGVkaXRvciwgbmV4dENhcmV0UG9zaXRpb24udG9SYW5nZSgpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVZlcnRpY2FsbHkgPSAoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZSwgaXNBZnRlciwgaXNFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gZ2V0Tm9ybWFsaXplZFJhbmdlRW5kUG9pbnQoZGlyZWN0aW9uLCBlZGl0b3IuZ2V0Qm9keSgpLCByYW5nZSk7XG4gICAgICBjb25zdCBjYXJldENsaWVudFJlY3QgPSBsYXN0JDIoY2FyZXRQb3NpdGlvbi5nZXRDbGllbnRSZWN0cygpKTtcbiAgICAgIGNvbnN0IGZvcndhcmRzID0gZGlyZWN0aW9uID09PSBWRGlyZWN0aW9uLkRvd247XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGlmICghY2FyZXRDbGllbnRSZWN0KSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDZWZBdEVkZ2VTZWxlY3RlZChlZGl0b3IpKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSBmb3J3YXJkcyA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJhbmdlKSA6IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocmFuZ2UpO1xuICAgICAgICBjb25zdCBnZXRDbG9zZXN0Rm4gPSAhZm9yd2FyZHMgPyBnZXRDbG9zZXN0UG9zaXRpb25BYm92ZSA6IGdldENsb3Nlc3RQb3NpdGlvbkJlbG93O1xuICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdEZuKHJvb3QsIGNhcmV0UG9zaXRpb24pLm9yVGh1bmsoKCkgPT4gT3B0aW9uYWwuZnJvbShjYXJldFBvc2l0aW9uKSkubWFwKHBvcyA9PiBwb3MudG9SYW5nZSgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGtlckZuID0gZm9yd2FyZHMgPyBkb3duVW50aWwgOiB1cFVudGlsO1xuICAgICAgY29uc3QgbGluZVBvc2l0aW9ucyA9IHdhbGtlckZuKHJvb3QsIGlzQWJvdmVMaW5lKDEpLCBjYXJldFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IG5leHRMaW5lUG9zaXRpb25zID0gZmlsdGVyJDUobGluZVBvc2l0aW9ucywgaXNMaW5lKDEpKTtcbiAgICAgIGNvbnN0IGNsaWVudFggPSBjYXJldENsaWVudFJlY3QubGVmdDtcbiAgICAgIGNvbnN0IG5leHRMaW5lUmVjdCA9IGZpbmRDbG9zZXN0Q2xpZW50UmVjdChuZXh0TGluZVBvc2l0aW9ucywgY2xpZW50WCk7XG4gICAgICBpZiAobmV4dExpbmVSZWN0ICYmIGlzRWxlbWVudChuZXh0TGluZVJlY3Qubm9kZSkpIHtcbiAgICAgICAgY29uc3QgZGlzdDEgPSBNYXRoLmFicyhjbGllbnRYIC0gbmV4dExpbmVSZWN0LmxlZnQpO1xuICAgICAgICBjb25zdCBkaXN0MiA9IE1hdGguYWJzKGNsaWVudFggLSBuZXh0TGluZVJlY3QucmlnaHQpO1xuICAgICAgICByZXR1cm4gc2hvd0NhcmV0KGRpcmVjdGlvbiwgZWRpdG9yLCBuZXh0TGluZVJlY3Qubm9kZSwgZGlzdDEgPCBkaXN0MiwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgbGV0IGN1cnJlbnROb2RlO1xuICAgICAgaWYgKGlzQmVmb3JlKGNhcmV0UG9zaXRpb24pKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2FyZXRQb3NpdGlvbi5nZXROb2RlKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQWZ0ZXIoY2FyZXRQb3NpdGlvbikpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGdldFNlbGVjdGVkTm9kZShyYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbnMgPSBwb3NpdGlvbnNVbnRpbChkaXJlY3Rpb24sIHJvb3QsIGlzQWJvdmVMaW5lKDEpLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGxldCBjbG9zZXN0TmV4dExpbmVSZWN0ID0gZmluZENsb3Nlc3RDbGllbnRSZWN0KGZpbHRlciQ1KGNhcmV0UG9zaXRpb25zLCBpc0xpbmUoMSkpLCBjbGllbnRYKTtcbiAgICAgICAgaWYgKGNsb3Nlc3ROZXh0TGluZVJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyUmFuZ2VDYXJldE9wdChlZGl0b3IsIGNsb3Nlc3ROZXh0TGluZVJlY3QucG9zaXRpb24udG9SYW5nZSgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VzdE5leHRMaW5lUmVjdCA9IGxhc3QkMihmaWx0ZXIkNShjYXJldFBvc2l0aW9ucywgaXNMaW5lKDApKSk7XG4gICAgICAgIGlmIChjbG9zZXN0TmV4dExpbmVSZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclJhbmdlQ2FyZXRPcHQoZWRpdG9yLCBjbG9zZXN0TmV4dExpbmVSZWN0LnBvc2l0aW9uLnRvUmFuZ2UoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dExpbmVQb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkcykuZmlsdGVyKGZvcndhcmRzID8gaXNBZnRlciA6IGlzQmVmb3JlKS5tYXAocG9zID0+IHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCBwb3MudG9SYW5nZSgpLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldExpbmVFbmRQb2ludCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBmcm9tID0gZm9yd2FyZCA/IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlRW5kKHJuZykgOiBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBjb25zdCBob3N0ID0gZ2V0RWRpdGluZ0hvc3QoZnJvbS5jb250YWluZXIoKSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBjb25zdCBsaW5lSW5mbyA9IGdldFBvc2l0aW9uc1VudGlsTmV4dExpbmUoaG9zdCwgZnJvbSk7XG4gICAgICAgIHJldHVybiBsYXN0JDMobGluZUluZm8ucG9zaXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbmVJbmZvID0gZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUoaG9zdCwgZnJvbSk7XG4gICAgICAgIHJldHVybiBoZWFkKGxpbmVJbmZvLnBvc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9MaW5lRW5kUG9pbnQkMyA9IChlZGl0b3IsIGZvcndhcmQsIGlzRWxlbWVudFBvc2l0aW9uKSA9PiBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkKS5maWx0ZXIoaXNFbGVtZW50UG9zaXRpb24pLmV4aXN0cyhwb3MgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldENhcmV0UG9zaXRpb24gPSAoZWRpdG9yLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5kb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnQocG9zLmNvbnRhaW5lcigpLCBwb3Mub2Zmc2V0KCkpO1xuICAgICAgcm5nLnNldEVuZChwb3MuY29udGFpbmVyKCksIHBvcy5vZmZzZXQoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0U2VsZWN0ZWQgPSAoc3RhdGUsIGVsbSkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNlbGVjdGVkJywgJ2lubGluZS1ib3VuZGFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1tY2Utc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckNhcmV0TG9jYXRpb24gPSAoZWRpdG9yLCBjYXJldCwgbG9jYXRpb24pID0+IHJlbmRlckNhcmV0KGNhcmV0LCBsb2NhdGlvbikubWFwKHBvcyA9PiB7XG4gICAgICBzZXRDYXJldFBvc2l0aW9uKGVkaXRvciwgcG9zKTtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRQb3NpdGlvbkZyb21SYW5nZSA9IChyYW5nZSwgcm9vdCwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJhbmdlKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW5kID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocmFuZ2UpO1xuICAgICAgICByZXR1cm4gZm9yd2FyZCA/IHByZXZQb3NpdGlvbihyb290LCBlbmQpLmdldE9yKGVuZCkgOiBuZXh0UG9zaXRpb24ocm9vdCwgc3RhcnQpLmdldE9yKHN0YXJ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGZpbmRMb2NhdGlvbiA9IChlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBmcm9tID0gZ2V0UG9zaXRpb25Gcm9tUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgcm9vdE5vZGUsIGZvcndhcmQpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBmaW5kTG9jYXRpb24kMShmb3J3YXJkLCBpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICByZXR1cm4gbG9jYXRpb24uYmluZChsb2NhdGlvbiA9PiByZW5kZXJDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVJbmxpbmVzID0gKGlzSW5saW5lVGFyZ2V0LCBkb20sIGVsbXMpID0+IHtcbiAgICAgIGNvbnN0IGlubGluZUJvdW5kYXJpZXMgPSBtYXAkMyhkZXNjZW5kYW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShkb20uZ2V0Um9vdCgpKSwgJypbZGF0YS1tY2Utc2VsZWN0ZWQ9XCJpbmxpbmUtYm91bmRhcnlcIl0nKSwgZSA9PiBlLmRvbSk7XG4gICAgICBjb25zdCBzZWxlY3RlZElubGluZXMgPSBmaWx0ZXIkNShpbmxpbmVCb3VuZGFyaWVzLCBpc0lubGluZVRhcmdldCk7XG4gICAgICBjb25zdCB0YXJnZXRJbmxpbmVzID0gZmlsdGVyJDUoZWxtcywgaXNJbmxpbmVUYXJnZXQpO1xuICAgICAgZWFjaCRlKGRpZmZlcmVuY2Uoc2VsZWN0ZWRJbmxpbmVzLCB0YXJnZXRJbmxpbmVzKSwgY3Vycnkoc2V0U2VsZWN0ZWQsIGZhbHNlKSk7XG4gICAgICBlYWNoJGUoZGlmZmVyZW5jZSh0YXJnZXRJbmxpbmVzLCBzZWxlY3RlZElubGluZXMpLCBjdXJyeShzZXRTZWxlY3RlZCwgdHJ1ZSkpO1xuICAgIH07XG4gICAgY29uc3Qgc2FmZVJlbW92ZUNhcmV0Q29udGFpbmVyID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGNvbnN0IGNhcmV0VmFsdWUgPSBjYXJldC5nZXQoKTtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgIWVkaXRvci5jb21wb3NpbmcgJiYgY2FyZXRWYWx1ZSkge1xuICAgICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpZiAoQ2FyZXRQb3NpdGlvbi5pc1RleHRQb3NpdGlvbihwb3MpICYmICFpc0F0WndzcChwb3MpKSB7XG4gICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHJlbW92ZUFuZFJlcG9zaXRpb24oY2FyZXRWYWx1ZSwgcG9zKSk7XG4gICAgICAgICAgY2FyZXQuc2V0KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJJbnNpZGVJbmxpbmVDYXJldCA9IChpc0lubGluZVRhcmdldCwgZWRpdG9yLCBjYXJldCwgZWxtcykgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBpbmxpbmVzID0gZmlsdGVyJDUoZWxtcywgaXNJbmxpbmVUYXJnZXQpO1xuICAgICAgICBlYWNoJGUoaW5saW5lcywgX2lubGluZSA9PiB7XG4gICAgICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgICByZWFkTG9jYXRpb24oaXNJbmxpbmVUYXJnZXQsIGVkaXRvci5nZXRCb2R5KCksIHBvcykuYmluZChsb2NhdGlvbiA9PiByZW5kZXJDYXJldExvY2F0aW9uKGVkaXRvciwgY2FyZXQsIGxvY2F0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZSQzID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IGlzSW5saW5lQm91bmRhcmllc0VuYWJsZWQoZWRpdG9yKSA/IGZpbmRMb2NhdGlvbihlZGl0b3IsIGNhcmV0LCBmb3J3YXJkKS5pc1NvbWUoKSA6IGZhbHNlO1xuICAgIGNvbnN0IG1vdmVXb3JkID0gKGZvcndhcmQsIGVkaXRvciwgX2NhcmV0KSA9PiBpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikgPyBtb3ZlQnlXb3JkKGZvcndhcmQsIGVkaXRvcikgOiBmYWxzZTtcbiAgICBjb25zdCBzZXR1cFNlbGVjdGVkU3RhdGUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgY2FyZXQgPSBDZWxsKG51bGwpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgZSA9PiB7XG4gICAgICAgIGlmIChpc0lubGluZUJvdW5kYXJpZXNFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgICB0b2dnbGVJbmxpbmVzKGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvci5kb20sIGUucGFyZW50cyk7XG4gICAgICAgICAgc2FmZVJlbW92ZUNhcmV0Q29udGFpbmVyKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICAgIHJlbmRlckluc2lkZUlubGluZUNhcmV0KGlzSW5saW5lVGFyZ2V0JDEsIGVkaXRvciwgY2FyZXQsIGUucGFyZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhcmV0O1xuICAgIH07XG4gICAgY29uc3QgbW92ZU5leHRXb3JkID0gY3VycnkobW92ZVdvcmQsIHRydWUpO1xuICAgIGNvbnN0IG1vdmVQcmV2V29yZCA9IGN1cnJ5KG1vdmVXb3JkLCBmYWxzZSk7XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50JDIgPSAoZWRpdG9yLCBmb3J3YXJkLCBjYXJldCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQm91bmRhcmllc0VuYWJsZWQoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBsaW5lUG9pbnQgPSBnZXRMaW5lRW5kUG9pbnQoZWRpdG9yLCBmb3J3YXJkKS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgIHJldHVybiBmb3J3YXJkID8gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSA6IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWFkTG9jYXRpb24oY3VycnkoaXNJbmxpbmVUYXJnZXQsIGVkaXRvciksIGVkaXRvci5nZXRCb2R5KCksIGxpbmVQb2ludCkuZXhpc3RzKGxvYyA9PiB7XG4gICAgICAgICAgY29uc3Qgb3V0c2lkZUxvYyA9IG91dHNpZGUobG9jKTtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ2FyZXQoY2FyZXQsIG91dHNpZGVMb2MpLmV4aXN0cyhwb3MgPT4ge1xuICAgICAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJhbmdlRnJvbVBvc2l0aW9ucyA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQoZnJvbS5jb250YWluZXIoKSwgZnJvbS5vZmZzZXQoKSk7XG4gICAgICByYW5nZS5zZXRFbmQodG8uY29udGFpbmVyKCksIHRvLm9mZnNldCgpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc09ubHlUd29Pckxlc3NQb3NpdGlvbnNMZWZ0ID0gZWxtID0+IGxpZnQyKGZpcnN0UG9zaXRpb25JbihlbG0pLCBsYXN0UG9zaXRpb25JbihlbG0pLCAoZmlyc3RQb3MsIGxhc3RQb3MpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaXJzdFBvcyA9IG5vcm1hbGl6ZVBvc2l0aW9uKHRydWUsIGZpcnN0UG9zKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMYXN0UG9zID0gbm9ybWFsaXplUG9zaXRpb24oZmFsc2UsIGxhc3RQb3MpO1xuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbihlbG0sIG5vcm1hbGl6ZWRGaXJzdFBvcykuZm9yYWxsKHBvcyA9PiBwb3MuaXNFcXVhbChub3JtYWxpemVkTGFzdFBvcykpO1xuICAgIH0pLmdldE9yKHRydWUpO1xuICAgIGNvbnN0IHNldENhcmV0TG9jYXRpb24gPSAoZWRpdG9yLCBjYXJldCkgPT4gbG9jYXRpb24gPT4gcmVuZGVyQ2FyZXQoY2FyZXQsIGxvY2F0aW9uKS5tYXAocG9zID0+ICgpID0+IHNldENhcmV0UG9zaXRpb24oZWRpdG9yLCBwb3MpKTtcbiAgICBjb25zdCBkZWxldGVGcm9tVG8gPSAoZWRpdG9yLCBjYXJldCwgZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IGlzSW5saW5lVGFyZ2V0JDEgPSBjdXJyeShpc0lubGluZVRhcmdldCwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhyYW5nZUZyb21Qb3NpdGlvbnMoZnJvbSwgdG8pKTtcbiAgICAgICAgZXhlY05hdGl2ZURlbGV0ZUNvbW1hbmQoZWRpdG9yKTtcbiAgICAgICAgcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpKS5tYXAoaW5zaWRlKS5iaW5kKHNldENhcmV0TG9jYXRpb24oZWRpdG9yLCBjYXJldCkpLmVhY2goY2FsbCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgY29uc3QgcmVzY29wZSA9IChyb290Tm9kZSwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2sgPSBnZXRQYXJlbnRCbG9jayQzKG5vZGUsIHJvb3ROb2RlKTtcbiAgICAgIHJldHVybiBwYXJlbnRCbG9jayA/IHBhcmVudEJsb2NrIDogcm9vdE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGVDb2xsYXBzZWQgPSAoZWRpdG9yLCBjYXJldCwgZm9yd2FyZCwgZnJvbSkgPT4ge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSByZXNjb3BlKGVkaXRvci5nZXRCb2R5KCksIGZyb20uY29udGFpbmVyKCkpO1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgZnJvbUxvY2F0aW9uID0gcmVhZExvY2F0aW9uKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBmcm9tKTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZnJvbUxvY2F0aW9uLmJpbmQobG9jYXRpb24gPT4ge1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKGNvbnN0YW50KE9wdGlvbmFsLnNvbWUoaW5zaWRlKGxvY2F0aW9uKSkpLCBPcHRpb25hbC5ub25lLCBjb25zdGFudChPcHRpb25hbC5zb21lKG91dHNpZGUobG9jYXRpb24pKSksIE9wdGlvbmFsLm5vbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5mb2xkKE9wdGlvbmFsLm5vbmUsIGNvbnN0YW50KE9wdGlvbmFsLnNvbWUob3V0c2lkZShsb2NhdGlvbikpKSwgT3B0aW9uYWwubm9uZSwgY29uc3RhbnQoT3B0aW9uYWwuc29tZShpbnNpZGUobG9jYXRpb24pKSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5tYXAoc2V0Q2FyZXRMb2NhdGlvbihlZGl0b3IsIGNhcmV0KSkuZ2V0T3JUaHVuaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvUG9zaXRpb24gPSBuYXZpZ2F0ZShmb3J3YXJkLCByb290Tm9kZSwgZnJvbSk7XG4gICAgICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0b1Bvc2l0aW9uLmJpbmQocG9zID0+IHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCByb290Tm9kZSwgcG9zKSk7XG4gICAgICAgIHJldHVybiBsaWZ0Mihmcm9tTG9jYXRpb24sIHRvTG9jYXRpb24sICgpID0+IGZpbmRSb290SW5saW5lKGlzSW5saW5lVGFyZ2V0JDEsIHJvb3ROb2RlLCBmcm9tKS5iaW5kKGVsbSA9PiB7XG4gICAgICAgICAgaWYgKGhhc09ubHlUd29Pckxlc3NQb3NpdGlvbnNMZWZ0KGVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKS5nZXRPclRodW5rKCgpID0+IHRvTG9jYXRpb24uYmluZCgoKSA9PiB0b1Bvc2l0aW9uLm1hcCh0byA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZUZyb21UbyhlZGl0b3IsIGNhcmV0LCBmcm9tLCB0byk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGVGcm9tVG8oZWRpdG9yLCBjYXJldCwgdG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQ0ID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgaXNJbmxpbmVCb3VuZGFyaWVzRW5hYmxlZChlZGl0b3IpKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICByZXR1cm4gYmFja3NwYWNlRGVsZXRlQ29sbGFwc2VkKGVkaXRvciwgY2FyZXQsIGZvcndhcmQsIGZyb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTXVsdGlwbGVDaGlsZHJlbiA9IGVsbSA9PiBjaGlsZE5vZGVzQ291bnQoZWxtKSA+IDE7XG4gICAgY29uc3QgZ2V0UGFyZW50c1VudGlsID0gKGVkaXRvciwgcHJlZCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsbSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgY29uc3Qgc3RhcnRFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpO1xuICAgICAgY29uc3QgcGFyZW50cyA9IHBhcmVudHNBbmRTZWxmKHN0YXJ0RWxtLCByb290RWxtKTtcbiAgICAgIHJldHVybiBmaW5kSW5kZXgkMihwYXJlbnRzLCBwcmVkKS5mb2xkKGNvbnN0YW50KHBhcmVudHMpLCBpbmRleCA9PiBwYXJlbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNPbmx5T25lQ2hpbGQgPSBlbG0gPT4gY2hpbGROb2Rlc0NvdW50KGVsbSkgPT09IDE7XG4gICAgY29uc3QgZ2V0UGFyZW50SW5saW5lc1VudGlsTXVsdGljaGlsZElubGluZSA9IGVkaXRvciA9PiBnZXRQYXJlbnRzVW50aWwoZWRpdG9yLCBlbG0gPT4gaXNCbG9jayQyKGVsbSkgfHwgaGFzTXVsdGlwbGVDaGlsZHJlbihlbG0pKTtcbiAgICBjb25zdCBnZXRQYXJlbnRJbmxpbmVzID0gZWRpdG9yID0+IGdldFBhcmVudHNVbnRpbChlZGl0b3IsIGlzQmxvY2skMik7XG4gICAgY29uc3QgZ2V0Rm9ybWF0Tm9kZXMgPSAoZWRpdG9yLCBwYXJlbnRJbmxpbmVzKSA9PiB7XG4gICAgICBjb25zdCBpc0Zvcm1hdEVsZW1lbnQkMSA9IGN1cnJ5KGlzRm9ybWF0RWxlbWVudCwgZWRpdG9yKTtcbiAgICAgIHJldHVybiBiaW5kJDMocGFyZW50SW5saW5lcywgZWxtID0+IGlzRm9ybWF0RWxlbWVudCQxKGVsbSkgPyBbZWxtLmRvbV0gOiBbXSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRGb3JtYXROb2Rlc0F0U3RhcnQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcGFyZW50SW5saW5lcyA9IGdldFBhcmVudElubGluZXMoZWRpdG9yKTtcbiAgICAgIHJldHVybiBnZXRGb3JtYXROb2RlcyhlZGl0b3IsIHBhcmVudElubGluZXMpO1xuICAgIH07XG4gICAgY29uc3QgZGVsZXRlTGFzdFBvc2l0aW9uID0gKGZvcndhcmQsIGVkaXRvciwgdGFyZ2V0LCBwYXJlbnRJbmxpbmVzKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXROb2RlcyA9IGdldEZvcm1hdE5vZGVzKGVkaXRvciwgcGFyZW50SW5saW5lcyk7XG4gICAgICBpZiAoZm9ybWF0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZUVsZW1lbnQkMihlZGl0b3IsIGZvcndhcmQsIHRhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3MgPSByZXBsYWNlV2l0aENhcmV0Rm9ybWF0KHRhcmdldC5kb20sIGZvcm1hdE5vZGVzKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocG9zLnRvUmFuZ2UoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVDYXJldCQxID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50SW5saW5lcyA9IGZpbHRlciQ1KGdldFBhcmVudElubGluZXNVbnRpbE11bHRpY2hpbGRJbmxpbmUoZWRpdG9yKSwgaGFzT25seU9uZUNoaWxkKTtcbiAgICAgIHJldHVybiBsYXN0JDMocGFyZW50SW5saW5lcykuYmluZCh0YXJnZXQgPT4ge1xuICAgICAgICBjb25zdCBmcm9tUG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgaWYgKHdpbGxEZWxldGVMYXN0UG9zaXRpb25JbkVsZW1lbnQoZm9yd2FyZCwgZnJvbVBvcywgdGFyZ2V0LmRvbSkgJiYgIWlzRW1wdHlDYXJldEZvcm1hdEVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IGRlbGV0ZUxhc3RQb3NpdGlvbihmb3J3YXJkLCBlZGl0b3IsIHRhcmdldCwgcGFyZW50SW5saW5lcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNCckluRW1wdHlFbGVtZW50ID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnRFbG0gPSBlbG0ucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBpc0JyJDYoZWxtKSAmJiAhaXNOdWxsKHBhcmVudEVsbSkgJiYgZWRpdG9yLmRvbS5pc0VtcHR5KHBhcmVudEVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5Q2FyZXQgPSBlbG0gPT4gaXNFbXB0eUNhcmV0Rm9ybWF0RWxlbWVudChTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pKTtcbiAgICBjb25zdCBjcmVhdGVDYXJldEZvcm1hdEF0U3RhcnQgPSAoZWRpdG9yLCBmb3JtYXROb2RlcykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRFbG0gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBjb25zdCBwb3MgPSBpc0JySW5FbXB0eUVsZW1lbnQoZWRpdG9yLCBzdGFydEVsbSkgfHwgaXNFbXB0eUNhcmV0KHN0YXJ0RWxtKSA/IHJlcGxhY2VXaXRoQ2FyZXRGb3JtYXQoc3RhcnRFbG0sIGZvcm1hdE5vZGVzKSA6IGNyZWF0ZUNhcmV0Rm9ybWF0QXRTdGFydCQxKGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCksIGZvcm1hdE5vZGVzKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlQ2FyZXRGb3JtYXQgPSAoZWRpdG9yLCB1cGRhdGVGb3JtYXRzKSA9PiB7XG4gICAgICBjb25zdCBtaXNzaW5nRm9ybWF0cyA9IGRpZmZlcmVuY2UodXBkYXRlRm9ybWF0cywgZ2V0Rm9ybWF0Tm9kZXNBdFN0YXJ0KGVkaXRvcikpO1xuICAgICAgaWYgKG1pc3NpbmdGb3JtYXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3JlYXRlQ2FyZXRGb3JtYXRBdFN0YXJ0KGVkaXRvciwgbWlzc2luZ0Zvcm1hdHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmFuZ2VTdGFydHNBdFRleHRDb250YWluZXIgPSBybmcgPT4gaXNUZXh0JGEocm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICBjb25zdCByYW5nZVN0YXJ0c0F0U3RhcnRPZlRleHRDb250YWluZXIgPSBybmcgPT4gcm5nLnN0YXJ0T2Zmc2V0ID09PSAwICYmIHJhbmdlU3RhcnRzQXRUZXh0Q29udGFpbmVyKHJuZyk7XG4gICAgY29uc3QgcmFuZ2VTdGFydFBhcmVudElzRm9ybWF0RWxlbWVudCA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQYXJlbnQgPSBybmcuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICAgIHJldHVybiAhaXNOdWxsKHN0YXJ0UGFyZW50KSAmJiBpc0Zvcm1hdEVsZW1lbnQoZWRpdG9yLCBTdWdhckVsZW1lbnQuZnJvbURvbShzdGFydFBhcmVudCkpO1xuICAgIH07XG4gICAgY29uc3QgcmFuZ2VTdGFydEFuZEVuZEhhdmVTYW1lUGFyZW50ID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UGFyZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBlbmRQYXJlbnQgPSBybmcuZW5kQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICByZXR1cm4gIWlzTnVsbChzdGFydFBhcmVudCkgJiYgIWlzTnVsbChlbmRQYXJlbnQpICYmIHN0YXJ0UGFyZW50LmlzRXF1YWxOb2RlKGVuZFBhcmVudCk7XG4gICAgfTtcbiAgICBjb25zdCByYW5nZUVuZHNBdEVuZE9mRW5kQ29udGFpbmVyID0gcm5nID0+IHtcbiAgICAgIGNvbnN0IGVuZENvbnRhaW5lciA9IHJuZy5lbmRDb250YWluZXI7XG4gICAgICByZXR1cm4gcm5nLmVuZE9mZnNldCA9PT0gKGlzVGV4dCRhKGVuZENvbnRhaW5lcikgPyBlbmRDb250YWluZXIubGVuZ3RoIDogZW5kQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlRW5kc0F0RW5kT2ZTdGFydENvbnRhaW5lciA9IHJuZyA9PiByYW5nZVN0YXJ0QW5kRW5kSGF2ZVNhbWVQYXJlbnQocm5nKSAmJiByYW5nZUVuZHNBdEVuZE9mRW5kQ29udGFpbmVyKHJuZyk7XG4gICAgY29uc3QgcmFuZ2VFbmRzQWZ0ZXJFbmRPZlN0YXJ0Q29udGFpbmVyID0gcm5nID0+ICFybmcuZW5kQ29udGFpbmVyLmlzRXF1YWxOb2RlKHJuZy5jb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gICAgY29uc3QgcmFuZ2VFbmRzQXRPckFmdGVyRW5kT2ZTdGFydENvbnRhaW5lciA9IHJuZyA9PiByYW5nZUVuZHNBdEVuZE9mU3RhcnRDb250YWluZXIocm5nKSB8fCByYW5nZUVuZHNBZnRlckVuZE9mU3RhcnRDb250YWluZXIocm5nKTtcbiAgICBjb25zdCByZXF1aXJlc0RlbGV0ZVJhbmdlT3ZlcnJpZGUgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiByYW5nZVN0YXJ0c0F0U3RhcnRPZlRleHRDb250YWluZXIocm5nKSAmJiByYW5nZVN0YXJ0UGFyZW50SXNGb3JtYXRFbGVtZW50KGVkaXRvciwgcm5nKSAmJiByYW5nZUVuZHNBdE9yQWZ0ZXJFbmRPZlN0YXJ0Q29udGFpbmVyKHJuZyk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVSYW5nZSQxID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChyZXF1aXJlc0RlbGV0ZVJhbmdlT3ZlcnJpZGUoZWRpdG9yKSkge1xuICAgICAgICBjb25zdCBmb3JtYXROb2RlcyA9IGdldEZvcm1hdE5vZGVzQXRTdGFydChlZGl0b3IpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiB7XG4gICAgICAgICAgZXhlY05hdGl2ZURlbGV0ZUNvbW1hbmQoZWRpdG9yKTtcbiAgICAgICAgICB1cGRhdGVDYXJldEZvcm1hdChlZGl0b3IsIGZvcm1hdE5vZGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmFja3NwYWNlRGVsZXRlJDMgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgPyBkZWxldGVDYXJldCQxKGVkaXRvciwgZm9yd2FyZCkgOiBkZWxldGVSYW5nZSQxKGVkaXRvcik7XG4gICAgY29uc3QgaGFzQW5jZXN0b3JJbmxpbmVDYXJldCA9IGVsbSA9PiBhbmNlc3RvciQxKGVsbSwgbm9kZSA9PiBpc0NhcmV0Tm9kZShub2RlLmRvbSksIGlzQmxvY2skMik7XG4gICAgY29uc3QgaGFzQW5jZXN0b3JJbmxpbmVDYXJldEF0U3RhcnQgPSBlZGl0b3IgPT4gaGFzQW5jZXN0b3JJbmxpbmVDYXJldChTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KCkpKTtcbiAgICBjb25zdCByZXF1aXJlc1JlZnJlc2hDYXJldE92ZXJyaWRlID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gcm5nLmNvbGxhcHNlZCAmJiAocmFuZ2VTdGFydHNBdFRleHRDb250YWluZXIocm5nKSB8fCBlZGl0b3IuZG9tLmlzRW1wdHkocm5nLnN0YXJ0Q29udGFpbmVyKSkgJiYgIWhhc0FuY2VzdG9ySW5saW5lQ2FyZXRBdFN0YXJ0KGVkaXRvcik7XG4gICAgfTtcbiAgICBjb25zdCByZWZyZXNoQ2FyZXQgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKHJlcXVpcmVzUmVmcmVzaENhcmV0T3ZlcnJpZGUoZWRpdG9yKSkge1xuICAgICAgICBjcmVhdGVDYXJldEZvcm1hdEF0U3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVsZXRlRWxlbWVudCA9IChlZGl0b3IsIGZvcndhcmQsIGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKCgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgICAgZGVsZXRlRWxlbWVudCQyKGVkaXRvciwgZm9yd2FyZCwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVDYXJldCA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGlzTmVhck1lZGlhID0gZm9yd2FyZCA/IGlzQmVmb3JlTWVkaWEgOiBpc0FmdGVyTWVkaWE7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBmb3J3YXJkID8gSERpcmVjdGlvbi5Gb3J3YXJkcyA6IEhEaXJlY3Rpb24uQmFja3dhcmRzO1xuICAgICAgY29uc3QgZnJvbVBvcyA9IGdldE5vcm1hbGl6ZWRSYW5nZUVuZFBvaW50KGRpcmVjdGlvbiwgZWRpdG9yLmdldEJvZHkoKSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICBpZiAoaXNOZWFyTWVkaWEoZnJvbVBvcykpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUVsZW1lbnQoZWRpdG9yLCBmb3J3YXJkLCBmcm9tUG9zLmdldE5vZGUoIWZvcndhcmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKG5vcm1hbGl6ZVBvc2l0aW9uKGZvcndhcmQsIGZyb21Qb3MpKS5maWx0ZXIocG9zID0+IGlzTmVhck1lZGlhKHBvcykgJiYgaXNNb3ZlSW5zaWRlU2FtZUJsb2NrKGZyb21Qb3MsIHBvcykpLmJpbmQocG9zID0+IGRlbGV0ZUVsZW1lbnQoZWRpdG9yLCBmb3J3YXJkLCBwb3MuZ2V0Tm9kZSghZm9yd2FyZCkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICByZXR1cm4gaXNNZWRpYSQyKHNlbGVjdGVkTm9kZSkgPyBkZWxldGVFbGVtZW50KGVkaXRvciwgZm9yd2FyZCwgc2VsZWN0ZWROb2RlKSA6IE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gZGVsZXRlQ2FyZXQoZWRpdG9yLCBmb3J3YXJkKSA6IGRlbGV0ZVJhbmdlKGVkaXRvciwgZm9yd2FyZCk7XG5cbiAgICBjb25zdCBpc0VkaXRhYmxlID0gdGFyZ2V0ID0+IGNsb3Nlc3QkNCh0YXJnZXQsIGVsbSA9PiBpc0NvbnRlbnRFZGl0YWJsZVRydWUkMyhlbG0uZG9tKSB8fCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoZWxtLmRvbSkpLmV4aXN0cyhlbG0gPT4gaXNDb250ZW50RWRpdGFibGVUcnVlJDMoZWxtLmRvbSkpO1xuICAgIGNvbnN0IHBhcnNlSW5kZW50VmFsdWUgPSB2YWx1ZSA9PiB0b0ludCh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiAnJykuZ2V0T3IoMCk7XG4gICAgY29uc3QgZ2V0SW5kZW50U3R5bGVOYW1lID0gKHVzZU1hcmdpbiwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgaW5kZW50U3R5bGVOYW1lID0gdXNlTWFyZ2luIHx8IGlzVGFibGUkMShlbGVtZW50KSA/ICdtYXJnaW4nIDogJ3BhZGRpbmcnO1xuICAgICAgY29uc3Qgc3VmZml4ID0gZ2V0JDcoZWxlbWVudCwgJ2RpcmVjdGlvbicpID09PSAncnRsJyA/ICctcmlnaHQnIDogJy1sZWZ0JztcbiAgICAgIHJldHVybiBpbmRlbnRTdHlsZU5hbWUgKyBzdWZmaXg7XG4gICAgfTtcbiAgICBjb25zdCBpbmRlbnRFbGVtZW50ID0gKGRvbSwgY29tbWFuZCwgdXNlTWFyZ2luLCB2YWx1ZSwgdW5pdCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgaW5kZW50U3R5bGVOYW1lID0gZ2V0SW5kZW50U3R5bGVOYW1lKHVzZU1hcmdpbiwgU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCkpO1xuICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUluZGVudFZhbHVlKGRvbS5nZXRTdHlsZShlbGVtZW50LCBpbmRlbnRTdHlsZU5hbWUpKTtcbiAgICAgIGlmIChjb21tYW5kID09PSAnb3V0ZGVudCcpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZSA9IE1hdGgubWF4KDAsIHBhcnNlZFZhbHVlIC0gdmFsdWUpO1xuICAgICAgICBkb20uc2V0U3R5bGUoZWxlbWVudCwgaW5kZW50U3R5bGVOYW1lLCBzdHlsZVZhbHVlID8gc3R5bGVWYWx1ZSArIHVuaXQgOiAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHlsZVZhbHVlID0gcGFyc2VkVmFsdWUgKyB2YWx1ZSArIHVuaXQ7XG4gICAgICAgIGRvbS5zZXRTdHlsZShlbGVtZW50LCBpbmRlbnRTdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdmFsaWRhdGVCbG9ja3MgPSAoZWRpdG9yLCBibG9ja3MpID0+IGZvcmFsbChibG9ja3MsIGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudFN0eWxlTmFtZSA9IGdldEluZGVudFN0eWxlTmFtZShzaG91bGRJbmRlbnRVc2VNYXJnaW4oZWRpdG9yKSwgYmxvY2spO1xuICAgICAgY29uc3QgaW50ZW50VmFsdWUgPSBnZXRSYXcoYmxvY2ssIGluZGVudFN0eWxlTmFtZSkubWFwKHBhcnNlSW5kZW50VmFsdWUpLmdldE9yKDApO1xuICAgICAgY29uc3QgY29udGVudEVkaXRhYmxlID0gZWRpdG9yLmRvbS5nZXRDb250ZW50RWRpdGFibGUoYmxvY2suZG9tKTtcbiAgICAgIHJldHVybiBjb250ZW50RWRpdGFibGUgIT09ICdmYWxzZScgJiYgaW50ZW50VmFsdWUgPiAwO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbk91dGRlbnQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYmxvY2tzID0gZ2V0QmxvY2tzVG9JbmRlbnQoZWRpdG9yKTtcbiAgICAgIHJldHVybiAhZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpICYmIChibG9ja3MubGVuZ3RoID4gMSB8fCB2YWxpZGF0ZUJsb2NrcyhlZGl0b3IsIGJsb2NrcykpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0Q29tcG9uZW50ID0gZWwgPT4gaXNMaXN0KGVsKSB8fCBpc0xpc3RJdGVtJDEoZWwpO1xuICAgIGNvbnN0IHBhcmVudElzTGlzdENvbXBvbmVudCA9IGVsID0+IHBhcmVudChlbCkuZXhpc3RzKGlzTGlzdENvbXBvbmVudCk7XG4gICAgY29uc3QgZ2V0QmxvY2tzVG9JbmRlbnQgPSBlZGl0b3IgPT4gZmlsdGVyJDUoZnJvbURvbSQxKGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRCbG9ja3MoKSksIGVsID0+ICFpc0xpc3RDb21wb25lbnQoZWwpICYmICFwYXJlbnRJc0xpc3RDb21wb25lbnQoZWwpICYmIGlzRWRpdGFibGUoZWwpKTtcbiAgICBjb25zdCBoYW5kbGUgPSAoZWRpdG9yLCBjb21tYW5kKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3Qge2RvbX0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGdldEluZGVudGF0aW9uKGVkaXRvcik7XG4gICAgICBjb25zdCBpbmRlbnRVbml0ID0gKF9iID0gKF9hID0gL1thLXolXSskL2kuZXhlYyhpbmRlbnRhdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3B4JztcbiAgICAgIGNvbnN0IGluZGVudFZhbHVlID0gcGFyc2VJbmRlbnRWYWx1ZShpbmRlbnRhdGlvbik7XG4gICAgICBjb25zdCB1c2VNYXJnaW4gPSBzaG91bGRJbmRlbnRVc2VNYXJnaW4oZWRpdG9yKTtcbiAgICAgIGVhY2gkZShnZXRCbG9ja3NUb0luZGVudChlZGl0b3IpLCBibG9jayA9PiB7XG4gICAgICAgIGluZGVudEVsZW1lbnQoZG9tLCBjb21tYW5kLCB1c2VNYXJnaW4sIGluZGVudFZhbHVlLCBpbmRlbnRVbml0LCBibG9jay5kb20pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbmRlbnQgPSBlZGl0b3IgPT4gaGFuZGxlKGVkaXRvciwgJ2luZGVudCcpO1xuICAgIGNvbnN0IG91dGRlbnQgPSBlZGl0b3IgPT4gaGFuZGxlKGVkaXRvciwgJ291dGRlbnQnKTtcblxuICAgIGNvbnN0IGJhY2tzcGFjZURlbGV0ZSQxID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgY2FuT3V0ZGVudChlZGl0b3IpKSB7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIGNvbnN0IHBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBkb20uZ2V0UGFyZW50KHJuZy5zdGFydENvbnRhaW5lciwgZG9tLmlzQmxvY2spO1xuICAgICAgICBpZiAoYmxvY2sgIT09IG51bGwgJiYgaXNBdFN0YXJ0T2ZCbG9jayhTdWdhckVsZW1lbnQuZnJvbURvbShibG9jayksIHBvcykpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSgoKSA9PiBvdXRkZW50KGVkaXRvcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5kQWN0aW9uID0gKGVkaXRvciwgY2FyZXQsIGZvcndhcmQpID0+IGZpbmRNYXAoW1xuICAgICAgYmFja3NwYWNlRGVsZXRlJDEsXG4gICAgICBiYWNrc3BhY2VEZWxldGUkNixcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ3LFxuICAgICAgKGVkaXRvciwgZm9yd2FyZCkgPT4gYmFja3NwYWNlRGVsZXRlJDQoZWRpdG9yLCBjYXJldCwgZm9yd2FyZCksXG4gICAgICBiYWNrc3BhY2VEZWxldGUkOSxcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSRhLFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDUsXG4gICAgICBiYWNrc3BhY2VEZWxldGUkMixcbiAgICAgIGJhY2tzcGFjZURlbGV0ZSQ4LFxuICAgICAgYmFja3NwYWNlRGVsZXRlJDNcbiAgICBdLCBpdGVtID0+IGl0ZW0oZWRpdG9yLCBmb3J3YXJkKSkuZmlsdGVyKF8gPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0VkaXRhYmxlKCkpO1xuICAgIGNvbnN0IGRlbGV0ZUNvbW1hbmQgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmluZEFjdGlvbihlZGl0b3IsIGNhcmV0LCBmYWxzZSk7XG4gICAgICByZXN1bHQuZm9sZCgoKSA9PiB7XG4gICAgICAgIGV4ZWNOYXRpdmVEZWxldGVDb21tYW5kKGVkaXRvcik7XG4gICAgICAgIHBhZGRFbXB0eUJvZHkoZWRpdG9yKTtcbiAgICAgIH0sIGNhbGwpO1xuICAgIH07XG4gICAgY29uc3QgZm9yd2FyZERlbGV0ZUNvbW1hbmQgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZmluZEFjdGlvbihlZGl0b3IsIGNhcmV0LCB0cnVlKTtcbiAgICAgIHJlc3VsdC5mb2xkKCgpID0+IGV4ZWNOYXRpdmVGb3J3YXJkRGVsZXRlQ29tbWFuZChlZGl0b3IpLCBjYWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJHAgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ2RlbGV0ZScsICgpID0+IHtcbiAgICAgICAgZGVsZXRlQ29tbWFuZChlZGl0b3IsIGNhcmV0KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ2ZvcndhcmREZWxldGUnLCAoKSA9PiB7XG4gICAgICAgIGZvcndhcmREZWxldGVDb21tYW5kKGVkaXRvciwgY2FyZXQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IFNJR05JRklDQU5UX01PVkUgPSA1O1xuICAgIGNvbnN0IExPTkdQUkVTU19ERUxBWSA9IDQwMDtcbiAgICBjb25zdCBnZXRUb3VjaCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50b3VjaGVzID09PSB1bmRlZmluZWQgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGV2ZW50LnRvdWNoZXNbMF0pO1xuICAgIH07XG4gICAgY29uc3QgaXNGYXJFbm91Z2ggPSAodG91Y2gsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRpc3RYID0gTWF0aC5hYnModG91Y2guY2xpZW50WCAtIGRhdGEueCk7XG4gICAgICBjb25zdCBkaXN0WSA9IE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSBkYXRhLnkpO1xuICAgICAgcmV0dXJuIGRpc3RYID4gU0lHTklGSUNBTlRfTU9WRSB8fCBkaXN0WSA+IFNJR05JRklDQU5UX01PVkU7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRvID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0RGF0YSA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IGxvbmdwcmVzc0ZpcmVkID0gQ2VsbChmYWxzZSk7XG4gICAgICBjb25zdCBkZWJvdW5jZUxvbmdwcmVzcyA9IGxhc3QkMShlID0+IHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdsb25ncHJlc3MnLCB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICB0eXBlOiAnbG9uZ3ByZXNzJ1xuICAgICAgICB9KTtcbiAgICAgICAgbG9uZ3ByZXNzRmlyZWQuc2V0KHRydWUpO1xuICAgICAgfSwgTE9OR1BSRVNTX0RFTEFZKTtcbiAgICAgIGVkaXRvci5vbigndG91Y2hzdGFydCcsIGUgPT4ge1xuICAgICAgICBnZXRUb3VjaChlKS5lYWNoKHRvdWNoID0+IHtcbiAgICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy5jYW5jZWwoKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy50aHJvdHRsZShlKTtcbiAgICAgICAgICBsb25ncHJlc3NGaXJlZC5zZXQoZmFsc2UpO1xuICAgICAgICAgIHN0YXJ0RGF0YS5zZXQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBlZGl0b3Iub24oJ3RvdWNobW92ZScsIGUgPT4ge1xuICAgICAgICBkZWJvdW5jZUxvbmdwcmVzcy5jYW5jZWwoKTtcbiAgICAgICAgZ2V0VG91Y2goZSkuZWFjaCh0b3VjaCA9PiB7XG4gICAgICAgICAgc3RhcnREYXRhLm9uKGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRmFyRW5vdWdoKHRvdWNoLCBkYXRhKSkge1xuICAgICAgICAgICAgICBzdGFydERhdGEuY2xlYXIoKTtcbiAgICAgICAgICAgICAgbG9uZ3ByZXNzRmlyZWQuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdsb25ncHJlc3NjYW5jZWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGVkaXRvci5vbigndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBlID0+IHtcbiAgICAgICAgZGVib3VuY2VMb25ncHJlc3MuY2FuY2VsKCk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnREYXRhLmdldCgpLmZpbHRlcihkYXRhID0+IGRhdGEudGFyZ2V0LmlzRXF1YWxOb2RlKGUudGFyZ2V0KSkuZWFjaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGxvbmdwcmVzc0ZpcmVkLmdldCgpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgndGFwJywge1xuICAgICAgICAgICAgICAuLi5lLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0Jsb2NrRWxlbWVudCA9IChibG9ja0VsZW1lbnRzLCBub2RlKSA9PiBoYXMkMihibG9ja0VsZW1lbnRzLCBub2RlLm5vZGVOYW1lKTtcbiAgICBjb25zdCBpc1ZhbGlkVGFyZ2V0ID0gKHNjaGVtYSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICByZXR1cm4gIWlzQmxvY2tFbGVtZW50KHNjaGVtYS5nZXRCbG9ja0VsZW1lbnRzKCksIG5vZGUpICYmICFpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpICYmICFpc1RyYW5zcGFyZW50QmxvY2soc2NoZW1hLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0Jsb2NrUGFyZW50ID0gKGJsb2NrRWxlbWVudHMsIHJvb3QsIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBleGlzdHMocGFyZW50cyhTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSwgU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCkpLCBlbG0gPT4ge1xuICAgICAgICByZXR1cm4gaXNCbG9ja0VsZW1lbnQoYmxvY2tFbGVtZW50cywgZWxtLmRvbSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZFJlbW92ZVRleHROb2RlID0gKGJsb2NrRWxlbWVudHMsIG5vZGUpID0+IHtcbiAgICAgIGlmIChpc1RleHQkYShub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9eXFxzKyQvLnRlc3Qobm9kZS5kYXRhKSAmJiAoIW5vZGUubmV4dFNpYmxpbmcgfHwgaXNCbG9ja0VsZW1lbnQoYmxvY2tFbGVtZW50cywgbm9kZS5uZXh0U2libGluZykpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVJvb3RCbG9jayA9IGVkaXRvciA9PiBlZGl0b3IuZG9tLmNyZWF0ZShnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKSwgZ2V0Rm9yY2VkUm9vdEJsb2NrQXR0cnMoZWRpdG9yKSk7XG4gICAgY29uc3QgYWRkUm9vdEJsb2NrcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yLnNjaGVtYTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBsZXQgcm9vdEJsb2NrTm9kZTtcbiAgICAgIGxldCB0ZW1wTm9kZTtcbiAgICAgIGxldCB3cmFwcGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2sgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGlmICghc3RhcnROb2RlIHx8ICFpc0VsZW1lbnQkNihzdGFydE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvb3ROb2RlTmFtZSA9IHJvb3ROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIXNjaGVtYS5pc1ZhbGlkQ2hpbGQocm9vdE5vZGVOYW1lLCBmb3JjZWRSb290QmxvY2sudG9Mb3dlckNhc2UoKSkgfHwgaGFzQmxvY2tQYXJlbnQoYmxvY2tFbGVtZW50cywgcm9vdE5vZGUsIHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qge3N0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXR9ID0gcm5nO1xuICAgICAgY29uc3QgcmVzdG9yZVNlbGVjdGlvbiA9IGhhc0ZvY3VzKGVkaXRvcik7XG4gICAgICBsZXQgbm9kZSA9IHJvb3ROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoaXNFbGVtZW50JDYobm9kZSkpIHtcbiAgICAgICAgICB1cGRhdGVFbGVtZW50KHNjaGVtYSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWRUYXJnZXQoc2NoZW1hLCBub2RlKSkge1xuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVUZXh0Tm9kZShibG9ja0VsZW1lbnRzLCBub2RlKSkge1xuICAgICAgICAgICAgdGVtcE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKHRlbXBOb2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJvb3RCbG9ja05vZGUpIHtcbiAgICAgICAgICAgIHJvb3RCbG9ja05vZGUgPSBjcmVhdGVSb290QmxvY2soZWRpdG9yKTtcbiAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydEJlZm9yZShyb290QmxvY2tOb2RlLCBub2RlKTtcbiAgICAgICAgICAgIHdyYXBwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcm9vdEJsb2NrTm9kZS5hcHBlbmRDaGlsZCh0ZW1wTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdEJsb2NrTm9kZSA9IG51bGw7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3cmFwcGVkICYmIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIHJuZy5zZXRFbmQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpO1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0RW1wdHlMaW5lID0gKGVkaXRvciwgcm9vdCwgaW5zZXJ0QmxvY2spID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrID0gU3VnYXJFbGVtZW50LmZyb21Eb20oY3JlYXRlUm9vdEJsb2NrKGVkaXRvcikpO1xuICAgICAgY29uc3QgYnIgPSBjcmVhdGVQYWRkaW5nQnIoKTtcbiAgICAgIGFwcGVuZCQxKGJsb2NrLCBicik7XG4gICAgICBpbnNlcnRCbG9jayhyb290LCBibG9jayk7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKGJyLmRvbSk7XG4gICAgICBybmcuc2V0RW5kQmVmb3JlKGJyLmRvbSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ05vZGVDaGFuZ2UnLCBjdXJyeShhZGRSb290QmxvY2tzLCBlZGl0b3IpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzQ2xhc3MgPSBjaGVja0NsYXNzTmFtZSA9PiBub2RlID0+ICgnICcgKyBub2RlLmF0dHIoJ2NsYXNzJykgKyAnICcpLmluZGV4T2YoY2hlY2tDbGFzc05hbWUpICE9PSAtMTtcbiAgICBjb25zdCByZXBsYWNlTWF0Y2hXaXRoU3BhbiA9IChlZGl0b3IsIGNvbnRlbnQsIGNscykgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzLCBpbmRleCA9IGFyZ3NbYXJncy5sZW5ndGggLSAyXTtcbiAgICAgICAgY29uc3QgcHJldkNoYXIgPSBpbmRleCA+IDAgPyBjb250ZW50LmNoYXJBdChpbmRleCAtIDEpIDogJyc7XG4gICAgICAgIGlmIChwcmV2Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNoYXIgPT09ICc+Jykge1xuICAgICAgICAgIGNvbnN0IGZpbmRTdGFydFRhZ0luZGV4ID0gY29udGVudC5sYXN0SW5kZXhPZignPCcsIGluZGV4KTtcbiAgICAgICAgICBpZiAoZmluZFN0YXJ0VGFnSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdIdG1sID0gY29udGVudC5zdWJzdHJpbmcoZmluZFN0YXJ0VGFnSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0YWdIdG1sLmluZGV4T2YoJ2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCInKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiJyArIGNscyArICdcIiBkYXRhLW1jZS1jb250ZW50PVwiJyArIGVkaXRvci5kb20uZW5jb2RlKGFyZ3NbMF0pICsgJ1wiPicgKyBlZGl0b3IuZG9tLmVuY29kZSh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycgPyBhcmdzWzFdIDogYXJnc1swXSkgKyAnPC9zcGFuPic7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29udmVydFJlZ0V4cHNUb05vbkVkaXRhYmxlID0gKGVkaXRvciwgbm9uRWRpdGFibGVSZWdFeHBzLCBlKSA9PiB7XG4gICAgICBsZXQgaSA9IG5vbkVkaXRhYmxlUmVnRXhwcy5sZW5ndGgsIGNvbnRlbnQgPSBlLmNvbnRlbnQ7XG4gICAgICBpZiAoZS5mb3JtYXQgPT09ICdyYXcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShub25FZGl0YWJsZVJlZ0V4cHNbaV0sIHJlcGxhY2VNYXRjaFdpdGhTcGFuKGVkaXRvciwgY29udGVudCwgZ2V0Tm9uRWRpdGFibGVDbGFzcyhlZGl0b3IpKSk7XG4gICAgICB9XG4gICAgICBlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkbSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBjb250ZW50RWRpdGFibGVBdHRyTmFtZSA9ICdjb250ZW50ZWRpdGFibGUnO1xuICAgICAgY29uc3QgZWRpdENsYXNzID0gJyAnICsgVG9vbHMudHJpbShnZXRFZGl0YWJsZUNsYXNzKGVkaXRvcikpICsgJyAnO1xuICAgICAgY29uc3Qgbm9uRWRpdENsYXNzID0gJyAnICsgVG9vbHMudHJpbShnZXROb25FZGl0YWJsZUNsYXNzKGVkaXRvcikpICsgJyAnO1xuICAgICAgY29uc3QgaGFzRWRpdENsYXNzID0gaGFzQ2xhc3MoZWRpdENsYXNzKTtcbiAgICAgIGNvbnN0IGhhc05vbkVkaXRDbGFzcyA9IGhhc0NsYXNzKG5vbkVkaXRDbGFzcyk7XG4gICAgICBjb25zdCBub25FZGl0YWJsZVJlZ0V4cHMgPSBnZXROb25FZGl0YWJsZVJlZ0V4cHMoZWRpdG9yKTtcbiAgICAgIGlmIChub25FZGl0YWJsZVJlZ0V4cHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3Iub24oJ0JlZm9yZVNldENvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgICBjb252ZXJ0UmVnRXhwc1RvTm9uRWRpdGFibGUoZWRpdG9yLCBub25FZGl0YWJsZVJlZ0V4cHMsIGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkQXR0cmlidXRlRmlsdGVyKCdjbGFzcycsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKGhhc0VkaXRDbGFzcyhub2RlKSkge1xuICAgICAgICAgICAgbm9kZS5hdHRyKGNvbnRlbnRFZGl0YWJsZUF0dHJOYW1lLCAndHJ1ZScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzTm9uRWRpdENsYXNzKG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoY29udGVudEVkaXRhYmxlQXR0ck5hbWUsICdmYWxzZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGRBdHRyaWJ1dGVGaWx0ZXIoY29udGVudEVkaXRhYmxlQXR0ck5hbWUsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCFoYXNFZGl0Q2xhc3Mobm9kZSkgJiYgIWhhc05vbkVkaXRDbGFzcyhub2RlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub25FZGl0YWJsZVJlZ0V4cHMubGVuZ3RoID4gMCAmJiBub2RlLmF0dHIoJ2RhdGEtbWNlLWNvbnRlbnQnKSkge1xuICAgICAgICAgICAgbm9kZS5uYW1lID0gJyN0ZXh0JztcbiAgICAgICAgICAgIG5vZGUudHlwZSA9IDM7XG4gICAgICAgICAgICBub2RlLnJhdyA9IHRydWU7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5hdHRyKCdkYXRhLW1jZS1jb250ZW50Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cihjb250ZW50RWRpdGFibGVBdHRyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmluZEJsb2NrQ2FyZXRDb250YWluZXIgPSBlZGl0b3IgPT4gZGVzY2VuZGFudChTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSwgJypbZGF0YS1tY2UtY2FyZXRdJykubWFwKGVsbSA9PiBlbG0uZG9tKS5nZXRPck51bGwoKTtcbiAgICBjb25zdCBzaG93QmxvY2tDYXJldENvbnRhaW5lciA9IChlZGl0b3IsIGJsb2NrQ2FyZXRDb250YWluZXIpID0+IHtcbiAgICAgIGlmIChibG9ja0NhcmV0Q29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSkge1xuICAgICAgICBzaG93Q2FyZXRDb250YWluZXJCbG9jayhibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVCbG9ja0NvbnRhaW5lciA9IChlZGl0b3IsIGUpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrQ2FyZXRDb250YWluZXIgPSBmaW5kQmxvY2tDYXJldENvbnRhaW5lcihlZGl0b3IpO1xuICAgICAgaWYgKCFibG9ja0NhcmV0Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT09ICdjb21wb3NpdGlvbnN0YXJ0Jykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHNob3dCbG9ja0NhcmV0Q29udGFpbmVyKGVkaXRvciwgYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNDb250ZW50KGJsb2NrQ2FyZXRDb250YWluZXIpKSB7XG4gICAgICAgIHNob3dCbG9ja0NhcmV0Q29udGFpbmVyKGVkaXRvciwgYmxvY2tDYXJldENvbnRhaW5lcik7XG4gICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGwgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCBjb21wb3NpdGlvbnN0YXJ0JywgY3VycnkoaGFuZGxlQmxvY2tDb250YWluZXIsIGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDMgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgbW92ZVRvQ2VGYWxzZUhvcml6b250YWxseSA9IChkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpID0+IG1vdmVIb3Jpem9udGFsbHkoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZUNvbnRlbnRFZGl0YWJsZUZhbHNlLCBpc0FmdGVyQ29udGVudEVkaXRhYmxlRmFsc2UsIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMyk7XG4gICAgY29uc3QgbW92ZVRvQ2VGYWxzZVZlcnRpY2FsbHkgPSAoZGlyZWN0aW9uLCBlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgICBjb25zdCBpc0JlZm9yZSA9IGNhcmV0UG9zaXRpb24gPT4gaXNCZWZvcmVDb250ZW50RWRpdGFibGVGYWxzZShjYXJldFBvc2l0aW9uKSB8fCBpc0JlZm9yZVRhYmxlKGNhcmV0UG9zaXRpb24pO1xuICAgICAgY29uc3QgaXNBZnRlciA9IGNhcmV0UG9zaXRpb24gPT4gaXNBZnRlckNvbnRlbnRFZGl0YWJsZUZhbHNlKGNhcmV0UG9zaXRpb24pIHx8IGlzQWZ0ZXJUYWJsZShjYXJldFBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBtb3ZlVmVydGljYWxseShlZGl0b3IsIGRpcmVjdGlvbiwgcmFuZ2UsIGlzQmVmb3JlLCBpc0FmdGVyLCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDMpO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlVGV4dEJsb2NrID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGVkaXRvci5kb20uY3JlYXRlKGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpKTtcbiAgICAgIHRleHRCbG9jay5pbm5lckhUTUwgPSAnPGJyIGRhdGEtbWNlLWJvZ3VzPVwiMVwiPic7XG4gICAgICByZXR1cm4gdGV4dEJsb2NrO1xuICAgIH07XG4gICAgY29uc3QgZXhpdFByZUJsb2NrID0gKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSkgPT4ge1xuICAgICAgY29uc3QgY2FyZXRXYWxrZXIgPSBDYXJldFdhbGtlcihlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGdldFZpc3VhbENhcmV0UG9zaXRpb24kMSA9IGN1cnJ5KGdldFZpc3VhbENhcmV0UG9zaXRpb24sIGRpcmVjdGlvbiA9PT0gMSA/IGNhcmV0V2Fsa2VyLm5leHQgOiBjYXJldFdhbGtlci5wcmV2KTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgcHJlID0gZWRpdG9yLmRvbS5nZXRQYXJlbnQocmFuZ2Uuc3RhcnRDb250YWluZXIsICdQUkUnKTtcbiAgICAgICAgaWYgKCFwcmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FyZXRQb3MgPSBnZXRWaXN1YWxDYXJldFBvc2l0aW9uJDEoQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChyYW5nZSkpO1xuICAgICAgICBpZiAoIWNhcmV0UG9zKSB7XG4gICAgICAgICAgY29uc3QgbmV3QmxvY2sgPSBTdWdhckVsZW1lbnQuZnJvbURvbShjcmVhdGVUZXh0QmxvY2soZWRpdG9yKSk7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgYWZ0ZXIkNChTdWdhckVsZW1lbnQuZnJvbURvbShwcmUpLCBuZXdCbG9jayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKHByZSksIG5ld0Jsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QobmV3QmxvY2suZG9tLCB0cnVlKTtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEhvcml6b250YWxSYW5nZSA9IChlZGl0b3IsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGZvcndhcmQgPyBIRGlyZWN0aW9uLkZvcndhcmRzIDogSERpcmVjdGlvbi5CYWNrd2FyZHM7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZVRvQ2VGYWxzZUhvcml6b250YWxseShkaXJlY3Rpb24sIGVkaXRvciwgcmFuZ2UpLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICBleGl0UHJlQmxvY2soZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VmVydGljYWxSYW5nZSA9IChlZGl0b3IsIGRvd24pID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRvd24gPyAxIDogLTE7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZVRvQ2VGYWxzZVZlcnRpY2FsbHkoZGlyZWN0aW9uLCBlZGl0b3IsIHJhbmdlKS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgZXhpdFByZUJsb2NrKGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZsaXBEaXJlY3Rpb24gPSAoc2VsZWN0aW9uLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBlbG0gPSBmb3J3YXJkID8gc2VsZWN0aW9uLmdldEVuZCh0cnVlKSA6IHNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKTtcbiAgICAgIHJldHVybiBpc1J0bChlbG0pID8gIWZvcndhcmQgOiBmb3J3YXJkO1xuICAgIH07XG4gICAgY29uc3QgbW92ZUgkMiA9IChlZGl0b3IsIGZvcndhcmQpID0+IGdldEhvcml6b250YWxSYW5nZShlZGl0b3IsIGZsaXBEaXJlY3Rpb24oZWRpdG9yLnNlbGVjdGlvbiwgZm9yd2FyZCkpLmV4aXN0cyhuZXdSYW5nZSA9PiB7XG4gICAgICBtb3ZlVG9SYW5nZShlZGl0b3IsIG5ld1JhbmdlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVWJDQgPSAoZWRpdG9yLCBkb3duKSA9PiBnZXRWZXJ0aWNhbFJhbmdlKGVkaXRvciwgZG93bikuZXhpc3RzKG5ld1JhbmdlID0+IHtcbiAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3UmFuZ2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgY29uc3QgbW92ZVRvTGluZUVuZFBvaW50JDEgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBpc0NlZlBvc2l0aW9uID0gZm9yd2FyZCA/IGlzQWZ0ZXJDb250ZW50RWRpdGFibGVGYWxzZSA6IGlzQmVmb3JlQ29udGVudEVkaXRhYmxlRmFsc2U7XG4gICAgICByZXR1cm4gbW92ZVRvTGluZUVuZFBvaW50JDMoZWRpdG9yLCBmb3J3YXJkLCBpc0NlZlBvc2l0aW9uKTtcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdFRvRW5kUG9pbnQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBnZXRFZGdlQ2VmUG9zaXRpb24oZWRpdG9yLCAhZm9yd2FyZCkubWFwKHBvcyA9PiB7XG4gICAgICBjb25zdCBybmcgPSBwb3MudG9SYW5nZSgpO1xuICAgICAgY29uc3QgY3VyUm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgIHJuZy5zZXRTdGFydChjdXJSbmcuc3RhcnRDb250YWluZXIsIGN1clJuZy5zdGFydE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybmcuc2V0RW5kKGN1clJuZy5lbmRDb250YWluZXIsIGN1clJuZy5lbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJuZztcbiAgICB9KS5leGlzdHMocm5nID0+IHtcbiAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgcm5nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNUYXJnZXQgPSBub2RlID0+IGNvbnRhaW5zJDIoWydmaWdjYXB0aW9uJ10sIG5hbWUobm9kZSkpO1xuICAgIGNvbnN0IGdldENsb3Nlc3RUYXJnZXRCbG9jayA9IChwb3MsIHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGN1cnJ5KGVxLCByb290KTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDQoU3VnYXJFbGVtZW50LmZyb21Eb20ocG9zLmNvbnRhaW5lcigpKSwgaXNCbG9jayQyLCBpc1Jvb3QpLmZpbHRlcihpc1RhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0F0Rmlyc3RPckxhc3RMaW5lID0gKHJvb3QsIGZvcndhcmQsIHBvcykgPT4gZm9yd2FyZCA/IGlzQXRMYXN0TGluZShyb290LmRvbSwgcG9zKSA6IGlzQXRGaXJzdExpbmUocm9vdC5kb20sIHBvcyk7XG4gICAgY29uc3QgbW92ZUNhcmV0VG9OZXdFbXB0eUxpbmUgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgcmV0dXJuIGdldENsb3Nlc3RUYXJnZXRCbG9jayhwb3MsIHJvb3QpLmV4aXN0cygoKSA9PiB7XG4gICAgICAgIGlmIChpc0F0Rmlyc3RPckxhc3RMaW5lKHJvb3QsIGZvcndhcmQsIHBvcykpIHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRGbiA9IGZvcndhcmQgPyBhcHBlbmQkMSA6IHByZXBlbmQ7XG4gICAgICAgICAgY29uc3Qgcm5nID0gaW5zZXJ0RW1wdHlMaW5lKGVkaXRvciwgcm9vdCwgaW5zZXJ0Rm4pO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmVWJDMgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIHJldHVybiBtb3ZlQ2FyZXRUb05ld0VtcHR5TGluZShlZGl0b3IsIGZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBtb3ZlVXAgPSAoZWRpdG9yLCBkZXRhaWxzLCBzdW1tYXJ5KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBpZiAocm9vdC5maXJzdENoaWxkID09PSBkZXRhaWxzICYmIGlzQXRGaXJzdExpbmUoc3VtbWFyeSwgcG9zKSkge1xuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0luc2VydE5ld0Jsb2NrQmVmb3JlJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZURvd24gPSAoZWRpdG9yLCBkZXRhaWxzKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBpZiAocm9vdC5sYXN0Q2hpbGQgPT09IGRldGFpbHMgJiYgaXNBdExhc3RMaW5lKGRldGFpbHMsIHBvcykpIHtcbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdJbnNlcnROZXdCbG9ja0FmdGVyJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZSQyID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCksICdkZXRhaWxzJykpLm1hcChkZXRhaWxzID0+IG1vdmVEb3duKGVkaXRvciwgZGV0YWlscykpLmdldE9yKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCAnc3VtbWFyeScpKS5iaW5kKHN1bW1hcnkgPT4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChzdW1tYXJ5LCAnZGV0YWlscycpKS5tYXAoZGV0YWlscyA9PiBtb3ZlVXAoZWRpdG9yLCBkZXRhaWxzLCBzdW1tYXJ5KSkpLmdldE9yKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdmVWJDIgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiBtb3ZlJDIoZWRpdG9yLCBmb3J3YXJkKTtcblxuICAgIGNvbnN0IGJhc2VLZXlQYXR0ZXJuID0ge1xuICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICBrZXlDb2RlOiAwXG4gICAgfTtcbiAgICBjb25zdCBkZWZhdWx0UGF0dGVybnMgPSBwYXR0ZXJucyA9PiBtYXAkMyhwYXR0ZXJucywgcGF0dGVybiA9PiAoe1xuICAgICAgLi4uYmFzZUtleVBhdHRlcm4sXG4gICAgICAuLi5wYXR0ZXJuXG4gICAgfSkpO1xuICAgIGNvbnN0IGRlZmF1bHREZWxheWVkUGF0dGVybnMgPSBwYXR0ZXJucyA9PiBtYXAkMyhwYXR0ZXJucywgcGF0dGVybiA9PiAoe1xuICAgICAgLi4uYmFzZUtleVBhdHRlcm4sXG4gICAgICAuLi5wYXR0ZXJuXG4gICAgfSkpO1xuICAgIGNvbnN0IG1hdGNoZXNFdmVudCA9IChwYXR0ZXJuLCBldnQpID0+IGV2dC5rZXlDb2RlID09PSBwYXR0ZXJuLmtleUNvZGUgJiYgZXZ0LnNoaWZ0S2V5ID09PSBwYXR0ZXJuLnNoaWZ0S2V5ICYmIGV2dC5hbHRLZXkgPT09IHBhdHRlcm4uYWx0S2V5ICYmIGV2dC5jdHJsS2V5ID09PSBwYXR0ZXJuLmN0cmxLZXkgJiYgZXZ0Lm1ldGFLZXkgPT09IHBhdHRlcm4ubWV0YUtleTtcbiAgICBjb25zdCBtYXRjaCQxID0gKHBhdHRlcm5zLCBldnQpID0+IGJpbmQkMyhkZWZhdWx0UGF0dGVybnMocGF0dGVybnMpLCBwYXR0ZXJuID0+IG1hdGNoZXNFdmVudChwYXR0ZXJuLCBldnQpID8gW3BhdHRlcm5dIDogW10pO1xuICAgIGNvbnN0IG1hdGNoRGVsYXllZCA9IChwYXR0ZXJucywgZXZ0KSA9PiBiaW5kJDMoZGVmYXVsdERlbGF5ZWRQYXR0ZXJucyhwYXR0ZXJucyksIHBhdHRlcm4gPT4gbWF0Y2hlc0V2ZW50KHBhdHRlcm4sIGV2dCkgPyBbcGF0dGVybl0gOiBbXSk7XG4gICAgY29uc3QgYWN0aW9uID0gKGYsIC4uLngpID0+ICgpID0+IGYuYXBwbHkobnVsbCwgeCk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IChwYXR0ZXJucywgZXZ0KSA9PiBmaW5kJDIobWF0Y2gkMShwYXR0ZXJucywgZXZ0KSwgcGF0dGVybiA9PiBwYXR0ZXJuLmFjdGlvbigpKTtcbiAgICBjb25zdCBleGVjdXRlV2l0aERlbGF5ZWRBY3Rpb24gPSAocGF0dGVybnMsIGV2dCkgPT4gZmluZE1hcChtYXRjaERlbGF5ZWQocGF0dGVybnMsIGV2dCksIHBhdHRlcm4gPT4gcGF0dGVybi5hY3Rpb24oKSk7XG5cbiAgICBjb25zdCBtb3ZlSCQxID0gKGVkaXRvciwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IEhEaXJlY3Rpb24uRm9yd2FyZHMgOiBIRGlyZWN0aW9uLkJhY2t3YXJkcztcbiAgICAgIGNvbnN0IHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBtb3ZlSG9yaXpvbnRhbGx5KGVkaXRvciwgZGlyZWN0aW9uLCByYW5nZSwgaXNCZWZvcmVNZWRpYSwgaXNBZnRlck1lZGlhLCBpc01lZGlhJDIpLmV4aXN0cyhuZXdSYW5nZSA9PiB7XG4gICAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3UmFuZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbW92ZVYkMSA9IChlZGl0b3IsIGRvd24pID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRvd24gPyAxIDogLTE7XG4gICAgICBjb25zdCByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICByZXR1cm4gbW92ZVZlcnRpY2FsbHkoZWRpdG9yLCBkaXJlY3Rpb24sIHJhbmdlLCBpc0JlZm9yZU1lZGlhLCBpc0FmdGVyTWVkaWEsIGlzTWVkaWEkMikuZXhpc3RzKG5ld1JhbmdlID0+IHtcbiAgICAgICAgbW92ZVRvUmFuZ2UoZWRpdG9yLCBuZXdSYW5nZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9MaW5lRW5kUG9pbnQgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCBpc05lYXJNZWRpYSA9IGZvcndhcmQgPyBpc0FmdGVyTWVkaWEgOiBpc0JlZm9yZU1lZGlhO1xuICAgICAgcmV0dXJuIG1vdmVUb0xpbmVFbmRQb2ludCQzKGVkaXRvciwgZm9yd2FyZCwgaXNOZWFyTWVkaWEpO1xuICAgIH07XG5cbiAgICBjb25zdCBhZHQgPSBBZHQuZ2VuZXJhdGUoW1xuICAgICAgeyBub25lOiBbJ2N1cnJlbnQnXSB9LFxuICAgICAgeyBmaXJzdDogWydjdXJyZW50J10gfSxcbiAgICAgIHtcbiAgICAgICAgbWlkZGxlOiBbXG4gICAgICAgICAgJ2N1cnJlbnQnLFxuICAgICAgICAgICd0YXJnZXQnXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7IGxhc3Q6IFsnY3VycmVudCddIH1cbiAgICBdKTtcbiAgICBjb25zdCBub25lID0gY3VycmVudCA9PiBhZHQubm9uZShjdXJyZW50KTtcbiAgICBjb25zdCBDZWxsTG9jYXRpb24gPSB7XG4gICAgICAuLi5hZHQsXG4gICAgICBub25lXG4gICAgfTtcblxuICAgIGNvbnN0IGZpcnN0TGF5ZXIgPSAoc2NvcGUsIHNlbGVjdG9yKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyRmlyc3RMYXllcihzY29wZSwgc2VsZWN0b3IsIGFsd2F5cyk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJGaXJzdExheWVyID0gKHNjb3BlLCBzZWxlY3RvciwgcHJlZGljYXRlKSA9PiB7XG4gICAgICByZXR1cm4gYmluZCQzKGNoaWxkcmVuJDEoc2NvcGUpLCB4ID0+IHtcbiAgICAgICAgaWYgKGlzJDEoeCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh4KSA/IFt4XSA6IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJGaXJzdExheWVyKHgsIHNlbGVjdG9yLCBwcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwJDEgPSAodGFncywgZWxlbWVudCwgaXNSb290ID0gbmV2ZXIpID0+IHtcbiAgICAgIGlmIChpc1Jvb3QoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWlucyQyKHRhZ3MsIG5hbWUoZWxlbWVudCkpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNSb290T3JVcHBlclRhYmxlID0gZWxtID0+IGlzJDEoZWxtLCAndGFibGUnKSB8fCBpc1Jvb3QoZWxtKTtcbiAgICAgIHJldHVybiBhbmNlc3RvciQzKGVsZW1lbnQsIHRhZ3Muam9pbignLCcpLCBpc1Jvb3RPclVwcGVyVGFibGUpO1xuICAgIH07XG4gICAgY29uc3QgY2VsbCA9IChlbGVtZW50LCBpc1Jvb3QpID0+IGxvb2t1cCQxKFtcbiAgICAgICd0ZCcsXG4gICAgICAndGgnXG4gICAgXSwgZWxlbWVudCwgaXNSb290KTtcbiAgICBjb25zdCBjZWxscyA9IGFuY2VzdG9yID0+IGZpcnN0TGF5ZXIoYW5jZXN0b3IsICd0aCx0ZCcpO1xuICAgIGNvbnN0IHRhYmxlID0gKGVsZW1lbnQsIGlzUm9vdCkgPT4gY2xvc2VzdCQzKGVsZW1lbnQsICd0YWJsZScsIGlzUm9vdCk7XG5cbiAgICBjb25zdCB3YWxrID0gKGFsbCwgY3VycmVudCwgaW5kZXgsIGRpcmVjdGlvbiwgaXNFbGlnaWJsZSA9IGFsd2F5cykgPT4ge1xuICAgICAgY29uc3QgZm9yd2FyZHMgPSBkaXJlY3Rpb24gPT09IDE7XG4gICAgICBpZiAoIWZvcndhcmRzICYmIGluZGV4IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIENlbGxMb2NhdGlvbi5maXJzdChhbGxbMF0pO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkcyAmJiBpbmRleCA+PSBhbGwubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gQ2VsbExvY2F0aW9uLmxhc3QoYWxsW2FsbC5sZW5ndGggLSAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IGluZGV4ICsgZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBlbGVtID0gYWxsW25ld0luZGV4XTtcbiAgICAgICAgcmV0dXJuIGlzRWxpZ2libGUoZWxlbSkgPyBDZWxsTG9jYXRpb24ubWlkZGxlKGN1cnJlbnQsIGVsZW0pIDogd2FsayhhbGwsIGN1cnJlbnQsIG5ld0luZGV4LCBkaXJlY3Rpb24sIGlzRWxpZ2libGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGV0ZWN0ID0gKGN1cnJlbnQsIGlzUm9vdCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlKGN1cnJlbnQsIGlzUm9vdCkuYmluZCh0YWJsZSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbCA9IGNlbGxzKHRhYmxlKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgkMihhbGwsIHggPT4gZXEoY3VycmVudCwgeCkpO1xuICAgICAgICByZXR1cm4gaW5kZXgubWFwKGluZGV4ID0+ICh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgYWxsXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbmV4dCA9IChjdXJyZW50LCBpc0VsaWdpYmxlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IGRldGVjdGlvbiA9IGRldGVjdChjdXJyZW50LCBpc1Jvb3QpO1xuICAgICAgcmV0dXJuIGRldGVjdGlvbi5mb2xkKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIENlbGxMb2NhdGlvbi5ub25lKGN1cnJlbnQpO1xuICAgICAgfSwgaW5mbyA9PiB7XG4gICAgICAgIHJldHVybiB3YWxrKGluZm8uYWxsLCBjdXJyZW50LCBpbmZvLmluZGV4LCAxLCBpc0VsaWdpYmxlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcHJldiA9IChjdXJyZW50LCBpc0VsaWdpYmxlLCBpc1Jvb3QpID0+IHtcbiAgICAgIGNvbnN0IGRldGVjdGlvbiA9IGRldGVjdChjdXJyZW50LCBpc1Jvb3QpO1xuICAgICAgcmV0dXJuIGRldGVjdGlvbi5mb2xkKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIENlbGxMb2NhdGlvbi5ub25lKCk7XG4gICAgICB9LCBpbmZvID0+IHtcbiAgICAgICAgcmV0dXJuIHdhbGsoaW5mby5hbGwsIGN1cnJlbnQsIGluZm8uaW5kZXgsIC0xLCBpc0VsaWdpYmxlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBkZWZsYXRlID0gKHJlY3QsIGRlbHRhKSA9PiAoe1xuICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gZGVsdGEsXG4gICAgICB0b3A6IHJlY3QudG9wIC0gZGVsdGEsXG4gICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhICogMixcbiAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YSAqIDIsXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIGRlbHRhLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIGRlbHRhXG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Q29ybmVycyA9IChnZXRZQXhpc1ZhbHVlLCB0ZHMpID0+IGJpbmQkMyh0ZHMsIHRkID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBkZWZsYXRlKGNsb25lJDEodGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCAtMSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgeDogcmVjdC5sZWZ0LFxuICAgICAgICAgIHk6IGdldFlBeGlzVmFsdWUocmVjdCksXG4gICAgICAgICAgY2VsbDogdGRcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHg6IHJlY3QucmlnaHQsXG4gICAgICAgICAgeTogZ2V0WUF4aXNWYWx1ZShyZWN0KSxcbiAgICAgICAgICBjZWxsOiB0ZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0Q29ybmVyID0gKGNvcm5lcnMsIHgsIHkpID0+IGZvbGRsKGNvcm5lcnMsIChhY2MsIG5ld0Nvcm5lcikgPT4gYWNjLmZvbGQoKCkgPT4gT3B0aW9uYWwuc29tZShuZXdDb3JuZXIpLCBvbGRDb3JuZXIgPT4ge1xuICAgICAgY29uc3Qgb2xkRGlzdCA9IE1hdGguc3FydChNYXRoLmFicyhvbGRDb3JuZXIueCAtIHgpICsgTWF0aC5hYnMob2xkQ29ybmVyLnkgLSB5KSk7XG4gICAgICBjb25zdCBuZXdEaXN0ID0gTWF0aC5zcXJ0KE1hdGguYWJzKG5ld0Nvcm5lci54IC0geCkgKyBNYXRoLmFicyhuZXdDb3JuZXIueSAtIHkpKTtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG5ld0Rpc3QgPCBvbGREaXN0ID8gbmV3Q29ybmVyIDogb2xkQ29ybmVyKTtcbiAgICB9KSwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICBjb25zdCBnZXRDbG9zZXN0Q2VsbCA9IChnZXRZQXhpc1ZhbHVlLCBpc1RhcmdldENvcm5lciwgdGFibGUsIHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gZGVzY2VuZGFudHMoU3VnYXJFbGVtZW50LmZyb21Eb20odGFibGUpLCAndGQsdGgsY2FwdGlvbicpLm1hcChlID0+IGUuZG9tKTtcbiAgICAgIGNvbnN0IGNvcm5lcnMgPSBmaWx0ZXIkNShnZXRDb3JuZXJzKGdldFlBeGlzVmFsdWUsIGNlbGxzKSwgY29ybmVyID0+IGlzVGFyZ2V0Q29ybmVyKGNvcm5lciwgeSkpO1xuICAgICAgcmV0dXJuIGZpbmRDbG9zZXN0Q29ybmVyKGNvcm5lcnMsIHgsIHkpLm1hcChjb3JuZXIgPT4gY29ybmVyLmNlbGwpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Qm90dG9tVmFsdWUgPSByZWN0ID0+IHJlY3QuYm90dG9tO1xuICAgIGNvbnN0IGdldFRvcFZhbHVlID0gcmVjdCA9PiByZWN0LnRvcDtcbiAgICBjb25zdCBpc0Fib3ZlID0gKGNvcm5lciwgeSkgPT4gY29ybmVyLnkgPCB5O1xuICAgIGNvbnN0IGlzQmVsb3cgPSAoY29ybmVyLCB5KSA9PiBjb3JuZXIueSA+IHk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlbGxBYm92ZSA9IGN1cnJ5KGdldENsb3Nlc3RDZWxsLCBnZXRCb3R0b21WYWx1ZSwgaXNBYm92ZSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlbGxCZWxvdyA9IGN1cnJ5KGdldENsb3Nlc3RDZWxsLCBnZXRUb3BWYWx1ZSwgaXNCZWxvdyk7XG4gICAgY29uc3QgZmluZENsb3Nlc3RQb3NpdGlvbkluQWJvdmVDZWxsID0gKHRhYmxlLCBwb3MpID0+IGhlYWQocG9zLmdldENsaWVudFJlY3RzKCkpLmJpbmQocmVjdCA9PiBnZXRDbG9zZXN0Q2VsbEFib3ZlKHRhYmxlLCByZWN0LmxlZnQsIHJlY3QudG9wKSkuYmluZChjZWxsID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uKGdldExhc3RMaW5lUG9zaXRpb25zKGNlbGwpLCBwb3MpKTtcbiAgICBjb25zdCBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5CZWxvd0NlbGwgPSAodGFibGUsIHBvcykgPT4gbGFzdCQzKHBvcy5nZXRDbGllbnRSZWN0cygpKS5iaW5kKHJlY3QgPT4gZ2V0Q2xvc2VzdENlbGxCZWxvdyh0YWJsZSwgcmVjdC5sZWZ0LCByZWN0LnRvcCkpLmJpbmQoY2VsbCA9PiBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbihnZXRGaXJzdExpbmVQb3NpdGlvbnMoY2VsbCksIHBvcykpO1xuXG4gICAgY29uc3QgaGFzTmV4dEJyZWFrID0gKGdldFBvc2l0aW9uc1VudGlsLCBzY29wZSwgbGluZUluZm8pID0+IGxpbmVJbmZvLmJyZWFrQXQuZXhpc3RzKGJyZWFrUG9zID0+IGdldFBvc2l0aW9uc1VudGlsKHNjb3BlLCBicmVha1BvcykuYnJlYWtBdC5pc1NvbWUoKSk7XG4gICAgY29uc3Qgc3RhcnRzV2l0aFdyYXBCcmVhayA9IGxpbmVJbmZvID0+IGxpbmVJbmZvLmJyZWFrVHlwZSA9PT0gQnJlYWtUeXBlLldyYXAgJiYgbGluZUluZm8ucG9zaXRpb25zLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBzdGFydHNXaXRoQnJCcmVhayA9IGxpbmVJbmZvID0+IGxpbmVJbmZvLmJyZWFrVHlwZSA9PT0gQnJlYWtUeXBlLkJyICYmIGxpbmVJbmZvLnBvc2l0aW9ucy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgaXNBdFRhYmxlQ2VsbExpbmUgPSAoZ2V0UG9zaXRpb25zVW50aWwsIHNjb3BlLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IGxpbmVJbmZvID0gZ2V0UG9zaXRpb25zVW50aWwoc2NvcGUsIHBvcyk7XG4gICAgICBpZiAoc3RhcnRzV2l0aFdyYXBCcmVhayhsaW5lSW5mbykgfHwgIWlzQnIkNihwb3MuZ2V0Tm9kZSgpKSAmJiBzdGFydHNXaXRoQnJCcmVhayhsaW5lSW5mbykpIHtcbiAgICAgICAgcmV0dXJuICFoYXNOZXh0QnJlYWsoZ2V0UG9zaXRpb25zVW50aWwsIHNjb3BlLCBsaW5lSW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGluZUluZm8uYnJlYWtBdC5pc05vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzQXRGaXJzdFRhYmxlQ2VsbExpbmUgPSBjdXJyeShpc0F0VGFibGVDZWxsTGluZSwgZ2V0UG9zaXRpb25zVW50aWxQcmV2aW91c0xpbmUpO1xuICAgIGNvbnN0IGlzQXRMYXN0VGFibGVDZWxsTGluZSA9IGN1cnJ5KGlzQXRUYWJsZUNlbGxMaW5lLCBnZXRQb3NpdGlvbnNVbnRpbE5leHRMaW5lKTtcbiAgICBjb25zdCBpc0NhcmV0QXRTdGFydE9yRW5kT2ZUYWJsZSA9IChmb3J3YXJkLCBybmcsIHRhYmxlKSA9PiB7XG4gICAgICBjb25zdCBjYXJldFBvcyA9IENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbkluKCFmb3J3YXJkLCB0YWJsZSkuZXhpc3RzKHBvcyA9PiBwb3MuaXNFcXVhbChjYXJldFBvcykpO1xuICAgIH07XG4gICAgY29uc3QgbmF2aWdhdGVIb3Jpem9udGFsbHkgPSAoZWRpdG9yLCBmb3J3YXJkLCB0YWJsZSwgX3RkKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgIGlmIChpc0Zha2VDYXJldFRhYmxlQnJvd3NlcigpICYmIGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZlRhYmxlKGZvcndhcmQsIHJuZywgdGFibGUpKSB7XG4gICAgICAgIHNob3dDYXJldChkaXJlY3Rpb24sIGVkaXRvciwgdGFibGUsICFmb3J3YXJkLCBmYWxzZSkuZWFjaChuZXdSbmcgPT4ge1xuICAgICAgICAgIG1vdmVUb1JhbmdlKGVkaXRvciwgbmV3Um5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q2xvc2VzdEFib3ZlUG9zaXRpb24gPSAocm9vdCwgdGFibGUsIHN0YXJ0KSA9PiBmaW5kQ2xvc2VzdFBvc2l0aW9uSW5BYm92ZUNlbGwodGFibGUsIHN0YXJ0KS5vclRodW5rKCgpID0+IGhlYWQoc3RhcnQuZ2V0Q2xpZW50UmVjdHMoKSkuYmluZChyZWN0ID0+IGZpbmRDbG9zZXN0SG9yaXpvbnRhbFBvc2l0aW9uRnJvbVBvaW50KGdldFBvc2l0aW9uc0Fib3ZlKHJvb3QsIENhcmV0UG9zaXRpb24uYmVmb3JlKHRhYmxlKSksIHJlY3QubGVmdCkpKS5nZXRPcihDYXJldFBvc2l0aW9uLmJlZm9yZSh0YWJsZSkpO1xuICAgIGNvbnN0IGdldENsb3Nlc3RCZWxvd1Bvc2l0aW9uID0gKHJvb3QsIHRhYmxlLCBzdGFydCkgPT4gZmluZENsb3Nlc3RQb3NpdGlvbkluQmVsb3dDZWxsKHRhYmxlLCBzdGFydCkub3JUaHVuaygoKSA9PiBoZWFkKHN0YXJ0LmdldENsaWVudFJlY3RzKCkpLmJpbmQocmVjdCA9PiBmaW5kQ2xvc2VzdEhvcml6b250YWxQb3NpdGlvbkZyb21Qb2ludChnZXRQb3NpdGlvbnNCZWxvdyhyb290LCBDYXJldFBvc2l0aW9uLmFmdGVyKHRhYmxlKSksIHJlY3QubGVmdCkpKS5nZXRPcihDYXJldFBvc2l0aW9uLmFmdGVyKHRhYmxlKSk7XG4gICAgY29uc3QgZ2V0VGFibGUgPSAocHJldmlvdXMsIHBvcykgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHBvcy5nZXROb2RlKHByZXZpb3VzKTtcbiAgICAgIHJldHVybiBpc1RhYmxlJDIobm9kZSkgPyBPcHRpb25hbC5zb21lKG5vZGUpIDogT3B0aW9uYWwubm9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyQmxvY2sgPSAoZG93biwgZWRpdG9yLCB0YWJsZSkgPT4ge1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0Rm4gPSBkb3duID8gYWZ0ZXIkNCA6IGJlZm9yZSQzO1xuICAgICAgICBjb25zdCBybmcgPSBpbnNlcnRFbXB0eUxpbmUoZWRpdG9yLCBTdWdhckVsZW1lbnQuZnJvbURvbSh0YWJsZSksIGluc2VydEZuKTtcbiAgICAgICAgbW92ZVRvUmFuZ2UoZWRpdG9yLCBybmcpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlQ2FyZXQgPSAoZWRpdG9yLCBkb3duLCBwb3MpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlID0gZG93biA/IGdldFRhYmxlKHRydWUsIHBvcykgOiBnZXRUYWJsZShmYWxzZSwgcG9zKTtcbiAgICAgIGNvbnN0IGxhc3QgPSBkb3duID09PSBmYWxzZTtcbiAgICAgIHRhYmxlLmZvbGQoKCkgPT4gbW92ZVRvUmFuZ2UoZWRpdG9yLCBwb3MudG9SYW5nZSgpKSwgdGFibGUgPT4gcG9zaXRpb25JbihsYXN0LCBlZGl0b3IuZ2V0Qm9keSgpKS5maWx0ZXIobGFzdFBvcyA9PiBsYXN0UG9zLmlzRXF1YWwocG9zKSkuZm9sZCgoKSA9PiBtb3ZlVG9SYW5nZShlZGl0b3IsIHBvcy50b1JhbmdlKCkpLCBfID0+IHJlbmRlckJsb2NrKGRvd24sIGVkaXRvciwgdGFibGUpKSk7XG4gICAgfTtcbiAgICBjb25zdCBuYXZpZ2F0ZVZlcnRpY2FsbHkgPSAoZWRpdG9yLCBkb3duLCB0YWJsZSwgdGQpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KHJuZyk7XG4gICAgICBjb25zdCByb290ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGlmICghZG93biAmJiBpc0F0Rmlyc3RUYWJsZUNlbGxMaW5lKHRkLCBwb3MpKSB7XG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IGdldENsb3Nlc3RBYm92ZVBvc2l0aW9uKHJvb3QsIHRhYmxlLCBwb3MpO1xuICAgICAgICBtb3ZlQ2FyZXQoZWRpdG9yLCBkb3duLCBuZXdQb3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZG93biAmJiBpc0F0TGFzdFRhYmxlQ2VsbExpbmUodGQsIHBvcykpIHtcbiAgICAgICAgY29uc3QgbmV3UG9zID0gZ2V0Q2xvc2VzdEJlbG93UG9zaXRpb24ocm9vdCwgdGFibGUsIHBvcyk7XG4gICAgICAgIG1vdmVDYXJldChlZGl0b3IsIGRvd24sIG5ld1Bvcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW92ZSQxID0gKGVkaXRvciwgZm9yd2FyZCwgbW92ZXIpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQoZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCksICd0ZCx0aCcpKS5iaW5kKHRkID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQodGQsICd0YWJsZScpKS5tYXAodGFibGUgPT4gbW92ZXIoZWRpdG9yLCBmb3J3YXJkLCB0YWJsZSwgdGQpKSkuZ2V0T3IoZmFsc2UpO1xuICAgIGNvbnN0IG1vdmVIID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gbW92ZSQxKGVkaXRvciwgZm9yd2FyZCwgbmF2aWdhdGVIb3Jpem9udGFsbHkpO1xuICAgIGNvbnN0IG1vdmVWID0gKGVkaXRvciwgZm9yd2FyZCkgPT4gbW92ZSQxKGVkaXRvciwgZm9yd2FyZCwgbmF2aWdhdGVWZXJ0aWNhbGx5KTtcbiAgICBjb25zdCBnZXRDZWxsRmlyc3RDdXJzb3JQb3NpdGlvbiA9IGNlbGwgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gU2ltU2VsZWN0aW9uLmV4YWN0KGNlbGwsIDAsIGNlbGwsIDApO1xuICAgICAgcmV0dXJuIHRvTmF0aXZlKHNlbGVjdGlvbik7XG4gICAgfTtcbiAgICBjb25zdCB0YWJHbyA9IChlZGl0b3IsIGlzUm9vdCwgY2VsbCkgPT4ge1xuICAgICAgcmV0dXJuIGNlbGwuZm9sZChPcHRpb25hbC5ub25lLCBPcHRpb25hbC5ub25lLCAoX2N1cnJlbnQsIG5leHQpID0+IHtcbiAgICAgICAgcmV0dXJuIGZpcnN0KG5leHQpLm1hcChjZWxsID0+IHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q2VsbEZpcnN0Q3Vyc29yUG9zaXRpb24oY2VsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgY3VycmVudCA9PiB7XG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlVGFibGVJbnNlcnRSb3dBZnRlcicpO1xuICAgICAgICByZXR1cm4gdGFiRm9yd2FyZChlZGl0b3IsIGlzUm9vdCwgY3VycmVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRhYkZvcndhcmQgPSAoZWRpdG9yLCBpc1Jvb3QsIGNlbGwpID0+IHRhYkdvKGVkaXRvciwgaXNSb290LCBuZXh0KGNlbGwsIGlzRWRpdGFibGUkMykpO1xuICAgIGNvbnN0IHRhYkJhY2t3YXJkID0gKGVkaXRvciwgaXNSb290LCBjZWxsKSA9PiB0YWJHbyhlZGl0b3IsIGlzUm9vdCwgcHJldihjZWxsLCBpc0VkaXRhYmxlJDMpKTtcbiAgICBjb25zdCBoYW5kbGVUYWIgPSAoZWRpdG9yLCBmb3J3YXJkKSA9PiB7XG4gICAgICBjb25zdCByb290RWxlbWVudHMgPSBbXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICdsaScsXG4gICAgICAgICdkbCdcbiAgICAgIF07XG4gICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSQxID0gbmFtZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVxKGVsZW1lbnQsIGJvZHkpIHx8IGNvbnRhaW5zJDIocm9vdEVsZW1lbnRzLCBuYW1lJDEpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbURvbSghZm9yd2FyZCA/IHJuZy5zdGFydENvbnRhaW5lciA6IHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgcmV0dXJuIGNlbGwoY29udGFpbmVyLCBpc1Jvb3QpLm1hcChjZWxsID0+IHtcbiAgICAgICAgdGFibGUoY2VsbCwgaXNSb290KS5lYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICBlZGl0b3IubW9kZWwudGFibGUuY2xlYXJTZWxlY3RlZENlbGxzKHRhYmxlLmRvbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLmNvbGxhcHNlKCFmb3J3YXJkKTtcbiAgICAgICAgY29uc3QgbmF2aWdhdGlvbiA9ICFmb3J3YXJkID8gdGFiQmFja3dhcmQgOiB0YWJGb3J3YXJkO1xuICAgICAgICBjb25zdCBybmcgPSBuYXZpZ2F0aW9uKGVkaXRvciwgaXNSb290LCBjZWxsKTtcbiAgICAgICAgcm5nLmVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkuZ2V0T3IoZmFsc2UpO1xuICAgIH07XG5cbiAgICBjb25zdCBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDQgPSAoZWRpdG9yLCBjYXJldCwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBpc01hYyA9IEVudi5vcy5pc01hY09TKCkgfHwgRW52Lm9zLmlzaU9TKCk7XG4gICAgICBleGVjdXRlKFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVIJDIsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgkMiwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlVQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDQsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDQsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgLi4uaXNNYWMgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihzZWxlY3RUb0VuZFBvaW50LCBlZGl0b3IsIGZhbHNlKSxcbiAgICAgICAgICAgIG1ldGFLZXk6IHRydWUsXG4gICAgICAgICAgICBzaGlmdEtleTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuRE9XTixcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHNlbGVjdFRvRW5kUG9pbnQsIGVkaXRvciwgdHJ1ZSksXG4gICAgICAgICAgICBtZXRhS2V5OiB0cnVlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVILCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5MRUZULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVILCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5VUCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlViwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlVQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDIsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDIsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVIJDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZUgkMSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlVQLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDEsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ET1dOLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVWJDEsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmUkMywgZWRpdG9yLCBjYXJldCwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZSQzLCBlZGl0b3IsIGNhcmV0LCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlJJR0hULFxuICAgICAgICAgIGN0cmxLZXk6ICFpc01hYyxcbiAgICAgICAgICBhbHRLZXk6IGlzTWFjLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVOZXh0V29yZCwgZWRpdG9yLCBjYXJldClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkxFRlQsXG4gICAgICAgICAgY3RybEtleTogIWlzTWFjLFxuICAgICAgICAgIGFsdEtleTogaXNNYWMsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVByZXZXb3JkLCBlZGl0b3IsIGNhcmV0KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuVVAsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMywgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRPV04sXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVYkMywgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9XG4gICAgICBdLCBldnQpLmVhY2goXyA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRrID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQ0KGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBwb2ludCA9IChjb250YWluZXIsIG9mZnNldCkgPT4gKHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuXG4gICAgY29uc3QgRE9NJDcgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgYWx3YXlzTmV4dCA9IHN0YXJ0Tm9kZSA9PiBub2RlID0+IHN0YXJ0Tm9kZSA9PT0gbm9kZSA/IC0xIDogMDtcbiAgICBjb25zdCBpc0JvdW5kYXJ5ID0gZG9tID0+IG5vZGUgPT4gZG9tLmlzQmxvY2sobm9kZSkgfHwgY29udGFpbnMkMihbXG4gICAgICAnQlInLFxuICAgICAgJ0lNRycsXG4gICAgICAnSFInLFxuICAgICAgJ0lOUFVUJ1xuICAgIF0sIG5vZGUubm9kZU5hbWUpIHx8IGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgPT09ICdmYWxzZSc7XG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgb2Zmc2V0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5tYXAocHJldiA9PiBwb2ludChwcmV2LmNvbnRhaW5lciwgcHJldi5jb250YWluZXIuZGF0YS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRleHRBZnRlciA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoaXNUZXh0JGEobm9kZSkgJiYgb2Zmc2V0ID49IG5vZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHBvaW50KG5vZGUsIG9mZnNldCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dFNlZWtlciA9IFRleHRTZWVrZXIoRE9NJDcpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbSh0ZXh0U2Vla2VyLmZvcndhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5tYXAocHJldiA9PiBwb2ludChwcmV2LmNvbnRhaW5lciwgMCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2NhbkxlZnQgPSAobm9kZSwgb2Zmc2V0LCByb290Tm9kZSkgPT4ge1xuICAgICAgaWYgKCFpc1RleHQkYShub2RlKSkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChvZmZzZXQgPj0gMCAmJiBvZmZzZXQgPD0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocG9pbnQobm9kZSwgb2Zmc2V0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U2Vla2VyID0gVGV4dFNlZWtlcihET00kNyk7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKHRleHRTZWVrZXIuYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgYWx3YXlzTmV4dChub2RlKSwgcm9vdE5vZGUpKS5iaW5kKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZUZXh0ID0gcHJldi5jb250YWluZXIuZGF0YTtcbiAgICAgICAgICByZXR1cm4gc2NhbkxlZnQocHJldi5jb250YWluZXIsIG9mZnNldCArIHByZXZUZXh0Lmxlbmd0aCwgcm9vdE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjYW5SaWdodCA9IChub2RlLCBvZmZzZXQsIHJvb3ROb2RlKSA9PiB7XG4gICAgICBpZiAoIWlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5kYXRhO1xuICAgICAgaWYgKG9mZnNldCA8PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShwb2ludChub2RlLCBvZmZzZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRleHRTZWVrZXIgPSBUZXh0U2Vla2VyKERPTSQ3KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20odGV4dFNlZWtlci5mb3J3YXJkcyhub2RlLCBvZmZzZXQsIGFsd2F5c05leHQobm9kZSksIHJvb3ROb2RlKSkuYmluZChuZXh0ID0+IHNjYW5SaWdodChuZXh0LmNvbnRhaW5lciwgb2Zmc2V0IC0gdGV4dC5sZW5ndGgsIHJvb3ROb2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXBlYXRMZWZ0ID0gKGRvbSwgbm9kZSwgb2Zmc2V0LCBwcm9jZXNzLCByb290Tm9kZSkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoID0gVGV4dFNlZWtlcihkb20sIGlzQm91bmRhcnkoZG9tKSk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShzZWFyY2guYmFja3dhcmRzKG5vZGUsIG9mZnNldCwgcHJvY2Vzcywgcm9vdE5vZGUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNWYWxpZFRleHRSYW5nZSA9IHJuZyA9PiBybmcuY29sbGFwc2VkICYmIGlzVGV4dCRhKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgY29uc3QgZ2V0VGV4dCA9IHJuZyA9PiB0cmltJDEocm5nLnRvU3RyaW5nKCkucmVwbGFjZSgvXFx1MDBBMC9nLCAnICcpKTtcbiAgICBjb25zdCBpc1doaXRlc3BhY2UgPSBjaHIgPT4gY2hyICE9PSAnJyAmJiAnIFxceEEwXFxmXFxuXFxyXFx0XFx4MEInLmluZGV4T2YoY2hyKSAhPT0gLTE7XG5cbiAgICBjb25zdCBzdHJpcFRyaWdnZXIgPSAodGV4dCwgdHJpZ2dlcikgPT4gdGV4dC5zdWJzdHJpbmcodHJpZ2dlci5sZW5ndGgpO1xuICAgIGNvbnN0IGZpbmRUcmlnZ2VyID0gKHRleHQsIGluZGV4LCB0cmlnZ2VyKSA9PiB7XG4gICAgICBsZXQgaTtcbiAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IHRyaWdnZXIuY2hhckF0KDApO1xuICAgICAgZm9yIChpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IGNoYXIgJiYgY29udGFpbnMkMSh0ZXh0LCB0cmlnZ2VyLCBpLCBpbmRleCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoaSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kU3RhcnQgPSAoZG9tLCBpbml0UmFuZ2UsIHRyaWdnZXIsIG1pbkNoYXJzID0gMCkgPT4ge1xuICAgICAgaWYgKCFpc1ZhbGlkVGV4dFJhbmdlKGluaXRSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRUcmlnZ2VySW5kZXggPSAoZWxlbWVudCwgb2Zmc2V0LCB0ZXh0KSA9PiB7XG4gICAgICAgIGJ1ZmZlci50ZXh0ID0gdGV4dCArIGJ1ZmZlci50ZXh0O1xuICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZpbmRUcmlnZ2VyKGJ1ZmZlci50ZXh0LCBidWZmZXIub2Zmc2V0LCB0cmlnZ2VyKS5nZXRPcihvZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0UGFyZW50KGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgZG9tLmlzQmxvY2spIHx8IGRvbS5nZXRSb290KCk7XG4gICAgICByZXR1cm4gcmVwZWF0TGVmdChkb20sIGluaXRSYW5nZS5zdGFydENvbnRhaW5lciwgaW5pdFJhbmdlLnN0YXJ0T2Zmc2V0LCBmaW5kVHJpZ2dlckluZGV4LCByb290KS5iaW5kKHNwb3QgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9IGluaXRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChpbml0UmFuZ2UuZW5kQ29udGFpbmVyLCBpbml0UmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGdldFRleHQocmFuZ2UpO1xuICAgICAgICBjb25zdCB0cmlnZ2VySW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKHRyaWdnZXIpO1xuICAgICAgICBpZiAodHJpZ2dlckluZGV4ICE9PSAwIHx8IHN0cmlwVHJpZ2dlcih0ZXh0LCB0cmlnZ2VyKS5sZW5ndGggPCBtaW5DaGFycykge1xuICAgICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgdGV4dDogc3RyaXBUcmlnZ2VyKHRleHQsIHRyaWdnZXIpLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICB0cmlnZ2VyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0Q29udGV4dCA9IChkb20sIGluaXRSYW5nZSwgdHJpZ2dlciwgbWluQ2hhcnMgPSAwKSA9PiBkZXRlY3QkMShTdWdhckVsZW1lbnQuZnJvbURvbShpbml0UmFuZ2Uuc3RhcnRDb250YWluZXIpKS5mb2xkKCgpID0+IGZpbmRTdGFydChkb20sIGluaXRSYW5nZSwgdHJpZ2dlciwgbWluQ2hhcnMpLCBlbG0gPT4ge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlKGVsbS5kb20pO1xuICAgICAgY29uc3QgdGV4dCA9IGdldFRleHQocmFuZ2UpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICByYW5nZSxcbiAgICAgICAgdGV4dDogc3RyaXBUcmlnZ2VyKHRleHQsIHRyaWdnZXIpLFxuICAgICAgICB0cmlnZ2VyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzVGV4dCQxID0gbm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBURVhUO1xuICAgIGNvbnN0IGlzRWxlbWVudCA9IG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVDtcbiAgICBjb25zdCB0b0xhc3QgPSBub2RlID0+IHtcbiAgICAgIGlmIChpc1RleHQkMShub2RlKSkge1xuICAgICAgICByZXR1cm4gcG9pbnQobm9kZSwgbm9kZS5kYXRhLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA+IDAgPyB0b0xhc3QoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIDogcG9pbnQobm9kZSwgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRvTGVhZiA9IChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgb2Zmc2V0IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0b0xlYWYoY2hpbGRyZW5bb2Zmc2V0XSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgaXNFbGVtZW50KG5vZGUpICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0b0xhc3QoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGlzUHJldmlvdXNDaGFyQ29udGVudCA9IChkb20sIGxlYWYpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb3QgPSAoX2EgPSBkb20uZ2V0UGFyZW50KGxlYWYuY29udGFpbmVyLCBkb20uaXNCbG9jaykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvbS5nZXRSb290KCk7XG4gICAgICByZXR1cm4gcmVwZWF0TGVmdChkb20sIGxlYWYuY29udGFpbmVyLCBsZWFmLm9mZnNldCwgKF9lbGVtZW50LCBvZmZzZXQpID0+IG9mZnNldCA9PT0gMCA/IC0xIDogb2Zmc2V0LCByb290KS5maWx0ZXIoc3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzcG90LmNvbnRhaW5lci5kYXRhLmNoYXJBdChzcG90Lm9mZnNldCAtIDEpO1xuICAgICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjaGFyKTtcbiAgICAgIH0pLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3QgaXNTdGFydE9mV29yZCA9IGRvbSA9PiBybmcgPT4ge1xuICAgICAgY29uc3QgbGVhZiA9IHRvTGVhZihybmcuc3RhcnRDb250YWluZXIsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICByZXR1cm4gIWlzUHJldmlvdXNDaGFyQ29udGVudChkb20sIGxlYWYpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VHJpZ2dlckNvbnRleHQgPSAoZG9tLCBpbml0UmFuZ2UsIGRhdGFiYXNlKSA9PiBmaW5kTWFwKGRhdGFiYXNlLnRyaWdnZXJzLCB0cmlnZ2VyID0+IGdldENvbnRleHQoZG9tLCBpbml0UmFuZ2UsIHRyaWdnZXIpKTtcbiAgICBjb25zdCBsb29rdXAgPSAoZWRpdG9yLCBnZXREYXRhYmFzZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YWJhc2UgPSBnZXREYXRhYmFzZSgpO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBnZXRUcmlnZ2VyQ29udGV4dChlZGl0b3IuZG9tLCBybmcsIGRhdGFiYXNlKS5iaW5kKGNvbnRleHQgPT4gbG9va3VwV2l0aENvbnRleHQoZWRpdG9yLCBnZXREYXRhYmFzZSwgY29udGV4dCkpO1xuICAgIH07XG4gICAgY29uc3QgbG9va3VwV2l0aENvbnRleHQgPSAoZWRpdG9yLCBnZXREYXRhYmFzZSwgY29udGV4dCwgZmV0Y2hPcHRpb25zID0ge30pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRhdGFiYXNlID0gZ2V0RGF0YWJhc2UoKTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBzdGFydFRleHQgPSAoX2EgPSBybmcuc3RhcnRDb250YWluZXIubm9kZVZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZXJzID0gZmlsdGVyJDUoZGF0YWJhc2UubG9va3VwQnlUcmlnZ2VyKGNvbnRleHQudHJpZ2dlciksIGF1dG9jb21wbGV0ZXIgPT4gY29udGV4dC50ZXh0Lmxlbmd0aCA+PSBhdXRvY29tcGxldGVyLm1pbkNoYXJzICYmIGF1dG9jb21wbGV0ZXIubWF0Y2hlcy5nZXRPclRodW5rKCgpID0+IGlzU3RhcnRPZldvcmQoZWRpdG9yLmRvbSkpKGNvbnRleHQucmFuZ2UsIHN0YXJ0VGV4dCwgY29udGV4dC50ZXh0KSk7XG4gICAgICBpZiAoYXV0b2NvbXBsZXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb29rdXBEYXRhID0gUHJvbWlzZS5hbGwobWFwJDMoYXV0b2NvbXBsZXRlcnMsIGFjID0+IHtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXN1bHQgPSBhYy5mZXRjaChjb250ZXh0LnRleHQsIGFjLm1heFJlc3VsdHMsIGZldGNoT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmZXRjaFJlc3VsdC50aGVuKHJlc3VsdHMgPT4gKHtcbiAgICAgICAgICBtYXRjaFRleHQ6IGNvbnRleHQudGV4dCxcbiAgICAgICAgICBpdGVtczogcmVzdWx0cyxcbiAgICAgICAgICBjb2x1bW5zOiBhYy5jb2x1bW5zLFxuICAgICAgICAgIG9uQWN0aW9uOiBhYy5vbkFjdGlvbixcbiAgICAgICAgICBoaWdobGlnaHRPbjogYWMuaGlnaGxpZ2h0T25cbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICBsb29rdXBEYXRhLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFNpbXBsZVJlc3VsdFR5cGU7XG4gICAgKGZ1bmN0aW9uIChTaW1wbGVSZXN1bHRUeXBlKSB7XG4gICAgICBTaW1wbGVSZXN1bHRUeXBlW1NpbXBsZVJlc3VsdFR5cGVbJ0Vycm9yJ10gPSAwXSA9ICdFcnJvcic7XG4gICAgICBTaW1wbGVSZXN1bHRUeXBlW1NpbXBsZVJlc3VsdFR5cGVbJ1ZhbHVlJ10gPSAxXSA9ICdWYWx1ZSc7XG4gICAgfShTaW1wbGVSZXN1bHRUeXBlIHx8IChTaW1wbGVSZXN1bHRUeXBlID0ge30pKSk7XG4gICAgY29uc3QgZm9sZCQxID0gKHJlcywgb25FcnJvciwgb25WYWx1ZSkgPT4gcmVzLnN0eXBlID09PSBTaW1wbGVSZXN1bHRUeXBlLkVycm9yID8gb25FcnJvcihyZXMuc2Vycm9yKSA6IG9uVmFsdWUocmVzLnN2YWx1ZSk7XG4gICAgY29uc3QgcGFydGl0aW9uID0gcmVzdWx0cyA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgZWFjaCRlKHJlc3VsdHMsIG9iaiA9PiB7XG4gICAgICAgIGZvbGQkMShvYmosIGVyciA9PiBlcnJvcnMucHVzaChlcnIpLCB2YWwgPT4gdmFsdWVzLnB1c2godmFsKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZXJyb3JzXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFwRXJyb3IgPSAocmVzLCBmKSA9PiB7XG4gICAgICBpZiAocmVzLnN0eXBlID09PSBTaW1wbGVSZXN1bHRUeXBlLkVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3R5cGU6IFNpbXBsZVJlc3VsdFR5cGUuRXJyb3IsXG4gICAgICAgICAgc2Vycm9yOiBmKHJlcy5zZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbWFwID0gKHJlcywgZikgPT4ge1xuICAgICAgaWYgKHJlcy5zdHlwZSA9PT0gU2ltcGxlUmVzdWx0VHlwZS5WYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0eXBlOiBTaW1wbGVSZXN1bHRUeXBlLlZhbHVlLFxuICAgICAgICAgIHN2YWx1ZTogZihyZXMuc3ZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJpbmQkMSA9IChyZXMsIGYpID0+IHtcbiAgICAgIGlmIChyZXMuc3R5cGUgPT09IFNpbXBsZVJlc3VsdFR5cGUuVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYocmVzLnN2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYmluZEVycm9yID0gKHJlcywgZikgPT4ge1xuICAgICAgaWYgKHJlcy5zdHlwZSA9PT0gU2ltcGxlUmVzdWx0VHlwZS5FcnJvcikge1xuICAgICAgICByZXR1cm4gZihyZXMuc2Vycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdmFsdWUgPSB2ID0+ICh7XG4gICAgICBzdHlwZTogU2ltcGxlUmVzdWx0VHlwZS5WYWx1ZSxcbiAgICAgIHN2YWx1ZTogdlxuICAgIH0pO1xuICAgIGNvbnN0IHNlcnJvciA9IGUgPT4gKHtcbiAgICAgIHN0eXBlOiBTaW1wbGVSZXN1bHRUeXBlLkVycm9yLFxuICAgICAgc2Vycm9yOiBlXG4gICAgfSk7XG4gICAgY29uc3QgdG9SZXN1bHQgPSByZXMgPT4gZm9sZCQxKHJlcywgUmVzdWx0LmVycm9yLCBSZXN1bHQudmFsdWUpO1xuICAgIGNvbnN0IGZyb21SZXN1bHQgPSByZXMgPT4gcmVzLmZvbGQoc2Vycm9yLCBzdmFsdWUpO1xuICAgIGNvbnN0IFNpbXBsZVJlc3VsdCA9IHtcbiAgICAgIGZyb21SZXN1bHQsXG4gICAgICB0b1Jlc3VsdCxcbiAgICAgIHN2YWx1ZSxcbiAgICAgIHBhcnRpdGlvbixcbiAgICAgIHNlcnJvcixcbiAgICAgIGJpbmQ6IGJpbmQkMSxcbiAgICAgIGJpbmRFcnJvcixcbiAgICAgIG1hcCxcbiAgICAgIG1hcEVycm9yLFxuICAgICAgZm9sZDogZm9sZCQxXG4gICAgfTtcblxuICAgIGNvbnN0IGZvcm1hdE9iaiA9IGlucHV0ID0+IHtcbiAgICAgIHJldHVybiBpc09iamVjdChpbnB1dCkgJiYga2V5cyhpbnB1dCkubGVuZ3RoID4gMTAwID8gJyByZW1vdmVkIGR1ZSB0byBzaXplJyA6IEpTT04uc3RyaW5naWZ5KGlucHV0LCBudWxsLCAyKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdEVycm9ycyA9IGVycm9ycyA9PiB7XG4gICAgICBjb25zdCBlcyA9IGVycm9ycy5sZW5ndGggPiAxMCA/IGVycm9ycy5zbGljZSgwLCAxMCkuY29uY2F0KFt7XG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgZ2V0RXJyb3JJbmZvOiBjb25zdGFudCgnLi4uIChvbmx5IHNob3dpbmcgZmlyc3QgdGVuIGZhaWx1cmVzKScpXG4gICAgICAgIH1dKSA6IGVycm9ycztcbiAgICAgIHJldHVybiBtYXAkMyhlcywgZSA9PiB7XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHBhdGg6ICgnICsgZS5wYXRoLmpvaW4oJyA+ICcpICsgJylcXG4nICsgZS5nZXRFcnJvckluZm8oKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBudSA9IChwYXRoLCBnZXRFcnJvckluZm8pID0+IHtcbiAgICAgIHJldHVybiBTaW1wbGVSZXN1bHQuc2Vycm9yKFt7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBnZXRFcnJvckluZm9cbiAgICAgICAgfV0pO1xuICAgIH07XG4gICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gKHBhdGgsIGtleSwgb2JqKSA9PiBudShwYXRoLCAoKSA9PiAnQ291bGQgbm90IGZpbmQgdmFsaWQgKnJlcXVpcmVkKiB2YWx1ZSBmb3IgXCInICsga2V5ICsgJ1wiIGluICcgKyBmb3JtYXRPYmoob2JqKSk7XG4gICAgY29uc3QgbWlzc2luZ0tleSA9IChwYXRoLCBrZXkpID0+IG51KHBhdGgsICgpID0+ICdDaG9pY2Ugc2NoZW1hIGRpZCBub3QgY29udGFpbiBjaG9pY2Uga2V5OiBcIicgKyBrZXkgKyAnXCInKTtcbiAgICBjb25zdCBtaXNzaW5nQnJhbmNoID0gKHBhdGgsIGJyYW5jaGVzLCBicmFuY2gpID0+IG51KHBhdGgsICgpID0+ICdUaGUgY2hvc2VuIHNjaGVtYTogXCInICsgYnJhbmNoICsgJ1wiIGRpZCBub3QgZXhpc3QgaW4gYnJhbmNoZXM6ICcgKyBmb3JtYXRPYmooYnJhbmNoZXMpKTtcbiAgICBjb25zdCBjdXN0b20gPSAocGF0aCwgZXJyKSA9PiBudShwYXRoLCBjb25zdGFudChlcnIpKTtcblxuICAgIGNvbnN0IGNob29zZUZyb20gPSAocGF0aCwgaW5wdXQsIGJyYW5jaGVzLCBjaCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gZ2V0JGEoYnJhbmNoZXMsIGNoKTtcbiAgICAgIHJldHVybiBmaWVsZHMuZm9sZCgoKSA9PiBtaXNzaW5nQnJhbmNoKHBhdGgsIGJyYW5jaGVzLCBjaCksIHZwID0+IHZwLmV4dHJhY3QocGF0aC5jb25jYXQoWydicmFuY2g6ICcgKyBjaF0pLCBpbnB1dCkpO1xuICAgIH07XG4gICAgY29uc3QgY2hvb3NlJDEgPSAoa2V5LCBicmFuY2hlcykgPT4ge1xuICAgICAgY29uc3QgZXh0cmFjdCA9IChwYXRoLCBpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBjaG9pY2UgPSBnZXQkYShpbnB1dCwga2V5KTtcbiAgICAgICAgcmV0dXJuIGNob2ljZS5mb2xkKCgpID0+IG1pc3NpbmdLZXkocGF0aCwga2V5KSwgY2hvc2VuID0+IGNob29zZUZyb20ocGF0aCwgaW5wdXQsIGJyYW5jaGVzLCBjaG9zZW4pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0b1N0cmluZyA9ICgpID0+ICdjaG9vc2VPbignICsga2V5ICsgJykuIFBvc3NpYmxlIHZhbHVlczogJyArIGtleXMoYnJhbmNoZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNoYWxsb3cgPSAob2xkLCBudSkgPT4ge1xuICAgICAgcmV0dXJuIG51O1xuICAgIH07XG4gICAgY29uc3QgZGVlcCA9IChvbGQsIG51KSA9PiB7XG4gICAgICBjb25zdCBib3RoT2JqZWN0cyA9IGlzUGxhaW5PYmplY3Qob2xkKSAmJiBpc1BsYWluT2JqZWN0KG51KTtcbiAgICAgIHJldHVybiBib3RoT2JqZWN0cyA/IGRlZXBNZXJnZShvbGQsIG51KSA6IG51O1xuICAgIH07XG4gICAgY29uc3QgYmFzZU1lcmdlID0gbWVyZ2VyID0+IHtcbiAgICAgIHJldHVybiAoLi4ub2JqZWN0cykgPT4ge1xuICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IG1lcmdlIHplcm8gb2JqZWN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iamVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjdXJPYmplY3QgPSBvYmplY3RzW2pdO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1ck9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhcyQyKGN1ck9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICByZXRba2V5XSA9IG1lcmdlcihyZXRba2V5XSwgY3VyT2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGRlZXBNZXJnZSA9IGJhc2VNZXJnZShkZWVwKTtcbiAgICBjb25zdCBtZXJnZSA9IGJhc2VNZXJnZShzaGFsbG93KTtcblxuICAgIGNvbnN0IHJlcXVpcmVkID0gKCkgPT4gKHtcbiAgICAgIHRhZzogJ3JlcXVpcmVkJyxcbiAgICAgIHByb2Nlc3M6IHt9XG4gICAgfSk7XG4gICAgY29uc3QgZGVmYXVsdGVkVGh1bmsgPSBmYWxsYmFja1RodW5rID0+ICh7XG4gICAgICB0YWc6ICdkZWZhdWx0ZWRUaHVuaycsXG4gICAgICBwcm9jZXNzOiBmYWxsYmFja1RodW5rXG4gICAgfSk7XG4gICAgY29uc3QgZGVmYXVsdGVkJDEgPSBmYWxsYmFjayA9PiBkZWZhdWx0ZWRUaHVuayhjb25zdGFudChmYWxsYmFjaykpO1xuICAgIGNvbnN0IGFzT3B0aW9uID0gKCkgPT4gKHtcbiAgICAgIHRhZzogJ29wdGlvbicsXG4gICAgICBwcm9jZXNzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgbWVyZ2VWYWx1ZXMgPSAodmFsdWVzLCBiYXNlKSA9PiB2YWx1ZXMubGVuZ3RoID4gMCA/IFNpbXBsZVJlc3VsdC5zdmFsdWUoZGVlcE1lcmdlKGJhc2UsIG1lcmdlLmFwcGx5KHVuZGVmaW5lZCwgdmFsdWVzKSkpIDogU2ltcGxlUmVzdWx0LnN2YWx1ZShiYXNlKTtcbiAgICBjb25zdCBtZXJnZUVycm9ycyA9IGVycm9ycyA9PiBjb21wb3NlKFNpbXBsZVJlc3VsdC5zZXJyb3IsIGZsYXR0ZW4pKGVycm9ycyk7XG4gICAgY29uc3QgY29uc29saWRhdGVPYmogPSAob2JqZWN0cywgYmFzZSkgPT4ge1xuICAgICAgY29uc3QgcGFydGl0aW9uID0gU2ltcGxlUmVzdWx0LnBhcnRpdGlvbihvYmplY3RzKTtcbiAgICAgIHJldHVybiBwYXJ0aXRpb24uZXJyb3JzLmxlbmd0aCA+IDAgPyBtZXJnZUVycm9ycyhwYXJ0aXRpb24uZXJyb3JzKSA6IG1lcmdlVmFsdWVzKHBhcnRpdGlvbi52YWx1ZXMsIGJhc2UpO1xuICAgIH07XG4gICAgY29uc3QgY29uc29saWRhdGVBcnIgPSBvYmplY3RzID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpdGlvbnMgPSBTaW1wbGVSZXN1bHQucGFydGl0aW9uKG9iamVjdHMpO1xuICAgICAgcmV0dXJuIHBhcnRpdGlvbnMuZXJyb3JzLmxlbmd0aCA+IDAgPyBtZXJnZUVycm9ycyhwYXJ0aXRpb25zLmVycm9ycykgOiBTaW1wbGVSZXN1bHQuc3ZhbHVlKHBhcnRpdGlvbnMudmFsdWVzKTtcbiAgICB9O1xuICAgIGNvbnN0IFJlc3VsdENvbWJpbmUgPSB7XG4gICAgICBjb25zb2xpZGF0ZU9iaixcbiAgICAgIGNvbnNvbGlkYXRlQXJyXG4gICAgfTtcblxuICAgIGNvbnN0IGZpZWxkJDEgPSAoa2V5LCBuZXdLZXksIHByZXNlbmNlLCBwcm9wKSA9PiAoe1xuICAgICAgdGFnOiAnZmllbGQnLFxuICAgICAga2V5LFxuICAgICAgbmV3S2V5LFxuICAgICAgcHJlc2VuY2UsXG4gICAgICBwcm9wXG4gICAgfSk7XG4gICAgY29uc3QgY3VzdG9tRmllbGQkMSA9IChuZXdLZXksIGluc3RhbnRpYXRvcikgPT4gKHtcbiAgICAgIHRhZzogJ2N1c3RvbScsXG4gICAgICBuZXdLZXksXG4gICAgICBpbnN0YW50aWF0b3JcbiAgICB9KTtcbiAgICBjb25zdCBmb2xkID0gKHZhbHVlLCBpZkZpZWxkLCBpZkN1c3RvbSkgPT4ge1xuICAgICAgc3dpdGNoICh2YWx1ZS50YWcpIHtcbiAgICAgIGNhc2UgJ2ZpZWxkJzpcbiAgICAgICAgcmV0dXJuIGlmRmllbGQodmFsdWUua2V5LCB2YWx1ZS5uZXdLZXksIHZhbHVlLnByZXNlbmNlLCB2YWx1ZS5wcm9wKTtcbiAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIHJldHVybiBpZkN1c3RvbSh2YWx1ZS5uZXdLZXksIHZhbHVlLmluc3RhbnRpYXRvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdG9yID0+IHtcbiAgICAgIGNvbnN0IGV4dHJhY3QgPSAocGF0aCwgdmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBTaW1wbGVSZXN1bHQuYmluZEVycm9yKHZhbGlkYXRvcih2YWwpLCBlcnIgPT4gY3VzdG9tKHBhdGgsIGVycikpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gY29uc3RhbnQoJ3ZhbCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0cmFjdCxcbiAgICAgICAgdG9TdHJpbmdcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBhbnlWYWx1ZSQxID0gdmFsdWUoU2ltcGxlUmVzdWx0LnN2YWx1ZSk7XG5cbiAgICBjb25zdCByZXF1aXJlZEFjY2VzcyA9IChwYXRoLCBvYmosIGtleSwgYnVuZGxlKSA9PiBnZXQkYShvYmosIGtleSkuZm9sZCgoKSA9PiBtaXNzaW5nUmVxdWlyZWQocGF0aCwga2V5LCBvYmopLCBidW5kbGUpO1xuICAgIGNvbnN0IGZhbGxiYWNrQWNjZXNzID0gKG9iaiwga2V5LCBmYWxsYmFjaywgYnVuZGxlKSA9PiB7XG4gICAgICBjb25zdCB2ID0gZ2V0JGEob2JqLCBrZXkpLmdldE9yVGh1bmsoKCkgPT4gZmFsbGJhY2sob2JqKSk7XG4gICAgICByZXR1cm4gYnVuZGxlKHYpO1xuICAgIH07XG4gICAgY29uc3Qgb3B0aW9uQWNjZXNzID0gKG9iaiwga2V5LCBidW5kbGUpID0+IGJ1bmRsZShnZXQkYShvYmosIGtleSkpO1xuICAgIGNvbnN0IG9wdGlvbkRlZmF1bHRlZEFjY2VzcyA9IChvYmosIGtleSwgZmFsbGJhY2ssIGJ1bmRsZSkgPT4ge1xuICAgICAgY29uc3Qgb3B0ID0gZ2V0JGEob2JqLCBrZXkpLm1hcCh2YWwgPT4gdmFsID09PSB0cnVlID8gZmFsbGJhY2sob2JqKSA6IHZhbCk7XG4gICAgICByZXR1cm4gYnVuZGxlKG9wdCk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0RmllbGQgPSAoZmllbGQsIHBhdGgsIG9iaiwga2V5LCBwcm9wKSA9PiB7XG4gICAgICBjb25zdCBidW5kbGUgPSBhdiA9PiBwcm9wLmV4dHJhY3QocGF0aC5jb25jYXQoW2tleV0pLCBhdik7XG4gICAgICBjb25zdCBidW5kbGVBc09wdGlvbiA9IG9wdFZhbHVlID0+IG9wdFZhbHVlLmZvbGQoKCkgPT4gU2ltcGxlUmVzdWx0LnN2YWx1ZShPcHRpb25hbC5ub25lKCkpLCBvdiA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb3AuZXh0cmFjdChwYXRoLmNvbmNhdChba2V5XSksIG92KTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZVJlc3VsdC5tYXAocmVzdWx0LCBPcHRpb25hbC5zb21lKTtcbiAgICAgIH0pO1xuICAgICAgc3dpdGNoIChmaWVsZC50YWcpIHtcbiAgICAgIGNhc2UgJ3JlcXVpcmVkJzpcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkQWNjZXNzKHBhdGgsIG9iaiwga2V5LCBidW5kbGUpO1xuICAgICAgY2FzZSAnZGVmYXVsdGVkVGh1bmsnOlxuICAgICAgICByZXR1cm4gZmFsbGJhY2tBY2Nlc3Mob2JqLCBrZXksIGZpZWxkLnByb2Nlc3MsIGJ1bmRsZSk7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gb3B0aW9uQWNjZXNzKG9iaiwga2V5LCBidW5kbGVBc09wdGlvbik7XG4gICAgICBjYXNlICdkZWZhdWx0ZWRPcHRpb25UaHVuayc6XG4gICAgICAgIHJldHVybiBvcHRpb25EZWZhdWx0ZWRBY2Nlc3Mob2JqLCBrZXksIGZpZWxkLnByb2Nlc3MsIGJ1bmRsZUFzT3B0aW9uKTtcbiAgICAgIGNhc2UgJ21lcmdlV2l0aFRodW5rJzoge1xuICAgICAgICAgIHJldHVybiBmYWxsYmFja0FjY2VzcyhvYmosIGtleSwgY29uc3RhbnQoe30pLCB2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZXBNZXJnZShmaWVsZC5wcm9jZXNzKG9iaiksIHYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1bmRsZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0RmllbGRzID0gKHBhdGgsIG9iaiwgZmllbGRzKSA9PiB7XG4gICAgICBjb25zdCBzdWNjZXNzID0ge307XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgIGZvbGQoZmllbGQsIChrZXksIG5ld0tleSwgcHJlc2VuY2UsIHByb3ApID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0RmllbGQocHJlc2VuY2UsIHBhdGgsIG9iaiwga2V5LCBwcm9wKTtcbiAgICAgICAgICBTaW1wbGVSZXN1bHQuZm9sZChyZXN1bHQsIGVyciA9PiB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lcnIpO1xuICAgICAgICAgIH0sIHJlcyA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzW25ld0tleV0gPSByZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIChuZXdLZXksIGluc3RhbnRpYXRvcikgPT4ge1xuICAgICAgICAgIHN1Y2Nlc3NbbmV3S2V5XSA9IGluc3RhbnRpYXRvcihvYmopO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID4gMCA/IFNpbXBsZVJlc3VsdC5zZXJyb3IoZXJyb3JzKSA6IFNpbXBsZVJlc3VsdC5zdmFsdWUoc3VjY2Vzcyk7XG4gICAgfTtcbiAgICBjb25zdCBvYmpPZiA9IHZhbHVlcyA9PiB7XG4gICAgICBjb25zdCBleHRyYWN0ID0gKHBhdGgsIG8pID0+IGV4dHJhY3RGaWVsZHMocGF0aCwgbywgdmFsdWVzKTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZFN0cmluZ3MgPSBtYXAkMyh2YWx1ZXMsIHZhbHVlID0+IGZvbGQodmFsdWUsIChrZXksIF9va2V5LCBfcHJlc2VuY2UsIHByb3ApID0+IGtleSArICcgLT4gJyArIHByb3AudG9TdHJpbmcoKSwgKG5ld0tleSwgX2luc3RhbnRpYXRvcikgPT4gJ3N0YXRlKCcgKyBuZXdLZXkgKyAnKScpKTtcbiAgICAgICAgcmV0dXJuICdvYmp7XFxuJyArIGZpZWxkU3RyaW5ncy5qb2luKCdcXG4nKSArICd9JztcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHRyYWN0LFxuICAgICAgICB0b1N0cmluZ1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGFyck9mID0gcHJvcCA9PiB7XG4gICAgICBjb25zdCBleHRyYWN0ID0gKHBhdGgsIGFycmF5KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBtYXAkMyhhcnJheSwgKGEsIGkpID0+IHByb3AuZXh0cmFjdChwYXRoLmNvbmNhdChbJ1snICsgaSArICddJ10pLCBhKSk7XG4gICAgICAgIHJldHVybiBSZXN1bHRDb21iaW5lLmNvbnNvbGlkYXRlQXJyKHJlc3VsdHMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvU3RyaW5nID0gKCkgPT4gJ2FycmF5KCcgKyBwcm9wLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHRyYWN0LFxuICAgICAgICB0b1N0cmluZ1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWVPZiA9IHZhbGlkYXRvciA9PiB2YWx1ZSh2ID0+IHZhbGlkYXRvcih2KS5mb2xkKFNpbXBsZVJlc3VsdC5zZXJyb3IsIFNpbXBsZVJlc3VsdC5zdmFsdWUpKTtcbiAgICBjb25zdCBleHRyYWN0VmFsdWUgPSAobGFiZWwsIHByb3AsIG9iaikgPT4ge1xuICAgICAgY29uc3QgcmVzID0gcHJvcC5leHRyYWN0KFtsYWJlbF0sIG9iaik7XG4gICAgICByZXR1cm4gU2ltcGxlUmVzdWx0Lm1hcEVycm9yKHJlcywgZXJycyA9PiAoe1xuICAgICAgICBpbnB1dDogb2JqLFxuICAgICAgICBlcnJvcnM6IGVycnNcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzUmF3ID0gKGxhYmVsLCBwcm9wLCBvYmopID0+IFNpbXBsZVJlc3VsdC50b1Jlc3VsdChleHRyYWN0VmFsdWUobGFiZWwsIHByb3AsIG9iaikpO1xuICAgIGNvbnN0IGZvcm1hdEVycm9yID0gZXJySW5mbyA9PiB7XG4gICAgICByZXR1cm4gJ0Vycm9yczogXFxuJyArIGZvcm1hdEVycm9ycyhlcnJJbmZvLmVycm9ycykuam9pbignXFxuJykgKyAnXFxuXFxuSW5wdXQgb2JqZWN0OiAnICsgZm9ybWF0T2JqKGVyckluZm8uaW5wdXQpO1xuICAgIH07XG4gICAgY29uc3QgY2hvb3NlID0gKGtleSwgYnJhbmNoZXMpID0+IGNob29zZSQxKGtleSwgbWFwJDIoYnJhbmNoZXMsIG9iak9mKSk7XG5cbiAgICBjb25zdCBhbnlWYWx1ZSA9IGNvbnN0YW50KGFueVZhbHVlJDEpO1xuICAgIGNvbnN0IHR5cGVkVmFsdWUgPSAodmFsaWRhdG9yLCBleHBlY3RlZFR5cGUpID0+IHZhbHVlKGEgPT4ge1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHR5cGVvZiBhO1xuICAgICAgcmV0dXJuIHZhbGlkYXRvcihhKSA/IFNpbXBsZVJlc3VsdC5zdmFsdWUoYSkgOiBTaW1wbGVSZXN1bHQuc2Vycm9yKGBFeHBlY3RlZCB0eXBlOiAkeyBleHBlY3RlZFR5cGUgfSBidXQgZ290OiAkeyBhY3R1YWxUeXBlIH1gKTtcbiAgICB9KTtcbiAgICBjb25zdCBudW1iZXIgPSB0eXBlZFZhbHVlKGlzTnVtYmVyLCAnbnVtYmVyJyk7XG4gICAgY29uc3Qgc3RyaW5nID0gdHlwZWRWYWx1ZShpc1N0cmluZywgJ3N0cmluZycpO1xuICAgIGNvbnN0IGJvb2xlYW4gPSB0eXBlZFZhbHVlKGlzQm9vbGVhbiwgJ2Jvb2xlYW4nKTtcbiAgICBjb25zdCBmdW5jdGlvblByb2Nlc3NvciA9IHR5cGVkVmFsdWUoaXNGdW5jdGlvbiwgJ2Z1bmN0aW9uJyk7XG5cbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkJDE7XG4gICAgY29uc3QgY3VzdG9tRmllbGQgPSBjdXN0b21GaWVsZCQxO1xuICAgIGNvbnN0IHZhbGlkYXRlRW51bSA9IHZhbHVlcyA9PiB2YWx1ZU9mKHZhbHVlID0+IGNvbnRhaW5zJDIodmFsdWVzLCB2YWx1ZSkgPyBSZXN1bHQudmFsdWUodmFsdWUpIDogUmVzdWx0LmVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZTogXCIkeyB2YWx1ZSB9XCIsIGNob29zZSBvbmUgb2YgXCIkeyB2YWx1ZXMuam9pbignLCAnKSB9XCIuYCkpO1xuICAgIGNvbnN0IHJlcXVpcmVkT2YgPSAoa2V5LCBzY2hlbWEpID0+IGZpZWxkKGtleSwga2V5LCByZXF1aXJlZCgpLCBzY2hlbWEpO1xuICAgIGNvbnN0IHJlcXVpcmVkU3RyaW5nID0ga2V5ID0+IHJlcXVpcmVkT2Yoa2V5LCBzdHJpbmcpO1xuICAgIGNvbnN0IHJlcXVpcmVkRnVuY3Rpb24gPSBrZXkgPT4gcmVxdWlyZWRPZihrZXksIGZ1bmN0aW9uUHJvY2Vzc29yKTtcbiAgICBjb25zdCByZXF1aXJlZEFycmF5T2YgPSAoa2V5LCBzY2hlbWEpID0+IGZpZWxkKGtleSwga2V5LCByZXF1aXJlZCgpLCBhcnJPZihzY2hlbWEpKTtcbiAgICBjb25zdCBvcHRpb25PZiA9IChrZXksIHNjaGVtYSkgPT4gZmllbGQoa2V5LCBrZXksIGFzT3B0aW9uKCksIHNjaGVtYSk7XG4gICAgY29uc3Qgb3B0aW9uU3RyaW5nID0ga2V5ID0+IG9wdGlvbk9mKGtleSwgc3RyaW5nKTtcbiAgICBjb25zdCBvcHRpb25GdW5jdGlvbiA9IGtleSA9PiBvcHRpb25PZihrZXksIGZ1bmN0aW9uUHJvY2Vzc29yKTtcbiAgICBjb25zdCBkZWZhdWx0ZWQgPSAoa2V5LCBmYWxsYmFjaykgPT4gZmllbGQoa2V5LCBrZXksIGRlZmF1bHRlZCQxKGZhbGxiYWNrKSwgYW55VmFsdWUoKSk7XG4gICAgY29uc3QgZGVmYXVsdGVkT2YgPSAoa2V5LCBmYWxsYmFjaywgc2NoZW1hKSA9PiBmaWVsZChrZXksIGtleSwgZGVmYXVsdGVkJDEoZmFsbGJhY2spLCBzY2hlbWEpO1xuICAgIGNvbnN0IGRlZmF1bHRlZE51bWJlciA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBudW1iZXIpO1xuICAgIGNvbnN0IGRlZmF1bHRlZFN0cmluZyA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBzdHJpbmcpO1xuICAgIGNvbnN0IGRlZmF1bHRlZFN0cmluZ0VudW0gPSAoa2V5LCBmYWxsYmFjaywgdmFsdWVzKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCB2YWxpZGF0ZUVudW0odmFsdWVzKSk7XG4gICAgY29uc3QgZGVmYXVsdGVkQm9vbGVhbiA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBib29sZWFuKTtcbiAgICBjb25zdCBkZWZhdWx0ZWRGdW5jdGlvbiA9IChrZXksIGZhbGxiYWNrKSA9PiBkZWZhdWx0ZWRPZihrZXksIGZhbGxiYWNrLCBmdW5jdGlvblByb2Nlc3Nvcik7XG4gICAgY29uc3QgZGVmYXVsdGVkQXJyYXlPZiA9IChrZXksIGZhbGxiYWNrLCBzY2hlbWEpID0+IGRlZmF1bHRlZE9mKGtleSwgZmFsbGJhY2ssIGFyck9mKHNjaGVtYSkpO1xuXG4gICAgY29uc3QgdHlwZSA9IHJlcXVpcmVkU3RyaW5nKCd0eXBlJyk7XG4gICAgY29uc3QgZmV0Y2gkMSA9IHJlcXVpcmVkRnVuY3Rpb24oJ2ZldGNoJyk7XG4gICAgY29uc3Qgb25BY3Rpb24gPSByZXF1aXJlZEZ1bmN0aW9uKCdvbkFjdGlvbicpO1xuICAgIGNvbnN0IG9uU2V0dXAgPSBkZWZhdWx0ZWRGdW5jdGlvbignb25TZXR1cCcsICgpID0+IG5vb3ApO1xuICAgIGNvbnN0IG9wdGlvbmFsVGV4dCA9IG9wdGlvblN0cmluZygndGV4dCcpO1xuICAgIGNvbnN0IG9wdGlvbmFsSWNvbiA9IG9wdGlvblN0cmluZygnaWNvbicpO1xuICAgIGNvbnN0IG9wdGlvbmFsVG9vbHRpcCA9IG9wdGlvblN0cmluZygndG9vbHRpcCcpO1xuICAgIGNvbnN0IG9wdGlvbmFsTGFiZWwgPSBvcHRpb25TdHJpbmcoJ2xhYmVsJyk7XG4gICAgY29uc3QgYWN0aXZlID0gZGVmYXVsdGVkQm9vbGVhbignYWN0aXZlJywgZmFsc2UpO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBkZWZhdWx0ZWRCb29sZWFuKCdlbmFibGVkJywgdHJ1ZSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IGRlZmF1bHRlZEJvb2xlYW4oJ3ByaW1hcnknLCBmYWxzZSk7XG4gICAgY29uc3QgZGVmYXVsdGVkQ29sdW1ucyA9IG51bSA9PiBkZWZhdWx0ZWQoJ2NvbHVtbnMnLCBudW0pO1xuICAgIGNvbnN0IGRlZmF1bHRlZFR5cGUgPSB0eXBlID0+IGRlZmF1bHRlZFN0cmluZygndHlwZScsIHR5cGUpO1xuXG4gICAgY29uc3QgYXV0b2NvbXBsZXRlclNjaGVtYSA9IG9iak9mKFtcbiAgICAgIHR5cGUsXG4gICAgICByZXF1aXJlZFN0cmluZygndHJpZ2dlcicpLFxuICAgICAgZGVmYXVsdGVkTnVtYmVyKCdtaW5DaGFycycsIDEpLFxuICAgICAgZGVmYXVsdGVkQ29sdW1ucygxKSxcbiAgICAgIGRlZmF1bHRlZE51bWJlcignbWF4UmVzdWx0cycsIDEwKSxcbiAgICAgIG9wdGlvbkZ1bmN0aW9uKCdtYXRjaGVzJyksXG4gICAgICBmZXRjaCQxLFxuICAgICAgb25BY3Rpb24sXG4gICAgICBkZWZhdWx0ZWRBcnJheU9mKCdoaWdobGlnaHRPbicsIFtdLCBzdHJpbmcpXG4gICAgXSk7XG4gICAgY29uc3QgY3JlYXRlQXV0b2NvbXBsZXRlciA9IHNwZWMgPT4gYXNSYXcoJ0F1dG9jb21wbGV0ZXInLCBhdXRvY29tcGxldGVyU2NoZW1hLCB7XG4gICAgICB0cmlnZ2VyOiBzcGVjLmNoLFxuICAgICAgLi4uc3BlY1xuICAgIH0pO1xuXG4gICAgY29uc3QgYmFzZVRvb2xiYXJCdXR0b25GaWVsZHMgPSBbXG4gICAgICBlbmFibGVkLFxuICAgICAgb3B0aW9uYWxUb29sdGlwLFxuICAgICAgb3B0aW9uYWxJY29uLFxuICAgICAgb3B0aW9uYWxUZXh0LFxuICAgICAgb25TZXR1cFxuICAgIF07XG5cbiAgICBjb25zdCBiYXNlVG9vbGJhclRvZ2dsZUJ1dHRvbkZpZWxkcyA9IFthY3RpdmVdLmNvbmNhdChiYXNlVG9vbGJhckJ1dHRvbkZpZWxkcyk7XG5cbiAgICBjb25zdCBjb250ZXh0QmFyRmllbGRzID0gW1xuICAgICAgZGVmYXVsdGVkRnVuY3Rpb24oJ3ByZWRpY2F0ZScsIG5ldmVyKSxcbiAgICAgIGRlZmF1bHRlZFN0cmluZ0VudW0oJ3Njb3BlJywgJ25vZGUnLCBbXG4gICAgICAgICdub2RlJyxcbiAgICAgICAgJ2VkaXRvcidcbiAgICAgIF0pLFxuICAgICAgZGVmYXVsdGVkU3RyaW5nRW51bSgncG9zaXRpb24nLCAnc2VsZWN0aW9uJywgW1xuICAgICAgICAnbm9kZScsXG4gICAgICAgICdzZWxlY3Rpb24nLFxuICAgICAgICAnbGluZSdcbiAgICAgIF0pXG4gICAgXTtcblxuICAgIGNvbnN0IGNvbnRleHRCdXR0b25GaWVsZHMgPSBiYXNlVG9vbGJhckJ1dHRvbkZpZWxkcy5jb25jYXQoW1xuICAgICAgZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKSxcbiAgICAgIHByaW1hcnksXG4gICAgICBvbkFjdGlvbixcbiAgICAgIGN1c3RvbUZpZWxkKCdvcmlnaW5hbCcsIGlkZW50aXR5KVxuICAgIF0pO1xuICAgIGNvbnN0IGNvbnRleHRUb2dnbGVCdXR0b25GaWVsZHMgPSBiYXNlVG9vbGJhclRvZ2dsZUJ1dHRvbkZpZWxkcy5jb25jYXQoW1xuICAgICAgZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKSxcbiAgICAgIHByaW1hcnksXG4gICAgICBvbkFjdGlvbixcbiAgICAgIGN1c3RvbUZpZWxkKCdvcmlnaW5hbCcsIGlkZW50aXR5KVxuICAgIF0pO1xuICAgIGNvbnN0IGxhdW5jaEJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyQnV0dG9uRmllbGRzLmNvbmNhdChbZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm1idXR0b24nKV0pO1xuICAgIGNvbnN0IGxhdW5jaFRvZ2dsZUJ1dHRvbkZpZWxkcyA9IGJhc2VUb29sYmFyVG9nZ2xlQnV0dG9uRmllbGRzLmNvbmNhdChbZGVmYXVsdGVkVHlwZSgnY29udGV4dGZvcm10b2dnbGVidXR0b24nKV0pO1xuICAgIGNvbnN0IHRvZ2dsZU9yTm9ybWFsID0gY2hvb3NlKCd0eXBlJywge1xuICAgICAgY29udGV4dGZvcm1idXR0b246IGNvbnRleHRCdXR0b25GaWVsZHMsXG4gICAgICBjb250ZXh0Zm9ybXRvZ2dsZWJ1dHRvbjogY29udGV4dFRvZ2dsZUJ1dHRvbkZpZWxkc1xuICAgIH0pO1xuICAgIG9iak9mKFtcbiAgICAgIGRlZmF1bHRlZFR5cGUoJ2NvbnRleHRmb3JtJyksXG4gICAgICBkZWZhdWx0ZWRGdW5jdGlvbignaW5pdFZhbHVlJywgY29uc3RhbnQoJycpKSxcbiAgICAgIG9wdGlvbmFsTGFiZWwsXG4gICAgICByZXF1aXJlZEFycmF5T2YoJ2NvbW1hbmRzJywgdG9nZ2xlT3JOb3JtYWwpLFxuICAgICAgb3B0aW9uT2YoJ2xhdW5jaCcsIGNob29zZSgndHlwZScsIHtcbiAgICAgICAgY29udGV4dGZvcm1idXR0b246IGxhdW5jaEJ1dHRvbkZpZWxkcyxcbiAgICAgICAgY29udGV4dGZvcm10b2dnbGVidXR0b246IGxhdW5jaFRvZ2dsZUJ1dHRvbkZpZWxkc1xuICAgICAgfSkpXG4gICAgXS5jb25jYXQoY29udGV4dEJhckZpZWxkcykpO1xuXG4gICAgY29uc3QgcmVnaXN0ZXIkMiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwb3B1cHMgPSBlZGl0b3IudWkucmVnaXN0cnkuZ2V0QWxsKCkucG9wdXBzO1xuICAgICAgY29uc3QgZGF0YXNldCA9IG1hcCQyKHBvcHVwcywgcG9wdXAgPT4gY3JlYXRlQXV0b2NvbXBsZXRlcihwb3B1cCkuZm9sZChlcnIgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0RXJyb3IoZXJyKSk7XG4gICAgICB9LCBpZGVudGl0eSkpO1xuICAgICAgY29uc3QgdHJpZ2dlcnMgPSBzdHJpbmdBcnJheShtYXBUb0FycmF5KGRhdGFzZXQsIHYgPT4gdi50cmlnZ2VyKSk7XG4gICAgICBjb25zdCBkYXRhc2V0VmFsdWVzID0gdmFsdWVzKGRhdGFzZXQpO1xuICAgICAgY29uc3QgbG9va3VwQnlUcmlnZ2VyID0gdHJpZ2dlciA9PiBmaWx0ZXIkNShkYXRhc2V0VmFsdWVzLCBkdiA9PiBkdi50cmlnZ2VyID09PSB0cmlnZ2VyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIHRyaWdnZXJzLFxuICAgICAgICBsb29rdXBCeVRyaWdnZXJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwRWRpdG9ySW5wdXQgPSAoZWRpdG9yLCBhcGkpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IGxhc3QkMShhcGkubG9hZCwgNTApO1xuICAgICAgZWRpdG9yLm9uKCdrZXlwcmVzcyBjb21wb3NpdGlvbmVuZCcsIGUgPT4ge1xuICAgICAgICBpZiAoZS53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlLnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZS53aGljaDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICB1cGRhdGUudGhyb3R0bGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSAyNykge1xuICAgICAgICAgIGFwaS5jYW5jZWxJZk5lY2Vzc2FyeSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgdXBkYXRlLmNhbmNlbCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRqID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUF1dG9jb21wbGV0ZXIgPSB2YWx1ZSQyKCk7XG4gICAgICBjb25zdCB1aUFjdGl2ZSA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgaXNBY3RpdmUgPSBhY3RpdmVBdXRvY29tcGxldGVyLmlzU2V0O1xuICAgICAgY29uc3QgY2FuY2VsSWZOZWNlc3NhcnkgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgcmVtb3ZlQXV0b2NvbXBsZXRlckRlY29yYXRpb24oZWRpdG9yKTtcbiAgICAgICAgICBmaXJlQXV0b2NvbXBsZXRlckVuZChlZGl0b3IpO1xuICAgICAgICAgIHVpQWN0aXZlLnNldChmYWxzZSk7XG4gICAgICAgICAgYWN0aXZlQXV0b2NvbXBsZXRlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29tbWVuY2VJZk5lY2Vzc2FyeSA9IGNvbnRleHQgPT4ge1xuICAgICAgICBpZiAoIWlzQWN0aXZlKCkpIHtcbiAgICAgICAgICBhZGRBdXRvY29tcGxldGVyRGVjb3JhdGlvbihlZGl0b3IsIGNvbnRleHQucmFuZ2UpO1xuICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuc2V0KHtcbiAgICAgICAgICAgIHRyaWdnZXI6IGNvbnRleHQudHJpZ2dlcixcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoOiBjb250ZXh0LnRleHQubGVuZ3RoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRBdXRvY29tcGxldGVycyA9IGNhY2hlZCgoKSA9PiByZWdpc3RlciQyKGVkaXRvcikpO1xuICAgICAgY29uc3QgZG9Mb29rdXAgPSBmZXRjaE9wdGlvbnMgPT4gYWN0aXZlQXV0b2NvbXBsZXRlci5nZXQoKS5tYXAoYWMgPT4gZ2V0Q29udGV4dChlZGl0b3IuZG9tLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLCBhYy50cmlnZ2VyKS5iaW5kKG5ld0NvbnRleHQgPT4gbG9va3VwV2l0aENvbnRleHQoZWRpdG9yLCBnZXRBdXRvY29tcGxldGVycywgbmV3Q29udGV4dCwgZmV0Y2hPcHRpb25zKSkpLmdldE9yVGh1bmsoKCkgPT4gbG9va3VwKGVkaXRvciwgZ2V0QXV0b2NvbXBsZXRlcnMpKTtcbiAgICAgIGNvbnN0IGxvYWQgPSBmZXRjaE9wdGlvbnMgPT4ge1xuICAgICAgICBkb0xvb2t1cChmZXRjaE9wdGlvbnMpLmZvbGQoY2FuY2VsSWZOZWNlc3NhcnksIGxvb2t1cEluZm8gPT4ge1xuICAgICAgICAgIGNvbW1lbmNlSWZOZWNlc3NhcnkobG9va3VwSW5mby5jb250ZXh0KTtcbiAgICAgICAgICBsb29rdXBJbmZvLmxvb2t1cERhdGEudGhlbihsb29rdXBEYXRhID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuZ2V0KCkubWFwKGFjID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGxvb2t1cEluZm8uY29udGV4dDtcbiAgICAgICAgICAgICAgaWYgKGFjLnRyaWdnZXIgPT09IGNvbnRleHQudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnRleHQubGVuZ3RoIC0gYWMubWF0Y2hMZW5ndGggPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbElmTmVjZXNzYXJ5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUF1dG9jb21wbGV0ZXIuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWMsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTGVuZ3RoOiBjb250ZXh0LnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICh1aUFjdGl2ZS5nZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlQXV0b2NvbXBsZXRlclVwZGF0ZShlZGl0b3IsIHsgbG9va3VwRGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpQWN0aXZlLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUF1dG9jb21wbGV0ZXJTdGFydChlZGl0b3IsIHsgbG9va3VwRGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuYWRkQ29tbWFuZCgnbWNlQXV0b2NvbXBsZXRlclJlbG9hZCcsIChfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLmZldGNoT3B0aW9ucyA6IHt9O1xuICAgICAgICBsb2FkKGZldGNoT3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5hZGRDb21tYW5kKCdtY2VBdXRvY29tcGxldGVyQ2xvc2UnLCBjYW5jZWxJZk5lY2Vzc2FyeSk7XG4gICAgICBzZXR1cEVkaXRvcklucHV0KGVkaXRvciwge1xuICAgICAgICBjYW5jZWxJZk5lY2Vzc2FyeSxcbiAgICAgICAgbG9hZFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGJyb3dzZXIkMSA9IGRldGVjdCQyKCkuYnJvd3NlcjtcbiAgICBjb25zdCBpc1NhZmFyaSA9IGJyb3dzZXIkMS5pc1NhZmFyaSgpO1xuICAgIGNvbnN0IGVtcHR5Tm9kZUNvbnRlbnRzID0gbm9kZSA9PiBmaWxsV2l0aFBhZGRpbmdCcihTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSk7XG4gICAgY29uc3QgaXNFbnRpcmVOb2RlU2VsZWN0ZWQgPSAocm5nLCBub2RlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gcm5nLnN0YXJ0T2Zmc2V0ID09PSAwICYmIHJuZy5lbmRPZmZzZXQgPT09ICgoX2EgPSBub2RlLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudERldGFpbHNFbGVtZW50QXRQb3MgPSAoZG9tLCBwb3MpID0+IE9wdGlvbmFsLmZyb20oZG9tLmdldFBhcmVudChwb3MuY29udGFpbmVyKCksICdkZXRhaWxzJykpO1xuICAgIGNvbnN0IGlzSW5EZXRhaWxzRWxlbWVudCA9IChkb20sIHBvcykgPT4gZ2V0UGFyZW50RGV0YWlsc0VsZW1lbnRBdFBvcyhkb20sIHBvcykuaXNTb21lKCk7XG4gICAgY29uc3QgZ2V0RGV0YWlsc0VsZW1lbnRzID0gKGRvbSwgcm5nKSA9PiB7XG4gICAgICBjb25zdCBzdGFydERldGFpbHMgPSBPcHRpb25hbC5mcm9tKGRvbS5nZXRQYXJlbnQocm5nLnN0YXJ0Q29udGFpbmVyLCAnZGV0YWlscycpKTtcbiAgICAgIGNvbnN0IGVuZERldGFpbHMgPSBPcHRpb25hbC5mcm9tKGRvbS5nZXRQYXJlbnQocm5nLmVuZENvbnRhaW5lciwgJ2RldGFpbHMnKSk7XG4gICAgICBpZiAoc3RhcnREZXRhaWxzLmlzU29tZSgpIHx8IGVuZERldGFpbHMuaXNTb21lKCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTdW1tYXJ5ID0gc3RhcnREZXRhaWxzLmJpbmQoZGV0YWlscyA9PiBPcHRpb25hbC5mcm9tKGRvbS5zZWxlY3QoJ3N1bW1hcnknLCBkZXRhaWxzKVswXSkpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZSh7XG4gICAgICAgICAgc3RhcnRTdW1tYXJ5LFxuICAgICAgICAgIHN0YXJ0RGV0YWlscyxcbiAgICAgICAgICBlbmREZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzQ2FyZXRJblRoZUJlZ2lubmluZ09mID0gKGNhcmV0UG9zLCBlbGVtZW50KSA9PiBmaXJzdFBvc2l0aW9uSW4oZWxlbWVudCkuZXhpc3RzKHBvcyA9PiBwb3MuaXNFcXVhbChjYXJldFBvcykpO1xuICAgIGNvbnN0IGlzQ2FyZXRJblRoZUVuZE9mID0gKGNhcmV0UG9zLCBlbGVtZW50KSA9PiB7XG4gICAgICByZXR1cm4gbGFzdFBvc2l0aW9uSW4oZWxlbWVudCkuZXhpc3RzKHBvcyA9PiB7XG4gICAgICAgIGlmIChpc0JyJDYocG9zLmdldE5vZGUoKSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlBvc2l0aW9uKGVsZW1lbnQsIHBvcykuZXhpc3RzKHBvczIgPT4gcG9zMi5pc0VxdWFsKGNhcmV0UG9zKSkgfHwgcG9zLmlzRXF1YWwoY2FyZXRQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwb3MuaXNFcXVhbChjYXJldFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNDYXJldEF0U3RhcnRPZlN1bW1hcnkgPSAoY2FyZXRQb3MsIGRldGFpbHNFbGVtZW50cykgPT4gZGV0YWlsc0VsZW1lbnRzLnN0YXJ0U3VtbWFyeS5leGlzdHMoc3VtbWFyeSA9PiBpc0NhcmV0SW5UaGVCZWdpbm5pbmdPZihjYXJldFBvcywgc3VtbWFyeSkpO1xuICAgIGNvbnN0IGlzQ2FyZXRBdEVuZE9mU3VtbWFyeSA9IChjYXJldFBvcywgZGV0YWlsc0VsZW1lbnRzKSA9PiBkZXRhaWxzRWxlbWVudHMuc3RhcnRTdW1tYXJ5LmV4aXN0cyhzdW1tYXJ5ID0+IGlzQ2FyZXRJblRoZUVuZE9mKGNhcmV0UG9zLCBzdW1tYXJ5KSk7XG4gICAgY29uc3QgaXNDYXJldEluRmlyc3RQb3NpdGlvbkluQm9keSA9IChjYXJldFBvcywgZGV0YWlsc0VsZW1lbnRzKSA9PiBkZXRhaWxzRWxlbWVudHMuc3RhcnREZXRhaWxzLmV4aXN0cyhkZXRhaWxzID0+IHByZXZQb3NpdGlvbihkZXRhaWxzLCBjYXJldFBvcykuZm9yYWxsKHBvcyA9PiBkZXRhaWxzRWxlbWVudHMuc3RhcnRTdW1tYXJ5LmV4aXN0cyhzdW1tYXJ5ID0+ICFzdW1tYXJ5LmNvbnRhaW5zKGNhcmV0UG9zLmNvbnRhaW5lcigpKSAmJiBzdW1tYXJ5LmNvbnRhaW5zKHBvcy5jb250YWluZXIoKSkpKSk7XG4gICAgY29uc3QgaXNDYXJldEluTGFzdFBvc2l0aW9uSW5Cb2R5ID0gKHJvb3QsIGNhcmV0UG9zLCBkZXRhaWxzRWxlbWVudHMpID0+IGRldGFpbHNFbGVtZW50cy5zdGFydERldGFpbHMuZXhpc3RzKGRldGFpbHMgPT4gbmV4dFBvc2l0aW9uKHJvb3QsIGNhcmV0UG9zKS5mb3JhbGwocG9zID0+ICFkZXRhaWxzLmNvbnRhaW5zKHBvcy5jb250YWluZXIoKSkpKTtcbiAgICBjb25zdCBzZXRDYXJldFRvUG9zaXRpb24gPSAoZWRpdG9yLCBwb3NpdGlvbikgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHBvc2l0aW9uLmdldE5vZGUoKTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQobm9kZSkpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihub2RlLCBwb3NpdGlvbi5vZmZzZXQoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlQ2FyZXRUb0RldGFpbHNQb3MgPSAoZWRpdG9yLCBwb3MsIGZvcndhcmQpID0+IHtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBlZGl0b3IuZG9tLmdldFBhcmVudChwb3MuY29udGFpbmVyKCksICdkZXRhaWxzJyk7XG4gICAgICBpZiAoZGV0YWlscyAmJiAhZGV0YWlscy5vcGVuKSB7XG4gICAgICAgIGNvbnN0IHN1bW1hcnkgPSBlZGl0b3IuZG9tLnNlbGVjdCgnc3VtbWFyeScsIGRldGFpbHMpWzBdO1xuICAgICAgICBpZiAoc3VtbWFyeSkge1xuICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IGZvcndhcmQgPyBmaXJzdFBvc2l0aW9uSW4oc3VtbWFyeSkgOiBsYXN0UG9zaXRpb25JbihzdW1tYXJ5KTtcbiAgICAgICAgICBuZXdQb3MuZWFjaChwb3MgPT4gc2V0Q2FyZXRUb1Bvc2l0aW9uKGVkaXRvciwgcG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldENhcmV0VG9Qb3NpdGlvbihlZGl0b3IsIHBvcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1BhcnRpYWxEZWxldGUgPSAocm5nLCBkZXRhaWxzRWxlbWVudHMpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5zU3RhcnQgPSBlbGVtZW50ID0+IGVsZW1lbnQuY29udGFpbnMocm5nLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5zRW5kID0gZWxlbWVudCA9PiBlbGVtZW50LmNvbnRhaW5zKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgY29uc3Qgc3RhcnRJblN1bW1hcnkgPSBkZXRhaWxzRWxlbWVudHMuc3RhcnRTdW1tYXJ5LmV4aXN0cyhjb250YWluc1N0YXJ0KTtcbiAgICAgIGNvbnN0IGVuZEluU3VtbWFyeSA9IGRldGFpbHNFbGVtZW50cy5zdGFydFN1bW1hcnkuZXhpc3RzKGNvbnRhaW5zRW5kKTtcbiAgICAgIGNvbnN0IGlzUGFydGlhbGx5U2VsZWN0ZWREZXRhaWxzRWxlbWVudHMgPSBkZXRhaWxzRWxlbWVudHMuc3RhcnREZXRhaWxzLmZvcmFsbChzdGFydERldGFpbHMgPT4gZGV0YWlsc0VsZW1lbnRzLmVuZERldGFpbHMuZm9yYWxsKGVuZERldGFpbHMgPT4gc3RhcnREZXRhaWxzICE9PSBlbmREZXRhaWxzKSk7XG4gICAgICBjb25zdCBpc0luUGFydGlhbGx5U2VsZWN0ZWRTdW1tYXJ5ID0gKHN0YXJ0SW5TdW1tYXJ5IHx8IGVuZEluU3VtbWFyeSkgJiYgIShzdGFydEluU3VtbWFyeSAmJiBlbmRJblN1bW1hcnkpO1xuICAgICAgcmV0dXJuIGlzSW5QYXJ0aWFsbHlTZWxlY3RlZFN1bW1hcnkgfHwgaXNQYXJ0aWFsbHlTZWxlY3RlZERldGFpbHNFbGVtZW50cztcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZFByZXZlbnREZWxldGVJbnRvRGV0YWlscyA9IChlZGl0b3IsIGZvcndhcmQsIGdyYW51bGFyaXR5KSA9PiB7XG4gICAgICBjb25zdCB7ZG9tLCBzZWxlY3Rpb259ID0gZWRpdG9yO1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBpZiAoZ3JhbnVsYXJpdHkgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChzZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBjb25zdCBwYXJlbnRCbG9jayA9IGRvbS5nZXRQYXJlbnQoY2FyZXRQb3MuY29udGFpbmVyKCksIGRvbS5pc0Jsb2NrKTtcbiAgICAgICAgY29uc3QgcGFyZW50RGV0YWlsc0F0Q2FyZXQgPSBnZXRQYXJlbnREZXRhaWxzRWxlbWVudEF0UG9zKGRvbSwgY2FyZXRQb3MpO1xuICAgICAgICBjb25zdCBpbkVtcHR5UGFyZW50QmxvY2sgPSBwYXJlbnRCbG9jayAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9jayk7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RCbG9jayA9IGlzTnVsbChwYXJlbnRCbG9jayA9PT0gbnVsbCB8fCBwYXJlbnRCbG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50QmxvY2sucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgY29uc3QgaXNMYXN0QmxvY2sgPSBpc051bGwocGFyZW50QmxvY2sgPT09IG51bGwgfHwgcGFyZW50QmxvY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEJsb2NrLm5leHRTaWJsaW5nKTtcbiAgICAgICAgaWYgKGluRW1wdHlQYXJlbnRCbG9jaykge1xuICAgICAgICAgIGNvbnN0IGZpcnN0T3JMYXN0ID0gZm9yd2FyZCA/IGlzTGFzdEJsb2NrIDogaXNGaXJzdEJsb2NrO1xuICAgICAgICAgIGlmIChmaXJzdE9yTGFzdCkge1xuICAgICAgICAgICAgY29uc3QgaXNCZWZvcmVBZnRlckRldGFpbHMgPSBuYXZpZ2F0ZSghZm9yd2FyZCwgcm9vdCwgY2FyZXRQb3MpLmV4aXN0cyhwb3MgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gaXNJbkRldGFpbHNFbGVtZW50KGRvbSwgcG9zKSAmJiAhZXF1YWxzKHBhcmVudERldGFpbHNBdENhcmV0LCBnZXRQYXJlbnREZXRhaWxzRWxlbWVudEF0UG9zKGRvbSwgcG9zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc0JlZm9yZUFmdGVyRGV0YWlscykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdmlnYXRlKGZvcndhcmQsIHJvb3QsIGNhcmV0UG9zKS5mb2xkKG5ldmVyLCBwb3MgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudERldGFpbHNBdE5ld1BvcyA9IGdldFBhcmVudERldGFpbHNFbGVtZW50QXRQb3MoZG9tLCBwb3MpO1xuICAgICAgICAgIGlmIChpc0luRGV0YWlsc0VsZW1lbnQoZG9tLCBwb3MpICYmICFlcXVhbHMocGFyZW50RGV0YWlsc0F0Q2FyZXQsIHBhcmVudERldGFpbHNBdE5ld1BvcykpIHtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCkge1xuICAgICAgICAgICAgICBtb3ZlQ2FyZXRUb0RldGFpbHNQb3MoZWRpdG9yLCBwb3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRCbG9jayAmJiBpbkVtcHR5UGFyZW50QmxvY2spIHtcbiAgICAgICAgICAgICAgaWYgKGZvcndhcmQgJiYgaXNGaXJzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZvcndhcmQgJiYgaXNMYXN0QmxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtb3ZlQ2FyZXRUb0RldGFpbHNQb3MoZWRpdG9yLCBwb3MsIGZvcndhcmQpO1xuICAgICAgICAgICAgICBlZGl0b3IuZG9tLnJlbW92ZShwYXJlbnRCbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRQcmV2ZW50RGVsZXRlU3VtbWFyeUFjdGlvbiA9IChlZGl0b3IsIGRldGFpbEVsZW1lbnRzLCBmb3J3YXJkLCBncmFudWxhcml0eSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBpZiAoZ3JhbnVsYXJpdHkgPT09ICdzZWxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpc1BhcnRpYWxEZWxldGUocm5nLCBkZXRhaWxFbGVtZW50cyk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2FyZXRBdEVuZE9mU3VtbWFyeShjYXJldFBvcywgZGV0YWlsRWxlbWVudHMpIHx8IGlzQ2FyZXRJbkxhc3RQb3NpdGlvbkluQm9keShyb290LCBjYXJldFBvcywgZGV0YWlsRWxlbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQ2FyZXRBdFN0YXJ0T2ZTdW1tYXJ5KGNhcmV0UG9zLCBkZXRhaWxFbGVtZW50cykgfHwgaXNDYXJldEluRmlyc3RQb3NpdGlvbkluQm9keShjYXJldFBvcywgZGV0YWlsRWxlbWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkUHJldmVudERlbGV0ZUFjdGlvbiA9IChlZGl0b3IsIGZvcndhcmQsIGdyYW51bGFyaXR5KSA9PiBnZXREZXRhaWxzRWxlbWVudHMoZWRpdG9yLmRvbSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkuZm9sZCgoKSA9PiBzaG91bGRQcmV2ZW50RGVsZXRlSW50b0RldGFpbHMoZWRpdG9yLCBmb3J3YXJkLCBncmFudWxhcml0eSksIGRldGFpbHNFbGVtZW50cyA9PiBzaG91bGRQcmV2ZW50RGVsZXRlU3VtbWFyeUFjdGlvbihlZGl0b3IsIGRldGFpbHNFbGVtZW50cywgZm9yd2FyZCwgZ3JhbnVsYXJpdHkpIHx8IHNob3VsZFByZXZlbnREZWxldGVJbnRvRGV0YWlscyhlZGl0b3IsIGZvcndhcmQsIGdyYW51bGFyaXR5KSk7XG4gICAgY29uc3QgaGFuZGxlRGVsZXRlQWN0aW9uU2FmYXJpID0gKGVkaXRvciwgZm9yd2FyZCwgZ3JhbnVsYXJpdHkpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICBjb25zdCBub2RlID0gc2VsZWN0aW9uLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNhcmV0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChybmcpO1xuICAgICAgaWYgKGlzU3VtbWFyeShub2RlKSkge1xuICAgICAgICBpZiAoZ3JhbnVsYXJpdHkgPT09ICdzZWxlY3Rpb24nICYmIGlzRW50aXJlTm9kZVNlbGVjdGVkKHJuZywgbm9kZSkgfHwgd2lsbERlbGV0ZUxhc3RQb3NpdGlvbkluRWxlbWVudChmb3J3YXJkLCBjYXJldFBvcywgbm9kZSkpIHtcbiAgICAgICAgICBlbXB0eU5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsID0gc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgICAgICAgbGV0IHthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXR9ID0gc2VsICE9PSBudWxsICYmIHNlbCAhPT0gdm9pZCAwID8gc2VsIDoge307XG4gICAgICAgICAgICBjb25zdCBhcHBseVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYW5jaG9yTm9kZSkgJiYgaXNOb25OdWxsYWJsZShhbmNob3JPZmZzZXQpICYmIGlzTm9uTnVsbGFibGUoZm9jdXNOb2RlKSAmJiBpc05vbk51bGxhYmxlKGZvY3VzT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbC5zZXRCYXNlQW5kRXh0ZW50KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBzZWwgPT09IG51bGwgfHwgc2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNOb2RlID0gc2VsID09PSBudWxsIHx8IHNlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBzZWwgPT09IG51bGwgfHwgc2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYXBwZW5kQWxsQ2hpbGROb2RlcyA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICBlYWNoJGUoZnJvbS5jaGlsZE5vZGVzLCBjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgIHRvLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGVkaXRvci5kb20uY3JlYXRlKCdzcGFuJywgeyAnZGF0YS1tY2UtYm9ndXMnOiAnMScgfSk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZE5vZGVzKG5vZGUsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBhcHBseVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGdyYW51bGFyaXR5ID09PSAnd29yZCcgfHwgZ3JhbnVsYXJpdHkgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICBzZWwgPT09IG51bGwgfHwgc2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWwubW9kaWZ5KCdleHRlbmQnLCBmb3J3YXJkID8gJ3JpZ2h0JyA6ICdsZWZ0JywgZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBpc0VudGlyZU5vZGVTZWxlY3RlZChzZWxlY3Rpb24uZ2V0Um5nKCksIGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgZW1wdHlOb2RlQ29udGVudHMobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoZm9yd2FyZCA/ICdGb3J3YXJkRGVsZXRlJyA6ICdEZWxldGUnKTtcbiAgICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkTm9kZXMoY29udGFpbmVyLCBub2RlKTtcbiAgICAgICAgICAgICAgYXBwbHlTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBiYWNrc3BhY2VEZWxldGUgPSAoZWRpdG9yLCBmb3J3YXJkLCBncmFudWxhcml0eSkgPT4gc2hvdWxkUHJldmVudERlbGV0ZUFjdGlvbihlZGl0b3IsIGZvcndhcmQsIGdyYW51bGFyaXR5KSB8fCBpc1NhZmFyaSAmJiBoYW5kbGVEZWxldGVBY3Rpb25TYWZhcmkoZWRpdG9yLCBmb3J3YXJkLCBncmFudWxhcml0eSkgPyBPcHRpb25hbC5zb21lKG5vb3ApIDogT3B0aW9uYWwubm9uZSgpO1xuXG4gICAgY29uc3QgY3JlYXRlQW5kRmlyZUlucHV0RXZlbnQgPSBldmVudFR5cGUgPT4gKGVkaXRvciwgaW5wdXRUeXBlLCBzcGVjaWZpY3MgPSB7fSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZWRpdG9yLmdldEJvZHkoKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGlzQ29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCxcbiAgICAgICAgZXZlbnRQaGFzZTogRXZlbnQuQVRfVEFSR0VULFxuICAgICAgICBvcmlnaW5hbFRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHBsaWNpdE9yaWdpbmFsVGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGlzVHJ1c3RlZDogZmFsc2UsXG4gICAgICAgIHNyY0VsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBub29wLFxuICAgICAgICBpbnB1dFR5cGVcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnB1dCA9IGNsb25lJDMobmV3IElucHV0RXZlbnQoZXZlbnRUeXBlKSk7XG4gICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoKGV2ZW50VHlwZSwge1xuICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgICAgICAuLi5zcGVjaWZpY3NcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmlyZUlucHV0RXZlbnQgPSBjcmVhdGVBbmRGaXJlSW5wdXRFdmVudCgnaW5wdXQnKTtcbiAgICBjb25zdCBmaXJlQmVmb3JlSW5wdXRFdmVudCA9IGNyZWF0ZUFuZEZpcmVJbnB1dEV2ZW50KCdiZWZvcmVpbnB1dCcpO1xuXG4gICAgY29uc3QgcGxhdGZvcm0kMiA9IGRldGVjdCQyKCk7XG4gICAgY29uc3Qgb3MgPSBwbGF0Zm9ybSQyLm9zO1xuICAgIGNvbnN0IGlzTWFjT1NPcmlPUyA9IG9zLmlzTWFjT1MoKSB8fCBvcy5pc2lPUygpO1xuICAgIGNvbnN0IGJyb3dzZXIgPSBwbGF0Zm9ybSQyLmJyb3dzZXI7XG4gICAgY29uc3QgaXNGaXJlZm94ID0gYnJvd3Nlci5pc0ZpcmVmb3goKTtcbiAgICBjb25zdCBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDMgPSAoZWRpdG9yLCBjYXJldCwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFR5cGUgPSBldnQua2V5Q29kZSA9PT0gVksuQkFDS1NQQUNFID8gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcgOiAnZGVsZXRlQ29udGVudEZvcndhcmQnO1xuICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gICAgICBjb25zdCB1bm1vZGlmaWVkR3JhbnVsYXJpdHkgPSBpc0NvbGxhcHNlZCA/ICdjaGFyYWN0ZXInIDogJ3NlbGVjdGlvbic7XG4gICAgICBjb25zdCBnZXRNb2RpZmllZEdyYW51bGFyaXR5ID0gaXNXb3JkID0+IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGlzV29yZCA/ICd3b3JkJyA6ICdsaW5lJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGVjdGlvbic7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBleGVjdXRlV2l0aERlbGF5ZWRBY3Rpb24oW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQxLCBlZGl0b3IpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDYsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDYsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNywgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNywgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQ0LCBlZGl0b3IsIGNhcmV0LCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNCwgZWRpdG9yLCBjYXJldCwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkYSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkYSwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSwgZWRpdG9yLCBmYWxzZSwgdW5tb2RpZmllZEdyYW51bGFyaXR5KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSwgZWRpdG9yLCB0cnVlLCB1bm1vZGlmaWVkR3JhbnVsYXJpdHkpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmlzTWFjT1NPcmlPUyA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgICBhbHRLZXk6IHRydWUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUsIGVkaXRvciwgZmFsc2UsIGdldE1vZGlmaWVkR3JhbnVsYXJpdHkodHJ1ZSkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgICBhbHRLZXk6IHRydWUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUsIGVkaXRvciwgdHJ1ZSwgZ2V0TW9kaWZpZWRHcmFudWxhcml0eSh0cnVlKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICAgIG1ldGFLZXk6IHRydWUsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUsIGVkaXRvciwgZmFsc2UsIGdldE1vZGlmaWVkR3JhbnVsYXJpdHkoZmFsc2UpKVxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgICBjdHJsS2V5OiB0cnVlLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlLCBlZGl0b3IsIGZhbHNlLCBnZXRNb2RpZmllZEdyYW51bGFyaXR5KHRydWUpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSwgZWRpdG9yLCB0cnVlLCBnZXRNb2RpZmllZEdyYW51bGFyaXR5KHRydWUpKVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkNSwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQyLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQyLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDgsIGVkaXRvciwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24oYmFja3NwYWNlRGVsZXRlJDgsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOSwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkRFTEVURSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihiYWNrc3BhY2VEZWxldGUkOSwgZWRpdG9yLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQzLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGJhY2tzcGFjZURlbGV0ZSQzLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCkuZmlsdGVyKF8gPT4gZWRpdG9yLnNlbGVjdGlvbi5pc0VkaXRhYmxlKCkpLmVhY2goYXBwbHlBY3Rpb24gPT4ge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgYmVmb3JlSW5wdXQgPSBmaXJlQmVmb3JlSW5wdXRFdmVudChlZGl0b3IsIGlucHV0VHlwZSk7XG4gICAgICAgIGlmICghYmVmb3JlSW5wdXQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBhcHBseUFjdGlvbigpO1xuICAgICAgICAgIGZpcmVJbnB1dEV2ZW50KGVkaXRvciwgaW5wdXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlS2V5dXBPdmVycmlkZSA9IChlZGl0b3IsIGV2dCwgaXNCYWNrc3BhY2VLZXlkb3duKSA9PiBleGVjdXRlKFtcbiAgICAgIHtcbiAgICAgICAga2V5Q29kZTogVksuQkFDS1NQQUNFLFxuICAgICAgICBhY3Rpb246IGFjdGlvbihwYWRkRW1wdHlFbGVtZW50LCBlZGl0b3IpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXlDb2RlOiBWSy5ERUxFVEUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uKHBhZGRFbXB0eUVsZW1lbnQsIGVkaXRvcilcbiAgICAgIH0sXG4gICAgICAuLi5pc01hY09TT3JpT1MgPyBbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5CQUNLU1BBQ0UsXG4gICAgICAgICAgYWx0S2V5OiB0cnVlLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHJlZnJlc2hDYXJldCwgZWRpdG9yKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGFsdEtleTogdHJ1ZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihyZWZyZXNoQ2FyZXQsIGVkaXRvcilcbiAgICAgICAgfSxcbiAgICAgICAgLi4uaXNCYWNrc3BhY2VLZXlkb3duID8gW3tcbiAgICAgICAgICAgIGtleUNvZGU6IGlzRmlyZWZveCA/IDIyNCA6IDkxLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24ocmVmcmVzaENhcmV0LCBlZGl0b3IpXG4gICAgICAgICAgfV0gOiBbXVxuICAgICAgXSA6IFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkJBQ0tTUEFDRSxcbiAgICAgICAgICBjdHJsS2V5OiB0cnVlLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHJlZnJlc2hDYXJldCwgZWRpdG9yKVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuREVMRVRFLFxuICAgICAgICAgIGN0cmxLZXk6IHRydWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24ocmVmcmVzaENhcmV0LCBlZGl0b3IpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdLCBldnQpO1xuICAgIGNvbnN0IHNldHVwJGkgPSAoZWRpdG9yLCBjYXJldCkgPT4ge1xuICAgICAgbGV0IGlzQmFja3NwYWNlS2V5ZG93biA9IGZhbHNlO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaXNCYWNrc3BhY2VLZXlkb3duID0gZXZ0LmtleUNvZGUgPT09IFZLLkJBQ0tTUEFDRTtcbiAgICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBleGVjdXRlS2V5ZG93bk92ZXJyaWRlJDMoZWRpdG9yLCBjYXJldCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBleGVjdXRlS2V5dXBPdmVycmlkZShlZGl0b3IsIGV2dCwgaXNCYWNrc3BhY2VLZXlkb3duKTtcbiAgICAgICAgfVxuICAgICAgICBpc0JhY2tzcGFjZUtleWRvd24gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaXJzdE5vbldoaXRlU3BhY2VOb2RlU2libGluZyA9IG5vZGUgPT4ge1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpIHx8IGlzVGV4dCRhKG5vZGUpICYmIG5vZGUuZGF0YSAmJiAvW1xcclxcblxcc10vLnRlc3Qobm9kZS5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlVG9DYXJldFBvc2l0aW9uID0gKGVkaXRvciwgcm9vdCkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IG1vdmVDYXJldEJlZm9yZU9uRW50ZXJFbGVtZW50c01hcCA9IGVkaXRvci5zY2hlbWEuZ2V0TW92ZUNhcmV0QmVmb3JlT25FbnRlckVsZW1lbnRzKCk7XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKC9eKExJfERUfEREKSQvLnRlc3Qocm9vdC5ub2RlTmFtZSkpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGZpcnN0Tm9uV2hpdGVTcGFjZU5vZGVTaWJsaW5nKHJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChmaXJzdENoaWxkICYmIC9eKFVMfE9MfERMKSQvLnRlc3QoZmlyc3RDaGlsZC5ub2RlTmFtZSkpIHtcbiAgICAgICAgICByb290Lmluc2VydEJlZm9yZShkb20uZG9jLmNyZWF0ZVRleHROb2RlKG5ic3ApLCByb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICByb290Lm5vcm1hbGl6ZSgpO1xuICAgICAgaWYgKHJvb3QuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKHJvb3QsIHJvb3QpO1xuICAgICAgICBsZXQgbGFzdE5vZGUgPSByb290O1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIuY3VycmVudCgpKSB7XG4gICAgICAgICAgaWYgKGlzVGV4dCRhKG5vZGUpKSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kKG5vZGUsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb3ZlQ2FyZXRCZWZvcmVPbkVudGVyRWxlbWVudHNNYXBbbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgcm5nLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGxhc3ROb2RlLCAwKTtcbiAgICAgICAgICBybmcuc2V0RW5kKGxhc3ROb2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQnIkNihyb290KSkge1xuICAgICAgICAgIGlmIChyb290Lm5leHRTaWJsaW5nICYmIGRvbS5pc0Jsb2NrKHJvb3QubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRCZWZvcmUocm9vdCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kQmVmb3JlKHJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybmcuc2V0U3RhcnRBZnRlcihyb290KTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHJvb3QsIDApO1xuICAgICAgICAgIHJuZy5zZXRFbmQocm9vdCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICBzY3JvbGxSYW5nZUludG9WaWV3KGVkaXRvciwgcm5nKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVkaXRhYmxlUm9vdCA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgbGV0IGVkaXRhYmxlUm9vdDtcbiAgICAgIGxldCBwYXJlbnQgPSBub2RlO1xuICAgICAgd2hpbGUgKHBhcmVudCAhPT0gcm9vdCAmJiBwYXJlbnQgJiYgZG9tLmdldENvbnRlbnRFZGl0YWJsZShwYXJlbnQpICE9PSAnZmFsc2UnKSB7XG4gICAgICAgIGlmIChkb20uZ2V0Q29udGVudEVkaXRhYmxlKHBhcmVudCkgPT09ICd0cnVlJykge1xuICAgICAgICAgIGVkaXRhYmxlUm9vdCA9IHBhcmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQgIT09IHJvb3QgPyBlZGl0YWJsZVJvb3QgOiByb290O1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2skMSA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldFN0YXJ0KHRydWUpLCBlZGl0b3IuZG9tLmlzQmxvY2spKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBhcmVudEJsb2NrTmFtZSA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gZ2V0UGFyZW50QmxvY2skMShlZGl0b3IpLmZvbGQoY29uc3RhbnQoJycpLCBwYXJlbnRCbG9jayA9PiB7XG4gICAgICAgIHJldHVybiBwYXJlbnRCbG9jay5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0xpc3RJdGVtUGFyZW50QmxvY2sgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIGdldFBhcmVudEJsb2NrJDEoZWRpdG9yKS5maWx0ZXIoZWxtID0+IHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdEl0ZW0kMShTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pKTtcbiAgICAgIH0pLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3QgZW1wdHlCbG9jayA9IGVsbSA9PiB7XG4gICAgICBlbG0uaW5uZXJIVE1MID0gJzxiciBkYXRhLW1jZS1ib2d1cz1cIjFcIj4nO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlBdHRyaWJ1dGVzID0gKGVkaXRvciwgbm9kZSwgZm9yY2VkUm9vdEJsb2NrQXR0cnMpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBPcHRpb25hbC5mcm9tKGZvcmNlZFJvb3RCbG9ja0F0dHJzLnN0eWxlKS5tYXAoZG9tLnBhcnNlU3R5bGUpLmVhY2goYXR0clN0eWxlcyA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZXMgPSBnZXRBbGxSYXcoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSkpO1xuICAgICAgICBjb25zdCBuZXdTdHlsZXMgPSB7XG4gICAgICAgICAgLi4uY3VycmVudFN0eWxlcyxcbiAgICAgICAgICAuLi5hdHRyU3R5bGVzXG4gICAgICAgIH07XG4gICAgICAgIGRvbS5zZXRTdHlsZXMobm9kZSwgbmV3U3R5bGVzKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXR0ckNsYXNzZXNPcHQgPSBPcHRpb25hbC5mcm9tKGZvcmNlZFJvb3RCbG9ja0F0dHJzLmNsYXNzKS5tYXAoYXR0ckNsYXNzZXMgPT4gYXR0ckNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG4gICAgICBjb25zdCBjdXJyZW50Q2xhc3Nlc09wdCA9IE9wdGlvbmFsLmZyb20obm9kZS5jbGFzc05hbWUpLm1hcChjdXJyZW50Q2xhc3NlcyA9PiBmaWx0ZXIkNShjdXJyZW50Q2xhc3Nlcy5zcGxpdCgvXFxzKy8pLCBjbGF6eiA9PiBjbGF6eiAhPT0gJycpKTtcbiAgICAgIGxpZnQyKGF0dHJDbGFzc2VzT3B0LCBjdXJyZW50Q2xhc3Nlc09wdCwgKGF0dHJDbGFzc2VzLCBjdXJyZW50Q2xhc3NlcykgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZENsYXNzZXMgPSBmaWx0ZXIkNShjdXJyZW50Q2xhc3NlcywgY2xhenogPT4gIWNvbnRhaW5zJDIoYXR0ckNsYXNzZXMsIGNsYXp6KSk7XG4gICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBbXG4gICAgICAgICAgLi4uYXR0ckNsYXNzZXMsXG4gICAgICAgICAgLi4uZmlsdGVyZWRDbGFzc2VzXG4gICAgICAgIF07XG4gICAgICAgIGRvbS5zZXRBdHRyaWIobm9kZSwgJ2NsYXNzJywgbmV3Q2xhc3Nlcy5qb2luKCcgJykpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBhcHBsaWVkQXR0cnMgPSBbXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdjbGFzcydcbiAgICAgIF07XG4gICAgICBjb25zdCByZW1haW5pbmdBdHRycyA9IGZpbHRlciQ0KGZvcmNlZFJvb3RCbG9ja0F0dHJzLCAoXywgYXR0cnMpID0+ICFjb250YWlucyQyKGFwcGxpZWRBdHRycywgYXR0cnMpKTtcbiAgICAgIGRvbS5zZXRBdHRyaWJzKG5vZGUsIHJlbWFpbmluZ0F0dHJzKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEZvcmNlZEJsb2NrQXR0cnMgPSAoZWRpdG9yLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCBmb3JjZWRSb290QmxvY2tOYW1lID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBpZiAoZm9yY2VkUm9vdEJsb2NrTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjb25zdCBmb3JjZWRSb290QmxvY2tBdHRycyA9IGdldEZvcmNlZFJvb3RCbG9ja0F0dHJzKGVkaXRvcik7XG4gICAgICAgIGFwcGx5QXR0cmlidXRlcyhlZGl0b3IsIG5vZGUsIGZvcmNlZFJvb3RCbG9ja0F0dHJzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZU5ld0Jsb2NrID0gKGVkaXRvciwgY29udGFpbmVyLCBwYXJlbnRCbG9jaywgZWRpdGFibGVSb290LCBrZWVwU3R5bGVzID0gdHJ1ZSwgbmFtZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGVkaXRvci5zY2hlbWE7XG4gICAgICBjb25zdCBuZXdCbG9ja05hbWUgPSBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKTtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrTmFtZSA9IHBhcmVudEJsb2NrID8gcGFyZW50QmxvY2subm9kZU5hbWUudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXI7XG4gICAgICBjb25zdCB0ZXh0SW5saW5lRWxlbWVudHMgPSBzY2hlbWEuZ2V0VGV4dElubGluZUVsZW1lbnRzKCk7XG4gICAgICBsZXQgYmxvY2s7XG4gICAgICBpZiAobmFtZSB8fCBwYXJlbnRCbG9ja05hbWUgPT09ICdUQUJMRScgfHwgcGFyZW50QmxvY2tOYW1lID09PSAnSFInKSB7XG4gICAgICAgIGJsb2NrID0gZG9tLmNyZWF0ZShuYW1lIHx8IG5ld0Jsb2NrTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9jayA9IHBhcmVudEJsb2NrLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICB9XG4gICAgICBsZXQgY2FyZXROb2RlID0gYmxvY2s7XG4gICAgICBpZiAoIWtlZXBTdHlsZXMpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYihibG9jaywgJ3N0eWxlJywgbnVsbCk7XG4gICAgICAgIGRvbS5zZXRBdHRyaWIoYmxvY2ssICdjbGFzcycsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh0ZXh0SW5saW5lRWxlbWVudHNbbm9kZS5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChpc0NhcmV0Tm9kZShub2RlKSB8fCBpc0Jvb2ttYXJrTm9kZSQxKG5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkTm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIoY2xvbmVkTm9kZSwgJ2lkJywgJycpO1xuICAgICAgICAgICAgaWYgKGJsb2NrLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKGJsb2NrLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjbG9uZWROb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhcmV0Tm9kZSA9IGNsb25lZE5vZGU7XG4gICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGNsb25lZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpICYmIG5vZGUgIT09IGVkaXRhYmxlUm9vdCk7XG4gICAgICB9XG4gICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgYmxvY2spO1xuICAgICAgZW1wdHlCbG9jayhjYXJldE5vZGUpO1xuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXREZXRhaWxzUm9vdCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5kb20uZ2V0UGFyZW50KGVsZW1lbnQsIGlzRGV0YWlscyk7XG4gICAgY29uc3QgaXNBdERldGFpbHNFZGdlID0gKHJvb3QsIGVsZW1lbnQsIGlzVGV4dEJsb2NrKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290ICYmIGlzTnVsbChub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICghcGFyZW50IHx8ICFpc1RleHRCbG9jayhwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRGV0YWlscyhwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBpc0xhc3RFbXB0eUJsb2NrSW5EZXRhaWxzID0gKGVkaXRvciwgc2hpZnRLZXksIGVsZW1lbnQpID0+ICFzaGlmdEtleSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpICYmIGVkaXRvci5kb20uaXNFbXB0eShlbGVtZW50KSAmJiBpc0F0RGV0YWlsc0VkZ2UoZWRpdG9yLmdldEJvZHkoKSwgZWxlbWVudCwgZWwgPT4gaGFzJDIoZWRpdG9yLnNjaGVtYS5nZXRUZXh0QmxvY2tFbGVtZW50cygpLCBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgY29uc3QgaW5zZXJ0TmV3TGluZSA9IChlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrLCBwYXJlbnRCbG9jaykgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCBuZXdCbG9jayA9IGNyZWF0ZU5ld0Jsb2NrKGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpKTtcbiAgICAgIGNvbnN0IHJvb3QgPSBnZXREZXRhaWxzUm9vdChlZGl0b3IsIHBhcmVudEJsb2NrKTtcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3IuZG9tLmluc2VydEFmdGVyKG5ld0Jsb2NrLCByb290KTtcbiAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICBpZiAoKChfYyA9IChfYiA9IChfYSA9IHBhcmVudEJsb2NrLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZE5vZGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSA+IDEpIHtcbiAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUocGFyZW50QmxvY2spO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoYXNGaXJzdENoaWxkID0gKGVsbSwgbmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGVsbS5maXJzdENoaWxkICYmIGVsbS5maXJzdENoaWxkLm5vZGVOYW1lID09PSBuYW1lO1xuICAgIH07XG4gICAgY29uc3QgaXNGaXJzdENoaWxkID0gZWxtID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoKF9hID0gZWxtLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdENoaWxkKSA9PT0gZWxtO1xuICAgIH07XG4gICAgY29uc3QgaGFzUGFyZW50ID0gKGVsbSwgcGFyZW50TmFtZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGVsbSA9PT0gbnVsbCB8fCBlbG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsbS5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuIGlzTm9uTnVsbGFibGUocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gcGFyZW50TmFtZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTGlzdEJsb2NrID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKGVsbSkgJiYgL14oT0x8VUx8TEkpJC8udGVzdChlbG0ubm9kZU5hbWUpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0SXRlbSA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShlbG0pICYmIC9eKExJfERUfEREKSQvLnRlc3QoZWxtLm5vZGVOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzTmVzdGVkTGlzdCA9IGVsbSA9PiB7XG4gICAgICByZXR1cm4gaXNMaXN0QmxvY2soZWxtKSAmJiBpc0xpc3RCbG9jayhlbG0ucGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRDb250YWluZXJCbG9jayA9IGNvbnRhaW5lckJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrUGFyZW50ID0gY29udGFpbmVyQmxvY2sucGFyZW50Tm9kZTtcbiAgICAgIHJldHVybiBpc0xpc3RJdGVtKGNvbnRhaW5lckJsb2NrUGFyZW50KSA/IGNvbnRhaW5lckJsb2NrUGFyZW50IDogY29udGFpbmVyQmxvY2s7XG4gICAgfTtcbiAgICBjb25zdCBpc0ZpcnN0T3JMYXN0TGkgPSAoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrLCBmaXJzdCkgPT4ge1xuICAgICAgbGV0IG5vZGUgPSBjb250YWluZXJCbG9ja1tmaXJzdCA/ICdmaXJzdENoaWxkJyA6ICdsYXN0Q2hpbGQnXTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2ZpcnN0ID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlID09PSBwYXJlbnRCbG9jaztcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydCQ0ID0gKGVkaXRvciwgY3JlYXRlTmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgbmV3QmxvY2tOYW1lKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhcmVudCA9IGNvbnRhaW5lckJsb2NrLnBhcmVudE5vZGU7XG4gICAgICBpZiAoY29udGFpbmVyQmxvY2sgPT09IGVkaXRvci5nZXRCb2R5KCkgfHwgIWNvbnRhaW5lclBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNOZXN0ZWRMaXN0KGNvbnRhaW5lckJsb2NrKSkge1xuICAgICAgICBuZXdCbG9ja05hbWUgPSAnTEknO1xuICAgICAgfVxuICAgICAgbGV0IG5ld0Jsb2NrID0gY3JlYXRlTmV3QmxvY2sobmV3QmxvY2tOYW1lKTtcbiAgICAgIGlmIChpc0ZpcnN0T3JMYXN0TGkoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrLCB0cnVlKSAmJiBpc0ZpcnN0T3JMYXN0TGkoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrLCBmYWxzZSkpIHtcbiAgICAgICAgaWYgKGhhc1BhcmVudChjb250YWluZXJCbG9jaywgJ0xJJykpIHtcbiAgICAgICAgICBjb25zdCBjb250YWluZXJCbG9ja1BhcmVudCA9IGdldENvbnRhaW5lckJsb2NrKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrUGFyZW50KTtcbiAgICAgICAgICBpZiAoaXNGaXJzdENoaWxkKGNvbnRhaW5lckJsb2NrKSkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZShjb250YWluZXJCbG9ja1BhcmVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmUoY29udGFpbmVyQmxvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20ucmVwbGFjZShuZXdCbG9jaywgY29udGFpbmVyQmxvY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3RPckxhc3RMaShjb250YWluZXJCbG9jaywgcGFyZW50QmxvY2ssIHRydWUpKSB7XG4gICAgICAgIGlmIChoYXNQYXJlbnQoY29udGFpbmVyQmxvY2ssICdMSScpKSB7XG4gICAgICAgICAgZG9tLmluc2VydEFmdGVyKG5ld0Jsb2NrLCBnZXRDb250YWluZXJCbG9jayhjb250YWluZXJCbG9jaykpO1xuICAgICAgICAgIG5ld0Jsb2NrLmFwcGVuZENoaWxkKGRvbS5kb2MuY3JlYXRlVGV4dE5vZGUoJyAnKSk7XG4gICAgICAgICAgbmV3QmxvY2suYXBwZW5kQ2hpbGQoY29udGFpbmVyQmxvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lclBhcmVudC5pbnNlcnRCZWZvcmUobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdE9yTGFzdExpKGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgZmFsc2UpKSB7XG4gICAgICAgIGRvbS5pbnNlcnRBZnRlcihuZXdCbG9jaywgZ2V0Q29udGFpbmVyQmxvY2soY29udGFpbmVyQmxvY2spKTtcbiAgICAgICAgZG9tLnJlbW92ZShwYXJlbnRCbG9jayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXJCbG9jayA9IGdldENvbnRhaW5lckJsb2NrKGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgY29uc3QgdG1wUm5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgdG1wUm5nLnNldFN0YXJ0QWZ0ZXIocGFyZW50QmxvY2spO1xuICAgICAgICB0bXBSbmcuc2V0RW5kQWZ0ZXIoY29udGFpbmVyQmxvY2spO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRtcFJuZy5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgaWYgKG5ld0Jsb2NrTmFtZSA9PT0gJ0xJJyAmJiBoYXNGaXJzdENoaWxkKGZyYWdtZW50LCAnTEknKSkge1xuICAgICAgICAgIG5ld0Jsb2NrID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoZnJhZ21lbnQsIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoZnJhZ21lbnQsIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIGNvbnRhaW5lckJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBkb20ucmVtb3ZlKHBhcmVudEJsb2NrKTtcbiAgICAgIH1cbiAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaW1ad3NwID0gZnJhZ21lbnQgPT4ge1xuICAgICAgZWFjaCRlKGRlc2NlbmRhbnRzJDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZnJhZ21lbnQpLCBpc1RleHQkYiksIHRleHQgPT4ge1xuICAgICAgICBjb25zdCByYXdOb2RlID0gdGV4dC5kb207XG4gICAgICAgIHJhd05vZGUubm9kZVZhbHVlID0gdHJpbSQxKHJhd05vZGUuZGF0YSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzV2l0aGluTm9uRWRpdGFibGVMaXN0ID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50TGlzdCA9IGVkaXRvci5kb20uZ2V0UGFyZW50KG5vZGUsICdvbCx1bCxkbCcpO1xuICAgICAgcmV0dXJuIHBhcmVudExpc3QgIT09IG51bGwgJiYgZWRpdG9yLmRvbS5nZXRDb250ZW50RWRpdGFibGVQYXJlbnQocGFyZW50TGlzdCkgPT09ICdmYWxzZSc7XG4gICAgfTtcbiAgICBjb25zdCBpc0VtcHR5QW5jaG9yID0gKGRvbSwgZWxtKSA9PiB7XG4gICAgICByZXR1cm4gZWxtICYmIGVsbS5ub2RlTmFtZSA9PT0gJ0EnICYmIGRvbS5pc0VtcHR5KGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBjb250YWluZXJBbmRTaWJsaW5nTmFtZSA9IChjb250YWluZXIsIG5vZGVOYW1lKSA9PiB7XG4gICAgICByZXR1cm4gY29udGFpbmVyLm5vZGVOYW1lID09PSBub2RlTmFtZSB8fCBjb250YWluZXIucHJldmlvdXNTaWJsaW5nICYmIGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcubm9kZU5hbWUgPT09IG5vZGVOYW1lO1xuICAgIH07XG4gICAgY29uc3QgY2FuU3BsaXRCbG9jayA9IChkb20sIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKG5vZGUpICYmIGRvbS5pc0Jsb2NrKG5vZGUpICYmICEvXihURHxUSHxDQVBUSU9OfEZPUk0pJC8udGVzdChub2RlLm5vZGVOYW1lKSAmJiAhL14oZml4ZWR8YWJzb2x1dGUpL2kudGVzdChub2RlLnN0eWxlLnBvc2l0aW9uKSAmJiBkb20uaXNFZGl0YWJsZShub2RlLnBhcmVudE5vZGUpICYmIGRvbS5nZXRDb250ZW50RWRpdGFibGUobm9kZSkgIT09ICdmYWxzZSc7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSW5saW5lRWxlbWVudHNPbkxlZnRTaWRlT2ZCbG9jayA9IChkb20sIG5vbkVtcHR5RWxlbWVudHNNYXAsIGJsb2NrKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBmaXJzdENoaWxkcyA9IFtdO1xuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgY3VycmVudE5vZGUgPSBibG9jaztcbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGRvbS5pc0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFbGVtZW50JDYoY3VycmVudE5vZGUpICYmICFub25FbXB0eUVsZW1lbnRzTWFwW2N1cnJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZHMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpID0gZmlyc3RDaGlsZHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGZpcnN0Q2hpbGRzW2ldO1xuICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmhhc0NoaWxkTm9kZXMoKSB8fCBjdXJyZW50Tm9kZS5maXJzdENoaWxkID09PSBjdXJyZW50Tm9kZS5sYXN0Q2hpbGQgJiYgKChfYSA9IGN1cnJlbnROb2RlLmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVmFsdWUpID09PSAnJykge1xuICAgICAgICAgIGRvbS5yZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0VtcHR5QW5jaG9yKGRvbSwgY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZVp3c3BPZmZzZXQgPSAoc3RhcnQsIGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoIWlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA9PT0gMSAmJiBjb250YWluZXIuZGF0YS5jaGFyQXQob2Zmc2V0IC0gMSkgPT09IFpXU1AkMSA/IDAgOiBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09PSBjb250YWluZXIuZGF0YS5sZW5ndGggLSAxICYmIGNvbnRhaW5lci5kYXRhLmNoYXJBdChvZmZzZXQpID09PSBaV1NQJDEgPyBjb250YWluZXIuZGF0YS5sZW5ndGggOiBvZmZzZXQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbmNsdWRlWndzcEluUmFuZ2UgPSBybmcgPT4ge1xuICAgICAgY29uc3QgbmV3Um5nID0gcm5nLmNsb25lUmFuZ2UoKTtcbiAgICAgIG5ld1JuZy5zZXRTdGFydChybmcuc3RhcnRDb250YWluZXIsIG5vcm1hbGl6ZVp3c3BPZmZzZXQodHJ1ZSwgcm5nLnN0YXJ0Q29udGFpbmVyLCBybmcuc3RhcnRPZmZzZXQpKTtcbiAgICAgIG5ld1JuZy5zZXRFbmQocm5nLmVuZENvbnRhaW5lciwgbm9ybWFsaXplWndzcE9mZnNldChmYWxzZSwgcm5nLmVuZENvbnRhaW5lciwgcm5nLmVuZE9mZnNldCkpO1xuICAgICAgcmV0dXJuIG5ld1JuZztcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1MZWFkaW5nTGluZUJyZWFrcyA9IG5vZGUgPT4ge1xuICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGlzVGV4dCRhKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIGN1cnJlbnROb2RlLmRhdGEgPSBjdXJyZW50Tm9kZS5kYXRhLnJlcGxhY2UoL15bXFxyXFxuXSsvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgfSB3aGlsZSAoY3VycmVudE5vZGUpO1xuICAgIH07XG4gICAgY29uc3Qgd3JhcFNlbGZBbmRTaWJsaW5nc0luRGVmYXVsdEJsb2NrID0gKGVkaXRvciwgbmV3QmxvY2tOYW1lLCBybmcsIGNvbnRhaW5lciwgb2Zmc2V0KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGVkaXRhYmxlUm9vdCA9IChfYSA9IGdldEVkaXRhYmxlUm9vdChkb20sIGNvbnRhaW5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvbS5nZXRSb290KCk7XG4gICAgICBsZXQgcGFyZW50QmxvY2sgPSBkb20uZ2V0UGFyZW50KGNvbnRhaW5lciwgZG9tLmlzQmxvY2spO1xuICAgICAgaWYgKCFwYXJlbnRCbG9jayB8fCAhY2FuU3BsaXRCbG9jayhkb20sIHBhcmVudEJsb2NrKSkge1xuICAgICAgICBwYXJlbnRCbG9jayA9IHBhcmVudEJsb2NrIHx8IGVkaXRhYmxlUm9vdDtcbiAgICAgICAgaWYgKCFwYXJlbnRCbG9jay5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjb25zdCBuZXdCbG9jayA9IGRvbS5jcmVhdGUobmV3QmxvY2tOYW1lKTtcbiAgICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgICAgIHBhcmVudEJsb2NrLmFwcGVuZENoaWxkKG5ld0Jsb2NrKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobmV3QmxvY2ssIDApO1xuICAgICAgICAgIHJuZy5zZXRFbmQobmV3QmxvY2ssIDApO1xuICAgICAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICE9PSBwYXJlbnRCbG9jaykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0Tm9kZTtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIWRvbS5pc0Jsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgc3RhcnROb2RlID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnROb2RlTmFtZSA9IChfYiA9IHN0YXJ0Tm9kZSA9PT0gbnVsbCB8fCBzdGFydE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXJ0Tm9kZS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZU5hbWU7XG4gICAgICAgIGlmIChzdGFydE5vZGUgJiYgc3RhcnROb2RlTmFtZSAmJiBlZGl0b3Iuc2NoZW1hLmlzVmFsaWRDaGlsZChzdGFydE5vZGVOYW1lLCBuZXdCbG9ja05hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBjb25zdCBzdGFydE5vZGVQYXJlbnQgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBjb25zdCBuZXdCbG9jayA9IGRvbS5jcmVhdGUobmV3QmxvY2tOYW1lKTtcbiAgICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgICAgIHN0YXJ0Tm9kZVBhcmVudC5pbnNlcnRCZWZvcmUobmV3QmxvY2ssIHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICB3aGlsZSAobm9kZSAmJiAhZG9tLmlzQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgbmV3QmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgICBybmcuc2V0RW5kKGNvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGFkZEJyVG9CbG9ja0lmTmVlZGVkID0gKGRvbSwgYmxvY2spID0+IHtcbiAgICAgIGJsb2NrLm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgaXNFbGVtZW50JDYobGFzdENoaWxkKSAmJiAvXihsZWZ0fHJpZ2h0KSQvZ2kudGVzdChkb20uZ2V0U3R5bGUobGFzdENoaWxkLCAnZmxvYXQnLCB0cnVlKSkpIHtcbiAgICAgICAgZG9tLmFkZChibG9jaywgJ2JyJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRFbmRDb250YWluZXIgPSAoZWRpdG9yLCBjb250YWluZXIpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gc2hvdWxkRW5kQ29udGFpbmVyT25FbXB0eUJsb2NrKGVkaXRvcik7XG4gICAgICBpZiAoaXNOdWxsYWJsZShjb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcob3B0aW9uVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb250YWlucyQyKFRvb2xzLmV4cGxvZGUob3B0aW9uVmFsdWUpLCBjb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMyA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgbGV0IGNvbnRhaW5lcjtcbiAgICAgIGxldCBvZmZzZXQ7XG4gICAgICBsZXQgcGFyZW50QmxvY2tOYW1lO1xuICAgICAgbGV0IGNvbnRhaW5lckJsb2NrO1xuICAgICAgbGV0IGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yLnNjaGVtYSwgbm9uRW1wdHlFbGVtZW50c01hcCA9IHNjaGVtYS5nZXROb25FbXB0eUVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3QgbmV3QmxvY2tOYW1lID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCBzdGFydCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkJDEoc3RhcnQsIHJuZy5zdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBpc0NlZiA9IGNoaWxkLmV4aXN0cyhlbGVtZW50ID0+IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgIWlzRWRpdGFibGUkMyhlbGVtZW50KSk7XG4gICAgICBjb25zdCBjb2xsYXBzZWRBbmRDZWYgPSBybmcuY29sbGFwc2VkICYmIGlzQ2VmO1xuICAgICAgY29uc3QgY3JlYXRlTmV3QmxvY2skMSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlTmV3QmxvY2soZWRpdG9yLCBjb250YWluZXIsIHBhcmVudEJsb2NrLCBlZGl0YWJsZVJvb3QsIHNob3VsZEtlZXBTdHlsZXMoZWRpdG9yKSwgbmFtZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNDYXJldEF0U3RhcnRPckVuZE9mQmxvY2sgPSBzdGFydCA9PiB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRPZmZzZXQgPSBub3JtYWxpemVad3NwT2Zmc2V0KHN0YXJ0LCBjb250YWluZXIsIG9mZnNldCk7XG4gICAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpICYmIChzdGFydCA/IG5vcm1hbGl6ZWRPZmZzZXQgPiAwIDogbm9ybWFsaXplZE9mZnNldCA8IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5wYXJlbnROb2RlID09PSBwYXJlbnRCbG9jayAmJiBpc0FmdGVyTGFzdE5vZGVJbkNvbnRhaW5lciAmJiAhc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgJiYgaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIgPT09IHBhcmVudEJsb2NrLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyQW5kU2libGluZ05hbWUoY29udGFpbmVyLCAnVEFCTEUnKSB8fCBjb250YWluZXJBbmRTaWJsaW5nTmFtZShjb250YWluZXIsICdIUicpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyICYmICFzdGFydCB8fCAhaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgJiYgc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoY29udGFpbmVyLCBwYXJlbnRCbG9jayk7XG4gICAgICAgIGlmIChpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ICYmIG5vcm1hbGl6ZWRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHdhbGtlci5wcmV2KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhcnQgJiYgbm9ybWFsaXplZE9mZnNldCA9PT0gY29udGFpbmVyLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSB3YWxrZXIuY3VycmVudCgpKSB7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCQ2KG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW1jZS1ib2d1cycpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChub25FbXB0eUVsZW1lbnRzTWFwW25hbWVdICYmIG5hbWUgIT09ICdicicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGV4dCRhKG5vZGUpICYmICFpc1doaXRlc3BhY2VUZXh0KG5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICB3YWxrZXIucHJldigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnNlcnROZXdCbG9ja0FmdGVyID0gKCkgPT4ge1xuICAgICAgICBsZXQgYmxvY2s7XG4gICAgICAgIGlmICgvXihIWzEtNl18UFJFfEZJR1VSRSkkLy50ZXN0KHBhcmVudEJsb2NrTmFtZSkgJiYgY29udGFpbmVyQmxvY2tOYW1lICE9PSAnSEdST1VQJykge1xuICAgICAgICAgIGJsb2NrID0gY3JlYXRlTmV3QmxvY2skMShuZXdCbG9ja05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb2NrID0gY3JlYXRlTmV3QmxvY2skMSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRFbmRDb250YWluZXIoZWRpdG9yLCBjb250YWluZXJCbG9jaykgJiYgY2FuU3BsaXRCbG9jayhkb20sIGNvbnRhaW5lckJsb2NrKSAmJiBkb20uaXNFbXB0eShwYXJlbnRCbG9jaywgdW5kZWZpbmVkLCB7IGluY2x1ZGVad3NwOiB0cnVlIH0pKSB7XG4gICAgICAgICAgYmxvY2sgPSBkb20uc3BsaXQoY29udGFpbmVyQmxvY2ssIHBhcmVudEJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoYmxvY2ssIHBhcmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlVG9DYXJldFBvc2l0aW9uKGVkaXRvciwgYmxvY2spO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICB9O1xuICAgICAgbm9ybWFsaXplJDIoZG9tLCBybmcpLmVhY2gobm9ybVJuZyA9PiB7XG4gICAgICAgIHJuZy5zZXRTdGFydChub3JtUm5nLnN0YXJ0Q29udGFpbmVyLCBub3JtUm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChub3JtUm5nLmVuZENvbnRhaW5lciwgbm9ybVJuZy5lbmRPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICBjb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBjb25zdCBzaGlmdEtleSA9ICEhKGV2dCAmJiBldnQuc2hpZnRLZXkpO1xuICAgICAgY29uc3QgY3RybEtleSA9ICEhKGV2dCAmJiBldnQuY3RybEtleSk7XG4gICAgICBpZiAoaXNFbGVtZW50JDYoY29udGFpbmVyKSAmJiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpICYmICFjb2xsYXBzZWRBbmRDZWYpIHtcbiAgICAgICAgaXNBZnRlckxhc3ROb2RlSW5Db250YWluZXIgPSBvZmZzZXQgPiBjb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY2hpbGROb2Rlc1tNYXRoLm1pbihvZmZzZXQsIGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpXSB8fCBjb250YWluZXI7XG4gICAgICAgIGlmIChpc0FmdGVyTGFzdE5vZGVJbkNvbnRhaW5lciAmJiBpc1RleHQkYShjb250YWluZXIpKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gY29udGFpbmVyLmRhdGEubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRhYmxlUm9vdCA9IGdldEVkaXRhYmxlUm9vdChkb20sIGNvbnRhaW5lcik7XG4gICAgICBpZiAoIWVkaXRhYmxlUm9vdCB8fCBpc1dpdGhpbk5vbkVkaXRhYmxlTGlzdChlZGl0b3IsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzaGlmdEtleSkge1xuICAgICAgICBjb250YWluZXIgPSB3cmFwU2VsZkFuZFNpYmxpbmdzSW5EZWZhdWx0QmxvY2soZWRpdG9yLCBuZXdCbG9ja05hbWUsIHJuZywgY29udGFpbmVyLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgbGV0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChjb250YWluZXIsIGRvbS5pc0Jsb2NrKSB8fCBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29udGFpbmVyQmxvY2sgPSBpc05vbk51bGxhYmxlKHBhcmVudEJsb2NrID09PSBudWxsIHx8IHBhcmVudEJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRCbG9jay5wYXJlbnROb2RlKSA/IGRvbS5nZXRQYXJlbnQocGFyZW50QmxvY2sucGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIDogbnVsbDtcbiAgICAgIHBhcmVudEJsb2NrTmFtZSA9IHBhcmVudEJsb2NrID8gcGFyZW50QmxvY2subm9kZU5hbWUudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgICAgY29uc3QgY29udGFpbmVyQmxvY2tOYW1lID0gY29udGFpbmVyQmxvY2sgPyBjb250YWluZXJCbG9jay5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgICBpZiAoY29udGFpbmVyQmxvY2tOYW1lID09PSAnTEknICYmICFjdHJsS2V5KSB7XG4gICAgICAgIGNvbnN0IGxpQmxvY2sgPSBjb250YWluZXJCbG9jaztcbiAgICAgICAgcGFyZW50QmxvY2sgPSBsaUJsb2NrO1xuICAgICAgICBjb250YWluZXJCbG9jayA9IGxpQmxvY2sucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50QmxvY2tOYW1lID0gY29udGFpbmVyQmxvY2tOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lckJsb2NrKSAmJiBpc0xhc3RFbXB0eUJsb2NrSW5EZXRhaWxzKGVkaXRvciwgc2hpZnRLZXksIHBhcmVudEJsb2NrKSkge1xuICAgICAgICByZXR1cm4gaW5zZXJ0TmV3TGluZShlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrJDEsIHBhcmVudEJsb2NrKTtcbiAgICAgIH1cbiAgICAgIGlmICgvXihMSXxEVHxERCkkLy50ZXN0KHBhcmVudEJsb2NrTmFtZSkgJiYgaXNFbGVtZW50JDYoY29udGFpbmVyQmxvY2spKSB7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBpbnNlcnQkNChlZGl0b3IsIGNyZWF0ZU5ld0Jsb2NrJDEsIGNvbnRhaW5lckJsb2NrLCBwYXJlbnRCbG9jaywgbmV3QmxvY2tOYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY29sbGFwc2VkQW5kQ2VmICYmIChwYXJlbnRCbG9jayA9PT0gZWRpdG9yLmdldEJvZHkoKSB8fCAhY2FuU3BsaXRCbG9jayhkb20sIHBhcmVudEJsb2NrKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50QmxvY2tQYXJlbnQgPSBwYXJlbnRCbG9jay5wYXJlbnROb2RlO1xuICAgICAgbGV0IG5ld0Jsb2NrO1xuICAgICAgaWYgKGNvbGxhcHNlZEFuZENlZikge1xuICAgICAgICBuZXdCbG9jayA9IGNyZWF0ZU5ld0Jsb2NrJDEobmV3QmxvY2tOYW1lKTtcbiAgICAgICAgY2hpbGQuZm9sZCgoKSA9PiB7XG4gICAgICAgICAgYXBwZW5kJDEoc3RhcnQsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5ld0Jsb2NrKSk7XG4gICAgICAgIH0sIGNoaWxkID0+IHtcbiAgICAgICAgICBiZWZvcmUkMyhjaGlsZCwgU3VnYXJFbGVtZW50LmZyb21Eb20obmV3QmxvY2spKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24obmV3QmxvY2ssIDApO1xuICAgICAgfSBlbHNlIGlmIChpc0NhcmV0Q29udGFpbmVyQmxvY2skMShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgbmV3QmxvY2sgPSBzaG93Q2FyZXRDb250YWluZXJCbG9jayhwYXJlbnRCbG9jayk7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBlbXB0eUJsb2NrKHBhcmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgICBtb3ZlVG9DYXJldFBvc2l0aW9uKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgfSBlbHNlIGlmIChpc0NhcmV0QXRTdGFydE9yRW5kT2ZCbG9jayhmYWxzZSkpIHtcbiAgICAgICAgbmV3QmxvY2sgPSBpbnNlcnROZXdCbG9ja0FmdGVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ2FyZXRBdFN0YXJ0T3JFbmRPZkJsb2NrKHRydWUpICYmIHBhcmVudEJsb2NrUGFyZW50KSB7XG4gICAgICAgIG5ld0Jsb2NrID0gcGFyZW50QmxvY2tQYXJlbnQuaW5zZXJ0QmVmb3JlKGNyZWF0ZU5ld0Jsb2NrJDEoKSwgcGFyZW50QmxvY2spO1xuICAgICAgICBjb25zdCBpc05lYXJDaGlsZHJlbiA9IGhhc0NoaWxkTm9kZXMoU3VnYXJFbGVtZW50LmZyb21Eb20ocm5nLnN0YXJ0Q29udGFpbmVyKSkgJiYgcm5nLmNvbGxhcHNlZDtcbiAgICAgICAgbW92ZVRvQ2FyZXRQb3NpdGlvbihlZGl0b3IsIGNvbnRhaW5lckFuZFNpYmxpbmdOYW1lKHBhcmVudEJsb2NrLCAnSFInKSB8fCBpc05lYXJDaGlsZHJlbiA/IG5ld0Jsb2NrIDogcGFyZW50QmxvY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG1wUm5nID0gaW5jbHVkZVp3c3BJblJhbmdlKHJuZykuY2xvbmVSYW5nZSgpO1xuICAgICAgICB0bXBSbmcuc2V0RW5kQWZ0ZXIocGFyZW50QmxvY2spO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRtcFJuZy5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgdHJpbVp3c3AoZnJhZ21lbnQpO1xuICAgICAgICB0cmltTGVhZGluZ0xpbmVCcmVha3MoZnJhZ21lbnQpO1xuICAgICAgICBuZXdCbG9jayA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGRvbS5pbnNlcnRBZnRlcihmcmFnbWVudCwgcGFyZW50QmxvY2spO1xuICAgICAgICB0cmltSW5saW5lRWxlbWVudHNPbkxlZnRTaWRlT2ZCbG9jayhkb20sIG5vbkVtcHR5RWxlbWVudHNNYXAsIG5ld0Jsb2NrKTtcbiAgICAgICAgYWRkQnJUb0Jsb2NrSWZOZWVkZWQoZG9tLCBwYXJlbnRCbG9jayk7XG4gICAgICAgIGlmIChkb20uaXNFbXB0eShwYXJlbnRCbG9jaykpIHtcbiAgICAgICAgICBlbXB0eUJsb2NrKHBhcmVudEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdCbG9jay5ub3JtYWxpemUoKTtcbiAgICAgICAgaWYgKGRvbS5pc0VtcHR5KG5ld0Jsb2NrKSkge1xuICAgICAgICAgIGRvbS5yZW1vdmUobmV3QmxvY2spO1xuICAgICAgICAgIGluc2VydE5ld0Jsb2NrQWZ0ZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRGb3JjZWRCbG9ja0F0dHJzKGVkaXRvciwgbmV3QmxvY2spO1xuICAgICAgICAgIG1vdmVUb0NhcmV0UG9zaXRpb24oZWRpdG9yLCBuZXdCbG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbS5zZXRBdHRyaWIobmV3QmxvY2ssICdpZCcsICcnKTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnTmV3QmxvY2snLCB7IG5ld0Jsb2NrIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmFrZUV2ZW50TmFtZSQxID0gJ2luc2VydFBhcmFncmFwaCc7XG4gICAgY29uc3QgYmxvY2ticmVhayA9IHtcbiAgICAgIGluc2VydDogaW5zZXJ0JDMsXG4gICAgICBmYWtlRXZlbnROYW1lOiBmYWtlRXZlbnROYW1lJDFcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzUmlnaHRTaWRlQ29udGVudCA9IChzY2hlbWEsIGNvbnRhaW5lciwgcGFyZW50QmxvY2spID0+IHtcbiAgICAgIGNvbnN0IHdhbGtlciA9IG5ldyBEb21UcmVlV2Fsa2VyKGNvbnRhaW5lciwgcGFyZW50QmxvY2spO1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBjb25zdCBub25FbXB0eUVsZW1lbnRzTWFwID0gc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgIHdoaWxlIChub2RlID0gd2Fsa2VyLm5leHQoKSkge1xuICAgICAgICBpZiAobm9uRW1wdHlFbGVtZW50c01hcFtub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGlzVGV4dCRhKG5vZGUpICYmIG5vZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0aW9uVG9CciA9IChlZGl0b3IsIGJyRWxtLCBleHRyYUJyKSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3IuZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgaWYgKCFleHRyYUJyKSB7XG4gICAgICAgIHJuZy5zZXRTdGFydEFmdGVyKGJyRWxtKTtcbiAgICAgICAgcm5nLnNldEVuZEFmdGVyKGJyRWxtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJuZy5zZXRTdGFydEJlZm9yZShickVsbSk7XG4gICAgICAgIHJuZy5zZXRFbmRCZWZvcmUoYnJFbG0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgIHNjcm9sbFJhbmdlSW50b1ZpZXcoZWRpdG9yLCBybmcpO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QnJBdENhcmV0ID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IHNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGxldCBickVsbTtcbiAgICAgIGxldCBleHRyYUJyID0gZmFsc2U7XG4gICAgICBub3JtYWxpemUkMihkb20sIHJuZykuZWFjaChub3JtUm5nID0+IHtcbiAgICAgICAgcm5nLnNldFN0YXJ0KG5vcm1Sbmcuc3RhcnRDb250YWluZXIsIG5vcm1Sbmcuc3RhcnRPZmZzZXQpO1xuICAgICAgICBybmcuc2V0RW5kKG5vcm1SbmcuZW5kQ29udGFpbmVyLCBub3JtUm5nLmVuZE9mZnNldCk7XG4gICAgICB9KTtcbiAgICAgIGxldCBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICBsZXQgY29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgaWYgKGlzRWxlbWVudCQ2KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjb25zdCBpc0FmdGVyTGFzdE5vZGVJbkNvbnRhaW5lciA9IG9mZnNldCA+IGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jaGlsZE5vZGVzW01hdGgubWluKG9mZnNldCwgY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSldIHx8IGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGlzQWZ0ZXJMYXN0Tm9kZUluQ29udGFpbmVyICYmIGlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICBvZmZzZXQgPSBjb250YWluZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChjb250YWluZXIsIGRvbS5pc0Jsb2NrKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrID0gcGFyZW50QmxvY2sgJiYgcGFyZW50QmxvY2sucGFyZW50Tm9kZSA/IGRvbS5nZXRQYXJlbnQocGFyZW50QmxvY2sucGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spIDogbnVsbDtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJsb2NrTmFtZSA9IGNvbnRhaW5lckJsb2NrID8gY29udGFpbmVyQmxvY2subm9kZU5hbWUudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgICAgY29uc3QgaXNDb250cm9sS2V5ID0gISEoZXZ0ICYmIGV2dC5jdHJsS2V5KTtcbiAgICAgIGlmIChjb250YWluZXJCbG9ja05hbWUgPT09ICdMSScgJiYgIWlzQ29udHJvbEtleSkge1xuICAgICAgICBwYXJlbnRCbG9jayA9IGNvbnRhaW5lckJsb2NrO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikgJiYgb2Zmc2V0ID49IGNvbnRhaW5lci5kYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWhhc1JpZ2h0U2lkZUNvbnRlbnQoZWRpdG9yLnNjaGVtYSwgY29udGFpbmVyLCBwYXJlbnRCbG9jayB8fCBkb20uZ2V0Um9vdCgpKSkge1xuICAgICAgICAgIGJyRWxtID0gZG9tLmNyZWF0ZSgnYnInKTtcbiAgICAgICAgICBybmcuaW5zZXJ0Tm9kZShickVsbSk7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIoYnJFbG0pO1xuICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihickVsbSk7XG4gICAgICAgICAgZXh0cmFCciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyRWxtID0gZG9tLmNyZWF0ZSgnYnInKTtcbiAgICAgIHJhbmdlSW5zZXJ0Tm9kZShkb20sIHJuZywgYnJFbG0pO1xuICAgICAgbW92ZVNlbGVjdGlvblRvQnIoZWRpdG9yLCBickVsbSwgZXh0cmFCcik7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnRCckJlZm9yZSA9IChlZGl0b3IsIGlubGluZSkgPT4ge1xuICAgICAgY29uc3QgYnIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKTtcbiAgICAgIGJlZm9yZSQzKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGlubGluZSksIGJyKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEJyQWZ0ZXIgPSAoZWRpdG9yLCBpbmxpbmUpID0+IHtcbiAgICAgIGlmICghaGFzQnJBZnRlcihlZGl0b3IuZ2V0Qm9keSgpLCBpbmxpbmUpKSB7XG4gICAgICAgIGFmdGVyJDQoU3VnYXJFbGVtZW50LmZyb21Eb20oaW5saW5lKSwgU3VnYXJFbGVtZW50LmZyb21UYWcoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgYnIgPSBTdWdhckVsZW1lbnQuZnJvbVRhZygnYnInKTtcbiAgICAgIGFmdGVyJDQoU3VnYXJFbGVtZW50LmZyb21Eb20oaW5saW5lKSwgYnIpO1xuICAgICAgbW92ZVNlbGVjdGlvblRvQnIoZWRpdG9yLCBici5kb20sIGZhbHNlKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQmVmb3JlQnIgPSBwb3MgPT4ge1xuICAgICAgcmV0dXJuIGlzQnIkNihwb3MuZ2V0Tm9kZSgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc0JyQWZ0ZXIgPSAocm9vdE5vZGUsIHN0YXJ0Tm9kZSkgPT4ge1xuICAgICAgaWYgKGlzQmVmb3JlQnIoQ2FyZXRQb3NpdGlvbi5hZnRlcihzdGFydE5vZGUpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXh0UG9zaXRpb24ocm9vdE5vZGUsIENhcmV0UG9zaXRpb24uYWZ0ZXIoc3RhcnROb2RlKSkubWFwKHBvcyA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzQnIkNihwb3MuZ2V0Tm9kZSgpKTtcbiAgICAgICAgfSkuZ2V0T3IoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNBbmNob3JMaW5rID0gZWxtID0+IHtcbiAgICAgIHJldHVybiBlbG0gJiYgZWxtLm5vZGVOYW1lID09PSAnQScgJiYgJ2hyZWYnIGluIGVsbTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSW5zaWRlQW5jaG9yID0gbG9jYXRpb24gPT4ge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uLmZvbGQobmV2ZXIsIGlzQW5jaG9yTGluaywgaXNBbmNob3JMaW5rLCBuZXZlcik7XG4gICAgfTtcbiAgICBjb25zdCByZWFkSW5saW5lQW5jaG9yTG9jYXRpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgcmV0dXJuIHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCBlZGl0b3IuZ2V0Qm9keSgpLCBwb3NpdGlvbikuZmlsdGVyKGlzSW5zaWRlQW5jaG9yKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEJyT3V0c2lkZUFuY2hvciA9IChlZGl0b3IsIGxvY2F0aW9uKSA9PiB7XG4gICAgICBsb2NhdGlvbi5mb2xkKG5vb3AsIGN1cnJ5KGluc2VydEJyQmVmb3JlLCBlZGl0b3IpLCBjdXJyeShpbnNlcnRCckFmdGVyLCBlZGl0b3IpLCBub29wKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydCQyID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBhbmNob3JMb2NhdGlvbiA9IHJlYWRJbmxpbmVBbmNob3JMb2NhdGlvbihlZGl0b3IpO1xuICAgICAgaWYgKGFuY2hvckxvY2F0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIGFuY2hvckxvY2F0aW9uLmVhY2goY3VycnkoaW5zZXJ0QnJPdXRzaWRlQW5jaG9yLCBlZGl0b3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydEJyQXRDYXJldChlZGl0b3IsIGV2dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmYWtlRXZlbnROYW1lID0gJ2luc2VydExpbmVCcmVhayc7XG4gICAgY29uc3QgbGluZWJyZWFrID0ge1xuICAgICAgaW5zZXJ0OiBpbnNlcnQkMixcbiAgICAgIGZha2VFdmVudE5hbWVcbiAgICB9O1xuXG4gICAgY29uc3QgbWF0Y2hlc1NlbGVjdG9yID0gKGVkaXRvciwgc2VsZWN0b3IpID0+IHtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayQxKGVkaXRvcikuZmlsdGVyKHBhcmVudEJsb2NrID0+IHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA+IDAgJiYgaXMkMShTdWdhckVsZW1lbnQuZnJvbURvbShwYXJlbnRCbG9jayksIHNlbGVjdG9yKTtcbiAgICAgIH0pLmlzU29tZSgpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0QnIgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvcihlZGl0b3IsIGdldEJyTmV3TGluZVNlbGVjdG9yKGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkQmxvY2tOZXdMaW5lJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvcihlZGl0b3IsIGdldE5vTmV3TGluZVNlbGVjdG9yKGVkaXRvcikpO1xuICAgIH07XG5cbiAgICBjb25zdCBuZXdMaW5lQWN0aW9uID0gQWR0LmdlbmVyYXRlKFtcbiAgICAgIHsgYnI6IFtdIH0sXG4gICAgICB7IGJsb2NrOiBbXSB9LFxuICAgICAgeyBub25lOiBbXSB9XG4gICAgXSk7XG4gICAgY29uc3Qgc2hvdWxkQmxvY2tOZXdMaW5lID0gKGVkaXRvciwgX3NoaWZ0S2V5KSA9PiB7XG4gICAgICByZXR1cm4gc2hvdWxkQmxvY2tOZXdMaW5lJDEoZWRpdG9yKTtcbiAgICB9O1xuICAgIGNvbnN0IGluTGlzdEJsb2NrID0gcmVxdWlyZWRTdGF0ZSA9PiB7XG4gICAgICByZXR1cm4gKGVkaXRvciwgX3NoaWZ0S2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBpc0xpc3RJdGVtUGFyZW50QmxvY2soZWRpdG9yKSA9PT0gcmVxdWlyZWRTdGF0ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpbkJsb2NrID0gKGJsb2NrTmFtZSwgcmVxdWlyZWRTdGF0ZSkgPT4gKGVkaXRvciwgX3NoaWZ0S2V5KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFBhcmVudEJsb2NrTmFtZShlZGl0b3IpID09PSBibG9ja05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBzdGF0ZSA9PT0gcmVxdWlyZWRTdGF0ZTtcbiAgICB9O1xuICAgIGNvbnN0IGluQ2VmQmxvY2sgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWRpdGFibGVSb290ID0gZ2V0RWRpdGFibGVSb290KGVkaXRvci5kb20sIGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSk7XG4gICAgICByZXR1cm4gaXNOdWxsYWJsZShlZGl0YWJsZVJvb3QpO1xuICAgIH07XG4gICAgY29uc3QgaW5QcmVCbG9jayA9IHJlcXVpcmVkU3RhdGUgPT4gaW5CbG9jaygncHJlJywgcmVxdWlyZWRTdGF0ZSk7XG4gICAgY29uc3QgaW5TdW1tYXJ5QmxvY2sgPSAoKSA9PiBpbkJsb2NrKCdzdW1tYXJ5JywgdHJ1ZSk7XG4gICAgY29uc3Qgc2hvdWxkUHV0QnJJblByZSA9IHJlcXVpcmVkU3RhdGUgPT4ge1xuICAgICAgcmV0dXJuIChlZGl0b3IsIF9zaGlmdEtleSkgPT4ge1xuICAgICAgICByZXR1cm4gc2hvdWxkUHV0QnJJblByZSQxKGVkaXRvcikgPT09IHJlcXVpcmVkU3RhdGU7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaW5CckNvbnRleHQgPSAoZWRpdG9yLCBfc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaG91bGRJbnNlcnRCcihlZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgaGFzU2hpZnRLZXkgPSAoX2VkaXRvciwgc2hpZnRLZXkpID0+IHtcbiAgICAgIHJldHVybiBzaGlmdEtleTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbkluc2VydEludG9FZGl0YWJsZVJvb3QgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZm9yY2VkUm9vdEJsb2NrID0gZ2V0Rm9yY2VkUm9vdEJsb2NrKGVkaXRvcik7XG4gICAgICBjb25zdCByb290RWRpdGFibGUgPSBnZXRFZGl0YWJsZVJvb3QoZWRpdG9yLmRvbSwgZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKHJvb3RFZGl0YWJsZSkgJiYgZWRpdG9yLnNjaGVtYS5pc1ZhbGlkQ2hpbGQocm9vdEVkaXRhYmxlLm5vZGVOYW1lLCBmb3JjZWRSb290QmxvY2spO1xuICAgIH07XG4gICAgY29uc3QgaXNJblJvb3RXaXRoRW1wdHlPckNFRiA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShybmcuc3RhcnRDb250YWluZXIpO1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZCQxKHN0YXJ0LCBybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgY29uc3QgaXNDZWZPcHQgPSBjaGlsZC5tYXAoZWxlbWVudCA9PiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmICFpc0VkaXRhYmxlJDMoZWxlbWVudCkpO1xuICAgICAgcmV0dXJuIHJuZy5jb2xsYXBzZWQgJiYgaXNDZWZPcHQuZ2V0T3IodHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBtYXRjaCA9IChwcmVkaWNhdGVzLCBhY3Rpb24pID0+IHtcbiAgICAgIHJldHVybiAoZWRpdG9yLCBzaGlmdEtleSkgPT4ge1xuICAgICAgICBjb25zdCBpc01hdGNoID0gZm9sZGwocHJlZGljYXRlcywgKHJlcywgcCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZXMgJiYgcChlZGl0b3IsIHNoaWZ0S2V5KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc01hdGNoID8gT3B0aW9uYWwuc29tZShhY3Rpb24pIDogT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEFjdGlvbiA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVW50aWwoW1xuICAgICAgICBtYXRjaChbc2hvdWxkQmxvY2tOZXdMaW5lXSwgbmV3TGluZUFjdGlvbi5ub25lKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBpbkNlZkJsb2NrXG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24ubm9uZSgpKSxcbiAgICAgICAgbWF0Y2goW2luU3VtbWFyeUJsb2NrKCldLCBuZXdMaW5lQWN0aW9uLmJyKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKGZhbHNlKSxcbiAgICAgICAgICBoYXNTaGlmdEtleVxuICAgICAgICBdLCBuZXdMaW5lQWN0aW9uLmJyKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKGZhbHNlKVxuICAgICAgICBdLCBuZXdMaW5lQWN0aW9uLmJsb2NrKCkpLFxuICAgICAgICBtYXRjaChbXG4gICAgICAgICAgaW5QcmVCbG9jayh0cnVlKSxcbiAgICAgICAgICBzaG91bGRQdXRCckluUHJlKHRydWUpLFxuICAgICAgICAgIGhhc1NoaWZ0S2V5XG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYmxvY2soKSksXG4gICAgICAgIG1hdGNoKFtcbiAgICAgICAgICBpblByZUJsb2NrKHRydWUpLFxuICAgICAgICAgIHNob3VsZFB1dEJySW5QcmUodHJ1ZSlcbiAgICAgICAgXSwgbmV3TGluZUFjdGlvbi5icigpKSxcbiAgICAgICAgbWF0Y2goW1xuICAgICAgICAgIGluTGlzdEJsb2NrKHRydWUpLFxuICAgICAgICAgIGhhc1NoaWZ0S2V5XG4gICAgICAgIF0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtpbkxpc3RCbG9jayh0cnVlKV0sIG5ld0xpbmVBY3Rpb24uYmxvY2soKSksXG4gICAgICAgIG1hdGNoKFtpbkJyQ29udGV4dF0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtoYXNTaGlmdEtleV0sIG5ld0xpbmVBY3Rpb24uYnIoKSksXG4gICAgICAgIG1hdGNoKFtjYW5JbnNlcnRJbnRvRWRpdGFibGVSb290XSwgbmV3TGluZUFjdGlvbi5ibG9jaygpKSxcbiAgICAgICAgbWF0Y2goW2lzSW5Sb290V2l0aEVtcHR5T3JDRUZdLCBuZXdMaW5lQWN0aW9uLmJsb2NrKCkpXG4gICAgICBdLCBbXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgISEoZXZ0ICYmIGV2dC5zaGlmdEtleSlcbiAgICAgIF0pLmdldE9yKG5ld0xpbmVBY3Rpb24ubm9uZSgpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaW5zZXJ0QnJlYWsgPSAoYnJlYWtUeXBlLCBlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgZXhlY0VkaXRvckRlbGV0ZUNvbW1hbmQoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05vbk51bGxhYmxlKGV2dCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBmaXJlQmVmb3JlSW5wdXRFdmVudChlZGl0b3IsIGJyZWFrVHlwZS5mYWtlRXZlbnROYW1lKTtcbiAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1R5cGUuaW5zZXJ0KGVkaXRvciwgZXZ0KTtcbiAgICAgIGlmIChpc05vbk51bGxhYmxlKGV2dCkpIHtcbiAgICAgICAgZmlyZUlucHV0RXZlbnQoZWRpdG9yLCBicmVha1R5cGUuZmFrZUV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgY29uc3QgYnIgPSAoKSA9PiBpbnNlcnRCcmVhayhsaW5lYnJlYWssIGVkaXRvciwgZXZ0KTtcbiAgICAgIGNvbnN0IGJsb2NrID0gKCkgPT4gaW5zZXJ0QnJlYWsoYmxvY2ticmVhaywgZWRpdG9yLCBldnQpO1xuICAgICAgY29uc3QgbG9naWNhbEFjdGlvbiA9IGdldEFjdGlvbihlZGl0b3IsIGV2dCk7XG4gICAgICBzd2l0Y2ggKGdldE5ld2xpbmVCZWhhdmlvcihlZGl0b3IpKSB7XG4gICAgICBjYXNlICdsaW5lYnJlYWsnOlxuICAgICAgICBsb2dpY2FsQWN0aW9uLmZvbGQoYnIsIGJyLCBub29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIGxvZ2ljYWxBY3Rpb24uZm9sZChibG9jaywgYmxvY2ssIG5vb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludmVydCc6XG4gICAgICAgIGxvZ2ljYWxBY3Rpb24uZm9sZChibG9jaywgYnIsIG5vb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZ2ljYWxBY3Rpb24uZm9sZChiciwgYmxvY2ssIG5vb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcGxhdGZvcm0kMSA9IGRldGVjdCQyKCk7XG4gICAgY29uc3QgaXNJT1NTYWZhcmkgPSBwbGF0Zm9ybSQxLm9zLmlzaU9TKCkgJiYgcGxhdGZvcm0kMS5icm93c2VyLmlzU2FmYXJpKCk7XG4gICAgY29uc3QgaGFuZGxlRW50ZXJLZXlFdmVudCA9IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVuZFR5cGluZ0xldmVsSWdub3JlTG9ja3MoZWRpdG9yLnVuZG9NYW5hZ2VyKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgIGluc2VydCQxKGVkaXRvciwgZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NhcmV0QWZ0ZXJLb3JlYW5DaGFyYWN0ZXIgPSBybmcgPT4ge1xuICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgaWYgKGlzVGV4dCRhKHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBrb3JlYW5DaGFyUmVnZXggPSAvXltcXHVBQzAwLVxcdUQ3QUZcXHUxMTAwLVxcdTExRkZcXHUzMTMwLVxcdTMxOEZcXHVBOTYwLVxcdUE5N0ZcXHVEN0IwLVxcdUQ3RkZdJC87XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdGFydENvbnRhaW5lci5kYXRhLmNoYXJBdChybmcuc3RhcnRPZmZzZXQgLSAxKTtcbiAgICAgICAgcmV0dXJuIGtvcmVhbkNoYXJSZWdleC50ZXN0KGNoYXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkaCA9IGVkaXRvciA9PiB7XG4gICAgICBsZXQgaU9TU2FmYXJpS2V5ZG93bkJvb2ttYXJrID0gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgY29uc3QgaU9TU2FmYXJpS2V5ZG93bk92ZXJyaWRlID0gZWRpdG9yID0+IHtcbiAgICAgICAgaU9TU2FmYXJpS2V5ZG93bkJvb2ttYXJrID0gT3B0aW9uYWwuc29tZShlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkpO1xuICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaU9TU2FmYXJpS2V5dXBPdmVycmlkZSA9IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gICAgICAgIGVkaXRvci51bmRvTWFuYWdlci51bmRvKCk7XG4gICAgICAgIGlPU1NhZmFyaUtleWRvd25Cb29rbWFyay5mb2xkKG5vb3AsIGIgPT4gZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhiKSk7XG4gICAgICAgIGhhbmRsZUVudGVyS2V5RXZlbnQoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIGlPU1NhZmFyaUtleWRvd25Cb29rbWFyayA9IE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBWSy5FTlRFUikge1xuICAgICAgICAgIGlmIChpc0lPU1NhZmFyaSAmJiBpc0NhcmV0QWZ0ZXJLb3JlYW5DaGFyYWN0ZXIoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSkpIHtcbiAgICAgICAgICAgIGlPU1NhZmFyaUtleWRvd25PdmVycmlkZShlZGl0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVFbnRlcktleUV2ZW50KGVkaXRvciwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ2tleXVwJywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVksuRU5URVIpIHtcbiAgICAgICAgICBpT1NTYWZhcmlLZXlkb3duQm9va21hcmsuZWFjaCgoKSA9PiBpT1NTYWZhcmlLZXl1cE92ZXJyaWRlKGVkaXRvciwgZXZlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMiA9IChlZGl0b3IsIGNhcmV0LCBldnQpID0+IHtcbiAgICAgIGNvbnN0IGlzTWFjID0gRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKTtcbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuRU5ELFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQxLCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5IT01FLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCQxLCBlZGl0b3IsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICAuLi4haXNNYWMgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuSE9NRSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKHNlbGVjdFRvRW5kUG9pbnQsIGVkaXRvciwgZmFsc2UpLFxuICAgICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5FTkQsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbihzZWxlY3RUb0VuZFBvaW50LCBlZGl0b3IsIHRydWUpLFxuICAgICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5FTkQsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50LCBlZGl0b3IsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5IT01FLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKG1vdmVUb0xpbmVFbmRQb2ludCwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkVORCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQkMiwgZWRpdG9yLCB0cnVlLCBjYXJldClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLkhPTUUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDIsIGVkaXRvciwgZmFsc2UsIGNhcmV0KVxuICAgICAgICB9XG4gICAgICBdLCBldnQpLmVhY2goXyA9PiB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCRnID0gKGVkaXRvciwgY2FyZXQpID0+IHtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleWRvd25PdmVycmlkZSQyKGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCRmID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignaW5wdXQnLCBlID0+IHtcbiAgICAgICAgaWYgKCFlLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgbm9ybWFsaXplTmJzcHNJbkVkaXRvcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGxhdGZvcm0gPSBkZXRlY3QkMigpO1xuICAgIGNvbnN0IGV4ZWN1dGVLZXl1cEFjdGlvbiA9IChlZGl0b3IsIGNhcmV0LCBldnQpID0+IHtcbiAgICAgIGV4ZWN1dGUoW1xuICAgICAgICB7XG4gICAgICAgICAga2V5Q29kZTogVksuUEFHRV9VUCxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbihtb3ZlVG9MaW5lRW5kUG9pbnQkMiwgZWRpdG9yLCBmYWxzZSwgY2FyZXQpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBrZXlDb2RlOiBWSy5QQUdFX0RPV04sXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24obW92ZVRvTGluZUVuZFBvaW50JDIsIGVkaXRvciwgdHJ1ZSwgY2FyZXQpXG4gICAgICAgIH1cbiAgICAgIF0sIGV2dCk7XG4gICAgfTtcbiAgICBjb25zdCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBlID0+IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgaXNQYWdlVXBEb3duID0gZXZ0ID0+IGV2dC5rZXlDb2RlID09PSBWSy5QQUdFX1VQIHx8IGV2dC5rZXlDb2RlID09PSBWSy5QQUdFX0RPV047XG4gICAgY29uc3Qgc2V0Tm9kZUNoYW5nZUJsb2NrZXIgPSAoYmxvY2tlZCwgZWRpdG9yLCBibG9jaykgPT4ge1xuICAgICAgaWYgKGJsb2NrICYmICFibG9ja2VkLmdldCgpKSB7XG4gICAgICAgIGVkaXRvci5vbignTm9kZUNoYW5nZScsIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFibG9jayAmJiBibG9ja2VkLmdldCgpKSB7XG4gICAgICAgIGVkaXRvci5vZmYoJ05vZGVDaGFuZ2UnLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pO1xuICAgICAgfVxuICAgICAgYmxvY2tlZC5zZXQoYmxvY2spO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkZSA9IChlZGl0b3IsIGNhcmV0KSA9PiB7XG4gICAgICBpZiAocGxhdGZvcm0ub3MuaXNNYWNPUygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJsb2NrZWQgPSBDZWxsKGZhbHNlKTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGV2dCA9PiB7XG4gICAgICAgIGlmIChpc1BhZ2VVcERvd24oZXZ0KSkge1xuICAgICAgICAgIHNldE5vZGVDaGFuZ2VCbG9ja2VyKGJsb2NrZWQsIGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXl1cCcsIGV2dCA9PiB7XG4gICAgICAgIGlmICghZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgZXhlY3V0ZUtleXVwQWN0aW9uKGVkaXRvciwgY2FyZXQsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGFnZVVwRG93bihldnQpICYmIGJsb2NrZWQuZ2V0KCkpIHtcbiAgICAgICAgICBzZXROb2RlQ2hhbmdlQmxvY2tlcihibG9ja2VkLCBlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGluc2VydFRleHRBdFBvc2l0aW9uID0gKHRleHQsIHBvcykgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gcG9zLmNvbnRhaW5lcigpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gcG9zLm9mZnNldCgpO1xuICAgICAgaWYgKGlzVGV4dCRhKGNvbnRhaW5lcikpIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydERhdGEob2Zmc2V0LCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoQ2FyZXRQb3NpdGlvbihjb250YWluZXIsIG9mZnNldCArIHRleHQubGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21Qb3NpdGlvbihwb3MpLm1hcChlbG0gPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gU3VnYXJFbGVtZW50LmZyb21UZXh0KHRleHQpO1xuICAgICAgICAgIGlmIChwb3MuaXNBdEVuZCgpKSB7XG4gICAgICAgICAgICBhZnRlciQ0KGVsbSwgdGV4dE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUkMyhlbG0sIHRleHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIENhcmV0UG9zaXRpb24odGV4dE5vZGUuZG9tLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0TmJzcEF0UG9zaXRpb24gPSBjdXJyeShpbnNlcnRUZXh0QXRQb3NpdGlvbiwgbmJzcCk7XG4gICAgY29uc3QgaW5zZXJ0U3BhY2VBdFBvc2l0aW9uID0gY3VycnkoaW5zZXJ0VGV4dEF0UG9zaXRpb24sICcgJyk7XG5cbiAgICBjb25zdCBpbnNlcnRTcGFjZU9yTmJzcEF0UG9zaXRpb24gPSAocm9vdCwgcG9zKSA9PiBuZWVkc1RvSGF2ZU5ic3Aocm9vdCwgcG9zKSA/IGluc2VydE5ic3BBdFBvc2l0aW9uKHBvcykgOiBpbnNlcnRTcGFjZUF0UG9zaXRpb24ocG9zKTtcbiAgICBjb25zdCBsb2NhdGlvblRvQ2FyZXRQb3NpdGlvbiA9IHJvb3QgPT4gbG9jYXRpb24gPT4gbG9jYXRpb24uZm9sZChlbGVtZW50ID0+IHByZXZQb3NpdGlvbihyb290LmRvbSwgQ2FyZXRQb3NpdGlvbi5iZWZvcmUoZWxlbWVudCkpLCBlbGVtZW50ID0+IGZpcnN0UG9zaXRpb25JbihlbGVtZW50KSwgZWxlbWVudCA9PiBsYXN0UG9zaXRpb25JbihlbGVtZW50KSwgZWxlbWVudCA9PiBuZXh0UG9zaXRpb24ocm9vdC5kb20sIENhcmV0UG9zaXRpb24uYWZ0ZXIoZWxlbWVudCkpKTtcbiAgICBjb25zdCBpbnNlcnRJbmxpbmVCb3VuZGFyeVNwYWNlT3JOYnNwID0gKHJvb3QsIHBvcykgPT4gY2hlY2tQb3MgPT4gbmVlZHNUb0hhdmVOYnNwKHJvb3QsIGNoZWNrUG9zKSA/IGluc2VydE5ic3BBdFBvc2l0aW9uKHBvcykgOiBpbnNlcnRTcGFjZUF0UG9zaXRpb24ocG9zKTtcbiAgICBjb25zdCBzZXRTZWxlY3Rpb24gPSBlZGl0b3IgPT4gcG9zID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHBvcy50b1JhbmdlKCkpO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBjb25zdCBpc0luc2lkZVN1bW1hcnkgPSAoZG9tVXRpbHMsIG5vZGUpID0+IGRvbVV0aWxzLmlzRWRpdGFibGUoZG9tVXRpbHMuZ2V0UGFyZW50KG5vZGUsICdzdW1tYXJ5JykpO1xuICAgIGNvbnN0IGluc2VydFNwYWNlT3JOYnNwQXRTZWxlY3Rpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIGNvbnN0IHJvb3QgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgaXNJbmxpbmVUYXJnZXQkMSA9IGN1cnJ5KGlzSW5saW5lVGFyZ2V0LCBlZGl0b3IpO1xuICAgICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgICAgcmV0dXJuIHJlYWRMb2NhdGlvbihpc0lubGluZVRhcmdldCQxLCBlZGl0b3IuZ2V0Qm9keSgpLCBjYXJldFBvc2l0aW9uKS5iaW5kKGxvY2F0aW9uVG9DYXJldFBvc2l0aW9uKHJvb3QpKS5tYXAoY2hlY2tQb3MgPT4gKCkgPT4gaW5zZXJ0SW5saW5lQm91bmRhcnlTcGFjZU9yTmJzcChyb290LCBwb3MpKGNoZWNrUG9zKS5lYWNoKHNldFNlbGVjdGlvbihlZGl0b3IpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0U3BhY2VJblN1bW1hcnlBdFNlbGVjdGlvbk9uRmlyZWZveCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpbnNlcnRTcGFjZVRodW5rID0gKCkgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKCdEZWxldGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3MgPSBDYXJldFBvc2l0aW9uLmZyb21SYW5nZVN0YXJ0KGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgICAgICBpbnNlcnRTcGFjZU9yTmJzcEF0UG9zaXRpb24ocm9vdCwgcG9zKS5lYWNoKHNldFNlbGVjdGlvbihlZGl0b3IpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc29tZUlmKEVudi5icm93c2VyLmlzRmlyZWZveCgpICYmIGVkaXRvci5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpICYmIGlzSW5zaWRlU3VtbWFyeShlZGl0b3IuZG9tLCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLnN0YXJ0Q29udGFpbmVyKSwgaW5zZXJ0U3BhY2VUaHVuayk7XG4gICAgfTtcblxuICAgIGNvbnN0IGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMSA9IChlZGl0b3IsIGV2dCkgPT4ge1xuICAgICAgZXhlY3V0ZVdpdGhEZWxheWVkQWN0aW9uKFtcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlNQQUNFQkFSLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGluc2VydFNwYWNlT3JOYnNwQXRTZWxlY3Rpb24sIGVkaXRvcilcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGtleUNvZGU6IFZLLlNQQUNFQkFSLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGluc2VydFNwYWNlSW5TdW1tYXJ5QXRTZWxlY3Rpb25PbkZpcmVmb3gsIGVkaXRvcilcbiAgICAgICAgfVxuICAgICAgXSwgZXZ0KS5lYWNoKGFwcGx5QWN0aW9uID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZmlyZUJlZm9yZUlucHV0RXZlbnQoZWRpdG9yLCAnaW5zZXJ0VGV4dCcsIHsgZGF0YTogJyAnIH0pO1xuICAgICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgYXBwbHlBY3Rpb24oKTtcbiAgICAgICAgICBmaXJlSW5wdXRFdmVudChlZGl0b3IsICdpbnNlcnRUZXh0JywgeyBkYXRhOiAnICcgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkZCA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBldnQgPT4ge1xuICAgICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGV4ZWN1dGVLZXlkb3duT3ZlcnJpZGUkMShlZGl0b3IsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCB0YWJsZVRhYk5hdmlnYXRpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGhhc1RhYmxlVGFiTmF2aWdhdGlvbihlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5Q29kZTogVksuVEFCLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24oaGFuZGxlVGFiLCBlZGl0b3IsIHRydWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlDb2RlOiBWSy5UQUIsXG4gICAgICAgICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uKGhhbmRsZVRhYiwgZWRpdG9yLCBmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlS2V5ZG93bk92ZXJyaWRlID0gKGVkaXRvciwgZXZ0KSA9PiB7XG4gICAgICBleGVjdXRlKFsuLi50YWJsZVRhYk5hdmlnYXRpb24oZWRpdG9yKV0sIGV2dCkuZWFjaChfID0+IHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldHVwJGMgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICBleGVjdXRlS2V5ZG93bk92ZXJyaWRlKGVkaXRvciwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldHVwJGIgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmFkZFNob3J0Y3V0KCdNZXRhK1AnLCAnJywgJ21jZVByaW50Jyk7XG4gICAgICBzZXR1cCRqKGVkaXRvcik7XG4gICAgICBpZiAoaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICByZXR1cm4gQ2VsbChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhcmV0ID0gc2V0dXBTZWxlY3RlZFN0YXRlKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGwoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkayhlZGl0b3IsIGNhcmV0KTtcbiAgICAgICAgc2V0dXAkaShlZGl0b3IsIGNhcmV0KTtcbiAgICAgICAgc2V0dXAkaChlZGl0b3IpO1xuICAgICAgICBzZXR1cCRkKGVkaXRvcik7XG4gICAgICAgIHNldHVwJGYoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkYyhlZGl0b3IpO1xuICAgICAgICBzZXR1cCRnKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICBzZXR1cCRlKGVkaXRvciwgY2FyZXQpO1xuICAgICAgICByZXR1cm4gY2FyZXQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNsYXNzIE5vZGVDaGFuZ2Uge1xuICAgICAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAgIHRoaXMubGFzdFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIGxldCBsYXN0Um5nO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCEoJ29uc2VsZWN0aW9uY2hhbmdlJyBpbiBlZGl0b3IuZ2V0RG9jKCkpKSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlIGNsaWNrIG1vdXNldXAga2V5dXAgZm9jdXMnLCBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgICAgICBjb25zdCBmYWtlUm5nID0ge1xuICAgICAgICAgICAgICBzdGFydENvbnRhaW5lcjogbmF0aXZlUm5nLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgICBzdGFydE9mZnNldDogbmF0aXZlUm5nLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICBlbmRDb250YWluZXI6IG5hdGl2ZVJuZy5lbmRDb250YWluZXIsXG4gICAgICAgICAgICAgIGVuZE9mZnNldDogbmF0aXZlUm5nLmVuZE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdub2RlY2hhbmdlJyB8fCAhaXNFcSQ0KGZha2VSbmcsIGxhc3RSbmcpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnU2VsZWN0aW9uQ2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Um5nID0gZmFrZVJuZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub24oJ2NvbnRleHRtZW51JywgKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnU2VsZWN0aW9uQ2hhbmdlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ1NlbGVjdGlvbkNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGFydEVsbSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQodHJ1ZSk7XG4gICAgICAgICAgaWYgKCFzdGFydEVsbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzQW55UmFuZ2VzKGVkaXRvcikgJiYgIXNlbGYuaXNTYW1lRWxlbWVudFBhdGgoc3RhcnRFbG0pICYmIGVkaXRvci5kb20uaXNDaGlsZE9mKHN0YXJ0RWxtLCBlZGl0b3IuZ2V0Qm9keSgpKSkge1xuICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKHsgc2VsZWN0aW9uQ2hhbmdlOiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignbW91c2V1cCcsIGUgPT4ge1xuICAgICAgICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBoYXNBbnlSYW5nZXMoZWRpdG9yKSkge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLm5vZGVOYW1lID09PSAnSU1HJykge1xuICAgICAgICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBub2RlQ2hhbmdlZChhcmdzID0ge30pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmluaXRpYWxpemVkICYmIHNlbGVjdGlvbiAmJiAhc2hvdWxkRGlzYWJsZU5vZGVDaGFuZ2UodGhpcy5lZGl0b3IpICYmICF0aGlzLmVkaXRvci5tb2RlLmlzUmVhZE9ubHkoKSkge1xuICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgICAgbm9kZSA9IHNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSB8fCByb290O1xuICAgICAgICAgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IHRoaXMuZWRpdG9yLmdldERvYygpIHx8ICF0aGlzLmVkaXRvci5kb20uaXNDaGlsZE9mKG5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgICBub2RlID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmRvbS5nZXRQYXJlbnQobm9kZSwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoKCdOb2RlQ2hhbmdlJywge1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGUsXG4gICAgICAgICAgICBwYXJlbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzU2FtZUVsZW1lbnRQYXRoKHN0YXJ0RWxtKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGggPSByZXZlcnNlKGVkaXRvci5kb20uZ2V0UGFyZW50cyhzdGFydEVsbSwgYWx3YXlzLCBlZGl0b3IuZ2V0Qm9keSgpKSk7XG4gICAgICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPT09IHRoaXMubGFzdFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChpID0gY3VycmVudFBhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoW2ldICE9PSB0aGlzLmxhc3RQYXRoW2ldKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFBhdGggPSBjdXJyZW50UGF0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RQYXRoID0gY3VycmVudFBhdGg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZUlkID0gZ2VuZXJhdGUkMSgnaW1hZ2UnKTtcbiAgICBjb25zdCBnZXREcmFnSW1hZ2UgPSB0cmFuc2ZlciA9PiB7XG4gICAgICBjb25zdCBkdCA9IHRyYW5zZmVyO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZHRbaW1hZ2VJZF0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0RHJhZ0ltYWdlID0gKHRyYW5zZmVyLCBpbWFnZURhdGEpID0+IHtcbiAgICAgIGNvbnN0IGR0ID0gdHJhbnNmZXI7XG4gICAgICBkdFtpbWFnZUlkXSA9IGltYWdlRGF0YTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXZlbnRJZCA9IGdlbmVyYXRlJDEoJ2V2ZW50Jyk7XG4gICAgY29uc3QgZ2V0RXZlbnQgPSB0cmFuc2ZlciA9PiB7XG4gICAgICBjb25zdCBkdCA9IHRyYW5zZmVyO1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLmZyb20oZHRbZXZlbnRJZF0pO1xuICAgIH07XG4gICAgY29uc3QgbWtTZXRFdmVudEZuID0gdHlwZSA9PiB0cmFuc2ZlciA9PiB7XG4gICAgICBjb25zdCBkdCA9IHRyYW5zZmVyO1xuICAgICAgZHRbZXZlbnRJZF0gPSB0eXBlO1xuICAgIH07XG4gICAgY29uc3Qgc2V0RXZlbnQgPSAodHJhbnNmZXIsIHR5cGUpID0+IG1rU2V0RXZlbnRGbih0eXBlKSh0cmFuc2Zlcik7XG4gICAgY29uc3Qgc2V0RHJhZ3N0YXJ0RXZlbnQgPSBta1NldEV2ZW50Rm4oMCk7XG4gICAgY29uc3Qgc2V0RHJvcEV2ZW50ID0gbWtTZXRFdmVudEZuKDIpO1xuICAgIGNvbnN0IHNldERyYWdlbmRFdmVudCA9IG1rU2V0RXZlbnRGbigxKTtcbiAgICBjb25zdCBjaGVja0V2ZW50ID0gZXhwZWN0ZWRUeXBlID0+IHRyYW5zZmVyID0+IHtcbiAgICAgIGNvbnN0IGR0ID0gdHJhbnNmZXI7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShkdFtldmVudElkXSkuZXhpc3RzKHR5cGUgPT4gdHlwZSA9PT0gZXhwZWN0ZWRUeXBlKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSW5EcmFnU3RhcnRFdmVudCA9IGNoZWNrRXZlbnQoMCk7XG5cbiAgICBjb25zdCBjcmVhdGVFbXB0eUZpbGVMaXN0ID0gKCkgPT4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBpdGVtOiBfID0+IG51bGxcbiAgICB9KTtcblxuICAgIGNvbnN0IG1vZGVJZCA9IGdlbmVyYXRlJDEoJ21vZGUnKTtcbiAgICBjb25zdCBnZXRNb2RlID0gdHJhbnNmZXIgPT4ge1xuICAgICAgY29uc3QgZHQgPSB0cmFuc2ZlcjtcbiAgICAgIHJldHVybiBPcHRpb25hbC5mcm9tKGR0W21vZGVJZF0pO1xuICAgIH07XG4gICAgY29uc3QgbWtTZXRNb2RlRm4gPSBtb2RlID0+IHRyYW5zZmVyID0+IHtcbiAgICAgIGNvbnN0IGR0ID0gdHJhbnNmZXI7XG4gICAgICBkdFttb2RlSWRdID0gbW9kZTtcbiAgICB9O1xuICAgIGNvbnN0IHNldE1vZGUkMSA9ICh0cmFuc2ZlciwgbW9kZSkgPT4gbWtTZXRNb2RlRm4obW9kZSkodHJhbnNmZXIpO1xuICAgIGNvbnN0IHNldFJlYWRXcml0ZU1vZGUgPSBta1NldE1vZGVGbigwKTtcbiAgICBjb25zdCBzZXRSZWFkT25seU1vZGUgPSBta1NldE1vZGVGbigyKTtcbiAgICBjb25zdCBzZXRQcm90ZWN0ZWRNb2RlID0gbWtTZXRNb2RlRm4oMSk7XG4gICAgY29uc3QgY2hlY2tNb2RlID0gZXhwZWN0ZWRNb2RlID0+IHRyYW5zZmVyID0+IHtcbiAgICAgIGNvbnN0IGR0ID0gdHJhbnNmZXI7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShkdFttb2RlSWRdKS5leGlzdHMobW9kZSA9PiBtb2RlID09PSBleHBlY3RlZE1vZGUpO1xuICAgIH07XG4gICAgY29uc3QgaXNJblJlYWRXcml0ZU1vZGUgPSBjaGVja01vZGUoMCk7XG4gICAgY29uc3QgaXNJblByb3RlY3RlZE1vZGUgPSBjaGVja01vZGUoMSk7XG5cbiAgICBjb25zdCBub3JtYWxpemVJdGVtcyA9IChkYXRhVHJhbnNmZXIsIGl0ZW1zSW1wbCkgPT4gKHtcbiAgICAgIC4uLml0ZW1zSW1wbCxcbiAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBpdGVtc0ltcGwubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGFkZDogKGRhdGEsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKGlzSW5SZWFkV3JpdGVNb2RlKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodHlwZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zSW1wbC5hZGQoZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtc0ltcGwuYWRkKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGlkeCA9PiB7XG4gICAgICAgIGlmIChpc0luUmVhZFdyaXRlTW9kZShkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgaXRlbXNJbXBsLnJlbW92ZShpZHgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgaWYgKGlzSW5SZWFkV3JpdGVNb2RlKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICBpdGVtc0ltcGwuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgdmFsaWREcm9wRWZmZWN0cyA9IFtcbiAgICAgICdub25lJyxcbiAgICAgICdjb3B5JyxcbiAgICAgICdsaW5rJyxcbiAgICAgICdtb3ZlJ1xuICAgIF07XG4gICAgY29uc3QgdmFsaWRFZmZlY3RBbGxvd2VkcyA9IFtcbiAgICAgICdub25lJyxcbiAgICAgICdjb3B5JyxcbiAgICAgICdjb3B5TGluaycsXG4gICAgICAnY29weU1vdmUnLFxuICAgICAgJ2xpbmsnLFxuICAgICAgJ2xpbmtNb3ZlJyxcbiAgICAgICdtb3ZlJyxcbiAgICAgICdhbGwnLFxuICAgICAgJ3VuaW5pdGlhbGl6ZWQnXG4gICAgXTtcbiAgICBjb25zdCBjcmVhdGVEYXRhVHJhbnNmZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhVHJhbnNmZXJJbXBsID0gbmV3IHdpbmRvdy5EYXRhVHJhbnNmZXIoKTtcbiAgICAgIGxldCBkcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgbGV0IGVmZmVjdEFsbG93ZWQgPSAnYWxsJztcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IHtcbiAgICAgICAgZ2V0IGRyb3BFZmZlY3QoKSB7XG4gICAgICAgICAgcmV0dXJuIGRyb3BFZmZlY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBkcm9wRWZmZWN0KGVmZmVjdCkge1xuICAgICAgICAgIGlmIChjb250YWlucyQyKHZhbGlkRHJvcEVmZmVjdHMsIGVmZmVjdCkpIHtcbiAgICAgICAgICAgIGRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQgZWZmZWN0QWxsb3dlZCgpIHtcbiAgICAgICAgICByZXR1cm4gZWZmZWN0QWxsb3dlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGVmZmVjdEFsbG93ZWQoYWxsb3dlZCkge1xuICAgICAgICAgIGlmIChpc0luRHJhZ1N0YXJ0RXZlbnQoZGF0YVRyYW5zZmVyKSAmJiBjb250YWlucyQyKHZhbGlkRWZmZWN0QWxsb3dlZHMsIGFsbG93ZWQpKSB7XG4gICAgICAgICAgICBlZmZlY3RBbGxvd2VkID0gYWxsb3dlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplSXRlbXMoZGF0YVRyYW5zZmVyLCBkYXRhVHJhbnNmZXJJbXBsLml0ZW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGZpbGVzKCkge1xuICAgICAgICAgIGlmIChpc0luUHJvdGVjdGVkTW9kZShkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlGaWxlTGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVRyYW5zZmVySW1wbC5maWxlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB0eXBlcygpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVRyYW5zZmVySW1wbC50eXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RHJhZ0ltYWdlOiAoaW1hZ2UsIHgsIHkpID0+IHtcbiAgICAgICAgICBpZiAoaXNJblJlYWRXcml0ZU1vZGUoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgc2V0RHJhZ0ltYWdlKGRhdGFUcmFuc2Zlciwge1xuICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhVHJhbnNmZXJJbXBsLnNldERyYWdJbWFnZShpbWFnZSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXREYXRhOiBmb3JtYXQgPT4ge1xuICAgICAgICAgIGlmIChpc0luUHJvdGVjdGVkTW9kZShkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVHJhbnNmZXJJbXBsLmdldERhdGEoZm9ybWF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldERhdGE6IChmb3JtYXQsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoaXNJblJlYWRXcml0ZU1vZGUoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVySW1wbC5zZXREYXRhKGZvcm1hdCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhckRhdGE6IGZvcm1hdCA9PiB7XG4gICAgICAgICAgaWYgKGlzSW5SZWFkV3JpdGVNb2RlKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlckltcGwuY2xlYXJEYXRhKGZvcm1hdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2V0UmVhZFdyaXRlTW9kZShkYXRhVHJhbnNmZXIpO1xuICAgICAgcmV0dXJuIGRhdGFUcmFuc2ZlcjtcbiAgICB9O1xuICAgIGNvbnN0IGNsb25lRGF0YVRyYW5zZmVyID0gb3JpZ2luYWwgPT4ge1xuICAgICAgY29uc3QgY2xvbmUgPSBjcmVhdGVEYXRhVHJhbnNmZXIoKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTW9kZSA9IGdldE1vZGUob3JpZ2luYWwpO1xuICAgICAgc2V0UmVhZE9ubHlNb2RlKG9yaWdpbmFsKTtcbiAgICAgIHNldERyYWdzdGFydEV2ZW50KGNsb25lKTtcbiAgICAgIGNsb25lLmRyb3BFZmZlY3QgPSBvcmlnaW5hbC5kcm9wRWZmZWN0O1xuICAgICAgY2xvbmUuZWZmZWN0QWxsb3dlZCA9IG9yaWdpbmFsLmVmZmVjdEFsbG93ZWQ7XG4gICAgICBnZXREcmFnSW1hZ2Uob3JpZ2luYWwpLmVhY2goaW1hZ2VEYXRhID0+IGNsb25lLnNldERyYWdJbWFnZShpbWFnZURhdGEuaW1hZ2UsIGltYWdlRGF0YS54LCBpbWFnZURhdGEueSkpO1xuICAgICAgZWFjaCRlKG9yaWdpbmFsLnR5cGVzLCB0eXBlID0+IHtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdGaWxlcycpIHtcbiAgICAgICAgICBjbG9uZS5zZXREYXRhKHR5cGUsIG9yaWdpbmFsLmdldERhdGEodHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVhY2gkZShvcmlnaW5hbC5maWxlcywgZmlsZSA9PiBjbG9uZS5pdGVtcy5hZGQoZmlsZSkpO1xuICAgICAgZ2V0RXZlbnQob3JpZ2luYWwpLmVhY2godHlwZSA9PiB7XG4gICAgICAgIHNldEV2ZW50KGNsb25lLCB0eXBlKTtcbiAgICAgIH0pO1xuICAgICAgb3JpZ2luYWxNb2RlLmVhY2gobW9kZSA9PiB7XG4gICAgICAgIHNldE1vZGUkMShvcmlnaW5hbCwgbW9kZSk7XG4gICAgICAgIHNldE1vZGUkMShjbG9uZSwgbW9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0SHRtbERhdGEgPSBkYXRhVHJhbnNmZXIgPT4ge1xuICAgICAgY29uc3QgaHRtbCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICAgIHJldHVybiBodG1sID09PSAnJyA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUoaHRtbCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRIdG1sRGF0YSA9IChkYXRhVHJhbnNmZXIsIGh0bWwpID0+IGRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sKTtcblxuICAgIGNvbnN0IGludGVybmFsTWltZVR5cGUgPSAneC10aW55bWNlL2h0bWwnO1xuICAgIGNvbnN0IGludGVybmFsSHRtbE1pbWUgPSBjb25zdGFudChpbnRlcm5hbE1pbWVUeXBlKTtcbiAgICBjb25zdCBpbnRlcm5hbE1hcmsgPSAnPCEtLSAnICsgaW50ZXJuYWxNaW1lVHlwZSArICcgLS0+JztcbiAgICBjb25zdCBtYXJrID0gaHRtbCA9PiBpbnRlcm5hbE1hcmsgKyBodG1sO1xuICAgIGNvbnN0IHVubWFyayA9IGh0bWwgPT4gaHRtbC5yZXBsYWNlKGludGVybmFsTWFyaywgJycpO1xuICAgIGNvbnN0IGlzTWFya2VkID0gaHRtbCA9PiBodG1sLmluZGV4T2YoaW50ZXJuYWxNYXJrKSAhPT0gLTE7XG5cbiAgICBjb25zdCBpc1BsYWluVGV4dCA9IHRleHQgPT4ge1xuICAgICAgcmV0dXJuICEvPCg/OlxcLz8oPyEoPzpkaXZ8cHxicnxzcGFuKT4pXFx3K3woPzooPyEoPzpzcGFuIHN0eWxlPVwid2hpdGUtc3BhY2U6XFxzP3ByZTs/XCI+KXxiclxccz9cXC8+KSlcXHcrXFxzW14+XSspPi9pLnRlc3QodGV4dCk7XG4gICAgfTtcbiAgICBjb25zdCBvcGVuQ29udGFpbmVyID0gKHJvb3RUYWcsIHJvb3RBdHRycykgPT4ge1xuICAgICAgbGV0IHRhZyA9ICc8JyArIHJvb3RUYWc7XG4gICAgICBjb25zdCBhdHRycyA9IG1hcFRvQXJyYXkocm9vdEF0dHJzLCAodmFsdWUsIGtleSkgPT4ga2V5ICsgJz1cIicgKyBFbnRpdGllcy5lbmNvZGVBbGxSYXcodmFsdWUpICsgJ1wiJyk7XG4gICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIHRhZyArPSAnICcgKyBhdHRycy5qb2luKCcgJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnICsgJz4nO1xuICAgIH07XG4gICAgY29uc3QgdG9CbG9ja0VsZW1lbnRzID0gKHRleHQsIHJvb3RUYWcsIHJvb3RBdHRycykgPT4ge1xuICAgICAgY29uc3QgYmxvY2tzID0gdGV4dC5zcGxpdCgvXFxuXFxuLyk7XG4gICAgICBjb25zdCB0YWdPcGVuID0gb3BlbkNvbnRhaW5lcihyb290VGFnLCByb290QXR0cnMpO1xuICAgICAgY29uc3QgdGFnQ2xvc2UgPSAnPC8nICsgcm9vdFRhZyArICc+JztcbiAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBtYXAkMyhibG9ja3MsIHAgPT4ge1xuICAgICAgICByZXR1cm4gcC5zcGxpdCgvXFxuLykuam9pbignPGJyIC8+Jyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0aXRjaCA9IHAgPT4ge1xuICAgICAgICByZXR1cm4gdGFnT3BlbiArIHAgKyB0YWdDbG9zZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcGFyYWdyYXBocy5sZW5ndGggPT09IDEgPyBwYXJhZ3JhcGhzWzBdIDogbWFwJDMocGFyYWdyYXBocywgc3RpdGNoKS5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFzdGVCaW5EZWZhdWx0Q29udGVudCA9ICclTUNFUEFTVEVCSU4lJztcbiAgICBjb25zdCBjcmVhdGUkNiA9IChlZGl0b3IsIGxhc3RSbmdDZWxsKSA9PiB7XG4gICAgICBjb25zdCB7ZG9tLCBzZWxlY3Rpb259ID0gZWRpdG9yO1xuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBsYXN0Um5nQ2VsbC5zZXQoc2VsZWN0aW9uLmdldFJuZygpKTtcbiAgICAgIGNvbnN0IHBhc3RlQmluRWxtID0gZG9tLmFkZChlZGl0b3IuZ2V0Qm9keSgpLCAnZGl2Jywge1xuICAgICAgICAnaWQnOiAnbWNlcGFzdGViaW4nLFxuICAgICAgICAnY2xhc3MnOiAnbWNlLXBhc3RlYmluJyxcbiAgICAgICAgJ2NvbnRlbnRFZGl0YWJsZSc6IHRydWUsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnLFxuICAgICAgICAnc3R5bGUnOiAncG9zaXRpb246IGZpeGVkOyB0b3A6IDUwJTsgd2lkdGg6IDEwcHg7IGhlaWdodDogMTBweDsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogMCdcbiAgICAgIH0sIHBhc3RlQmluRGVmYXVsdENvbnRlbnQpO1xuICAgICAgaWYgKEVudi5icm93c2VyLmlzRmlyZWZveCgpKSB7XG4gICAgICAgIGRvbS5zZXRTdHlsZShwYXN0ZUJpbkVsbSwgJ2xlZnQnLCBkb20uZ2V0U3R5bGUoYm9keSwgJ2RpcmVjdGlvbicsIHRydWUpID09PSAncnRsJyA/IDY1NTM1IDogLTY1NTM1KTtcbiAgICAgIH1cbiAgICAgIGRvbS5iaW5kKHBhc3RlQmluRWxtLCAnYmVmb3JlZGVhY3RpdmF0ZSBmb2N1c2luIGZvY3Vzb3V0JywgZSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHBhc3RlQmluRWxtLmZvY3VzKCk7XG4gICAgICBzZWxlY3Rpb24uc2VsZWN0KHBhc3RlQmluRWxtLCB0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChlZGl0b3IsIGxhc3RSbmdDZWxsKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgaWYgKGdldEVsKGVkaXRvcikpIHtcbiAgICAgICAgbGV0IHBhc3RlQmluQ2xvbmU7XG4gICAgICAgIGNvbnN0IGxhc3RSbmcgPSBsYXN0Um5nQ2VsbC5nZXQoKTtcbiAgICAgICAgd2hpbGUgKHBhc3RlQmluQ2xvbmUgPSBnZXRFbChlZGl0b3IpKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZShwYXN0ZUJpbkNsb25lKTtcbiAgICAgICAgICBkb20udW5iaW5kKHBhc3RlQmluQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Um5nKSB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcobGFzdFJuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RSbmdDZWxsLnNldChudWxsKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEVsID0gZWRpdG9yID0+IGVkaXRvci5kb20uZ2V0KCdtY2VwYXN0ZWJpbicpO1xuICAgIGNvbnN0IGlzUGFzdGVCaW4gPSBlbG0gPT4gaXNOb25OdWxsYWJsZShlbG0pICYmIGVsbS5pZCA9PT0gJ21jZXBhc3RlYmluJztcbiAgICBjb25zdCBnZXRIdG1sID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBjb3B5QW5kUmVtb3ZlID0gKHRvRWxtLCBmcm9tRWxtKSA9PiB7XG4gICAgICAgIHRvRWxtLmFwcGVuZENoaWxkKGZyb21FbG0pO1xuICAgICAgICBkb20ucmVtb3ZlKGZyb21FbG0sIHRydWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IFtwYXN0ZUJpbkVsbSwgLi4ucGFzdGVCaW5DbG9uZXNdID0gZmlsdGVyJDUoZWRpdG9yLmdldEJvZHkoKS5jaGlsZE5vZGVzLCBpc1Bhc3RlQmluKTtcbiAgICAgIGVhY2gkZShwYXN0ZUJpbkNsb25lcywgcGFzdGVCaW5DbG9uZSA9PiB7XG4gICAgICAgIGNvcHlBbmRSZW1vdmUocGFzdGVCaW5FbG0sIHBhc3RlQmluQ2xvbmUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBkaXJ0eVdyYXBwZXJzID0gZG9tLnNlbGVjdCgnZGl2W2lkPW1jZXBhc3RlYmluXScsIHBhc3RlQmluRWxtKTtcbiAgICAgIGZvciAobGV0IGkgPSBkaXJ0eVdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuV3JhcHBlciA9IGRvbS5jcmVhdGUoJ2RpdicpO1xuICAgICAgICBwYXN0ZUJpbkVsbS5pbnNlcnRCZWZvcmUoY2xlYW5XcmFwcGVyLCBkaXJ0eVdyYXBwZXJzW2ldKTtcbiAgICAgICAgY29weUFuZFJlbW92ZShjbGVhbldyYXBwZXIsIGRpcnR5V3JhcHBlcnNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhc3RlQmluRWxtID8gcGFzdGVCaW5FbG0uaW5uZXJIVE1MIDogJyc7XG4gICAgfTtcbiAgICBjb25zdCBpc0RlZmF1bHRQYXN0ZUJpbkNvbnRlbnQgPSBjb250ZW50ID0+IGNvbnRlbnQgPT09IHBhc3RlQmluRGVmYXVsdENvbnRlbnQ7XG4gICAgY29uc3QgUGFzdGVCaW4gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgbGFzdFJuZyA9IENlbGwobnVsbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGU6ICgpID0+IGNyZWF0ZSQ2KGVkaXRvciwgbGFzdFJuZyksXG4gICAgICAgIHJlbW92ZTogKCkgPT4gcmVtb3ZlKGVkaXRvciwgbGFzdFJuZyksXG4gICAgICAgIGdldEVsOiAoKSA9PiBnZXRFbChlZGl0b3IpLFxuICAgICAgICBnZXRIdG1sOiAoKSA9PiBnZXRIdG1sKGVkaXRvciksXG4gICAgICAgIGdldExhc3RSbmc6IGxhc3RSbmcuZ2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBmaWx0ZXIkMSA9IChjb250ZW50LCBpdGVtcykgPT4ge1xuICAgICAgVG9vbHMuZWFjaChpdGVtcywgdiA9PiB7XG4gICAgICAgIGlmIChpcyQ0KHYsIFJlZ0V4cCkpIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHYsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHZbMF0sIHZbMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH07XG4gICAgY29uc3QgaW5uZXJUZXh0ID0gaHRtbCA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoKTtcbiAgICAgIGNvbnN0IGRvbVBhcnNlciA9IERvbVBhcnNlcih7fSwgc2NoZW1hKTtcbiAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICBjb25zdCB2b2lkRWxlbWVudHMgPSBzY2hlbWEuZ2V0Vm9pZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBpZ25vcmVFbGVtZW50cyA9IFRvb2xzLm1ha2VNYXAoJ3NjcmlwdCBub3NjcmlwdCBzdHlsZSB0ZXh0YXJlYSB2aWRlbyBhdWRpbyBpZnJhbWUgb2JqZWN0JywgJyAnKTtcbiAgICAgIGNvbnN0IGJsb2NrRWxlbWVudHMgPSBzY2hlbWEuZ2V0QmxvY2tFbGVtZW50cygpO1xuICAgICAgY29uc3Qgd2FsayA9IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIGlmIChuYW1lID09PSAnYnInKSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICd3YnInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2lkRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWdub3JlRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0ZXh0ICs9ICcgJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAgIHRleHQgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlLm5hbWUgaW4gc2NoZW1hLmdldFZvaWRFbGVtZW50cygpKSkge1xuICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgd2FsayhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50c1tuYW1lXSAmJiBjdXJyZW50Tm9kZS5uZXh0KSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGh0bWwgPSBmaWx0ZXIkMShodG1sLCBbLzwhXFxbW15cXF1dK1xcXT4vZ10pO1xuICAgICAgd2Fsayhkb21QYXJzZXIucGFyc2UoaHRtbCkpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBjb25zdCB0cmltSHRtbCA9IGh0bWwgPT4ge1xuICAgICAgY29uc3QgdHJpbVNwYWNlcyA9IChhbGwsIHMxLCBzMikgPT4ge1xuICAgICAgICBpZiAoIXMxICYmICFzMikge1xuICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ic3A7XG4gICAgICB9O1xuICAgICAgaHRtbCA9IGZpbHRlciQxKGh0bWwsIFtcbiAgICAgICAgL15bXFxzXFxTXSo8Ym9keVtePl0qPlxccyp8XFxzKjxcXC9ib2R5W14+XSo+W1xcc1xcU10qJC9pZyxcbiAgICAgICAgLzwhLS1TdGFydEZyYWdtZW50LS0+fDwhLS1FbmRGcmFnbWVudC0tPi9nLFxuICAgICAgICBbXG4gICAgICAgICAgLyggPyk8c3BhbiBjbGFzcz1cIkFwcGxlLWNvbnZlcnRlZC1zcGFjZVwiPlxcdTAwYTA8XFwvc3Bhbj4oID8pL2csXG4gICAgICAgICAgdHJpbVNwYWNlc1xuICAgICAgICBdLFxuICAgICAgICAvPGJyIGNsYXNzPVwiQXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiPi9nLFxuICAgICAgICAvPGJyPiQvaVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUlkR2VuZXJhdG9yID0gcHJlZml4ID0+IHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY291bnQrKztcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRJbWFnZU1pbWVUeXBlID0gZXh0ID0+IHtcbiAgICAgIGNvbnN0IGxvd2VyRXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBtaW1lT3ZlcnJpZGVzID0ge1xuICAgICAgICBqcGc6ICdqcGVnJyxcbiAgICAgICAganBlOiAnanBlZycsXG4gICAgICAgIGpmaTogJ2pwZWcnLFxuICAgICAgICBqaWY6ICdqcGVnJyxcbiAgICAgICAgamZpZjogJ2pwZWcnLFxuICAgICAgICBwanBlZzogJ2pwZWcnLFxuICAgICAgICBwanA6ICdqcGVnJyxcbiAgICAgICAgc3ZnOiAnc3ZnK3htbCdcbiAgICAgIH07XG4gICAgICByZXR1cm4gVG9vbHMuaGFzT3duKG1pbWVPdmVycmlkZXMsIGxvd2VyRXh0KSA/ICdpbWFnZS8nICsgbWltZU92ZXJyaWRlc1tsb3dlckV4dF0gOiAnaW1hZ2UvJyArIGxvd2VyRXh0O1xuICAgIH07XG5cbiAgICBjb25zdCBwcmVQcm9jZXNzID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyID0gRG9tUGFyc2VyKHsgc2FuaXRpemU6IHNob3VsZFNhbml0aXplWHNzKGVkaXRvcikgfSwgZWRpdG9yLnNjaGVtYSk7XG4gICAgICBwYXJzZXIuYWRkTm9kZUZpbHRlcignbWV0YScsIG5vZGVzID0+IHtcbiAgICAgICAgVG9vbHMuZWFjaChub2Rlcywgbm9kZSA9PiB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VyLnBhcnNlKGh0bWwsIHtcbiAgICAgICAgZm9yY2VkX3Jvb3RfYmxvY2s6IGZhbHNlLFxuICAgICAgICBpc1Jvb3RDb250ZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBIdG1sU2VyaWFsaXplcih7IHZhbGlkYXRlOiB0cnVlIH0sIGVkaXRvci5zY2hlbWEpLnNlcmlhbGl6ZShmcmFnbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzUmVzdWx0ID0gKGNvbnRlbnQsIGNhbmNlbGxlZCkgPT4gKHtcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjYW5jZWxsZWRcbiAgICB9KTtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc0ZpbHRlciA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wQm9keSA9IGVkaXRvci5kb20uY3JlYXRlKCdkaXYnLCB7IHN0eWxlOiAnZGlzcGxheTpub25lJyB9LCBodG1sKTtcbiAgICAgIGNvbnN0IHBvc3RQcm9jZXNzQXJncyA9IGZpcmVQYXN0ZVBvc3RQcm9jZXNzKGVkaXRvciwgdGVtcEJvZHksIGludGVybmFsKTtcbiAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHBvc3RQcm9jZXNzQXJncy5ub2RlLmlubmVySFRNTCwgcG9zdFByb2Nlc3NBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbHRlckNvbnRlbnQgPSAoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3QgcHJlUHJvY2Vzc0FyZ3MgPSBmaXJlUGFzdGVQcmVQcm9jZXNzKGVkaXRvciwgY29udGVudCwgaW50ZXJuYWwpO1xuICAgICAgY29uc3QgZmlsdGVyZWRDb250ZW50ID0gcHJlUHJvY2VzcyhlZGl0b3IsIHByZVByb2Nlc3NBcmdzLmNvbnRlbnQpO1xuICAgICAgaWYgKGVkaXRvci5oYXNFdmVudExpc3RlbmVycygnUGFzdGVQb3N0UHJvY2VzcycpICYmICFwcmVQcm9jZXNzQXJncy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NGaWx0ZXIoZWRpdG9yLCBmaWx0ZXJlZENvbnRlbnQsIGludGVybmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KGZpbHRlcmVkQ29udGVudCwgcHJlUHJvY2Vzc0FyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2VzcyA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyQ29udGVudChlZGl0b3IsIGh0bWwsIGludGVybmFsKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFzdGVIdG1sJDEgPSAoZWRpdG9yLCBodG1sKSA9PiB7XG4gICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudChodG1sLCB7XG4gICAgICAgIG1lcmdlOiBzaG91bGRQYXN0ZU1lcmdlRm9ybWF0cyhlZGl0b3IpLFxuICAgICAgICBwYXN0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQWJzb2x1dGVVcmwgPSB1cmwgPT4gL15odHRwcz86XFwvXFwvW1xcd1xcLVxcLys9LiwhOzomJUBefigpe30/I10rJC9pLnRlc3QodXJsKTtcbiAgICBjb25zdCBpc0ltYWdlVXJsID0gKGVkaXRvciwgdXJsKSA9PiB7XG4gICAgICByZXR1cm4gaXNBYnNvbHV0ZVVybCh1cmwpICYmIGV4aXN0cyhnZXRBbGxvd2VkSW1hZ2VGaWxlVHlwZXMoZWRpdG9yKSwgdHlwZSA9PiBlbmRzV2l0aCh1cmwudG9Mb3dlckNhc2UoKSwgYC4keyB0eXBlLnRvTG93ZXJDYXNlKCkgfWApKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUltYWdlID0gKGVkaXRvciwgdXJsLCBwYXN0ZUh0bWxGbikgPT4ge1xuICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLmV4dHJhKCgpID0+IHtcbiAgICAgICAgcGFzdGVIdG1sRm4oZWRpdG9yLCB1cmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBlZGl0b3IuaW5zZXJ0Q29udGVudCgnPGltZyBzcmM9XCInICsgdXJsICsgJ1wiPicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUxpbmsgPSAoZWRpdG9yLCB1cmwsIHBhc3RlSHRtbEZuKSA9PiB7XG4gICAgICBlZGl0b3IudW5kb01hbmFnZXIuZXh0cmEoKCkgPT4ge1xuICAgICAgICBwYXN0ZUh0bWxGbihlZGl0b3IsIHVybCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0TGluaycsIGZhbHNlLCB1cmwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGxpbmtTZWxlY3Rpb24gPSAoZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWxGbikgPT4gIWVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBpc0Fic29sdXRlVXJsKGh0bWwpID8gY3JlYXRlTGluayhlZGl0b3IsIGh0bWwsIHBhc3RlSHRtbEZuKSA6IGZhbHNlO1xuICAgIGNvbnN0IGluc2VydEltYWdlID0gKGVkaXRvciwgaHRtbCwgcGFzdGVIdG1sRm4pID0+IGlzSW1hZ2VVcmwoZWRpdG9yLCBodG1sKSA/IGNyZWF0ZUltYWdlKGVkaXRvciwgaHRtbCwgcGFzdGVIdG1sRm4pIDogZmFsc2U7XG4gICAgY29uc3Qgc21hcnRJbnNlcnRDb250ZW50ID0gKGVkaXRvciwgaHRtbCkgPT4ge1xuICAgICAgVG9vbHMuZWFjaChbXG4gICAgICAgIGxpbmtTZWxlY3Rpb24sXG4gICAgICAgIGluc2VydEltYWdlLFxuICAgICAgICBwYXN0ZUh0bWwkMVxuICAgICAgXSwgYWN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuICFhY3Rpb24oZWRpdG9yLCBodG1sLCBwYXN0ZUh0bWwkMSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydENvbnRlbnQgPSAoZWRpdG9yLCBodG1sLCBwYXN0ZUFzVGV4dCkgPT4ge1xuICAgICAgaWYgKHBhc3RlQXNUZXh0IHx8ICFpc1NtYXJ0UGFzdGVFbmFibGVkKGVkaXRvcikpIHtcbiAgICAgICAgcGFzdGVIdG1sJDEoZWRpdG9yLCBodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNtYXJ0SW5zZXJ0Q29udGVudChlZGl0b3IsIGh0bWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1bmlxdWVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCdtY2VjbGlwJyk7XG4gICAgY29uc3QgY3JlYXRlUGFzdGVEYXRhVHJhbnNmZXIgPSBodG1sID0+IHtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGNyZWF0ZURhdGFUcmFuc2ZlcigpO1xuICAgICAgc2V0SHRtbERhdGEoZGF0YVRyYW5zZmVyLCBodG1sKTtcbiAgICAgIHNldFJlYWRPbmx5TW9kZShkYXRhVHJhbnNmZXIpO1xuICAgICAgcmV0dXJuIGRhdGFUcmFuc2ZlcjtcbiAgICB9O1xuICAgIGNvbnN0IGRvUGFzdGUgPSAoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCwgcGFzdGVBc1RleHQsIHNob3VsZFNpbXVsYXRlSW5wdXRFdmVudCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gcHJvY2VzcyhlZGl0b3IsIGNvbnRlbnQsIGludGVybmFsKTtcbiAgICAgIGlmICghcmVzLmNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVzLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGRvUGFzdGVBY3Rpb24gPSAoKSA9PiBpbnNlcnRDb250ZW50KGVkaXRvciwgY29udGVudCwgcGFzdGVBc1RleHQpO1xuICAgICAgICBpZiAoc2hvdWxkU2ltdWxhdGVJbnB1dEV2ZW50KSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IGZpcmVCZWZvcmVJbnB1dEV2ZW50KGVkaXRvciwgJ2luc2VydEZyb21QYXN0ZScsIHsgZGF0YVRyYW5zZmVyOiBjcmVhdGVQYXN0ZURhdGFUcmFuc2Zlcihjb250ZW50KSB9KTtcbiAgICAgICAgICBpZiAoIWFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIGRvUGFzdGVBY3Rpb24oKTtcbiAgICAgICAgICAgIGZpcmVJbnB1dEV2ZW50KGVkaXRvciwgJ2luc2VydEZyb21QYXN0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb1Bhc3RlQWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhc3RlSHRtbCA9IChlZGl0b3IsIGh0bWwsIGludGVybmFsRmxhZywgc2hvdWxkU2ltdWxhdGVJbnB1dEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpbnRlcm5hbCA9IGludGVybmFsRmxhZyA/IGludGVybmFsRmxhZyA6IGlzTWFya2VkKGh0bWwpO1xuICAgICAgZG9QYXN0ZShlZGl0b3IsIHVubWFyayhodG1sKSwgaW50ZXJuYWwsIGZhbHNlLCBzaG91bGRTaW11bGF0ZUlucHV0RXZlbnQpO1xuICAgIH07XG4gICAgY29uc3QgcGFzdGVUZXh0ID0gKGVkaXRvciwgdGV4dCwgc2hvdWxkU2ltdWxhdGVJbnB1dEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVkVGV4dCA9IGVkaXRvci5kb20uZW5jb2RlKHRleHQpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICBjb25zdCBub3JtYWxpemVkVGV4dCA9IG5vcm1hbGl6ZSQ0KGVuY29kZWRUZXh0LCBnZXRQYXN0ZVRhYlNwYWNlcyhlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGh0bWwgPSB0b0Jsb2NrRWxlbWVudHMobm9ybWFsaXplZFRleHQsIGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpLCBnZXRGb3JjZWRSb290QmxvY2tBdHRycyhlZGl0b3IpKTtcbiAgICAgIGRvUGFzdGUoZWRpdG9yLCBodG1sLCBmYWxzZSwgdHJ1ZSwgc2hvdWxkU2ltdWxhdGVJbnB1dEV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldERhdGFUcmFuc2Zlckl0ZW1zID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0ge307XG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGRhdGFUcmFuc2Zlci50eXBlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFUcmFuc2Zlci50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gZGF0YVRyYW5zZmVyLnR5cGVzW2ldO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtc1tjb250ZW50VHlwZV0gPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YShjb250ZW50VHlwZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGl0ZW1zW2NvbnRlbnRUeXBlXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG4gICAgY29uc3QgaGFzQ29udGVudFR5cGUgPSAoY2xpcGJvYXJkQ29udGVudCwgbWltZVR5cGUpID0+IG1pbWVUeXBlIGluIGNsaXBib2FyZENvbnRlbnQgJiYgY2xpcGJvYXJkQ29udGVudFttaW1lVHlwZV0ubGVuZ3RoID4gMDtcbiAgICBjb25zdCBoYXNIdG1sT3JUZXh0ID0gY29udGVudCA9PiBoYXNDb250ZW50VHlwZShjb250ZW50LCAndGV4dC9odG1sJykgfHwgaGFzQ29udGVudFR5cGUoY29udGVudCwgJ3RleHQvcGxhaW4nKTtcbiAgICBjb25zdCBleHRyYWN0RmlsZW5hbWUgPSAoZWRpdG9yLCBzdHIpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBzdHIubWF0Y2goLyhbXFxzXFxTXSs/KSg/OlxcLlthLXowLTkuXSspJC9pKTtcbiAgICAgIHJldHVybiBpc05vbk51bGxhYmxlKG0pID8gZWRpdG9yLmRvbS5lbmNvZGUobVsxXSkgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVCbG9iSW5mbyA9IChlZGl0b3IsIGJsb2JDYWNoZSwgZmlsZSwgYmFzZTY0KSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHVuaXF1ZUlkKCk7XG4gICAgICBjb25zdCB1c2VGaWxlTmFtZSA9IHNob3VsZFJldXNlRmlsZU5hbWUoZWRpdG9yKSAmJiBpc05vbk51bGxhYmxlKGZpbGUubmFtZSk7XG4gICAgICBjb25zdCBuYW1lID0gdXNlRmlsZU5hbWUgPyBleHRyYWN0RmlsZW5hbWUoZWRpdG9yLCBmaWxlLm5hbWUpIDogaWQ7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHVzZUZpbGVOYW1lID8gZmlsZS5uYW1lIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgYmxvYkluZm8gPSBibG9iQ2FjaGUuY3JlYXRlKGlkLCBmaWxlLCBiYXNlNjQsIG5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIGJsb2JDYWNoZS5hZGQoYmxvYkluZm8pO1xuICAgICAgcmV0dXJuIGJsb2JJbmZvO1xuICAgIH07XG4gICAgY29uc3QgcGFzdGVJbWFnZSA9IChlZGl0b3IsIGltYWdlSXRlbSkgPT4ge1xuICAgICAgcGFyc2VEYXRhVXJpKGltYWdlSXRlbS51cmkpLmVhY2goKHtkYXRhLCB0eXBlLCBiYXNlNjRFbmNvZGVkfSkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRFbmNvZGVkID8gZGF0YSA6IGJ0b2EoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBpbWFnZUl0ZW0uZmlsZTtcbiAgICAgICAgY29uc3QgYmxvYkNhY2hlID0gZWRpdG9yLmVkaXRvclVwbG9hZC5ibG9iQ2FjaGU7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQmxvYkluZm8gPSBibG9iQ2FjaGUuZ2V0QnlEYXRhKGJhc2U2NCwgdHlwZSk7XG4gICAgICAgIGNvbnN0IGJsb2JJbmZvID0gZXhpc3RpbmdCbG9iSW5mbyAhPT0gbnVsbCAmJiBleGlzdGluZ0Jsb2JJbmZvICE9PSB2b2lkIDAgPyBleGlzdGluZ0Jsb2JJbmZvIDogY3JlYXRlQmxvYkluZm8oZWRpdG9yLCBibG9iQ2FjaGUsIGZpbGUsIGJhc2U2NCk7XG4gICAgICAgIHBhc3RlSHRtbChlZGl0b3IsIGA8aW1nIHNyYz1cIiR7IGJsb2JJbmZvLmJsb2JVcmkoKSB9XCI+YCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0NsaXBib2FyZEV2ZW50ID0gZXZlbnQgPT4gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJztcbiAgICBjb25zdCByZWFkRmlsZXNBc0RhdGFVcmlzID0gaXRlbXMgPT4gUHJvbWlzZS5hbGwobWFwJDMoaXRlbXMsIGZpbGUgPT4ge1xuICAgICAgcmV0dXJuIGJsb2JUb0RhdGFVcmkoZmlsZSkudGhlbih1cmkgPT4gKHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgdXJpXG4gICAgICB9KSk7XG4gICAgfSkpO1xuICAgIGNvbnN0IGlzSW1hZ2UgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgYWxsb3dlZEV4dGVuc2lvbnMgPSBnZXRBbGxvd2VkSW1hZ2VGaWxlVHlwZXMoZWRpdG9yKTtcbiAgICAgIHJldHVybiBmaWxlID0+IHN0YXJ0c1dpdGgoZmlsZS50eXBlLCAnaW1hZ2UvJykgJiYgZXhpc3RzKGFsbG93ZWRFeHRlbnNpb25zLCBleHRlbnNpb24gPT4ge1xuICAgICAgICByZXR1cm4gZ2V0SW1hZ2VNaW1lVHlwZShleHRlbnNpb24pID09PSBmaWxlLnR5cGU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEltYWdlc0Zyb21EYXRhVHJhbnNmZXIgPSAoZWRpdG9yLCBkYXRhVHJhbnNmZXIpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gZGF0YVRyYW5zZmVyLml0ZW1zID8gYmluZCQzKGZyb20oZGF0YVRyYW5zZmVyLml0ZW1zKSwgaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLmtpbmQgPT09ICdmaWxlJyA/IFtpdGVtLmdldEFzRmlsZSgpXSA6IFtdO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGNvbnN0IGZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzID8gZnJvbShkYXRhVHJhbnNmZXIuZmlsZXMpIDogW107XG4gICAgICByZXR1cm4gZmlsdGVyJDUoaXRlbXMubGVuZ3RoID4gMCA/IGl0ZW1zIDogZmlsZXMsIGlzSW1hZ2UoZWRpdG9yKSk7XG4gICAgfTtcbiAgICBjb25zdCBwYXN0ZUltYWdlRGF0YSA9IChlZGl0b3IsIGUsIHJuZykgPT4ge1xuICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gaXNDbGlwYm9hcmRFdmVudChlKSA/IGUuY2xpcGJvYXJkRGF0YSA6IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgaWYgKHNob3VsZFBhc3RlRGF0YUltYWdlcyhlZGl0b3IpICYmIGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBjb25zdCBpbWFnZXMgPSBnZXRJbWFnZXNGcm9tRGF0YVRyYW5zZmVyKGVkaXRvciwgZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgaWYgKGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJlYWRGaWxlc0FzRGF0YVVyaXMoaW1hZ2VzKS50aGVuKGZpbGVSZXN1bHRzID0+IHtcbiAgICAgICAgICAgIGlmIChybmcpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhY2gkZShmaWxlUmVzdWx0cywgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgcGFzdGVJbWFnZShlZGl0b3IsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNCcm9rZW5BbmRyb2lkQ2xpcGJvYXJkRXZlbnQgPSBlID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gRW52Lm9zLmlzQW5kcm9pZCgpICYmICgoX2IgPSAoX2EgPSBlLmNsaXBib2FyZERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBpc0tleWJvYXJkUGFzdGVFdmVudCA9IGUgPT4gVksubWV0YUtleVByZXNzZWQoZSkgJiYgZS5rZXlDb2RlID09PSA4NiB8fCBlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0gNDU7XG4gICAgY29uc3QgaW5zZXJ0Q2xpcGJvYXJkQ29udGVudCA9IChlZGl0b3IsIGNsaXBib2FyZENvbnRlbnQsIGh0bWwsIHBsYWluVGV4dE1vZGUsIHNob3VsZFNpbXVsYXRlSW5wdXRFdmVudCkgPT4ge1xuICAgICAgbGV0IGNvbnRlbnQgPSB0cmltSHRtbChodG1sKTtcbiAgICAgIGNvbnN0IGlzSW50ZXJuYWwgPSBoYXNDb250ZW50VHlwZShjbGlwYm9hcmRDb250ZW50LCBpbnRlcm5hbEh0bWxNaW1lKCkpIHx8IGlzTWFya2VkKGh0bWwpO1xuICAgICAgY29uc3QgaXNQbGFpblRleHRIdG1sID0gIWlzSW50ZXJuYWwgJiYgaXNQbGFpblRleHQoY29udGVudCk7XG4gICAgICBjb25zdCBpc0Fic29sdXRlVXJsJDEgPSBpc0Fic29sdXRlVXJsKGNvbnRlbnQpO1xuICAgICAgaWYgKGlzRGVmYXVsdFBhc3RlQmluQ29udGVudChjb250ZW50KSB8fCAhY29udGVudC5sZW5ndGggfHwgaXNQbGFpblRleHRIdG1sICYmICFpc0Fic29sdXRlVXJsJDEpIHtcbiAgICAgICAgcGxhaW5UZXh0TW9kZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocGxhaW5UZXh0TW9kZSB8fCBpc0Fic29sdXRlVXJsJDEpIHtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnRUeXBlKGNsaXBib2FyZENvbnRlbnQsICd0ZXh0L3BsYWluJykgJiYgaXNQbGFpblRleHRIdG1sKSB7XG4gICAgICAgICAgY29udGVudCA9IGNsaXBib2FyZENvbnRlbnRbJ3RleHQvcGxhaW4nXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gaW5uZXJUZXh0KGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWZhdWx0UGFzdGVCaW5Db250ZW50KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFpblRleHRNb2RlKSB7XG4gICAgICAgIHBhc3RlVGV4dChlZGl0b3IsIGNvbnRlbnQsIHNob3VsZFNpbXVsYXRlSW5wdXRFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCBjb250ZW50LCBpc0ludGVybmFsLCBzaG91bGRTaW11bGF0ZUlucHV0RXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJFdmVudEhhbmRsZXJzID0gKGVkaXRvciwgcGFzdGVCaW4sIHBhc3RlRm9ybWF0KSA9PiB7XG4gICAgICBsZXQga2V5Ym9hcmRQYXN0ZVBsYWluVGV4dFN0YXRlO1xuICAgICAgY29uc3QgZ2V0TGFzdFJuZyA9ICgpID0+IHBhc3RlQmluLmdldExhc3RSbmcoKSB8fCBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgIGlmIChpc0tleWJvYXJkUGFzdGVFdmVudChlKSAmJiAhZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZSA9IGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSA4NjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iub24oJ3Bhc3RlJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGlzQnJva2VuQW5kcm9pZENsaXBib2FyZEV2ZW50KGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWluVGV4dE1vZGUgPSBwYXN0ZUZvcm1hdC5nZXQoKSA9PT0gJ3RleHQnIHx8IGtleWJvYXJkUGFzdGVQbGFpblRleHRTdGF0ZTtcbiAgICAgICAga2V5Ym9hcmRQYXN0ZVBsYWluVGV4dFN0YXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsaXBib2FyZENvbnRlbnQgPSBnZXREYXRhVHJhbnNmZXJJdGVtcyhlLmNsaXBib2FyZERhdGEpO1xuICAgICAgICBpZiAoIWhhc0h0bWxPclRleHQoY2xpcGJvYXJkQ29udGVudCkgJiYgcGFzdGVJbWFnZURhdGEoZWRpdG9yLCBlLCBnZXRMYXN0Um5nKCkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDb250ZW50VHlwZShjbGlwYm9hcmRDb250ZW50LCAndGV4dC9odG1sJykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaW5zZXJ0Q2xpcGJvYXJkQ29udGVudChlZGl0b3IsIGNsaXBib2FyZENvbnRlbnQsIGNsaXBib2FyZENvbnRlbnRbJ3RleHQvaHRtbCddLCBwbGFpblRleHRNb2RlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDb250ZW50VHlwZShjbGlwYm9hcmRDb250ZW50LCAndGV4dC9wbGFpbicpICYmIGhhc0NvbnRlbnRUeXBlKGNsaXBib2FyZENvbnRlbnQsICd0ZXh0L3VyaS1saXN0JykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaW5zZXJ0Q2xpcGJvYXJkQ29udGVudChlZGl0b3IsIGNsaXBib2FyZENvbnRlbnQsIGNsaXBib2FyZENvbnRlbnRbJ3RleHQvcGxhaW4nXSwgcGxhaW5UZXh0TW9kZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFzdGVCaW4uY3JlYXRlKCk7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBwYXN0ZUJpbi5nZXRIdG1sKCk7XG4gICAgICAgICAgICBwYXN0ZUJpbi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGluc2VydENsaXBib2FyZENvbnRlbnQoZWRpdG9yLCBjbGlwYm9hcmRDb250ZW50LCBodG1sLCBwbGFpblRleHRNb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJEYXRhSW1hZ2VGaWx0ZXIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaXNXZWJLaXRGYWtlVXJsID0gc3JjID0+IHN0YXJ0c1dpdGgoc3JjLCAnd2Via2l0LWZha2UtdXJsJyk7XG4gICAgICBjb25zdCBpc0RhdGFVcmkgPSBzcmMgPT4gc3RhcnRzV2l0aChzcmMsICdkYXRhOicpO1xuICAgICAgY29uc3QgaXNQYXN0ZUluc2VydCA9IGFyZ3MgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gYXJncy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFzdGUpID09PSB0cnVlO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkTm9kZUZpbHRlcignaW1nJywgKG5vZGVzLCBuYW1lLCBhcmdzKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkUGFzdGVEYXRhSW1hZ2VzKGVkaXRvcikgJiYgaXNQYXN0ZUluc2VydChhcmdzKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gbm9kZS5hdHRyKCdzcmMnKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhzcmMpICYmICFub2RlLmF0dHIoJ2RhdGEtbWNlLW9iamVjdCcpICYmIHNyYyAhPT0gRW52LnRyYW5zcGFyZW50U3JjKSB7XG4gICAgICAgICAgICAgIGlmIChpc1dlYktpdEZha2VVcmwoc3JjKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZEFsbG93SHRtbERhdGFVcmxzKGVkaXRvcikgJiYgaXNEYXRhVXJpKHNyYykpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRzQW5kRmlsdGVycyA9IChlZGl0b3IsIHBhc3RlQmluLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGVkaXRvciwgcGFzdGVCaW4sIHBhc3RlRm9ybWF0KTtcbiAgICAgIHJlZ2lzdGVyRGF0YUltYWdlRmlsdGVyKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZVBsYWluVGV4dFBhc3RlID0gKGVkaXRvciwgcGFzdGVGb3JtYXQpID0+IHtcbiAgICAgIGlmIChwYXN0ZUZvcm1hdC5nZXQoKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHBhc3RlRm9ybWF0LnNldCgnaHRtbCcpO1xuICAgICAgICBmaXJlUGFzdGVQbGFpblRleHRUb2dnbGUoZWRpdG9yLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXN0ZUZvcm1hdC5zZXQoJ3RleHQnKTtcbiAgICAgICAgZmlyZVBhc3RlUGxhaW5UZXh0VG9nZ2xlKGVkaXRvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyJDEgPSAoZWRpdG9yLCBwYXN0ZUZvcm1hdCkgPT4ge1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ21jZVRvZ2dsZVBsYWluVGV4dFBhc3RlJywgKCkgPT4ge1xuICAgICAgICB0b2dnbGVQbGFpblRleHRQYXN0ZShlZGl0b3IsIHBhc3RlRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLmFkZENvbW1hbmQoJ21jZUluc2VydENsaXBib2FyZENvbnRlbnQnLCAodWksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZS5odG1sKSB7XG4gICAgICAgICAgcGFzdGVIdG1sKGVkaXRvciwgdmFsdWUuaHRtbCwgdmFsdWUuaW50ZXJuYWwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudGV4dCkge1xuICAgICAgICAgIHBhc3RlVGV4dChlZGl0b3IsIHZhbHVlLnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNldEh0bWw1Q2xpcGJvYXJkID0gKGNsaXBib2FyZERhdGEsIGh0bWwsIHRleHQpID0+IHtcbiAgICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGh0bWwpO1xuICAgICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHRleHQpO1xuICAgICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YShpbnRlcm5hbEh0bWxNaW1lKCksIGh0bWwpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRDbGlwYm9hcmREYXRhID0gKGV2dCwgZGF0YSwgZmFsbGJhY2ssIGRvbmUpID0+IHtcbiAgICAgIGlmIChzZXRIdG1sNUNsaXBib2FyZChldnQuY2xpcGJvYXJkRGF0YSwgZGF0YS5odG1sLCBkYXRhLnRleHQpKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWxsYmFjayhkYXRhLmh0bWwsIGRvbmUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmFsbGJhY2sgPSBlZGl0b3IgPT4gKGh0bWwsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IHtkb20sIHNlbGVjdGlvbn0gPSBlZGl0b3I7XG4gICAgICBjb25zdCBvdXRlciA9IGRvbS5jcmVhdGUoJ2RpdicsIHtcbiAgICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdmYWxzZScsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlubmVyID0gZG9tLmNyZWF0ZSgnZGl2JywgeyBjb250ZW50ZWRpdGFibGU6ICd0cnVlJyB9LCBodG1sKTtcbiAgICAgIGRvbS5zZXRTdHlsZXMob3V0ZXIsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBsZWZ0OiAnLTMwMDBweCcsXG4gICAgICAgIHdpZHRoOiAnMTAwMHB4JyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICB9KTtcbiAgICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgIGRvbS5hZGQoZWRpdG9yLmdldEJvZHkoKSwgb3V0ZXIpO1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBpbm5lci5mb2N1cygpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuUmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBvZmZzY3JlZW5SYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoaW5uZXIpO1xuICAgICAgc2VsZWN0aW9uLnNldFJuZyhvZmZzY3JlZW5SYW5nZSk7XG4gICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgZG9tLnJlbW92ZShvdXRlcik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RGF0YSA9IGVkaXRvciA9PiAoe1xuICAgICAgaHRtbDogbWFyayhlZGl0b3Iuc2VsZWN0aW9uLmdldENvbnRlbnQoeyBjb250ZXh0dWFsOiB0cnVlIH0pKSxcbiAgICAgIHRleHQ6IGVkaXRvci5zZWxlY3Rpb24uZ2V0Q29udGVudCh7IGZvcm1hdDogJ3RleHQnIH0pXG4gICAgfSk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9IGVkaXRvciA9PiAhIWVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ3RkW2RhdGEtbWNlLXNlbGVjdGVkXSx0aFtkYXRhLW1jZS1zZWxlY3RlZF0nLCBlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICBjb25zdCBoYXNTZWxlY3RlZENvbnRlbnQgPSBlZGl0b3IgPT4gIWVkaXRvci5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBpc1RhYmxlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgY29uc3QgY3V0ID0gZWRpdG9yID0+IGV2dCA9PiB7XG4gICAgICBpZiAoIWV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBoYXNTZWxlY3RlZENvbnRlbnQoZWRpdG9yKSkge1xuICAgICAgICBzZXRDbGlwYm9hcmREYXRhKGV2dCwgZ2V0RGF0YShlZGl0b3IpLCBmYWxsYmFjayhlZGl0b3IpLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKEVudi5icm93c2VyLmlzQ2hyb21pdW0oKSB8fCBFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnRGVsZXRlJyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdEZWxldGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY29weSA9IGVkaXRvciA9PiBldnQgPT4ge1xuICAgICAgaWYgKCFldnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgaGFzU2VsZWN0ZWRDb250ZW50KGVkaXRvcikpIHtcbiAgICAgICAgc2V0Q2xpcGJvYXJkRGF0YShldnQsIGdldERhdGEoZWRpdG9yKSwgZmFsbGJhY2soZWRpdG9yKSwgbm9vcCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2N1dCcsIGN1dChlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5vbignY29weScsIGNvcHkoZWRpdG9yKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENhcmV0UmFuZ2VGcm9tRXZlbnQgPSAoZWRpdG9yLCBlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIFJhbmdlVXRpbHMuZ2V0Q2FyZXRSYW5nZUZyb21Qb2ludCgoX2EgPSBlLmNsaWVudFgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsIChfYiA9IGUuY2xpZW50WSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCwgZWRpdG9yLmdldERvYygpKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzUGxhaW5UZXh0RmlsZVVybCA9IGNvbnRlbnQgPT4ge1xuICAgICAgY29uc3QgcGxhaW5UZXh0Q29udGVudCA9IGNvbnRlbnRbJ3RleHQvcGxhaW4nXTtcbiAgICAgIHJldHVybiBwbGFpblRleHRDb250ZW50ID8gcGxhaW5UZXh0Q29udGVudC5pbmRleE9mKCdmaWxlOi8vJykgPT09IDAgOiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEZvY3VzZWRSYW5nZSA9IChlZGl0b3IsIHJuZykgPT4ge1xuICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICBpZiAocm5nKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYXNJbWFnZSA9IGRhdGFUcmFuc2ZlciA9PiBleGlzdHMoZGF0YVRyYW5zZmVyLmZpbGVzLCBmaWxlID0+IC9eaW1hZ2VcXC8vLnRlc3QoZmlsZS50eXBlKSk7XG4gICAgY29uc3QgbmVlZHNDdXN0b21JbnRlcm5hbERyb3AgPSAoZG9tLCBzY2hlbWEsIHRhcmdldCwgZHJvcENvbnRlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudFRyYW5zcGFyZW50ID0gZG9tLmdldFBhcmVudCh0YXJnZXQsIG5vZGUgPT4gaXNUcmFuc3BhcmVudEJsb2NrKHNjaGVtYSwgbm9kZSkpO1xuICAgICAgY29uc3QgaW5TdW1tYXJ5ID0gIWlzTnVsbChkb20uZ2V0UGFyZW50KHRhcmdldCwgJ3N1bW1hcnknKSk7XG4gICAgICBpZiAoaW5TdW1tYXJ5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnRUcmFuc3BhcmVudCAmJiBoYXMkMihkcm9wQ29udGVudCwgJ3RleHQvaHRtbCcpKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkcm9wQ29udGVudFsndGV4dC9odG1sJ10sICd0ZXh0L2h0bWwnKS5ib2R5O1xuICAgICAgICByZXR1cm4gIWlzTnVsbChmcmFnbWVudC5xdWVyeVNlbGVjdG9yKHBhcmVudFRyYW5zcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldHVwU3VtbWFyeURlbGV0ZUJ5RHJhZ0ZpeCA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2lucHV0JywgZSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc05vU3VtbWFyeSA9IGVsID0+IGlzTnVsbChlbC5xdWVyeVNlbGVjdG9yKCdzdW1tYXJ5JykpO1xuICAgICAgICBpZiAoZS5pbnB1dFR5cGUgPT09ICdkZWxldGVCeURyYWcnKSB7XG4gICAgICAgICAgY29uc3QgYnJva2VuRGV0YWlsRWxlbWVudHMgPSBmaWx0ZXIkNShlZGl0b3IuZG9tLnNlbGVjdCgnZGV0YWlscycpLCBoYXNOb1N1bW1hcnkpO1xuICAgICAgICAgIGVhY2gkZShicm9rZW5EZXRhaWxFbGVtZW50cywgZGV0YWlscyA9PiB7XG4gICAgICAgICAgICBpZiAoaXNCciQ2KGRldGFpbHMuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgZGV0YWlscy5maXJzdENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IGVkaXRvci5kb20uY3JlYXRlKCdzdW1tYXJ5Jyk7XG4gICAgICAgICAgICBzdW1tYXJ5LmFwcGVuZENoaWxkKGNyZWF0ZVBhZGRpbmdCcigpLmRvbSk7XG4gICAgICAgICAgICBkZXRhaWxzLnByZXBlbmQoc3VtbWFyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkYSA9IChlZGl0b3IsIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlKSA9PiB7XG4gICAgICBpZiAoc2hvdWxkUGFzdGVCbG9ja0Ryb3AoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ2RyYWdlbmQgZHJhZ292ZXIgZHJhZ2dlc3R1cmUgZHJhZ2Ryb3AgZHJvcCBkcmFnJywgZSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ2Ryb3AnLCBlID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGhhc0ltYWdlKGRhdGFUcmFuc2ZlcikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLm9uKCdkcm9wJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJuZyA9IGdldENhcmV0UmFuZ2VGcm9tRXZlbnQoZWRpdG9yLCBlKTtcbiAgICAgICAgaWYgKGlzTnVsbGFibGUocm5nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wQ29udGVudCA9IGdldERhdGFUcmFuc2Zlckl0ZW1zKGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBoYXNDb250ZW50VHlwZShkcm9wQ29udGVudCwgaW50ZXJuYWxIdG1sTWltZSgpKTtcbiAgICAgICAgaWYgKCghaGFzSHRtbE9yVGV4dChkcm9wQ29udGVudCkgfHwgaXNQbGFpblRleHRGaWxlVXJsKGRyb3BDb250ZW50KSkgJiYgcGFzdGVJbWFnZURhdGEoZWRpdG9yLCBlLCBybmcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVybmFsQ29udGVudCA9IGRyb3BDb250ZW50W2ludGVybmFsSHRtbE1pbWUoKV07XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpbnRlcm5hbENvbnRlbnQgfHwgZHJvcENvbnRlbnRbJ3RleHQvaHRtbCddIHx8IGRyb3BDb250ZW50Wyd0ZXh0L3BsYWluJ107XG4gICAgICAgIGNvbnN0IG5lZWRzSW50ZXJuYWxEcm9wID0gbmVlZHNDdXN0b21JbnRlcm5hbERyb3AoZWRpdG9yLmRvbSwgZWRpdG9yLnNjaGVtYSwgcm5nLnN0YXJ0Q29udGFpbmVyLCBkcm9wQ29udGVudCk7XG4gICAgICAgIGNvbnN0IGlzSW50ZXJuYWxEcm9wID0gZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUuZ2V0KCk7XG4gICAgICAgIGlmIChpc0ludGVybmFsRHJvcCAmJiAhbmVlZHNJbnRlcm5hbERyb3ApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbENvbnRlbnQgfHwgaXNJbnRlcm5hbERyb3AgJiYgbmVlZHNJbnRlcm5hbERyb3ApIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ0RlbGV0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldEZvY3VzZWRSYW5nZShlZGl0b3IsIHJuZyk7XG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRDb250ZW50ID0gdHJpbUh0bWwoY29udGVudCk7XG4gICAgICAgICAgICAgIGlmIChkcm9wQ29udGVudFsndGV4dC9odG1sJ10pIHtcbiAgICAgICAgICAgICAgICBwYXN0ZUh0bWwoZWRpdG9yLCB0cmltbWVkQ29udGVudCwgaW50ZXJuYWwsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhc3RlVGV4dChlZGl0b3IsIHRyaW1tZWRDb250ZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnc3RhcnQnLCBfZSA9PiB7XG4gICAgICAgIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlLnNldCh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdkcmFnb3ZlciBkcmFnZW5kJywgZSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRQYXN0ZURhdGFJbWFnZXMoZWRpdG9yKSAmJiAhZHJhZ2dpbmdJbnRlcm5hbGx5U3RhdGUuZ2V0KCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0Rm9jdXNlZFJhbmdlKGVkaXRvciwgZ2V0Q2FyZXRSYW5nZUZyb21FdmVudChlZGl0b3IsIGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50eXBlID09PSAnZHJhZ2VuZCcpIHtcbiAgICAgICAgICBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZS5zZXQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldHVwU3VtbWFyeURlbGV0ZUJ5RHJhZ0ZpeChlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQ5ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHByb2Nlc3NFdmVudCA9IGYgPT4gZSA9PiB7XG4gICAgICAgIGYoZWRpdG9yLCBlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBwcmVQcm9jZXNzID0gZ2V0UGFzdGVQcmVQcm9jZXNzKGVkaXRvcik7XG4gICAgICBpZiAoaXNGdW5jdGlvbihwcmVQcm9jZXNzKSkge1xuICAgICAgICBlZGl0b3Iub24oJ1Bhc3RlUHJlUHJvY2VzcycsIHByb2Nlc3NFdmVudChwcmVQcm9jZXNzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3N0UHJvY2VzcyA9IGdldFBhc3RlUG9zdFByb2Nlc3MoZWRpdG9yKTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHBvc3RQcm9jZXNzKSkge1xuICAgICAgICBlZGl0b3Iub24oJ1Bhc3RlUG9zdFByb2Nlc3MnLCBwcm9jZXNzRXZlbnQocG9zdFByb2Nlc3MpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWRkUHJlUHJvY2Vzc0ZpbHRlciA9IChlZGl0b3IsIGZpbHRlckZ1bmMpID0+IHtcbiAgICAgIGVkaXRvci5vbignUGFzdGVQcmVQcm9jZXNzJywgZSA9PiB7XG4gICAgICAgIGUuY29udGVudCA9IGZpbHRlckZ1bmMoZWRpdG9yLCBlLmNvbnRlbnQsIGUuaW50ZXJuYWwpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZ2JSZWdFeHAgPSAvcmdiXFxzKlxcKFxccyooWzAtOV0rKVxccyosXFxzKihbMC05XSspXFxzKixcXHMqKFswLTldKylcXHMqXFwpL2dpO1xuICAgIGNvbnN0IHJnYlRvSGV4ID0gdmFsdWUgPT4gVG9vbHMudHJpbSh2YWx1ZSkucmVwbGFjZShyZ2JSZWdFeHAsIHJnYmFUb0hleFN0cmluZykudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCByZW1vdmVXZWJLaXRTdHlsZXMgPSAoZWRpdG9yLCBjb250ZW50LCBpbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3Qgd2ViS2l0U3R5bGVzT3B0aW9uID0gZ2V0UGFzdGVXZWJraXRTdHlsZXMoZWRpdG9yKTtcbiAgICAgIGlmIChpbnRlcm5hbCB8fCB3ZWJLaXRTdHlsZXNPcHRpb24gPT09ICdhbGwnIHx8ICFzaG91bGRQYXN0ZVJlbW92ZVdlYktpdFN0eWxlcyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgd2ViS2l0U3R5bGVzID0gd2ViS2l0U3R5bGVzT3B0aW9uID8gd2ViS2l0U3R5bGVzT3B0aW9uLnNwbGl0KC9bLCBdLykgOiBbXTtcbiAgICAgIGlmICh3ZWJLaXRTdHlsZXMgJiYgd2ViS2l0U3R5bGVzT3B0aW9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbSwgbm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oPFtePl0rKSBzdHlsZT1cIihbXlwiXSopXCIoW14+XSo+KS9naSwgKGFsbCwgYmVmb3JlLCB2YWx1ZSwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnB1dFN0eWxlcyA9IGRvbS5wYXJzZVN0eWxlKGRvbS5kZWNvZGUodmFsdWUpKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTdHlsZXMgPSB7fTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlYktpdFN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGlucHV0U3R5bGVzW3dlYktpdFN0eWxlc1tpXV07XG4gICAgICAgICAgICBsZXQgY29tcGFyZUlucHV0ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBkb20uZ2V0U3R5bGUobm9kZSwgd2ViS2l0U3R5bGVzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICgvY29sb3IvLnRlc3Qod2ViS2l0U3R5bGVzW2ldKSkge1xuICAgICAgICAgICAgICBjb21wYXJlSW5wdXQgPSByZ2JUb0hleChjb21wYXJlSW5wdXQpO1xuICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSByZ2JUb0hleChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gY29tcGFyZUlucHV0KSB7XG4gICAgICAgICAgICAgIG91dHB1dFN0eWxlc1t3ZWJLaXRTdHlsZXNbaV1dID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3R5bGUgPSBkb20uc2VyaWFsaXplU3R5bGUob3V0cHV0U3R5bGVzLCAnc3BhbicpO1xuICAgICAgICAgIGlmIChvdXRwdXRTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArICcgc3R5bGU9XCInICsgb3V0cHV0U3R5bGUgKyAnXCInICsgYWZ0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiZWZvcmUgKyBhZnRlcjtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oPFtePl0rKSBzdHlsZT1cIihbXlwiXSopXCIoW14+XSo+KS9naSwgJyQxJDMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLyg8W14+XSspIGRhdGEtbWNlLXN0eWxlPVwiKFteXCJdKylcIihbXj5dKj4pL2dpLCAoYWxsLCBiZWZvcmUsIHZhbHVlLCBhZnRlcikgPT4ge1xuICAgICAgICByZXR1cm4gYmVmb3JlICsgJyBzdHlsZT1cIicgKyB2YWx1ZSArICdcIicgKyBhZnRlcjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCQ4ID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChFbnYuYnJvd3Nlci5pc0Nocm9taXVtKCkgfHwgRW52LmJyb3dzZXIuaXNTYWZhcmkoKSkge1xuICAgICAgICBhZGRQcmVQcm9jZXNzRmlsdGVyKGVkaXRvciwgcmVtb3ZlV2ViS2l0U3R5bGVzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkNyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBkcmFnZ2luZ0ludGVybmFsbHlTdGF0ZSA9IENlbGwoZmFsc2UpO1xuICAgICAgY29uc3QgcGFzdGVGb3JtYXQgPSBDZWxsKGlzUGFzdGVBc1RleHRFbmFibGVkKGVkaXRvcikgPyAndGV4dCcgOiAnaHRtbCcpO1xuICAgICAgY29uc3QgcGFzdGVCaW4gPSBQYXN0ZUJpbihlZGl0b3IpO1xuICAgICAgc2V0dXAkOChlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXIkMShlZGl0b3IsIHBhc3RlRm9ybWF0KTtcbiAgICAgIHNldHVwJDkoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5vbignUHJlSW5pdCcsICgpID0+IHtcbiAgICAgICAgcmVnaXN0ZXIoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkYShlZGl0b3IsIGRyYWdnaW5nSW50ZXJuYWxseVN0YXRlKTtcbiAgICAgICAgcmVnaXN0ZXJFdmVudHNBbmRGaWx0ZXJzKGVkaXRvciwgcGFzdGVCaW4sIHBhc3RlRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBwcmV2ZW50U3VtbWFyeVRvZ2dsZSA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3Iub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3IuZG9tLmdldFBhcmVudChlLnRhcmdldCwgJ2RldGFpbHMnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaWx0ZXJEZXRhaWxzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5wYXJzZXIuYWRkTm9kZUZpbHRlcignZGV0YWlscycsIGVsbXMgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsU3RhdGVPcHRpb24gPSBnZXREZXRhaWxzSW5pdGlhbFN0YXRlKGVkaXRvcik7XG4gICAgICAgIGVhY2gkZShlbG1zLCBkZXRhaWxzID0+IHtcbiAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlT3B0aW9uID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmF0dHIoJ29wZW4nLCAnb3BlbicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFN0YXRlT3B0aW9uID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgZGV0YWlscy5hdHRyKCdvcGVuJywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkTm9kZUZpbHRlcignZGV0YWlscycsIGVsbXMgPT4ge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkU3RhdGVPcHRpb24gPSBnZXREZXRhaWxzU2VyaWFsaXplZFN0YXRlKGVkaXRvcik7XG4gICAgICAgIGVhY2gkZShlbG1zLCBkZXRhaWxzID0+IHtcbiAgICAgICAgICBpZiAoc2VyaWFsaXplZFN0YXRlT3B0aW9uID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmF0dHIoJ29wZW4nLCAnb3BlbicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VyaWFsaXplZFN0YXRlT3B0aW9uID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgZGV0YWlscy5hdHRyKCdvcGVuJywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dXAkNiA9IGVkaXRvciA9PiB7XG4gICAgICBwcmV2ZW50U3VtbWFyeVRvZ2dsZShlZGl0b3IpO1xuICAgICAgZmlsdGVyRGV0YWlscyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0JyID0gaXNCciQ2O1xuICAgIGNvbnN0IGlzVGV4dCA9IGlzVGV4dCRhO1xuICAgIGNvbnN0IGlzQ29udGVudEVkaXRhYmxlRmFsc2UkMiA9IGVsbSA9PiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoZWxtLmRvbSk7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGVUcnVlID0gZWxtID0+IGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKGVsbS5kb20pO1xuICAgIGNvbnN0IGlzUm9vdCA9IHJvb3ROb2RlID0+IGVsbSA9PiBlcShTdWdhckVsZW1lbnQuZnJvbURvbShyb290Tm9kZSksIGVsbSk7XG4gICAgY29uc3QgZ2V0Q2xvc2VzdFNjb3BlID0gKG5vZGUsIHJvb3ROb2RlKSA9PiBjbG9zZXN0JDQoU3VnYXJFbGVtZW50LmZyb21Eb20obm9kZSksIGVsbSA9PiBpc0NvbnRlbnRFZGl0YWJsZVRydWUoZWxtKSB8fCBpc0Jsb2NrJDIoZWxtKSwgaXNSb290KHJvb3ROb2RlKSkuZ2V0T3IoU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdE5vZGUpKS5kb207XG4gICAgY29uc3QgZ2V0Q2xvc2VzdENlZiA9IChub2RlLCByb290Tm9kZSkgPT4gY2xvc2VzdCQ0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpLCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDIsIGlzUm9vdChyb290Tm9kZSkpO1xuICAgIGNvbnN0IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUgPSAoc3RhcnROb2RlLCBzY29wZSwgZm9yd2FyZCkgPT4ge1xuICAgICAgY29uc3Qgd2Fsa2VyID0gbmV3IERvbVRyZWVXYWxrZXIoc3RhcnROb2RlLCBzY29wZSk7XG4gICAgICBjb25zdCBuZXh0ID0gZm9yd2FyZCA/IHdhbGtlci5uZXh0LmJpbmQod2Fsa2VyKSA6IHdhbGtlci5wcmV2LmJpbmQod2Fsa2VyKTtcbiAgICAgIGxldCByZXN1bHQgPSBzdGFydE5vZGU7XG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gZm9yd2FyZCA/IHN0YXJ0Tm9kZSA6IG5leHQoKTsgY3VycmVudCAmJiAhaXNCcihjdXJyZW50KTsgY3VycmVudCA9IG5leHQoKSkge1xuICAgICAgICBpZiAoaXNDYXJldENhbmRpZGF0ZSQzKGN1cnJlbnQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRDbG9zZXN0QmxvY2tSYW5nZSA9IChzdGFydFJuZywgcm9vdE5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VTdGFydChzdGFydFJuZyk7XG4gICAgICBjb25zdCBjbGlja05vZGUgPSBzdGFydFBvcy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBzY29wZSA9IGdldENsb3Nlc3RTY29wZShjbGlja05vZGUsIHJvb3ROb2RlKTtcbiAgICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUoY2xpY2tOb2RlLCBzY29wZSwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kTm9kZSA9IGZpbmRFZGdlQ2FyZXRDYW5kaWRhdGUoY2xpY2tOb2RlLCBzY29wZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgZ2V0Q2xvc2VzdENlZihzdGFydE5vZGUsIHNjb3BlKS5mb2xkKCgpID0+IHtcbiAgICAgICAgaWYgKGlzVGV4dChzdGFydE5vZGUpKSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm5nLnNldFN0YXJ0QmVmb3JlKHN0YXJ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGNlZiA9PiBybmcuc2V0U3RhcnRCZWZvcmUoY2VmLmRvbSkpO1xuICAgICAgZ2V0Q2xvc2VzdENlZihlbmROb2RlLCBzY29wZSkuZm9sZCgoKSA9PiB7XG4gICAgICAgIGlmIChpc1RleHQoZW5kTm9kZSkpIHtcbiAgICAgICAgICBybmcuc2V0RW5kKGVuZE5vZGUsIGVuZE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJuZy5zZXRFbmRBZnRlcihlbmROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSwgY2VmID0+IHJuZy5zZXRFbmRBZnRlcihjZWYuZG9tKSk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3Qgb25UcmlwbGVDbGlja1NlbGVjdCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBybmcgPSBmaW5kQ2xvc2VzdEJsb2NrUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKSwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFJuZyhub3JtYWxpemUocm5nKSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cCQ1ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignbW91c2Vkb3duJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmRldGFpbCA+PSAzKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9uVHJpcGxlQ2xpY2tTZWxlY3QoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBGYWtlQ2FyZXRQb3NpdGlvbjtcbiAgICAoZnVuY3Rpb24gKEZha2VDYXJldFBvc2l0aW9uKSB7XG4gICAgICBGYWtlQ2FyZXRQb3NpdGlvblsnQmVmb3JlJ10gPSAnYmVmb3JlJztcbiAgICAgIEZha2VDYXJldFBvc2l0aW9uWydBZnRlciddID0gJ2FmdGVyJztcbiAgICB9KEZha2VDYXJldFBvc2l0aW9uIHx8IChGYWtlQ2FyZXRQb3NpdGlvbiA9IHt9KSkpO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9SZWN0TGVmdCA9IChjbGllbnRSZWN0LCBjbGllbnRYKSA9PiBNYXRoLmFicyhjbGllbnRSZWN0LmxlZnQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvUmVjdFJpZ2h0ID0gKGNsaWVudFJlY3QsIGNsaWVudFgpID0+IE1hdGguYWJzKGNsaWVudFJlY3QucmlnaHQgLSBjbGllbnRYKTtcbiAgICBjb25zdCBpc0luc2lkZVkgPSAoY2xpZW50WSwgY2xpZW50UmVjdCkgPT4gY2xpZW50WSA+PSBjbGllbnRSZWN0LnRvcCAmJiBjbGllbnRZIDw9IGNsaWVudFJlY3QuYm90dG9tO1xuICAgIGNvbnN0IGNvbGxpZGVzWSA9IChyMSwgcjIpID0+IHIxLnRvcCA8IHIyLmJvdHRvbSAmJiByMS5ib3R0b20gPiByMi50b3A7XG4gICAgY29uc3QgaXNPdmVybGFwcGluZyA9IChyMSwgcjIpID0+IHtcbiAgICAgIGNvbnN0IG92ZXJsYXAgPSBvdmVybGFwWShyMSwgcjIpIC8gTWF0aC5taW4ocjEuaGVpZ2h0LCByMi5oZWlnaHQpO1xuICAgICAgcmV0dXJuIGNvbGxpZGVzWShyMSwgcjIpICYmIG92ZXJsYXAgPiAwLjU7XG4gICAgfTtcbiAgICBjb25zdCBzcGxpdFJlY3RzUGVyQXhpcyA9IChyZWN0cywgeSkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW5nUmVjdHMgPSBmaWx0ZXIkNShyZWN0cywgcmVjdCA9PiBpc0luc2lkZVkoeSwgcmVjdCkpO1xuICAgICAgcmV0dXJuIGJvdW5kaW5nQ2xpZW50UmVjdEZyb21SZWN0cyhpbnRlcnNlY3RpbmdSZWN0cykuZm9sZCgoKSA9PiBbXG4gICAgICAgIFtdLFxuICAgICAgICByZWN0c1xuICAgICAgXSwgYm91bmRpbmdSZWN0ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBhc3M6IGhvcml6b250YWwsXG4gICAgICAgICAgZmFpbDogdmVydGljYWxcbiAgICAgICAgfSA9IHBhcnRpdGlvbiQyKHJlY3RzLCByZWN0ID0+IGlzT3ZlcmxhcHBpbmcocmVjdCwgYm91bmRpbmdSZWN0KSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGllbnRJbmZvID0gKHJlY3QsIGNsaWVudFgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IHJlY3Qubm9kZSxcbiAgICAgICAgcG9zaXRpb246IGRpc3RhbmNlVG9SZWN0TGVmdChyZWN0LCBjbGllbnRYKSA8IGRpc3RhbmNlVG9SZWN0UmlnaHQocmVjdCwgY2xpZW50WCkgPyBGYWtlQ2FyZXRQb3NpdGlvbi5CZWZvcmUgOiBGYWtlQ2FyZXRQb3NpdGlvbi5BZnRlclxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGhvcml6b250YWxEaXN0YW5jZSA9IChyZWN0LCB4LCBfeSkgPT4geCA+IHJlY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCA/IDAgOiBNYXRoLm1pbihNYXRoLmFicyhyZWN0LmxlZnQgLSB4KSwgTWF0aC5hYnMocmVjdC5yaWdodCAtIHgpKTtcbiAgICBjb25zdCBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0ID0gKGNoaWxkcmVuLCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCBjYXJldENhbmRpZGF0ZVJlY3QgPSByZWN0ID0+IHtcbiAgICAgICAgaWYgKGlzQ2FyZXRDYW5kaWRhdGUkMyhyZWN0Lm5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocmVjdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50JDYocmVjdC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGZyb20ocmVjdC5ub2RlLmNoaWxkTm9kZXMpLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0Q2xvc2VzdFRleHROb2RlID0gKHJlY3RzLCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICBpZiAocmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBjb25zdCByMSA9IGNhcmV0Q2FuZGlkYXRlUmVjdChyZWN0c1swXSkuZ2V0T3IocmVjdHNbMF0pO1xuICAgICAgICAgIGNvbnN0IHIyID0gY2FyZXRDYW5kaWRhdGVSZWN0KHJlY3RzWzFdKS5nZXRPcihyZWN0c1sxXSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFEaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKHIxLCBjbGllbnRYLCBjbGllbnRZKSAtIGRpc3RhbmNlKHIyLCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICAgICAgaWYgKGRlbHRhRGlzdGFuY2UgPCAyKSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0JGEocjEubm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocjEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1RleHQkYShyMi5ub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZENsb3Nlc3RDYXJldENhbmRpZGF0ZU5vZGVSZWN0ID0gKHJlY3RzLCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBzb3J0ZWRSZWN0cyA9IHNvcnQocmVjdHMsIChyMSwgcjIpID0+IGRpc3RhbmNlKHIxLCBjbGllbnRYLCBjbGllbnRZKSAtIGRpc3RhbmNlKHIyLCBjbGllbnRYLCBjbGllbnRZKSk7XG4gICAgICAgIHJldHVybiBnZXRDbG9zZXN0VGV4dE5vZGUoc29ydGVkUmVjdHMsIGRpc3RhbmNlKS5vclRodW5rKCgpID0+IGZpbmRNYXAoc29ydGVkUmVjdHMsIGNhcmV0Q2FuZGlkYXRlUmVjdCkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IFtob3Jpem9udGFsUmVjdHMsIHZlcnRpY2FsUmVjdHNdID0gc3BsaXRSZWN0c1BlckF4aXMoZ2V0Q2xpZW50UmVjdHMoY2hpbGRyZW4pLCBjbGllbnRZKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFzczogYWJvdmUsXG4gICAgICAgIGZhaWw6IGJlbG93XG4gICAgICB9ID0gcGFydGl0aW9uJDIodmVydGljYWxSZWN0cywgcmVjdCA9PiByZWN0LnRvcCA8IGNsaWVudFkpO1xuICAgICAgcmV0dXJuIGZpbmRDbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdChob3Jpem9udGFsUmVjdHMsIGhvcml6b250YWxEaXN0YW5jZSkub3JUaHVuaygoKSA9PiBmaW5kQ2xvc2VzdENhcmV0Q2FuZGlkYXRlTm9kZVJlY3QoYmVsb3csIGRpc3RhbmNlVG9SZWN0RWRnZUZyb21YWSkpLm9yVGh1bmsoKCkgPT4gZmluZENsb3Nlc3RDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGFib3ZlLCBkaXN0YW5jZVRvUmVjdEVkZ2VGcm9tWFkpKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYXZlcnNlVXAgPSAocm9vdEVsbSwgc2NvcGUsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGNvbnN0IGhlbHBlciA9IChzY29wZSwgcHJldlNjb3BlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ0dob3N0Q29udGFpbmVyID0gbm9kZSA9PiBpc0VsZW1lbnQkNihub2RlKSAmJiBub2RlLmNsYXNzTGlzdC5jb250YWlucygnbWNlLWRyYWctY29udGFpbmVyJyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXNXaXRob3V0R2hvc3QgPSBmaWx0ZXIkNShzY29wZS5kb20uY2hpbGROb2Rlcywgbm90KGlzRHJhZ0dob3N0Q29udGFpbmVyKSk7XG4gICAgICAgIHJldHVybiBwcmV2U2NvcGUuZm9sZCgoKSA9PiBjbG9zZXN0Q2hpbGRDYXJldENhbmRpZGF0ZU5vZGVSZWN0KGNoaWxkTm9kZXNXaXRob3V0R2hvc3QsIGNsaWVudFgsIGNsaWVudFkpLCBwcmV2U2NvcGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHVuY2hlY2tlZENoaWxkcmVuID0gZmlsdGVyJDUoY2hpbGROb2Rlc1dpdGhvdXRHaG9zdCwgbm9kZSA9PiBub2RlICE9PSBwcmV2U2NvcGUuZG9tKTtcbiAgICAgICAgICByZXR1cm4gY2xvc2VzdENoaWxkQ2FyZXRDYW5kaWRhdGVOb2RlUmVjdCh1bmNoZWNrZWRDaGlsZHJlbiwgY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIH0pLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVxKHNjb3BlLCByb290RWxtKSA/IE9wdGlvbmFsLm5vbmUoKSA6IHBhcmVudEVsZW1lbnQoc2NvcGUpO1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuYmluZChuZXdTY29wZSA9PiBoZWxwZXIobmV3U2NvcGUsIE9wdGlvbmFsLnNvbWUoc2NvcGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXIoc2NvcGUsIE9wdGlvbmFsLm5vbmUoKSk7XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdCA9IChyb290LCBjbGllbnRYLCBjbGllbnRZKSA9PiB7XG4gICAgICBjb25zdCByb290RWxtID0gU3VnYXJFbGVtZW50LmZyb21Eb20ocm9vdCk7XG4gICAgICBjb25zdCBvd25lckRvYyA9IGRvY3VtZW50T3JPd25lcihyb290RWxtKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRBdFBvaW50ID0gU3VnYXJFbGVtZW50LmZyb21Qb2ludChvd25lckRvYywgY2xpZW50WCwgY2xpZW50WSkuZmlsdGVyKGVsbSA9PiBjb250YWlucyhyb290RWxtLCBlbG0pKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50QXRQb2ludC5nZXRPcihyb290RWxtKTtcbiAgICAgIHJldHVybiB0cmF2ZXJzZVVwKHJvb3RFbG0sIGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIH07XG4gICAgY29uc3QgY2xvc2VzdEZha2VDYXJldENhbmRpZGF0ZSA9IChyb290LCBjbGllbnRYLCBjbGllbnRZKSA9PiBjbG9zZXN0Q2FyZXRDYW5kaWRhdGVOb2RlUmVjdChyb290LCBjbGllbnRYLCBjbGllbnRZKS5maWx0ZXIocmVjdCA9PiBpc0Zha2VDYXJldFRhcmdldChyZWN0Lm5vZGUpKS5tYXAocmVjdCA9PiBjbGllbnRJbmZvKHJlY3QsIGNsaWVudFgpKTtcblxuICAgIGNvbnN0IGdldEFic29sdXRlUG9zaXRpb24gPSBlbG0gPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBkb2MgPSBlbG0ub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCArICgoX2EgPSB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uc2Nyb2xsWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSBkb2NFbGVtLmNsaWVudFRvcCxcbiAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0ICsgKChfYiA9IHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5zY3JvbGxYKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAtIGRvY0VsZW0uY2xpZW50TGVmdFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJvZHlQb3NpdGlvbiA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gZ2V0QWJzb2x1dGVQb3NpdGlvbihlZGl0b3IuZ2V0Qm9keSgpKSA6IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGNvbnN0IGdldFNjcm9sbFBvc2l0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgcmV0dXJuIGVkaXRvci5pbmxpbmUgPyB7XG4gICAgICAgIGxlZnQ6IGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgdG9wOiBib2R5LnNjcm9sbFRvcFxuICAgICAgfSA6IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0Qm9keVNjcm9sbCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gZWRpdG9yLmdldEJvZHkoKSwgZG9jRWxtID0gZWRpdG9yLmdldERvYygpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGNvbnN0IGlubGluZVNjcm9sbCA9IHtcbiAgICAgICAgbGVmdDogYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IGJvZHkuc2Nyb2xsVG9wXG4gICAgICB9O1xuICAgICAgY29uc3QgaWZyYW1lU2Nyb2xsID0ge1xuICAgICAgICBsZWZ0OiBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxtLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogYm9keS5zY3JvbGxUb3AgfHwgZG9jRWxtLnNjcm9sbFRvcFxuICAgICAgfTtcbiAgICAgIHJldHVybiBlZGl0b3IuaW5saW5lID8gaW5saW5lU2Nyb2xsIDogaWZyYW1lU2Nyb2xsO1xuICAgIH07XG4gICAgY29uc3QgZ2V0TW91c2VQb3NpdGlvbiA9IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGVkaXRvci5nZXREb2MoKSkge1xuICAgICAgICBjb25zdCBpZnJhbWVQb3NpdGlvbiA9IGdldEFic29sdXRlUG9zaXRpb24oZWRpdG9yLmdldENvbnRlbnRBcmVhQ29udGFpbmVyKCkpO1xuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IGdldEJvZHlTY3JvbGwoZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCAtIGlmcmFtZVBvc2l0aW9uLmxlZnQgKyBzY3JvbGxQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgIHRvcDogZXZlbnQucGFnZVkgLSBpZnJhbWVQb3NpdGlvbi50b3AgKyBzY3JvbGxQb3NpdGlvbi50b3BcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlUG9zaXRpb24gPSAoYm9keVBvc2l0aW9uLCBzY3JvbGxQb3NpdGlvbiwgbW91c2VQb3NpdGlvbikgPT4gKHtcbiAgICAgIHBhZ2VYOiBtb3VzZVBvc2l0aW9uLmxlZnQgLSBib2R5UG9zaXRpb24ubGVmdCArIHNjcm9sbFBvc2l0aW9uLmxlZnQsXG4gICAgICBwYWdlWTogbW91c2VQb3NpdGlvbi50b3AgLSBib2R5UG9zaXRpb24udG9wICsgc2Nyb2xsUG9zaXRpb24udG9wXG4gICAgfSk7XG4gICAgY29uc3QgY2FsYyA9IChlZGl0b3IsIGV2ZW50KSA9PiBjYWxjdWxhdGVQb3NpdGlvbihnZXRCb2R5UG9zaXRpb24oZWRpdG9yKSwgZ2V0U2Nyb2xsUG9zaXRpb24oZWRpdG9yKSwgZ2V0TW91c2VQb3NpdGlvbihlZGl0b3IsIGV2ZW50KSk7XG5cbiAgICBjb25zdCBnZXRUYXJnZXRQcm9wcyA9IHRhcmdldCA9PiAoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgc3JjRWxlbWVudDogdGFyZ2V0XG4gICAgfSk7XG4gICAgY29uc3QgbWFrZURuZEV2ZW50RnJvbU1vdXNlRXZlbnQgPSAodHlwZSwgbW91c2VFdmVudCwgdGFyZ2V0LCBkYXRhVHJhbnNmZXIpID0+ICh7XG4gICAgICAuLi5tb3VzZUV2ZW50LFxuICAgICAgZGF0YVRyYW5zZmVyLFxuICAgICAgdHlwZSxcbiAgICAgIC4uLmdldFRhcmdldFByb3BzKHRhcmdldClcbiAgICB9KTtcbiAgICBjb25zdCBtYWtlRG5kRXZlbnQgPSAodHlwZSwgdGFyZ2V0LCBkYXRhVHJhbnNmZXIpID0+IHtcbiAgICAgIGNvbnN0IGZhaWwgPSBkaWUoJ0Z1bmN0aW9uIG5vdCBzdXBwb3J0ZWQgb24gc2ltdWxhdGVkIGV2ZW50LicpO1xuICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgICAgIGV2ZW50UGhhc2U6IDAsXG4gICAgICAgIGlzVHJ1c3RlZDogdHJ1ZSxcbiAgICAgICAgcmV0dXJuVmFsdWU6IGZhbHNlLFxuICAgICAgICB0aW1lU3RhbXA6IDAsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbXBvc2VkUGF0aDogZmFpbCxcbiAgICAgICAgaW5pdEV2ZW50OiBmYWlsLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogbm9vcCxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBub29wLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IG5vb3AsXG4gICAgICAgIEFUX1RBUkdFVDogd2luZG93LkV2ZW50LkFUX1RBUkdFVCxcbiAgICAgICAgQlVCQkxJTkdfUEhBU0U6IHdpbmRvdy5FdmVudC5CVUJCTElOR19QSEFTRSxcbiAgICAgICAgQ0FQVFVSSU5HX1BIQVNFOiB3aW5kb3cuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFLFxuICAgICAgICBOT05FOiB3aW5kb3cuRXZlbnQuTk9ORSxcbiAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgYnV0dG9uOiAwLFxuICAgICAgICBidXR0b25zOiAwLFxuICAgICAgICBjbGllbnRYOiAwLFxuICAgICAgICBjbGllbnRZOiAwLFxuICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgIG1vdmVtZW50WDogMCxcbiAgICAgICAgbW92ZW1lbnRZOiAwLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICBwYWdlWDogMCxcbiAgICAgICAgcGFnZVk6IDAsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG51bGwsXG4gICAgICAgIHNjcmVlblg6IDAsXG4gICAgICAgIHNjcmVlblk6IDAsXG4gICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICB3aGljaDogMCxcbiAgICAgICAgaW5pdFVJRXZlbnQ6IGZhaWwsXG4gICAgICAgIGluaXRNb3VzZUV2ZW50OiBmYWlsLFxuICAgICAgICBnZXRNb2RpZmllclN0YXRlOiBmYWlsLFxuICAgICAgICBkYXRhVHJhbnNmZXIsXG4gICAgICAgIC4uLmdldFRhcmdldFByb3BzKHRhcmdldClcbiAgICAgIH07XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcbiAgICBjb25zdCBtYWtlRGF0YVRyYW5zZmVyQ29weUZvckRyYWdFdmVudCA9IChkYXRhVHJhbnNmZXIsIGV2ZW50VHlwZSkgPT4ge1xuICAgICAgY29uc3QgY29weSA9IGNsb25lRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2Zlcik7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgICBzZXREcmFnc3RhcnRFdmVudChjb3B5KTtcbiAgICAgICAgc2V0UmVhZFdyaXRlTW9kZShjb3B5KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSAnZHJvcCcpIHtcbiAgICAgICAgc2V0RHJvcEV2ZW50KGNvcHkpO1xuICAgICAgICBzZXRSZWFkT25seU1vZGUoY29weSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREcmFnZW5kRXZlbnQoY29weSk7XG4gICAgICAgIHNldFByb3RlY3RlZE1vZGUoY29weSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VEcmFnRXZlbnQgPSAodHlwZSwgdGFyZ2V0LCBkYXRhVHJhbnNmZXIsIG1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlckZvckRpc3BhdGNoID0gbWFrZURhdGFUcmFuc2ZlckNvcHlGb3JEcmFnRXZlbnQoZGF0YVRyYW5zZmVyLCB0eXBlKTtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChtb3VzZUV2ZW50KSA/IG1ha2VEbmRFdmVudCh0eXBlLCB0YXJnZXQsIGRhdGFUcmFuc2ZlckZvckRpc3BhdGNoKSA6IG1ha2VEbmRFdmVudEZyb21Nb3VzZUV2ZW50KHR5cGUsIG1vdXNlRXZlbnQsIHRhcmdldCwgZGF0YVRyYW5zZmVyRm9yRGlzcGF0Y2gpO1xuICAgIH07XG5cbiAgICBjb25zdCBzY3JvbGxQaXhlbHNQZXJJbnRlcnZhbCA9IDMyO1xuICAgIGNvbnN0IHNjcm9sbEludGVydmFsVmFsdWUgPSAxMDA7XG4gICAgY29uc3QgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbEluc2lkZUVkaXRvciA9IDg7XG4gICAgY29uc3QgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbE91dHNpZGVFZGl0b3IgPSAxNjtcbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDEgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGI7XG4gICAgY29uc3QgaXNDb250ZW50RWRpdGFibGUgPSBvcihpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJDEsIGlzQ29udGVudEVkaXRhYmxlVHJ1ZSQzKTtcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9IChkb20sIHJvb3RFbG0sIGVsbSkgPT4gaXNDb250ZW50RWRpdGFibGVGYWxzZSQxKGVsbSkgJiYgZWxtICE9PSByb290RWxtICYmIGRvbS5pc0VkaXRhYmxlKGVsbS5wYXJlbnRFbGVtZW50KTtcbiAgICBjb25zdCBpc1ZhbGlkRHJvcFRhcmdldCA9IChlZGl0b3IsIHRhcmdldEVsZW1lbnQsIGRyYWdFbGVtZW50KSA9PiB7XG4gICAgICBpZiAoaXNOdWxsYWJsZSh0YXJnZXRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEVsZW1lbnQgPT09IGRyYWdFbGVtZW50IHx8IGVkaXRvci5kb20uaXNDaGlsZE9mKHRhcmdldEVsZW1lbnQsIGRyYWdFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRvbS5pc0VkaXRhYmxlKHRhcmdldEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlR2hvc3QgPSAoZWRpdG9yLCBlbG0sIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCBjbG9uZWRFbG0gPSBlbG0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgZG9tLnNldFN0eWxlcyhjbG9uZWRFbG0sIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSk7XG4gICAgICBkb20uc2V0QXR0cmliKGNsb25lZEVsbSwgJ2RhdGEtbWNlLXNlbGVjdGVkJywgbnVsbCk7XG4gICAgICBjb25zdCBnaG9zdEVsbSA9IGRvbS5jcmVhdGUoJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogJ21jZS1kcmFnLWNvbnRhaW5lcicsXG4gICAgICAgICdkYXRhLW1jZS1ib2d1cyc6ICdhbGwnLFxuICAgICAgICAndW5zZWxlY3RhYmxlJzogJ29uJyxcbiAgICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdmYWxzZSdcbiAgICAgIH0pO1xuICAgICAgZG9tLnNldFN0eWxlcyhnaG9zdEVsbSwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGRvbS5zZXRTdHlsZXMoY2xvbmVkRWxtLCB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgICAgIH0pO1xuICAgICAgZ2hvc3RFbG0uYXBwZW5kQ2hpbGQoY2xvbmVkRWxtKTtcbiAgICAgIHJldHVybiBnaG9zdEVsbTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZEdob3N0VG9Cb2R5ID0gKGdob3N0RWxtLCBib2R5RWxtKSA9PiB7XG4gICAgICBpZiAoZ2hvc3RFbG0ucGFyZW50Tm9kZSAhPT0gYm9keUVsbSkge1xuICAgICAgICBib2R5RWxtLmFwcGVuZENoaWxkKGdob3N0RWxtKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjcm9sbEVkaXRvciA9IChkaXJlY3Rpb24sIGFtb3VudCkgPT4gd2luID0+ICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IHdpbi5zY3JvbGxYIDogd2luLnNjcm9sbFk7XG4gICAgICB3aW4uc2Nyb2xsKHtcbiAgICAgICAgW2RpcmVjdGlvbl06IGN1cnJlbnQgKyBhbW91bnQsXG4gICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gc2Nyb2xsRWRpdG9yKCdsZWZ0JywgLXNjcm9sbFBpeGVsc1BlckludGVydmFsKTtcbiAgICBjb25zdCBzY3JvbGxSaWdodCA9IHNjcm9sbEVkaXRvcignbGVmdCcsIHNjcm9sbFBpeGVsc1BlckludGVydmFsKTtcbiAgICBjb25zdCBzY3JvbGxVcCA9IHNjcm9sbEVkaXRvcigndG9wJywgLXNjcm9sbFBpeGVsc1BlckludGVydmFsKTtcbiAgICBjb25zdCBzY3JvbGxEb3duID0gc2Nyb2xsRWRpdG9yKCd0b3AnLCBzY3JvbGxQaXhlbHNQZXJJbnRlcnZhbCk7XG4gICAgY29uc3QgbW92ZUdob3N0ID0gKGdob3N0RWxtLCBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgbWF4WCwgbWF4WSwgbW91c2VZLCBtb3VzZVgsIGNvbnRlbnRBcmVhQ29udGFpbmVyLCB3aW4sIHN0YXRlLCBtb3VzZUV2ZW50T3JpZ2luYXRlZEZyb21XaXRoaW5UaGVFZGl0b3IpID0+IHtcbiAgICAgIGxldCBvdmVyZmxvd1ggPSAwLCBvdmVyZmxvd1kgPSAwO1xuICAgICAgZ2hvc3RFbG0uc3R5bGUubGVmdCA9IHBvc2l0aW9uLnBhZ2VYICsgJ3B4JztcbiAgICAgIGdob3N0RWxtLnN0eWxlLnRvcCA9IHBvc2l0aW9uLnBhZ2VZICsgJ3B4JztcbiAgICAgIGlmIChwb3NpdGlvbi5wYWdlWCArIHdpZHRoID4gbWF4WCkge1xuICAgICAgICBvdmVyZmxvd1ggPSBwb3NpdGlvbi5wYWdlWCArIHdpZHRoIC0gbWF4WDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi5wYWdlWSArIGhlaWdodCA+IG1heFkpIHtcbiAgICAgICAgb3ZlcmZsb3dZID0gcG9zaXRpb24ucGFnZVkgKyBoZWlnaHQgLSBtYXhZO1xuICAgICAgfVxuICAgICAgZ2hvc3RFbG0uc3R5bGUud2lkdGggPSB3aWR0aCAtIG92ZXJmbG93WCArICdweCc7XG4gICAgICBnaG9zdEVsbS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvd1kgKyAncHgnO1xuICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gY29udGVudEFyZWFDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgY2xpZW50V2lkdGggPSBjb250ZW50QXJlYUNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IG91dGVyTW91c2VZID0gbW91c2VZICsgY29udGVudEFyZWFDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgY29uc3Qgb3V0ZXJNb3VzZVggPSBtb3VzZVggKyBjb250ZW50QXJlYUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgc3RhdGUub24oc3RhdGUgPT4ge1xuICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLmNsZWFyKCk7XG4gICAgICAgIGlmIChzdGF0ZS5kcmFnZ2luZyAmJiBtb3VzZUV2ZW50T3JpZ2luYXRlZEZyb21XaXRoaW5UaGVFZGl0b3IpIHtcbiAgICAgICAgICBpZiAobW91c2VZICsgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbEluc2lkZUVkaXRvciA+PSBjbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIHN0YXRlLmludGVydmFsSWQuc2V0KHNjcm9sbERvd24od2luKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb3VzZVkgLSBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsSW5zaWRlRWRpdG9yIDw9IDApIHtcbiAgICAgICAgICAgIHN0YXRlLmludGVydmFsSWQuc2V0KHNjcm9sbFVwKHdpbikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobW91c2VYICsgbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbEluc2lkZUVkaXRvciA+PSBjbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsUmlnaHQod2luKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb3VzZVggLSBtb3VzZVJhbmdlVG9UcmlnZ2VyU2Nyb2xsSW5zaWRlRWRpdG9yIDw9IDApIHtcbiAgICAgICAgICAgIHN0YXRlLmludGVydmFsSWQuc2V0KHNjcm9sbExlZnQod2luKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvdXRlck1vdXNlWSArIG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxPdXRzaWRlRWRpdG9yID49IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsRG93bih3aW5kb3cpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dGVyTW91c2VZIC0gbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbE91dHNpZGVFZGl0b3IgPD0gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsVXAod2luZG93KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvdXRlck1vdXNlWCArIG1vdXNlUmFuZ2VUb1RyaWdnZXJTY3JvbGxPdXRzaWRlRWRpdG9yID49IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRlcnZhbElkLnNldChzY3JvbGxSaWdodCh3aW5kb3cpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG91dGVyTW91c2VYIC0gbW91c2VSYW5nZVRvVHJpZ2dlclNjcm9sbE91dHNpZGVFZGl0b3IgPD0gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5zZXQoc2Nyb2xsTGVmdCh3aW5kb3cpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRWxlbWVudCA9IGVsbSA9PiB7XG4gICAgICBpZiAoZWxtICYmIGVsbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVFbGVtZW50V2l0aFBhZGRpbmcgPSAoZG9tLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrID0gZG9tLmdldFBhcmVudChlbG0ucGFyZW50Tm9kZSwgZG9tLmlzQmxvY2spO1xuICAgICAgcmVtb3ZlRWxlbWVudChlbG0pO1xuICAgICAgaWYgKHBhcmVudEJsb2NrICYmIHBhcmVudEJsb2NrICE9PSBkb20uZ2V0Um9vdCgpICYmIGRvbS5pc0VtcHR5KHBhcmVudEJsb2NrKSkge1xuICAgICAgICBmaWxsV2l0aFBhZGRpbmdCcihTdWdhckVsZW1lbnQuZnJvbURvbShwYXJlbnRCbG9jaykpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNMZWZ0TW91c2VCdXR0b25QcmVzc2VkID0gZSA9PiBlLmJ1dHRvbiA9PT0gMDtcbiAgICBjb25zdCBhcHBseVJlbFBvcyA9IChzdGF0ZSwgcG9zaXRpb24pID0+ICh7XG4gICAgICBwYWdlWDogcG9zaXRpb24ucGFnZVggLSBzdGF0ZS5yZWxYLFxuICAgICAgcGFnZVk6IHBvc2l0aW9uLnBhZ2VZICsgNVxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXJ0ID0gKHN0YXRlLCBlZGl0b3IpID0+IGUgPT4ge1xuICAgICAgaWYgKGlzTGVmdE1vdXNlQnV0dG9uUHJlc3NlZChlKSkge1xuICAgICAgICBjb25zdCBjZUVsbSA9IGZpbmQkMihlZGl0b3IuZG9tLmdldFBhcmVudHMoZS50YXJnZXQpLCBpc0NvbnRlbnRFZGl0YWJsZSkuZ2V0T3IobnVsbCk7XG4gICAgICAgIGlmIChpc05vbk51bGxhYmxlKGNlRWxtKSAmJiBpc0RyYWdnYWJsZShlZGl0b3IuZG9tLCBlZGl0b3IuZ2V0Qm9keSgpLCBjZUVsbSkpIHtcbiAgICAgICAgICBjb25zdCBlbG1Qb3MgPSBlZGl0b3IuZG9tLmdldFBvcyhjZUVsbSk7XG4gICAgICAgICAgY29uc3QgYm9keUVsbSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgICAgY29uc3QgZG9jRWxtID0gZWRpdG9yLmdldERvYygpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgICAgZWxlbWVudDogY2VFbG0sXG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IGNyZWF0ZURhdGFUcmFuc2ZlcigpLFxuICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICAgICAgbWF4WDogKGVkaXRvci5pbmxpbmUgPyBib2R5RWxtLnNjcm9sbFdpZHRoIDogZG9jRWxtLm9mZnNldFdpZHRoKSAtIDIsXG4gICAgICAgICAgICBtYXhZOiAoZWRpdG9yLmlubGluZSA/IGJvZHlFbG0uc2Nyb2xsSGVpZ2h0IDogZG9jRWxtLm9mZnNldEhlaWdodCkgLSAyLFxuICAgICAgICAgICAgcmVsWDogZS5wYWdlWCAtIGVsbVBvcy54LFxuICAgICAgICAgICAgcmVsWTogZS5wYWdlWSAtIGVsbVBvcy55LFxuICAgICAgICAgICAgd2lkdGg6IGNlRWxtLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjZUVsbS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBnaG9zdDogY3JlYXRlR2hvc3QoZWRpdG9yLCBjZUVsbSwgY2VFbG0ub2Zmc2V0V2lkdGgsIGNlRWxtLm9mZnNldEhlaWdodCksXG4gICAgICAgICAgICBpbnRlcnZhbElkOiByZXBlYXRhYmxlKHNjcm9sbEludGVydmFsVmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBsYWNlQ2FyZXRBdCA9IChlZGl0b3IsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzLmhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgIGNsb3Nlc3RGYWtlQ2FyZXRDYW5kaWRhdGUoZWRpdG9yLmdldEJvZHkoKSwgY2xpZW50WCwgY2xpZW50WSkuZm9sZCgoKSA9PiBlZGl0b3Iuc2VsZWN0aW9uLnBsYWNlQ2FyZXRBdChjbGllbnRYLCBjbGllbnRZKSwgY2FyZXRJbmZvID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5zaG93Q2FyZXQoMSwgY2FyZXRJbmZvLm5vZGUsIGNhcmV0SW5mby5wb3NpdGlvbiA9PT0gRmFrZUNhcmV0UG9zaXRpb24uQmVmb3JlLCBmYWxzZSk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnBsYWNlQ2FyZXRBdChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwYXRjaERyYWdFdmVudCA9IChlZGl0b3IsIHR5cGUsIHRhcmdldCwgZGF0YVRyYW5zZmVyLCBtb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2RyYWdzdGFydCcpIHtcbiAgICAgICAgc2V0SHRtbERhdGEoZGF0YVRyYW5zZmVyLCBlZGl0b3IuZG9tLmdldE91dGVySFRNTCh0YXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2ZW50ID0gbWFrZURyYWdFdmVudCh0eXBlLCB0YXJnZXQsIGRhdGFUcmFuc2ZlciwgbW91c2VFdmVudCk7XG4gICAgICBjb25zdCBhcmdzID0gZWRpdG9yLmRpc3BhdGNoKHR5cGUsIGV2ZW50KTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChzdGF0ZSwgZWRpdG9yKSA9PiB7XG4gICAgICBjb25zdCB0aHJvdHRsZWRQbGFjZUNhcmV0QXQgPSBmaXJzdCQxKChjbGllbnRYLCBjbGllbnRZKSA9PiBwbGFjZUNhcmV0QXQoZWRpdG9yLCBjbGllbnRYLCBjbGllbnRZKSwgMCk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsIHRocm90dGxlZFBsYWNlQ2FyZXRBdC5jYW5jZWwpO1xuICAgICAgY29uc3Qgc3RhdGVfID0gc3RhdGU7XG4gICAgICByZXR1cm4gZSA9PiBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVtZW50ID0gTWF0aC5tYXgoTWF0aC5hYnMoZS5zY3JlZW5YIC0gc3RhdGUuc2NyZWVuWCksIE1hdGguYWJzKGUuc2NyZWVuWSAtIHN0YXRlLnNjcmVlblkpKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5kcmFnZ2luZyAmJiBtb3ZlbWVudCA+IDEwKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IGRpc3BhdGNoRHJhZ0V2ZW50KGVkaXRvciwgJ2RyYWdzdGFydCcsIHN0YXRlLmVsZW1lbnQsIHN0YXRlLmRhdGFUcmFuc2ZlciwgZSk7XG4gICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYXJncy5kYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICBzdGF0ZS5kYXRhVHJhbnNmZXIgPSBhcmdzLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5kcmFnZ2luZykge1xuICAgICAgICAgIGNvbnN0IG1vdXNlRXZlbnRPcmlnaW5hdGVkRnJvbVdpdGhpblRoZUVkaXRvciA9IGUuY3VycmVudFRhcmdldCA9PT0gZWRpdG9yLmdldERvYygpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBjb25zdCB0YXJnZXRQb3MgPSBhcHBseVJlbFBvcyhzdGF0ZSwgY2FsYyhlZGl0b3IsIGUpKTtcbiAgICAgICAgICBhcHBlbmRHaG9zdFRvQm9keShzdGF0ZS5naG9zdCwgZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgICAgbW92ZUdob3N0KHN0YXRlLmdob3N0LCB0YXJnZXRQb3MsIHN0YXRlLndpZHRoLCBzdGF0ZS5oZWlnaHQsIHN0YXRlLm1heFgsIHN0YXRlLm1heFksIGUuY2xpZW50WSwgZS5jbGllbnRYLCBlZGl0b3IuZ2V0Q29udGVudEFyZWFDb250YWluZXIoKSwgZWRpdG9yLmdldFdpbigpLCBzdGF0ZV8sIG1vdXNlRXZlbnRPcmlnaW5hdGVkRnJvbVdpdGhpblRoZUVkaXRvcik7XG4gICAgICAgICAgdGhyb3R0bGVkUGxhY2VDYXJldEF0LnRocm90dGxlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSYXdUYXJnZXQgPSBzZWxlY3Rpb24gPT4ge1xuICAgICAgY29uc3Qgc2VsID0gc2VsZWN0aW9uLmdldFNlbCgpO1xuICAgICAgaWYgKGlzTm9uTnVsbGFibGUoc2VsKSkge1xuICAgICAgICBjb25zdCBybmcgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBybmcuc3RhcnRDb250YWluZXI7XG4gICAgICAgIHJldHVybiBpc1RleHQkYShzdGFydENvbnRhaW5lcikgPyBzdGFydENvbnRhaW5lci5wYXJlbnROb2RlIDogc3RhcnRDb250YWluZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyb3AgPSAoc3RhdGUsIGVkaXRvcikgPT4gZSA9PiB7XG4gICAgICBzdGF0ZS5vbihzdGF0ZSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5jbGVhcigpO1xuICAgICAgICBpZiAoc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZERyb3BUYXJnZXQoZWRpdG9yLCBnZXRSYXdUYXJnZXQoZWRpdG9yLnNlbGVjdGlvbiksIHN0YXRlLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gKF9hID0gZWRpdG9yLmdldERvYygpLmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGRpc3BhdGNoRHJhZ0V2ZW50KGVkaXRvciwgJ2Ryb3AnLCBkcm9wVGFyZ2V0LCBzdGF0ZS5kYXRhVHJhbnNmZXIsIGUpO1xuICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudFdpdGhQYWRkaW5nKGVkaXRvci5kb20sIHN0YXRlLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGdldEh0bWxEYXRhKHN0YXRlLmRhdGFUcmFuc2ZlcikuZWFjaChjb250ZW50ID0+IGVkaXRvci5pbnNlcnRDb250ZW50KGNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNwYXRjaERyYWdFdmVudChlZGl0b3IsICdkcmFnZW5kJywgZWRpdG9yLmdldEJvZHkoKSwgc3RhdGUuZGF0YVRyYW5zZmVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZW1vdmVEcmFnU3RhdGUoc3RhdGUpO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcERyYWdnaW5nID0gKHN0YXRlLCBlZGl0b3IsIGUpID0+IHtcbiAgICAgIHN0YXRlLm9uKHN0YXRlID0+IHtcbiAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5jbGVhcigpO1xuICAgICAgICBpZiAoc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICBlLmZvbGQoKCkgPT4gZGlzcGF0Y2hEcmFnRXZlbnQoZWRpdG9yLCAnZHJhZ2VuZCcsIHN0YXRlLmVsZW1lbnQsIHN0YXRlLmRhdGFUcmFuc2ZlciksIG1vdXNlRXZlbnQgPT4gZGlzcGF0Y2hEcmFnRXZlbnQoZWRpdG9yLCAnZHJhZ2VuZCcsIHN0YXRlLmVsZW1lbnQsIHN0YXRlLmRhdGFUcmFuc2ZlciwgbW91c2VFdmVudCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZURyYWdTdGF0ZShzdGF0ZSk7XG4gICAgfTtcbiAgICBjb25zdCBzdG9wID0gKHN0YXRlLCBlZGl0b3IpID0+IGUgPT4gc3RvcERyYWdnaW5nKHN0YXRlLCBlZGl0b3IsIE9wdGlvbmFsLnNvbWUoZSkpO1xuICAgIGNvbnN0IHJlbW92ZURyYWdTdGF0ZSA9IHN0YXRlID0+IHtcbiAgICAgIHN0YXRlLm9uKHN0YXRlID0+IHtcbiAgICAgICAgc3RhdGUuaW50ZXJ2YWxJZC5jbGVhcigpO1xuICAgICAgICByZW1vdmVFbGVtZW50KHN0YXRlLmdob3N0KTtcbiAgICAgIH0pO1xuICAgICAgc3RhdGUuY2xlYXIoKTtcbiAgICB9O1xuICAgIGNvbnN0IGJpbmRGYWtlRHJhZ0V2ZW50cyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IHBhZ2VEb20gPSBET01VdGlscy5ET007XG4gICAgICBjb25zdCByb290RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgIGNvbnN0IGRyYWdTdGFydEhhbmRsZXIgPSBzdGFydChzdGF0ZSwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IGRyYWdIYW5kbGVyID0gbW92ZShzdGF0ZSwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IGRyb3BIYW5kbGVyID0gZHJvcChzdGF0ZSwgZWRpdG9yKTtcbiAgICAgIGNvbnN0IGRyYWdFbmRIYW5kbGVyID0gc3RvcChzdGF0ZSwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5vbignbW91c2Vkb3duJywgZHJhZ1N0YXJ0SGFuZGxlcik7XG4gICAgICBlZGl0b3Iub24oJ21vdXNlbW92ZScsIGRyYWdIYW5kbGVyKTtcbiAgICAgIGVkaXRvci5vbignbW91c2V1cCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgIHBhZ2VEb20uYmluZChyb290RG9jdW1lbnQsICdtb3VzZW1vdmUnLCBkcmFnSGFuZGxlcik7XG4gICAgICBwYWdlRG9tLmJpbmQocm9vdERvY3VtZW50LCAnbW91c2V1cCcsIGRyYWdFbmRIYW5kbGVyKTtcbiAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICBwYWdlRG9tLnVuYmluZChyb290RG9jdW1lbnQsICdtb3VzZW1vdmUnLCBkcmFnSGFuZGxlcik7XG4gICAgICAgIHBhZ2VEb20udW5iaW5kKHJvb3REb2N1bWVudCwgJ21vdXNldXAnLCBkcmFnRW5kSGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBWSy5FU0MpIHtcbiAgICAgICAgICBzdG9wRHJhZ2dpbmcoc3RhdGUsIGVkaXRvciwgT3B0aW9uYWwubm9uZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBibG9ja1Vuc3VwcG9ydGVkRmlsZURyb3AgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgcHJldmVudEZpbGVEcm9wID0gZSA9PiB7XG4gICAgICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgKGNvbnRhaW5zJDIoZGF0YVRyYW5zZmVyLnR5cGVzLCAnRmlsZXMnKSB8fCBkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdkcm9wJykge1xuICAgICAgICAgICAgICBkaXNwbGF5RXJyb3IoZWRpdG9yLCAnRHJvcHBlZCBmaWxlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXZlbnRGaWxlRHJvcElmVUlFbGVtZW50ID0gZSA9PiB7XG4gICAgICAgIGlmIChpc1VJRWxlbWVudChlZGl0b3IsIGUudGFyZ2V0KSkge1xuICAgICAgICAgIHByZXZlbnRGaWxlRHJvcChlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlRG9tID0gRE9NVXRpbHMuRE9NO1xuICAgICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgZWRpdG9yUm9vdCA9IGVkaXRvci5pbmxpbmUgPyBlZGl0b3IuZ2V0Qm9keSgpIDogZWRpdG9yLmdldERvYygpO1xuICAgICAgICBjb25zdCBldmVudE5hbWVzID0gW1xuICAgICAgICAgICdkcm9wJyxcbiAgICAgICAgICAnZHJhZ292ZXInXG4gICAgICAgIF07XG4gICAgICAgIGVhY2gkZShldmVudE5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgICBwYWdlRG9tLmJpbmQoZG9jLCBuYW1lLCBwcmV2ZW50RmlsZURyb3BJZlVJRWxlbWVudCk7XG4gICAgICAgICAgZG9tLmJpbmQoZWRpdG9yUm9vdCwgbmFtZSwgcHJldmVudEZpbGVEcm9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbigncmVtb3ZlJywgKCkgPT4ge1xuICAgICAgICAgIGVhY2gkZShldmVudE5hbWVzLCBuYW1lID0+IHtcbiAgICAgICAgICAgIHBhZ2VEb20udW5iaW5kKGRvYywgbmFtZSwgcHJldmVudEZpbGVEcm9wSWZVSUVsZW1lbnQpO1xuICAgICAgICAgICAgZG9tLnVuYmluZChlZGl0b3JSb290LCBuYW1lLCBwcmV2ZW50RmlsZURyb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBlZGl0b3Iub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgIERlbGF5LnNldEVkaXRvclRpbWVvdXQoZWRpdG9yLCBzZXR1cCwgMCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXQkMiA9IGVkaXRvciA9PiB7XG4gICAgICBiaW5kRmFrZURyYWdFdmVudHMoZWRpdG9yKTtcbiAgICAgIGlmIChzaG91bGRCbG9ja1Vuc3VwcG9ydGVkRHJvcChlZGl0b3IpKSB7XG4gICAgICAgIGJsb2NrVW5zdXBwb3J0ZWRGaWxlRHJvcChlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQ0ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlckZvY3VzQ2FyZXQgPSBmaXJzdCQxKCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IucmVtb3ZlZCAmJiBlZGl0b3IuZ2V0Qm9keSgpLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgICAgICBpZiAocm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FyZXRSYW5nZSA9IHJlbmRlclJhbmdlQ2FyZXQoZWRpdG9yLCBybmcsIGZhbHNlKTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGNhcmV0UmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgICBlZGl0b3Iub24oJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICByZW5kZXJGb2N1c0NhcmV0LnRocm90dGxlKCk7XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5vbignYmx1cicsICgpID0+IHtcbiAgICAgICAgcmVuZGVyRm9jdXNDYXJldC5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBzZXR1cCQzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdmb2N1c2luJywgZSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKGlzTWVkaWEkMih0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBjZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoY2VSb290KSA/IGNlUm9vdCA6IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSAhPT0gbm9kZSkge1xuICAgICAgICAgICAgICBzZWxlY3ROb2RlKGVkaXRvciwgbm9kZSkuZWFjaChybmcgPT4gZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlID0gaXNDb250ZW50RWRpdGFibGVGYWxzZSRiO1xuICAgIGNvbnN0IGdldENvbnRlbnRFZGl0YWJsZVJvb3QgPSAoZWRpdG9yLCBub2RlKSA9PiBnZXRDb250ZW50RWRpdGFibGVSb290JDEoZWRpdG9yLmdldEJvZHkoKSwgbm9kZSk7XG4gICAgY29uc3QgU2VsZWN0aW9uT3ZlcnJpZGVzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sIGRvbSA9IGVkaXRvci5kb207XG4gICAgICBjb25zdCByb290Tm9kZSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBjb25zdCBmYWtlQ2FyZXQgPSBGYWtlQ2FyZXQoZWRpdG9yLCByb290Tm9kZSwgZG9tLmlzQmxvY2ssICgpID0+IGhhc0ZvY3VzKGVkaXRvcikpO1xuICAgICAgY29uc3QgcmVhbFNlbGVjdGlvbklkID0gJ3NlbC0nICsgZG9tLnVuaXF1ZUlkKCk7XG4gICAgICBjb25zdCBlbGVtZW50U2VsZWN0aW9uQXR0ciA9ICdkYXRhLW1jZS1zZWxlY3RlZCc7XG4gICAgICBsZXQgc2VsZWN0ZWRFbGVtZW50O1xuICAgICAgY29uc3QgaXNGYWtlU2VsZWN0aW9uRWxlbWVudCA9IG5vZGUgPT4gaXNOb25OdWxsYWJsZShub2RlKSAmJiBkb20uaGFzQ2xhc3Mobm9kZSwgJ21jZS1vZmZzY3JlZW4tc2VsZWN0aW9uJyk7XG4gICAgICBjb25zdCBpc0Zha2VTZWxlY3Rpb25UYXJnZXRFbGVtZW50ID0gbm9kZSA9PiBub2RlICE9PSByb290Tm9kZSAmJiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShub2RlKSB8fCBpc01lZGlhJDIobm9kZSkpICYmIGRvbS5pc0NoaWxkT2Yobm9kZSwgcm9vdE5vZGUpICYmIGRvbS5pc0VkaXRhYmxlKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICBjb25zdCBzZXRSYW5nZSA9IHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93Q2FyZXQgPSAoZGlyZWN0aW9uLCBub2RlLCBiZWZvcmUsIHNjcm9sbEludG9WaWV3ID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBlID0gZWRpdG9yLmRpc3BhdGNoKCdTaG93Q2FyZXQnLCB7XG4gICAgICAgICAgdGFyZ2V0OiBub2RlLFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KG5vZGUsIGRpcmVjdGlvbiA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWtlQ2FyZXQuc2hvdyhiZWZvcmUsIG5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3dCbG9ja0NhcmV0Q29udGFpbmVyID0gYmxvY2tDYXJldENvbnRhaW5lciA9PiB7XG4gICAgICAgIGlmIChibG9ja0NhcmV0Q29udGFpbmVyLmhhc0F0dHJpYnV0ZSgnZGF0YS1tY2UtY2FyZXQnKSkge1xuICAgICAgICAgIHNob3dDYXJldENvbnRhaW5lckJsb2NrKGJsb2NrQ2FyZXRDb250YWluZXIpO1xuICAgICAgICAgIHNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyhibG9ja0NhcmV0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyRXZlbnRzID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFkb20uaXNFZGl0YWJsZShlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignYmx1ciBOZXdCbG9jaycsIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24pO1xuICAgICAgICBlZGl0b3Iub24oJ1Jlc2l6ZVdpbmRvdyBGdWxsc2NyZWVuU3RhdGVDaGFuZ2VkJywgZmFrZUNhcmV0LnJlcG9zaXRpb24pO1xuICAgICAgICBlZGl0b3Iub24oJ3RhcCcsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEVsbSA9IGUudGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFZGl0YWJsZVJvb3QgPSBnZXRDb250ZW50RWRpdGFibGVSb290KGVkaXRvciwgdGFyZ2V0RWxtKTtcbiAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShjb250ZW50RWRpdGFibGVSb290KSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2VsZWN0Tm9kZShlZGl0b3IsIGNvbnRlbnRFZGl0YWJsZVJvb3QpLmVhY2goc2V0RWxlbWVudFNlbGVjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Zha2VTZWxlY3Rpb25UYXJnZXRFbGVtZW50KHRhcmdldEVsbSkpIHtcbiAgICAgICAgICAgIHNlbGVjdE5vZGUoZWRpdG9yLCB0YXJnZXRFbG0pLmVhY2goc2V0RWxlbWVudFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgZWRpdG9yLm9uKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRFbG0gPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0RWxtICE9PSByb290Tm9kZSAmJiB0YXJnZXRFbG0ubm9kZU5hbWUgIT09ICdIVE1MJyAmJiAhZG9tLmlzQ2hpbGRPZih0YXJnZXRFbG0sIHJvb3ROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzWFlJbkNvbnRlbnRBcmVhKGVkaXRvciwgZS5jbGllbnRYLCBlLmNsaWVudFkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICBoaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgICAgY29uc3QgY2xvc2VzdENvbnRlbnRFZGl0YWJsZSA9IGdldENvbnRlbnRFZGl0YWJsZVJvb3QoZWRpdG9yLCB0YXJnZXRFbG0pO1xuICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZUZhbHNlKGNsb3Nlc3RDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZWxlY3ROb2RlKGVkaXRvciwgY2xvc2VzdENvbnRlbnRFZGl0YWJsZSkuZWFjaChzZXRFbGVtZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VzdEZha2VDYXJldENhbmRpZGF0ZShyb290Tm9kZSwgZS5jbGllbnRYLCBlLmNsaWVudFkpLmVhY2goY2FyZXRJbmZvID0+IHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHNob3dDYXJldCgxLCBjYXJldEluZm8ubm9kZSwgY2FyZXRJbmZvLnBvc2l0aW9uID09PSBGYWtlQ2FyZXRQb3NpdGlvbi5CZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgc2V0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50JDYoY2xvc2VzdENvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Q29udGVudEVkaXRhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmdldEJvZHkoKS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgICAgaWYgKFZLLm1vZGlmaWVyUHJlc3NlZChlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGVGYWxzZShzZWxlY3Rpb24uZ2V0Tm9kZSgpKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5vbignR2V0U2VsZWN0aW9uUmFuZ2UnLCBlID0+IHtcbiAgICAgICAgICBsZXQgcm5nID0gZS5yYW5nZTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJuZyA9IHJuZy5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICBybmcuc2VsZWN0Tm9kZShzZWxlY3RlZEVsZW1lbnQpO1xuICAgICAgICAgICAgZS5yYW5nZSA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub24oJ1NldFNlbGVjdGlvblJhbmdlJywgZSA9PiB7XG4gICAgICAgICAgZS5yYW5nZSA9IG5vcm1hbGl6ZVZvaWRFbGVtZW50U2VsZWN0aW9uKGUucmFuZ2UpO1xuICAgICAgICAgIGNvbnN0IHJuZyA9IHNldEVsZW1lbnRTZWxlY3Rpb24oZS5yYW5nZSwgZS5mb3J3YXJkKTtcbiAgICAgICAgICBpZiAocm5nKSB7XG4gICAgICAgICAgICBlLnJhbmdlID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzUGFzdGVCaW4gPSBub2RlID0+IGlzRWxlbWVudCQ2KG5vZGUpICYmIG5vZGUuaWQgPT09ICdtY2VwYXN0ZWJpbic7XG4gICAgICAgIGVkaXRvci5vbignQWZ0ZXJTZXRTZWxlY3Rpb25SYW5nZScsIGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGUucmFuZ2U7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcm5nLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKCFpc1JhbmdlSW5DYXJldENvbnRhaW5lcihybmcpICYmICFpc1Bhc3RlQmluKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGhpZGVGYWtlQ2FyZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc0Zha2VTZWxlY3Rpb25FbGVtZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbml0JDIoZWRpdG9yKTtcbiAgICAgICAgc2V0dXAkNChlZGl0b3IpO1xuICAgICAgICBzZXR1cCQzKGVkaXRvcik7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNXaXRoaW5DYXJldENvbnRhaW5lciA9IG5vZGUgPT4gaXNDYXJldENvbnRhaW5lciQyKG5vZGUpIHx8IHN0YXJ0c1dpdGhDYXJldENvbnRhaW5lciQxKG5vZGUpIHx8IGVuZHNXaXRoQ2FyZXRDb250YWluZXIkMShub2RlKTtcbiAgICAgIGNvbnN0IGlzUmFuZ2VJbkNhcmV0Q29udGFpbmVyID0gcm5nID0+IGlzV2l0aGluQ2FyZXRDb250YWluZXIocm5nLnN0YXJ0Q29udGFpbmVyKSB8fCBpc1dpdGhpbkNhcmV0Q29udGFpbmVyKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgY29uc3Qgbm9ybWFsaXplVm9pZEVsZW1lbnRTZWxlY3Rpb24gPSBybmcgPT4ge1xuICAgICAgICBjb25zdCB2b2lkRWxlbWVudHMgPSBlZGl0b3Iuc2NoZW1hLmdldFZvaWRFbGVtZW50cygpO1xuICAgICAgICBjb25zdCBuZXdSbmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q29udGFpbmVyID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHJuZy5zdGFydE9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kQ29udGFpbmVyID0gcm5nLmVuZENvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gcm5nLmVuZE9mZnNldDtcbiAgICAgICAgaWYgKGhhcyQyKHZvaWRFbGVtZW50cywgc3RhcnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRTdGFydEJlZm9yZShzdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1JuZy5zZXRTdGFydEFmdGVyKHN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um5nLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhcyQyKHZvaWRFbGVtZW50cywgZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgbmV3Um5nLnNldEVuZEJlZm9yZShlbmRDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSbmcuc2V0RW5kQWZ0ZXIoZW5kQ29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Um5nLnNldEVuZChlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JuZztcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXR1cE9mZnNjcmVlblNlbGVjdGlvbiA9IChub2RlLCB0YXJnZXRDbG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICAgIGNvbnN0IGRvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgICAgY29uc3QgcmVhbFNlbGVjdGlvbkNvbnRhaW5lciA9IGRlc2NlbmRhbnQoYm9keSwgJyMnICsgcmVhbFNlbGVjdGlvbklkKS5nZXRPclRodW5rKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdDb250YWluZXIgPSBTdWdhckVsZW1lbnQuZnJvbUh0bWwoJzxkaXYgZGF0YS1tY2UtYm9ndXM9XCJhbGxcIiBjbGFzcz1cIm1jZS1vZmZzY3JlZW4tc2VsZWN0aW9uXCI+PC9kaXY+JywgZG9jKTtcbiAgICAgICAgICBzZXQkMyhuZXdDb250YWluZXIsICdpZCcsIHJlYWxTZWxlY3Rpb25JZCk7XG4gICAgICAgICAgYXBwZW5kJDEoYm9keSwgbmV3Q29udGFpbmVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q29udGFpbmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgIGVtcHR5KHJlYWxTZWxlY3Rpb25Db250YWluZXIpO1xuICAgICAgICBhcHBlbmQocmVhbFNlbGVjdGlvbkNvbnRhaW5lciwgW1xuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tVGV4dChuYnNwLCBkb2MpLFxuICAgICAgICAgIFN1Z2FyRWxlbWVudC5mcm9tRG9tKHRhcmdldENsb25lKSxcbiAgICAgICAgICBTdWdhckVsZW1lbnQuZnJvbVRleHQobmJzcCwgZG9jKVxuICAgICAgICBdKTtcbiAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQocmVhbFNlbGVjdGlvbkNvbnRhaW5lci5kb20uZmlyc3RDaGlsZCwgMSk7XG4gICAgICAgIG5ld1JhbmdlLnNldEVuZChyZWFsU2VsZWN0aW9uQ29udGFpbmVyLmRvbS5sYXN0Q2hpbGQsIDApO1xuICAgICAgICBzZXRBbGwocmVhbFNlbGVjdGlvbkNvbnRhaW5lciwgeyB0b3A6IGRvbS5nZXRQb3Mobm9kZSwgZWRpdG9yLmdldEJvZHkoKSkueSArICdweCcgfSk7XG4gICAgICAgIGZvY3VzJDEocmVhbFNlbGVjdGlvbkNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgICAgaWYgKHNlbCkge1xuICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWwuYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZWxtID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2xvbmUgPSBlbG0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBjb25zdCBlID0gZWRpdG9yLmRpc3BhdGNoKCdPYmplY3RTZWxlY3RlZCcsIHtcbiAgICAgICAgICB0YXJnZXQ6IGVsbSxcbiAgICAgICAgICB0YXJnZXRDbG9uZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZSA9IHNldHVwT2Zmc2NyZWVuU2VsZWN0aW9uKGVsbSwgZS50YXJnZXRDbG9uZSk7XG4gICAgICAgIGNvbnN0IG5vZGVFbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICBlYWNoJGUoZGVzY2VuZGFudHMoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSksIGAqWyR7IGVsZW1lbnRTZWxlY3Rpb25BdHRyIH1dYCksIGVsbSA9PiB7XG4gICAgICAgICAgaWYgKCFlcShub2RlRWxtLCBlbG0pKSB7XG4gICAgICAgICAgICByZW1vdmUkYShlbG0sIGVsZW1lbnRTZWxlY3Rpb25BdHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWRvbS5nZXRBdHRyaWIoZWxtLCBlbGVtZW50U2VsZWN0aW9uQXR0cikpIHtcbiAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKGVsZW1lbnRTZWxlY3Rpb25BdHRyLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IGVsbTtcbiAgICAgICAgaGlkZUZha2VDYXJldCgpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0RWxlbWVudFNlbGVjdGlvbiA9IChyYW5nZSwgZm9yd2FyZCkgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgIGlmICghaXNSYW5nZUluQ2FyZXRDb250YWluZXIocmFuZ2UpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IGdldE5vcm1hbGl6ZWRSYW5nZUVuZFBvaW50KGRpciwgcm9vdE5vZGUsIHJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZU5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUoIWZvcndhcmQpO1xuICAgICAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoYmVmb3JlTm9kZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzRmFrZUNhcmV0VGFyZ2V0KGJlZm9yZU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXIsIGJlZm9yZU5vZGUsIGZvcndhcmQgPyAhY2FyZXRQb3NpdGlvbi5pc0F0RW5kKCkgOiBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0NhcmV0Q29udGFpbmVySW5saW5lKGJlZm9yZU5vZGUpICYmIGlzQ29udGVudEVkaXRhYmxlRmFsc2UkYihiZWZvcmVOb2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgICAgICBybmcuc2V0U3RhcnQoYmVmb3JlTm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgcm5nLnNldEVuZChiZWZvcmVOb2RlLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZnRlck5vZGUgPSBjYXJldFBvc2l0aW9uLmdldE5vZGUoZm9yd2FyZCk7XG4gICAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZShhZnRlck5vZGUpKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Zha2VDYXJldFRhcmdldChhZnRlck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3dDYXJldChkaXIsIGFmdGVyTm9kZSwgZm9yd2FyZCA/IGZhbHNlIDogIWNhcmV0UG9zaXRpb24uaXNBdEVuZCgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQ2FyZXRDb250YWluZXJJbmxpbmUoYWZ0ZXJOb2RlKSAmJiBpc0NvbnRlbnRFZGl0YWJsZUZhbHNlJGIoYWZ0ZXJOb2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICAgICAgICAgICAgcm5nLnNldFN0YXJ0KGFmdGVyTm9kZSwgMSk7XG4gICAgICAgICAgICAgICAgcm5nLnNldEVuZChhZnRlck5vZGUsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBybmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGxldCBzdGFydE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlmIChpc1RleHQkYShzdGFydENvbnRhaW5lcikgJiYgc3RhcnRPZmZzZXQgPT09IDAgJiYgaXNDb250ZW50RWRpdGFibGVGYWxzZShzdGFydENvbnRhaW5lci5wYXJlbnROb2RlKSkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IGRvbS5ub2RlSW5kZXgoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRWxlbWVudCQ2KHN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRPZmZzZXQgPT09IHN0YXJ0T2Zmc2V0ICsgMSAmJiBzdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbc3RhcnRPZmZzZXRdO1xuICAgICAgICAgIGlmIChpc0Zha2VTZWxlY3Rpb25UYXJnZXRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0RWxlbWVudChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVtb3ZlRWxlbWVudFNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgIHNlbGVjdGVkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoZWxlbWVudFNlbGVjdGlvbkF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NlbmRhbnQoU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSksICcjJyArIHJlYWxTZWxlY3Rpb25JZCkuZWFjaChyZW1vdmUkNSk7XG4gICAgICAgIHNlbGVjdGVkRWxlbWVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgZmFrZUNhcmV0LmRlc3Ryb3koKTtcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjb25zdCBoaWRlRmFrZUNhcmV0ID0gKCkgPT4ge1xuICAgICAgICBmYWtlQ2FyZXQuaGlkZSgpO1xuICAgICAgfTtcbiAgICAgIGlmICghaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICByZWdpc3RlckV2ZW50cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvd0NhcmV0LFxuICAgICAgICBzaG93QmxvY2tDYXJldENvbnRhaW5lcixcbiAgICAgICAgaGlkZUZha2VDYXJldCxcbiAgICAgICAgZGVzdHJveVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Tm9ybWFsaXplZFRleHRPZmZzZXQgPSAoY29udGFpbmVyLCBvZmZzZXQpID0+IHtcbiAgICAgIGxldCBub3JtYWxpemVkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgZm9yIChsZXQgbm9kZSA9IGNvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7IGlzVGV4dCRhKG5vZGUpOyBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgbm9ybWFsaXplZE9mZnNldCArPSBub2RlLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRPZmZzZXQ7XG4gICAgfTtcbiAgICBjb25zdCBnZW5lcmF0ZVBhdGggPSAoZG9tLCByb290LCBub2RlLCBvZmZzZXQsIG5vcm1hbGl6ZWQpID0+IHtcbiAgICAgIGlmIChpc1RleHQkYShub2RlKSAmJiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBub2RlLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBwID0gbm9ybWFsaXplZCAmJiBpc1RleHQkYShub2RlKSA/IFtnZXROb3JtYWxpemVkVGV4dE9mZnNldChub2RlLCBvZmZzZXQpXSA6IFtvZmZzZXRdO1xuICAgICAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IHJvb3QgJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHAucHVzaChkb20ubm9kZUluZGV4KGN1cnJlbnQsIG5vcm1hbGl6ZWQpKTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50ID09PSByb290ID8gcC5yZXZlcnNlKCkgOiBbXTtcbiAgICB9O1xuICAgIGNvbnN0IGdlbmVyYXRlUGF0aFJhbmdlID0gKGRvbSwgcm9vdCwgc3RhcnROb2RlLCBzdGFydE9mZnNldCwgZW5kTm9kZSwgZW5kT2Zmc2V0LCBub3JtYWxpemVkID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZ2VuZXJhdGVQYXRoKGRvbSwgcm9vdCwgc3RhcnROb2RlLCBzdGFydE9mZnNldCwgbm9ybWFsaXplZCk7XG4gICAgICBjb25zdCBlbmQgPSBnZW5lcmF0ZVBhdGgoZG9tLCByb290LCBlbmROb2RlLCBlbmRPZmZzZXQsIG5vcm1hbGl6ZWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc29sdmVQYXRoID0gKHJvb3QsIHBhdGgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbm9kZVBhdGgucG9wKCk7XG4gICAgICBpZiAoIWlzTnVtYmVyKG9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkTm9kZSA9IGZvbGRsKG5vZGVQYXRoLCAob3B0Tm9kZSwgaW5kZXgpID0+IG9wdE5vZGUuYmluZChub2RlID0+IE9wdGlvbmFsLmZyb20obm9kZS5jaGlsZE5vZGVzW2luZGV4XSkpLCBPcHRpb25hbC5zb21lKHJvb3QpKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkTm9kZS5iaW5kKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChpc1RleHQkYShub2RlKSAmJiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBub2RlLmRhdGEubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNvbHZlUGF0aFJhbmdlID0gKHJvb3QsIHJhbmdlKSA9PiByZXNvbHZlUGF0aChyb290LCByYW5nZS5zdGFydCkuYmluZCgoe1xuICAgICAgbm9kZTogc3RhcnROb2RlLFxuICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldFxuICAgIH0pID0+IHJlc29sdmVQYXRoKHJvb3QsIHJhbmdlLmVuZCkubWFwKCh7XG4gICAgICBub2RlOiBlbmROb2RlLFxuICAgICAgb2Zmc2V0OiBlbmRPZmZzZXRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcm5nLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgcm5nLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHJuZztcbiAgICB9KSk7XG4gICAgY29uc3QgZ2VuZXJhdGVQYXRoUmFuZ2VGcm9tUmFuZ2UgPSAoZG9tLCByb290LCByYW5nZSwgbm9ybWFsaXplZCA9IGZhbHNlKSA9PiBnZW5lcmF0ZVBhdGhSYW5nZShkb20sIHJvb3QsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIG5vcm1hbGl6ZWQpO1xuXG4gICAgY29uc3QgY2xlYW5FbXB0eU5vZGVzID0gKGRvbSwgbm9kZSwgaXNSb290KSA9PiB7XG4gICAgICBpZiAobm9kZSAmJiBkb20uaXNFbXB0eShub2RlKSAmJiAhaXNSb290KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tLnJlbW92ZShub2RlLCBpc1RleHQkYShub2RlLmZpcnN0Q2hpbGQpICYmIGlzV2hpdGVzcGFjZVRleHQobm9kZS5maXJzdENoaWxkLmRhdGEpKTtcbiAgICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgcGFyZW50LCBpc1Jvb3QpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGVsZXRlUm5nID0gKGRvbSwgcm5nLCBpc1Jvb3QsIGNsZWFuID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRQYXJlbnQgPSBybmcuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IGVuZFBhcmVudCA9IHJuZy5lbmRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgIHJuZy5kZWxldGVDb250ZW50cygpO1xuICAgICAgaWYgKGNsZWFuICYmICFpc1Jvb3Qocm5nLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICBpZiAoaXNUZXh0JGEocm5nLnN0YXJ0Q29udGFpbmVyKSAmJiBybmcuc3RhcnRDb250YWluZXIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKHJuZy5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dCRhKHJuZy5lbmRDb250YWluZXIpICYmIHJuZy5lbmRDb250YWluZXIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkb20ucmVtb3ZlKHJuZy5lbmRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIHN0YXJ0UGFyZW50LCBpc1Jvb3QpO1xuICAgICAgICBpZiAoc3RhcnRQYXJlbnQgIT09IGVuZFBhcmVudCkge1xuICAgICAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIGVuZFBhcmVudCwgaXNSb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0UGFyZW50QmxvY2sgPSAoZWRpdG9yLCBybmcpID0+IE9wdGlvbmFsLmZyb20oZWRpdG9yLmRvbS5nZXRQYXJlbnQocm5nLnN0YXJ0Q29udGFpbmVyLCBlZGl0b3IuZG9tLmlzQmxvY2spKTtcbiAgICBjb25zdCByZXNvbHZlRnJvbUR5bmFtaWNQYXR0ZXJucyA9IChwYXR0ZXJuU2V0LCBibG9jaywgYmVmb3JlVGV4dCkgPT4ge1xuICAgICAgY29uc3QgZHluYW1pY1BhdHRlcm5zID0gcGF0dGVyblNldC5keW5hbWljUGF0dGVybnNMb29rdXAoe1xuICAgICAgICB0ZXh0OiBiZWZvcmVUZXh0LFxuICAgICAgICBibG9ja1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXR0ZXJuU2V0LFxuICAgICAgICBibG9ja1BhdHRlcm5zOiBnZXRCbG9ja1BhdHRlcm5zKGR5bmFtaWNQYXR0ZXJucykuY29uY2F0KHBhdHRlcm5TZXQuYmxvY2tQYXR0ZXJucyksXG4gICAgICAgIGlubGluZVBhdHRlcm5zOiBnZXRJbmxpbmVQYXR0ZXJucyhkeW5hbWljUGF0dGVybnMpLmNvbmNhdChwYXR0ZXJuU2V0LmlubGluZVBhdHRlcm5zKVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGdldEJlZm9yZVRleHQgPSAoZG9tLCBibG9jaywgbm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBybmcgPSBkb20uY3JlYXRlUm5nKCk7XG4gICAgICBybmcuc2V0U3RhcnQoYmxvY2ssIDApO1xuICAgICAgcm5nLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHJuZy50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdGFydHNXaXRoU2luZ2xlU3BhY2UgPSBzID0+IC9eXFxzW15cXHNdLy50ZXN0KHMpO1xuICAgIGNvbnN0IHN0cmlwUGF0dGVybiA9IChkb20sIGJsb2NrLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFRleHROb2RlID0gdGV4dEFmdGVyKGJsb2NrLCAwLCBibG9jayk7XG4gICAgICBmaXJzdFRleHROb2RlLmVhY2goc3BvdCA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzcG90LmNvbnRhaW5lcjtcbiAgICAgICAgc2NhblJpZ2h0KG5vZGUsIHBhdHRlcm4uc3RhcnQubGVuZ3RoLCBibG9jaykuZWFjaChlbmQgPT4ge1xuICAgICAgICAgIGNvbnN0IHJuZyA9IGRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICAgICAgcm5nLnNldEVuZChlbmQuY29udGFpbmVyLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgICBkZWxldGVSbmcoZG9tLCBybmcsIGUgPT4gZSA9PT0gYmxvY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKG5vZGUpO1xuICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGdldCQzKHRleHQpO1xuICAgICAgICBpZiAoc3RhcnRzV2l0aFNpbmdsZVNwYWNlKHRleHRDb250ZW50KSkge1xuICAgICAgICAgIHNldCh0ZXh0LCB0ZXh0Q29udGVudC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXBwbHlQYXR0ZXJuJDEgPSAoZWRpdG9yLCBtYXRjaCkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBtYXRjaC5wYXR0ZXJuO1xuICAgICAgY29uc3Qgcm5nID0gcmVzb2x2ZVBhdGhSYW5nZShkb20uZ2V0Um9vdCgpLCBtYXRjaC5yYW5nZSkuZ2V0T3JEaWUoJ1VuYWJsZSB0byByZXNvbHZlIHBhdGggcmFuZ2UnKTtcbiAgICAgIGNvbnN0IGlzQmxvY2tGb3JtYXROYW1lID0gKG5hbWUsIGZvcm1hdHRlcikgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXRTZXQgPSBmb3JtYXR0ZXIuZ2V0KG5hbWUpO1xuICAgICAgICByZXR1cm4gaXNBcnJheSQxKGZvcm1hdFNldCkgJiYgaGVhZChmb3JtYXRTZXQpLmV4aXN0cyhmb3JtYXQgPT4gaGFzJDIoZm9ybWF0LCAnYmxvY2snKSk7XG4gICAgICB9O1xuICAgICAgZ2V0UGFyZW50QmxvY2soZWRpdG9yLCBybmcpLmVhY2goYmxvY2sgPT4ge1xuICAgICAgICBpZiAocGF0dGVybi50eXBlID09PSAnYmxvY2stZm9ybWF0Jykge1xuICAgICAgICAgIGlmIChpc0Jsb2NrRm9ybWF0TmFtZShwYXR0ZXJuLmZvcm1hdCwgZWRpdG9yLmZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIHN0cmlwUGF0dGVybihlZGl0b3IuZG9tLCBibG9jaywgcGF0dGVybik7XG4gICAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIuYXBwbHkocGF0dGVybi5mb3JtYXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhdHRlcm4udHlwZSA9PT0gJ2Jsb2NrLWNvbW1hbmQnKSB7XG4gICAgICAgICAgZWRpdG9yLnVuZG9NYW5hZ2VyLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHN0cmlwUGF0dGVybihlZGl0b3IuZG9tLCBibG9jaywgcGF0dGVybik7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQocGF0dGVybi5jbWQsIGZhbHNlLCBwYXR0ZXJuLnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IHNvcnRQYXR0ZXJucyQxID0gcGF0dGVybnMgPT4gc29ydChwYXR0ZXJucywgKGEsIGIpID0+IGIuc3RhcnQubGVuZ3RoIC0gYS5zdGFydC5sZW5ndGgpO1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJuJDEgPSAocGF0dGVybnMsIHRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNvcnRlZFBhdHRlcm5zID0gc29ydFBhdHRlcm5zJDEocGF0dGVybnMpO1xuICAgICAgY29uc3QgbnVUZXh0ID0gdGV4dC5yZXBsYWNlKG5ic3AsICcgJyk7XG4gICAgICByZXR1cm4gZmluZCQyKHNvcnRlZFBhdHRlcm5zLCBwYXR0ZXJuID0+IHRleHQuaW5kZXhPZihwYXR0ZXJuLnN0YXJ0KSA9PT0gMCB8fCBudVRleHQuaW5kZXhPZihwYXR0ZXJuLnN0YXJ0KSA9PT0gMCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVybnMkMSA9IChlZGl0b3IsIGJsb2NrLCBwYXR0ZXJuU2V0LCBub3JtYWxpemVkTWF0Y2hlcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IGZvcmNlZFJvb3RCbG9jayA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgaWYgKCFkb20uaXMoYmxvY2ssIGZvcmNlZFJvb3RCbG9jaykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gKF9hID0gYmxvY2sudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgcmV0dXJuIGZpbmRQYXR0ZXJuJDEocGF0dGVyblNldC5ibG9ja1BhdHRlcm5zLCBibG9ja1RleHQpLm1hcChwYXR0ZXJuID0+IHtcbiAgICAgICAgaWYgKFRvb2xzLnRyaW0oYmxvY2tUZXh0KS5sZW5ndGggPT09IHBhdHRlcm4uc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgIHJhbmdlOiBnZW5lcmF0ZVBhdGhSYW5nZShkb20sIGRvbS5nZXRSb290KCksIGJsb2NrLCAwLCBibG9jaywgMCwgbm9ybWFsaXplZE1hdGNoZXMpXG4gICAgICAgICAgfV07XG4gICAgICB9KS5nZXRPcihbXSk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBseU1hdGNoZXMkMSA9IChlZGl0b3IsIG1hdGNoZXMpID0+IHtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBib29rbWFyayA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgIGVhY2gkZShtYXRjaGVzLCBtYXRjaCA9PiBhcHBseVBhdHRlcm4kMShlZGl0b3IsIG1hdGNoKSk7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3TWFya2VyID0gKGRvbSwgaWQpID0+IGRvbS5jcmVhdGUoJ3NwYW4nLCB7XG4gICAgICAnZGF0YS1tY2UtdHlwZSc6ICdib29rbWFyaycsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIGNvbnN0IHJhbmdlRnJvbU1hcmtlciA9IChkb20sIG1hcmtlcikgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgcm5nLnNldFN0YXJ0QWZ0ZXIobWFya2VyLnN0YXJ0KTtcbiAgICAgIHJuZy5zZXRFbmRCZWZvcmUobWFya2VyLmVuZCk7XG4gICAgICByZXR1cm4gcm5nO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlTWFya2VyID0gKGRvbSwgbWFya2VyUHJlZml4LCBwYXRoUmFuZ2UpID0+IHtcbiAgICAgIGNvbnN0IHJuZyA9IHJlc29sdmVQYXRoUmFuZ2UoZG9tLmdldFJvb3QoKSwgcGF0aFJhbmdlKS5nZXRPckRpZSgnVW5hYmxlIHRvIHJlc29sdmUgcGF0aCByYW5nZScpO1xuICAgICAgY29uc3Qgc3RhcnROb2RlID0gcm5nLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgY29uc3QgZW5kTm9kZSA9IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCB0ZXh0RW5kID0gcm5nLmVuZE9mZnNldCA9PT0gMCA/IGVuZE5vZGUgOiBlbmROb2RlLnNwbGl0VGV4dChybmcuZW5kT2Zmc2V0KTtcbiAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJuZy5zdGFydE9mZnNldCA9PT0gMCA/IHN0YXJ0Tm9kZSA6IHN0YXJ0Tm9kZS5zcGxpdFRleHQocm5nLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIGNvbnN0IHN0YXJ0UGFyZW50Tm9kZSA9IHRleHRTdGFydC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgZW5kUGFyZW50Tm9kZSA9IHRleHRFbmQucGFyZW50Tm9kZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogbWFya2VyUHJlZml4LFxuICAgICAgICBlbmQ6IGVuZFBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld01hcmtlcihkb20sIG1hcmtlclByZWZpeCArICctZW5kJyksIHRleHRFbmQpLFxuICAgICAgICBzdGFydDogc3RhcnRQYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdNYXJrZXIoZG9tLCBtYXJrZXJQcmVmaXggKyAnLXN0YXJ0JyksIHRleHRTdGFydClcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVNYXJrZXIgPSAoZG9tLCBtYXJrZXIsIGlzUm9vdCkgPT4ge1xuICAgICAgY2xlYW5FbXB0eU5vZGVzKGRvbSwgZG9tLmdldChtYXJrZXIucHJlZml4ICsgJy1lbmQnKSwgaXNSb290KTtcbiAgICAgIGNsZWFuRW1wdHlOb2Rlcyhkb20sIGRvbS5nZXQobWFya2VyLnByZWZpeCArICctc3RhcnQnKSwgaXNSb290KTtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNSZXBsYWNlbWVudFBhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm4uc3RhcnQubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IG1hdGNoZXNQYXR0ZXJuID0gcGF0dGVybkNvbnRlbnQgPT4gKGVsZW1lbnQsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQuZGF0YTtcbiAgICAgIGNvbnN0IHNlYXJjaFRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3Qgc3RhcnRFbmRJbmRleCA9IHNlYXJjaFRleHQubGFzdEluZGV4T2YocGF0dGVybkNvbnRlbnQuY2hhckF0KHBhdHRlcm5Db250ZW50Lmxlbmd0aCAtIDEpKTtcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzZWFyY2hUZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm5Db250ZW50KTtcbiAgICAgIGlmIChzdGFydEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc3RhcnRJbmRleCArIHBhdHRlcm5Db250ZW50Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0RW5kSW5kZXggKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5TdGFydEZyb21TcG90ID0gKGRvbSwgcGF0dGVybiwgYmxvY2ssIHNwb3QpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybiA9IHBhdHRlcm4uc3RhcnQ7XG4gICAgICBjb25zdCBzdGFydFNwb3QgPSByZXBlYXRMZWZ0KGRvbSwgc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0LCBtYXRjaGVzUGF0dGVybihzdGFydFBhdHRlcm4pLCBibG9jayk7XG4gICAgICByZXR1cm4gc3RhcnRTcG90LmJpbmQoc3BvdCA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHN0YXJ0UGF0dGVybkluZGV4ID0gKF9iID0gKF9hID0gYmxvY2sudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKHN0YXJ0UGF0dGVybikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xO1xuICAgICAgICBjb25zdCBpc0NvbXBsZXRlTWF0Y2ggPSBzdGFydFBhdHRlcm5JbmRleCAhPT0gLTEgJiYgc3BvdC5vZmZzZXQgPj0gc3RhcnRQYXR0ZXJuSW5kZXggKyBzdGFydFBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZU1hdGNoKSB7XG4gICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgIHJuZy5zZXRTdGFydChzcG90LmNvbnRhaW5lciwgc3BvdC5vZmZzZXQgLSBzdGFydFBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICBybmcuc2V0RW5kKHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUocm5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzcG90Lm9mZnNldCAtIHN0YXJ0UGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHNjYW5MZWZ0KHNwb3QuY29udGFpbmVyLCBvZmZzZXQsIGJsb2NrKS5tYXAobmV4dFNwb3QgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KG5leHRTcG90LmNvbnRhaW5lciwgbmV4dFNwb3Qub2Zmc2V0KTtcbiAgICAgICAgICAgIHJuZy5zZXRFbmQoc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBybmc7XG4gICAgICAgICAgfSkuZmlsdGVyKHJuZyA9PiBybmcudG9TdHJpbmcoKSA9PT0gc3RhcnRQYXR0ZXJuKS5vclRodW5rKCgpID0+IGZpbmRQYXR0ZXJuU3RhcnRGcm9tU3BvdChkb20sIHBhdHRlcm4sIGJsb2NrLCBwb2ludChzcG90LmNvbnRhaW5lciwgMCkpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVyblN0YXJ0ID0gKGRvbSwgcGF0dGVybiwgbm9kZSwgb2Zmc2V0LCBibG9jaywgcmVxdWlyZUdhcCA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAocGF0dGVybi5zdGFydC5sZW5ndGggPT09IDAgJiYgIXJlcXVpcmVHYXApIHtcbiAgICAgICAgY29uc3Qgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICBybmcuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShybmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRCZWZvcmUobm9kZSwgb2Zmc2V0LCBibG9jaykuYmluZChzcG90ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kUGF0dGVyblN0YXJ0RnJvbVNwb3QoZG9tLCBwYXR0ZXJuLCBibG9jaywgc3BvdCk7XG4gICAgICAgIHJldHVybiBzdGFydC5iaW5kKHN0YXJ0UmFuZ2UgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAocmVxdWlyZUdhcCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0UmFuZ2UuZW5kQ29udGFpbmVyID09PSBzcG90LmNvbnRhaW5lciAmJiBzdGFydFJhbmdlLmVuZE9mZnNldCA9PT0gc3BvdC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BvdC5vZmZzZXQgPT09IDAgJiYgKChfYSA9IHN0YXJ0UmFuZ2UuZW5kQ29udGFpbmVyLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gc3RhcnRSYW5nZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoc3RhcnRSYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5kUGF0dGVybiA9IChlZGl0b3IsIGJsb2NrLCBkZXRhaWxzLCBub3JtYWxpemVkTWF0Y2hlcykgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJvb3QgPSBkb20uZ2V0Um9vdCgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGRldGFpbHMucGF0dGVybjtcbiAgICAgIGNvbnN0IGVuZE5vZGUgPSBkZXRhaWxzLnBvc2l0aW9uLmNvbnRhaW5lcjtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGRldGFpbHMucG9zaXRpb24ub2Zmc2V0O1xuICAgICAgcmV0dXJuIHNjYW5MZWZ0KGVuZE5vZGUsIGVuZE9mZnNldCAtIGRldGFpbHMucGF0dGVybi5lbmQubGVuZ3RoLCBibG9jaykuYmluZChzcG90ID0+IHtcbiAgICAgICAgY29uc3QgZW5kUGF0aFJuZyA9IGdlbmVyYXRlUGF0aFJhbmdlKGRvbSwgcm9vdCwgc3BvdC5jb250YWluZXIsIHNwb3Qub2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQsIG5vcm1hbGl6ZWRNYXRjaGVzKTtcbiAgICAgICAgaWYgKGlzUmVwbGFjZW1lbnRQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoe1xuICAgICAgICAgICAgbWF0Y2hlczogW3tcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIHN0YXJ0Um5nOiBlbmRQYXRoUm5nLFxuICAgICAgICAgICAgICAgIGVuZFJuZzogZW5kUGF0aFJuZ1xuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzcG90XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0c09wdCA9IGZpbmRQYXR0ZXJuc1JlYyhlZGl0b3IsIGRldGFpbHMucmVtYWluaW5nUGF0dGVybnMsIHNwb3QuY29udGFpbmVyLCBzcG90Lm9mZnNldCwgYmxvY2ssIG5vcm1hbGl6ZWRNYXRjaGVzKTtcbiAgICAgICAgICBjb25zdCByZXN1bHRzID0gcmVzdWx0c09wdC5nZXRPcih7XG4gICAgICAgICAgICBtYXRjaGVzOiBbXSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzcG90XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcG9zID0gcmVzdWx0cy5wb3NpdGlvbjtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZpbmRQYXR0ZXJuU3RhcnQoZG9tLCBwYXR0ZXJuLCBwb3MuY29udGFpbmVyLCBwb3Mub2Zmc2V0LCBibG9jaywgcmVzdWx0c09wdC5pc05vbmUoKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0Lm1hcChzdGFydFJuZyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBhdGhSbmcgPSBnZW5lcmF0ZVBhdGhSYW5nZUZyb21SYW5nZShkb20sIHJvb3QsIHN0YXJ0Um5nLCBub3JtYWxpemVkTWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBtYXRjaGVzOiByZXN1bHRzLm1hdGNoZXMuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgc3RhcnRSbmc6IHN0YXJ0UGF0aFJuZyxcbiAgICAgICAgICAgICAgICAgIGVuZFJuZzogZW5kUGF0aFJuZ1xuICAgICAgICAgICAgICAgIH1dKSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvaW50KHN0YXJ0Um5nLnN0YXJ0Q29udGFpbmVyLCBzdGFydFJuZy5zdGFydE9mZnNldClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmluZFBhdHRlcm5zUmVjID0gKGVkaXRvciwgcGF0dGVybnMsIG5vZGUsIG9mZnNldCwgYmxvY2ssIG5vcm1hbGl6ZWRNYXRjaGVzKSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgcmV0dXJuIHRleHRCZWZvcmUobm9kZSwgb2Zmc2V0LCBkb20uZ2V0Um9vdCgpKS5iaW5kKGVuZFNwb3QgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZ2V0QmVmb3JlVGV4dChkb20sIGJsb2NrLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICAgIGlmICghZW5kc1dpdGgodGV4dCwgcGF0dGVybi5lbmQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcGF0dGVybnNXaXRob3V0Q3VycmVudCA9IHBhdHRlcm5zLnNsaWNlKCk7XG4gICAgICAgICAgcGF0dGVybnNXaXRob3V0Q3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZmluZFBhdHRlcm4oZWRpdG9yLCBibG9jaywge1xuICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgIHJlbWFpbmluZ1BhdHRlcm5zOiBwYXR0ZXJuc1dpdGhvdXRDdXJyZW50LFxuICAgICAgICAgICAgcG9zaXRpb246IGVuZFNwb3RcbiAgICAgICAgICB9LCBub3JtYWxpemVkTWF0Y2hlcyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc05vbmUoKSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZFBhdHRlcm5zUmVjKGVkaXRvciwgcGF0dGVybnMsIG5vZGUsIG9mZnNldCAtIDEsIGJsb2NrLCBub3JtYWxpemVkTWF0Y2hlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5UGF0dGVybiA9IChlZGl0b3IsIHBhdHRlcm4sIHBhdHRlcm5SYW5nZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocGF0dGVyblJhbmdlKTtcbiAgICAgIGlmIChwYXR0ZXJuLnR5cGUgPT09ICdpbmxpbmUtZm9ybWF0Jykge1xuICAgICAgICBlYWNoJGUocGF0dGVybi5mb3JtYXQsIGZvcm1hdCA9PiB7XG4gICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5hcHBseShmb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5leGVjQ29tbWFuZChwYXR0ZXJuLmNtZCwgZmFsc2UsIHBhdHRlcm4udmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXBwbHlSZXBsYWNlbWVudFBhdHRlcm4gPSAoZWRpdG9yLCBwYXR0ZXJuLCBtYXJrZXIsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3QgbWFya2VyUmFuZ2UgPSByYW5nZUZyb21NYXJrZXIoZWRpdG9yLmRvbSwgbWFya2VyKTtcbiAgICAgIGRlbGV0ZVJuZyhlZGl0b3IuZG9tLCBtYXJrZXJSYW5nZSwgaXNSb290KTtcbiAgICAgIGFwcGx5UGF0dGVybihlZGl0b3IsIHBhdHRlcm4sIG1hcmtlclJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5UGF0dGVybldpdGhDb250ZW50ID0gKGVkaXRvciwgcGF0dGVybiwgc3RhcnRNYXJrZXIsIGVuZE1hcmtlciwgaXNSb290KSA9PiB7XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgbWFya2VyRW5kUmFuZ2UgPSByYW5nZUZyb21NYXJrZXIoZG9tLCBlbmRNYXJrZXIpO1xuICAgICAgY29uc3QgbWFya2VyU3RhcnRSYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihkb20sIHN0YXJ0TWFya2VyKTtcbiAgICAgIGRlbGV0ZVJuZyhkb20sIG1hcmtlclN0YXJ0UmFuZ2UsIGlzUm9vdCk7XG4gICAgICBkZWxldGVSbmcoZG9tLCBtYXJrZXJFbmRSYW5nZSwgaXNSb290KTtcbiAgICAgIGNvbnN0IHBhdHRlcm5NYXJrZXIgPSB7XG4gICAgICAgIHByZWZpeDogc3RhcnRNYXJrZXIucHJlZml4LFxuICAgICAgICBzdGFydDogc3RhcnRNYXJrZXIuZW5kLFxuICAgICAgICBlbmQ6IGVuZE1hcmtlci5zdGFydFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhdHRlcm5SYW5nZSA9IHJhbmdlRnJvbU1hcmtlcihkb20sIHBhdHRlcm5NYXJrZXIpO1xuICAgICAgYXBwbHlQYXR0ZXJuKGVkaXRvciwgcGF0dGVybiwgcGF0dGVyblJhbmdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGFkZE1hcmtlcnMgPSAoZG9tLCBtYXRjaGVzKSA9PiB7XG4gICAgICBjb25zdCBtYXJrZXJQcmVmaXggPSBnZW5lcmF0ZSQxKCdtY2VfdGV4dHBhdHRlcm4nKTtcbiAgICAgIGNvbnN0IG1hdGNoZXNXaXRoRW5kcyA9IGZvbGRyKG1hdGNoZXMsIChhY2MsIG1hdGNoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuZE1hcmtlciA9IGNyZWF0ZU1hcmtlcihkb20sIG1hcmtlclByZWZpeCArIGBfZW5kJHsgYWNjLmxlbmd0aCB9YCwgbWF0Y2guZW5kUm5nKTtcbiAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQoW3tcbiAgICAgICAgICAgIC4uLm1hdGNoLFxuICAgICAgICAgICAgZW5kTWFya2VyXG4gICAgICAgICAgfV0pO1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIGZvbGRyKG1hdGNoZXNXaXRoRW5kcywgKGFjYywgbWF0Y2gpID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gbWF0Y2hlc1dpdGhFbmRzLmxlbmd0aCAtIGFjYy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBzdGFydE1hcmtlciA9IGlzUmVwbGFjZW1lbnRQYXR0ZXJuKG1hdGNoLnBhdHRlcm4pID8gbWF0Y2guZW5kTWFya2VyIDogY3JlYXRlTWFya2VyKGRvbSwgbWFya2VyUHJlZml4ICsgYF9zdGFydCR7IGlkeCB9YCwgbWF0Y2guc3RhcnRSbmcpO1xuICAgICAgICByZXR1cm4gYWNjLmNvbmNhdChbe1xuICAgICAgICAgICAgLi4ubWF0Y2gsXG4gICAgICAgICAgICBzdGFydE1hcmtlclxuICAgICAgICAgIH1dKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IHNvcnRQYXR0ZXJucyA9IHBhdHRlcm5zID0+IHNvcnQocGF0dGVybnMsIChhLCBiKSA9PiBiLmVuZC5sZW5ndGggLSBhLmVuZC5sZW5ndGgpO1xuICAgIGNvbnN0IGdldEJlc3RNYXRjaGVzID0gKG1hdGNoZXMsIG1hdGNoZXNXaXRoU29ydGVkUGF0dGVybnMpID0+IHtcbiAgICAgIGNvbnN0IGhhc1NhbWVNYXRjaGVzID0gZm9yYWxsKG1hdGNoZXMsIG1hdGNoID0+IGV4aXN0cyhtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zLCBzb3J0ZWRNYXRjaCA9PiBtYXRjaC5wYXR0ZXJuLnN0YXJ0ID09PSBzb3J0ZWRNYXRjaC5wYXR0ZXJuLnN0YXJ0ICYmIG1hdGNoLnBhdHRlcm4uZW5kID09PSBzb3J0ZWRNYXRjaC5wYXR0ZXJuLmVuZCkpO1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zLmxlbmd0aCkge1xuICAgICAgICBpZiAoaGFzU2FtZU1hdGNoZXMpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlc1dpdGhTb3J0ZWRQYXR0ZXJucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID4gbWF0Y2hlc1dpdGhTb3J0ZWRQYXR0ZXJucy5sZW5ndGggPyBtYXRjaGVzIDogbWF0Y2hlc1dpdGhTb3J0ZWRQYXR0ZXJucztcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRQYXR0ZXJucyA9IChlZGl0b3IsIGJsb2NrLCBub2RlLCBvZmZzZXQsIHBhdHRlcm5TZXQsIG5vcm1hbGl6ZWRNYXRjaGVzKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZmluZFBhdHRlcm5zUmVjKGVkaXRvciwgcGF0dGVyblNldC5pbmxpbmVQYXR0ZXJucywgbm9kZSwgb2Zmc2V0LCBibG9jaywgbm9ybWFsaXplZE1hdGNoZXMpLmZvbGQoKCkgPT4gW10sIHJlc3VsdCA9PiByZXN1bHQubWF0Y2hlcyk7XG4gICAgICBjb25zdCBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zID0gZmluZFBhdHRlcm5zUmVjKGVkaXRvciwgc29ydFBhdHRlcm5zKHBhdHRlcm5TZXQuaW5saW5lUGF0dGVybnMpLCBub2RlLCBvZmZzZXQsIGJsb2NrLCBub3JtYWxpemVkTWF0Y2hlcykuZm9sZCgoKSA9PiBbXSwgcmVzdWx0ID0+IHJlc3VsdC5tYXRjaGVzKTtcbiAgICAgIHJldHVybiBnZXRCZXN0TWF0Y2hlcyhtYXRjaGVzLCBtYXRjaGVzV2l0aFNvcnRlZFBhdHRlcm5zKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGx5TWF0Y2hlcyA9IChlZGl0b3IsIG1hdGNoZXMpID0+IHtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkb20gPSBlZGl0b3IuZG9tO1xuICAgICAgY29uc3QgYm9va21hcmsgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICBjb25zdCBtYXRjaGVzV2l0aE1hcmtlcnMgPSBhZGRNYXJrZXJzKGRvbSwgbWF0Y2hlcyk7XG4gICAgICBlYWNoJGUobWF0Y2hlc1dpdGhNYXJrZXJzLCBtYXRjaCA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZG9tLmdldFBhcmVudChtYXRjaC5zdGFydE1hcmtlci5zdGFydCwgZG9tLmlzQmxvY2spO1xuICAgICAgICBjb25zdCBpc1Jvb3QgPSBub2RlID0+IG5vZGUgPT09IGJsb2NrO1xuICAgICAgICBpZiAoaXNSZXBsYWNlbWVudFBhdHRlcm4obWF0Y2gucGF0dGVybikpIHtcbiAgICAgICAgICBhcHBseVJlcGxhY2VtZW50UGF0dGVybihlZGl0b3IsIG1hdGNoLnBhdHRlcm4sIG1hdGNoLmVuZE1hcmtlciwgaXNSb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBseVBhdHRlcm5XaXRoQ29udGVudChlZGl0b3IsIG1hdGNoLnBhdHRlcm4sIG1hdGNoLnN0YXJ0TWFya2VyLCBtYXRjaC5lbmRNYXJrZXIsIGlzUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlTWFya2VyKGRvbSwgbWF0Y2guZW5kTWFya2VyLCBpc1Jvb3QpO1xuICAgICAgICByZW1vdmVNYXJrZXIoZG9tLCBtYXRjaC5zdGFydE1hcmtlciwgaXNSb290KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Cb29rbWFyayhib29rbWFyayk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKGVkaXRvciwgcGF0dGVyblNldCkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIHJldHVybiBnZXRQYXJlbnRCbG9jayhlZGl0b3IsIHJuZykubWFwKGJsb2NrID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heCgwLCBybmcuc3RhcnRPZmZzZXQpO1xuICAgICAgICBjb25zdCBkeW5hbWljUGF0dGVyblNldCA9IHJlc29sdmVGcm9tRHluYW1pY1BhdHRlcm5zKHBhdHRlcm5TZXQsIGJsb2NrLCAoX2EgPSBibG9jay50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICBjb25zdCBpbmxpbmVNYXRjaGVzID0gZmluZFBhdHRlcm5zKGVkaXRvciwgYmxvY2ssIHJuZy5zdGFydENvbnRhaW5lciwgb2Zmc2V0LCBkeW5hbWljUGF0dGVyblNldCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGJsb2NrTWF0Y2hlcyA9IGZpbmRQYXR0ZXJucyQxKGVkaXRvciwgYmxvY2ssIGR5bmFtaWNQYXR0ZXJuU2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGJsb2NrTWF0Y2hlcy5sZW5ndGggPiAwIHx8IGlubGluZU1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIuZXh0cmEoKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdtY2VJbnNlcnROZXdMaW5lJyk7XG4gICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLmluc2VydENvbnRlbnQoemVyb1dpZHRoKTtcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hlcyhlZGl0b3IsIGlubGluZU1hdGNoZXMpO1xuICAgICAgICAgICAgYXBwbHlNYXRjaGVzJDEoZWRpdG9yLCBibG9ja01hdGNoZXMpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgY29uc3Qgc3BvdCA9IHRleHRCZWZvcmUocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCBlZGl0b3IuZG9tLmdldFJvb3QoKSk7XG4gICAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydE5ld0xpbmUnKTtcbiAgICAgICAgICAgIHNwb3QuZWFjaChzID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHMuY29udGFpbmVyO1xuICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhLmNoYXJBdChzLm9mZnNldCAtIDEpID09PSB6ZXJvV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLmRlbGV0ZURhdGEocy5vZmZzZXQgLSAxLCAxKTtcbiAgICAgICAgICAgICAgICBjbGVhbkVtcHR5Tm9kZXMoZWRpdG9yLmRvbSwgbm9kZS5wYXJlbnROb2RlLCBlID0+IGUgPT09IGVkaXRvci5kb20uZ2V0Um9vdCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkuZ2V0T3IoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlSW5saW5lS2V5ID0gKGVkaXRvciwgcGF0dGVyblNldCkgPT4ge1xuICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSbmcoKTtcbiAgICAgIGdldFBhcmVudEJsb2NrKGVkaXRvciwgcm5nKS5tYXAoYmxvY2sgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heCgwLCBybmcuc3RhcnRPZmZzZXQgLSAxKTtcbiAgICAgICAgY29uc3QgYmVmb3JlVGV4dCA9IGdldEJlZm9yZVRleHQoZWRpdG9yLmRvbSwgYmxvY2ssIHJuZy5zdGFydENvbnRhaW5lciwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgZHluYW1pY1BhdHRlcm5TZXQgPSByZXNvbHZlRnJvbUR5bmFtaWNQYXR0ZXJucyhwYXR0ZXJuU2V0LCBibG9jaywgYmVmb3JlVGV4dCk7XG4gICAgICAgIGNvbnN0IGlubGluZU1hdGNoZXMgPSBmaW5kUGF0dGVybnMoZWRpdG9yLCBibG9jaywgcm5nLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQsIGR5bmFtaWNQYXR0ZXJuU2V0LCBmYWxzZSk7XG4gICAgICAgIGlmIChpbmxpbmVNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgYXBwbHlNYXRjaGVzKGVkaXRvciwgaW5saW5lTWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2hlY2tLZXlFdmVudCA9IChjb2RlcywgZXZlbnQsIHByZWRpY2F0ZSkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJlZGljYXRlKGNvZGVzW2ldLCBldmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgY2hlY2tLZXlDb2RlID0gKGNvZGVzLCBldmVudCkgPT4gY2hlY2tLZXlFdmVudChjb2RlcywgZXZlbnQsIChjb2RlLCBldmVudCkgPT4ge1xuICAgICAgcmV0dXJuIGNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiYgIVZLLm1vZGlmaWVyUHJlc3NlZChldmVudCk7XG4gICAgfSk7XG4gICAgY29uc3QgY2hlY2tDaGFyQ29kZSA9IChjaGFycywgZXZlbnQpID0+IGNoZWNrS2V5RXZlbnQoY2hhcnMsIGV2ZW50LCAoY2hyLCBldmVudCkgPT4ge1xuICAgICAgcmV0dXJuIGNoci5jaGFyQ29kZUF0KDApID09PSBldmVudC5jaGFyQ29kZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNldHVwJDIgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgY2hhckNvZGVzID0gW1xuICAgICAgICAnLCcsXG4gICAgICAgICcuJyxcbiAgICAgICAgJzsnLFxuICAgICAgICAnOicsXG4gICAgICAgICchJyxcbiAgICAgICAgJz8nXG4gICAgICBdO1xuICAgICAgY29uc3Qga2V5Q29kZXMgPSBbMzJdO1xuICAgICAgY29uc3QgZ2V0UGF0dGVyblNldCA9ICgpID0+IGNyZWF0ZVBhdHRlcm5TZXQoZ2V0VGV4dFBhdHRlcm5zKGVkaXRvciksIGdldFRleHRQYXR0ZXJuc0xvb2t1cChlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGhhc0R5bmFtaWNQYXR0ZXJucyA9ICgpID0+IGhhc1RleHRQYXR0ZXJuc0xvb2t1cChlZGl0b3IpO1xuICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmICFWSy5tb2RpZmllclByZXNzZWQoZSkgJiYgZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcGF0dGVyblNldCA9IGdldFBhdHRlcm5TZXQoKTtcbiAgICAgICAgICBjb25zdCBoYXNQYXR0ZXJucyA9IHBhdHRlcm5TZXQuaW5saW5lUGF0dGVybnMubGVuZ3RoID4gMCB8fCBwYXR0ZXJuU2V0LmJsb2NrUGF0dGVybnMubGVuZ3RoID4gMCB8fCBoYXNEeW5hbWljUGF0dGVybnMoKTtcbiAgICAgICAgICBpZiAoaGFzUGF0dGVybnMgJiYgaGFuZGxlRW50ZXIoZWRpdG9yLCBwYXR0ZXJuU2V0KSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBjb25zdCBoYW5kbGVJbmxpbmVUcmlnZ2VyID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcGF0dGVyblNldCA9IGdldFBhdHRlcm5TZXQoKTtcbiAgICAgICAgICBjb25zdCBoYXNQYXR0ZXJucyA9IHBhdHRlcm5TZXQuaW5saW5lUGF0dGVybnMubGVuZ3RoID4gMCB8fCBoYXNEeW5hbWljUGF0dGVybnMoKTtcbiAgICAgICAgICBpZiAoaGFzUGF0dGVybnMpIHtcbiAgICAgICAgICAgIGhhbmRsZUlubGluZUtleShlZGl0b3IsIHBhdHRlcm5TZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVkaXRvci5vbigna2V5dXAnLCBlID0+IHtcbiAgICAgICAgaWYgKGNoZWNrS2V5Q29kZShrZXlDb2RlcywgZSkpIHtcbiAgICAgICAgICBoYW5kbGVJbmxpbmVUcmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdrZXlwcmVzcycsIGUgPT4ge1xuICAgICAgICBpZiAoY2hlY2tDaGFyQ29kZShjaGFyQ29kZXMsIGUpKSB7XG4gICAgICAgICAgRGVsYXkuc2V0RWRpdG9yVGltZW91dChlZGl0b3IsIGhhbmRsZUlubGluZVRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXAkMSA9IGVkaXRvciA9PiB7XG4gICAgICBzZXR1cCQyKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IFF1aXJrcyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBlYWNoID0gVG9vbHMuZWFjaDtcbiAgICAgIGNvbnN0IEJBQ0tTUEFDRSA9IFZLLkJBQ0tTUEFDRSwgREVMRVRFID0gVksuREVMRVRFLCBkb20gPSBlZGl0b3IuZG9tLCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLCBwYXJzZXIgPSBlZGl0b3IucGFyc2VyO1xuICAgICAgY29uc3QgYnJvd3NlciA9IEVudi5icm93c2VyO1xuICAgICAgY29uc3QgaXNHZWNrbyA9IGJyb3dzZXIuaXNGaXJlZm94KCk7XG4gICAgICBjb25zdCBpc1dlYktpdCA9IGJyb3dzZXIuaXNDaHJvbWl1bSgpIHx8IGJyb3dzZXIuaXNTYWZhcmkoKTtcbiAgICAgIGNvbnN0IGlzaU9TID0gRW52LmRldmljZVR5cGUuaXNpUGhvbmUoKSB8fCBFbnYuZGV2aWNlVHlwZS5pc2lQYWQoKTtcbiAgICAgIGNvbnN0IGlzTWFjID0gRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKTtcbiAgICAgIGNvbnN0IHNldEVkaXRvckNvbW1hbmRTdGF0ZSA9IChjbWQsIHN0YXRlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKGNtZCwgZmFsc2UsIFN0cmluZyhzdGF0ZSkpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNEZWZhdWx0UHJldmVudGVkID0gZSA9PiB7XG4gICAgICAgIHJldHVybiBlLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGVtcHR5RWRpdG9yV2hlbkRlbGV0aW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVSbmcgPSBybmcgPT4ge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBkb20uY3JlYXRlKCdib2R5Jyk7XG4gICAgICAgICAgY29uc3QgY29udGVudHMgPSBybmcuY2xvbmVDb250ZW50cygpO1xuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uc2VyaWFsaXplci5zZXJpYWxpemUoYm9keSwgeyBmb3JtYXQ6ICdodG1sJyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWxsQ29udGVudHNTZWxlY3RlZCA9IHJuZyA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc2VyaWFsaXplUm5nKHJuZyk7XG4gICAgICAgICAgY29uc3QgYWxsUm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgIGFsbFJuZy5zZWxlY3ROb2RlKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgICAgIGNvbnN0IGFsbFNlbGVjdGlvbiA9IHNlcmlhbGl6ZVJuZyhhbGxSbmcpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24gPT09IGFsbFNlbGVjdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFzUHJlc2VydmVkRW1wdHlFbGVtZW50cyA9IGVsbSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NvcGUgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlbG0pO1xuICAgICAgICAgIGNvbnN0IGlzRWRpdGFibGVIb3N0ID0gZWxtID0+IHBhcmVudEVsZW1lbnQoZWxtKS5leGlzdHMoZWxtID0+ICFpc0VkaXRhYmxlJDMoZWxtKSk7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0cyhkZXNjZW5kYW50cyhzY29wZSwgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJyksIGlzRWRpdGFibGVIb3N0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiAoa2V5Q29kZSA9PT0gREVMRVRFIHx8IGtleUNvZGUgPT09IEJBQ0tTUEFDRSkgJiYgZWRpdG9yLnNlbGVjdGlvbi5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsYXBzZWQgJiYgKCFkb20uaXNFbXB0eShib2R5KSB8fCBoYXNQcmVzZXJ2ZWRFbXB0eUVsZW1lbnRzKGJvZHkpKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VkICYmICFhbGxDb250ZW50c1NlbGVjdGVkKGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50KCcnKTtcbiAgICAgICAgICAgIGlmIChib2R5LmZpcnN0Q2hpbGQgJiYgZG9tLmlzQmxvY2soYm9keS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGJvZHkuZmlyc3RDaGlsZCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKGJvZHksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZWxlY3RBbGwgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5zaG9ydGN1dHMuYWRkKCdtZXRhK2EnLCBudWxsLCAnU2VsZWN0QWxsJyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZG9jdW1lbnRFbGVtZW50RWRpdGluZ0ZvY3VzID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICBkb20uYmluZChlZGl0b3IuZ2V0RG9jKCksICdtb3VzZWRvd24gbW91c2V1cCcsIGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJuZztcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWRpdG9yLmdldERvYygpLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICBybmcgPSBzZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5nZXRCb2R5KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDYXJldENvbnRhaW5lciQyKHJuZy5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnBsYWNlQ2FyZXRBdChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFJuZyhybmcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZW1vdmVIck9uQmFja3NwYWNlID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCBlID0+IHtcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiBlLmtleUNvZGUgPT09IEJBQ0tTUEFDRSkge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuZ2V0Qm9keSgpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdocicpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLmdldFJuZygpLnN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdIUicpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAmJiBwcmV2aW91c1NpYmxpbmcubm9kZU5hbWUgJiYgcHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdocicpIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlKHByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmb2N1c0JvZHkgPSAoKSA9PiB7XG4gICAgICAgIGlmICghUmFuZ2UucHJvdG90eXBlLmdldENsaWVudFJlY3RzKSB7XG4gICAgICAgICAgZWRpdG9yLm9uKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKGUpICYmIGUudGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgICAgICAgIGJvZHkuYmx1cigpO1xuICAgICAgICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZWxlY3RDb250cm9sRWxlbWVudHMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpc3VhbEFpZHNBbmNob3JDbGFzcyA9IGdldFZpc3VhbEFpZHNBbmNob3JDbGFzcyhlZGl0b3IpO1xuICAgICAgICBlZGl0b3Iub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKC9eKElNR3xIUikkLy50ZXN0KHRhcmdldC5ub2RlTmFtZSkgJiYgZG9tLmlzRWRpdGFibGUodGFyZ2V0LnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdBJyAmJiBkb20uaGFzQ2xhc3ModGFyZ2V0LCB2aXN1YWxBaWRzQW5jaG9yQ2xhc3MpICYmIHRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiBkb20uaXNFZGl0YWJsZSh0YXJnZXQucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3QodGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZVN0eWxlc1doZW5EZWxldGluZ0Fjcm9zc0Jsb2NrRWxlbWVudHMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdldEF0dHJpYnV0ZUFwcGx5RnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBkb20uZ2V0QXR0cmlicyhzZWxlY3Rpb24uZ2V0U3RhcnQoKS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0aW9uLmdldFN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBlZGl0b3IuZ2V0Qm9keSgpKSB7XG4gICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWIodGFyZ2V0LCAnc3R5bGUnLCBudWxsKTtcbiAgICAgICAgICAgICAgZWFjaCh0ZW1wbGF0ZSwgYXR0ciA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZU5vZGUoYXR0ci5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbkFjcm9zc0VsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgZG9tLmdldFBhcmVudChzZWxlY3Rpb24uZ2V0U3RhcnQoKSwgZG9tLmlzQmxvY2spICE9PSBkb20uZ2V0UGFyZW50KHNlbGVjdGlvbi5nZXRFbmQoKSwgZG9tLmlzQmxvY2spO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0b3Iub24oJ2tleXByZXNzJywgZSA9PiB7XG4gICAgICAgICAgbGV0IGFwcGx5QXR0cmlidXRlcztcbiAgICAgICAgICBpZiAoIWlzRGVmYXVsdFByZXZlbnRlZChlKSAmJiAoZS5rZXlDb2RlID09PSA4IHx8IGUua2V5Q29kZSA9PT0gNDYpICYmIGlzU2VsZWN0aW9uQWNyb3NzRWxlbWVudHMoKSkge1xuICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlQXBwbHlGdW5jdGlvbigpO1xuICAgICAgICAgICAgZWRpdG9yLmdldERvYygpLmV4ZWNDb21tYW5kKCdkZWxldGUnLCBmYWxzZSk7XG4gICAgICAgICAgICBhcHBseUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZG9tLmJpbmQoZWRpdG9yLmdldERvYygpLCAnY3V0JywgZSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0RlZmF1bHRQcmV2ZW50ZWQoZSkgJiYgaXNTZWxlY3Rpb25BY3Jvc3NFbGVtZW50cygpKSB7XG4gICAgICAgICAgICBjb25zdCBhcHBseUF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVBcHBseUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICBhcHBseUF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZGlzYWJsZUJhY2tzcGFjZUludG9BVGFibGUgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmICghaXNEZWZhdWx0UHJldmVudGVkKGUpICYmIGUua2V5Q29kZSA9PT0gQkFDS1NQQUNFKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLmdldFJuZygpLnN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZyA9IHNlbGVjdGlvbi5nZXROb2RlKCkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIHByZXZpb3VzU2libGluZy5ub2RlTmFtZSAmJiBwcmV2aW91c1NpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYmxlJykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUJsb2NrUXVvdGVPbkJhY2tTcGFjZSA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXlkb3duJywgZSA9PiB7XG4gICAgICAgICAgaWYgKGlzRGVmYXVsdFByZXZlbnRlZChlKSB8fCBlLmtleUNvZGUgIT09IFZLLkJBQ0tTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcm5nID0gc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJuZy5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBybmcuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IGNvbnRhaW5lcjtcbiAgICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQgfHwgb2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChwYXJlbnQucGFyZW50Tm9kZSAmJiBwYXJlbnQucGFyZW50Tm9kZS5maXJzdENoaWxkID09PSBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnQkxPQ0tRVU9URScpIHtcbiAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIudG9nZ2xlKCdibG9ja3F1b3RlJywgdW5kZWZpbmVkLCBwYXJlbnQpO1xuICAgICAgICAgICAgcm5nID0gZG9tLmNyZWF0ZVJuZygpO1xuICAgICAgICAgICAgcm5nLnNldFN0YXJ0KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBybmcuc2V0RW5kKGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXRHZWNrb0VkaXRpbmdPcHRpb25zID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZXRPcHRzID0gKCkgPT4ge1xuICAgICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZSgnU3R5bGVXaXRoQ1NTJywgZmFsc2UpO1xuICAgICAgICAgIHNldEVkaXRvckNvbW1hbmRTdGF0ZSgnZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nJywgZmFsc2UpO1xuICAgICAgICAgIGlmICghZ2V0T2JqZWN0UmVzaXppbmcoZWRpdG9yKSkge1xuICAgICAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKCdlbmFibGVPYmplY3RSZXNpemluZycsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghaXNSZWFkT25seSQxKGVkaXRvcikpIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ0JlZm9yZUV4ZWNDb21tYW5kIG1vdXNlZG93bicsIHNldE9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkQnJBZnRlckxhc3RMaW5rcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZml4TGlua3MgPSAoKSA9PiB7XG4gICAgICAgICAgZWFjaChkb20uc2VsZWN0KCdhOm5vdChbZGF0YS1tY2UtYmxvY2tdKScpLCBub2RlID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IGRvbS5nZXRSb290KCk7XG4gICAgICAgICAgICBpZiAoKHBhcmVudE5vZGUgPT09IG51bGwgfHwgcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Tm9kZS5sYXN0Q2hpbGQpID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnROb2RlICYmICFkb20uaXNCbG9jayhwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENoaWxkKSAhPT0gcGFyZW50Tm9kZSB8fCBwYXJlbnROb2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9tLmFkZChwYXJlbnROb2RlLCAnYnInLCB7ICdkYXRhLW1jZS1ib2d1cyc6IDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGVkaXRvci5vbignU2V0Q29udGVudCBFeGVjQ29tbWFuZCcsIGUgPT4ge1xuICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdzZXRjb250ZW50JyB8fCBlLmNvbW1hbmQgPT09ICdtY2VJbnNlcnRMaW5rJykge1xuICAgICAgICAgICAgZml4TGlua3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldERlZmF1bHRCbG9ja1R5cGUgPSAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgICBzZXRFZGl0b3JDb21tYW5kU3RhdGUoJ0RlZmF1bHRQYXJhZ3JhcGhTZXBhcmF0b3InLCBnZXRGb3JjZWRSb290QmxvY2soZWRpdG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzQWxsQ29udGVudFNlbGVjdGVkID0gZWRpdG9yID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICAgIHJldHVybiBybmcuc3RhcnRDb250YWluZXIgPT09IHJuZy5lbmRDb250YWluZXIgJiYgcm5nLnN0YXJ0Q29udGFpbmVyID09PSBib2R5ICYmIHJuZy5zdGFydE9mZnNldCA9PT0gMCAmJiBybmcuZW5kT2Zmc2V0ID09PSBib2R5LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdrZXl1cCBmb2N1c2luIG1vdXNldXAnLCBlID0+IHtcbiAgICAgICAgICBpZiAoIVZLLm1vZGlmaWVyUHJlc3NlZChlKSAmJiAhaXNBbGxDb250ZW50U2VsZWN0ZWQoZWRpdG9yKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvd0Jyb2tlbkltYWdlSWNvbiA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnRTdHlsZXMucHVzaCgnaW1nOi1tb3otYnJva2VuIHsnICsgJy1tb3otZm9yY2UtYnJva2VuLWltYWdlLWljb246MTsnICsgJ21pbi13aWR0aDoyNHB4OycgKyAnbWluLWhlaWdodDoyNHB4JyArICd9Jyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdG9yZUZvY3VzT25LZXlEb3duID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ2tleWRvd24nLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICBlZGl0b3IuZ2V0V2luKCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGJvZHlIZWlnaHQgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLmlubGluZSkge1xuICAgICAgICAgIGVkaXRvci5jb250ZW50U3R5bGVzLnB1c2goJ2JvZHkge21pbi1oZWlnaHQ6IDE1MHB4fScpO1xuICAgICAgICAgIGVkaXRvci5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGxldCBybmc7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICAgICAgICBlZGl0b3IuZ2V0Qm9keSgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYmxvY2tDbWRBcnJvd05hdmlnYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgIGVkaXRvci5vbigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgICAgaWYgKFZLLm1ldGFLZXlQcmVzc2VkKGUpICYmICFlLnNoaWZ0S2V5ICYmIChlLmtleUNvZGUgPT09IDM3IHx8IGUua2V5Q29kZSA9PT0gMzkpKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWwoKTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLm1vZGlmeSgnbW92ZScsIGUua2V5Q29kZSA9PT0gMzcgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnLCAnbGluZWJvdW5kYXJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB0YXBMaW5rc0FuZEltYWdlcyA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgIGxldCBlbG0gPSBlLnRhcmdldDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWxtLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChlbG0gPSBlbG0ucGFyZW50Tm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuY29udGVudFN0eWxlcy5wdXNoKCcubWNlLWNvbnRlbnQtYm9keSB7LXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lfScpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGJsb2NrRm9ybVN1Ym1pdEluc2lkZUVkaXRvciA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5kb20uYmluZChlZGl0b3IuZ2V0Qm9keSgpLCAnc3VibWl0JywgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlbW92ZUFwcGxlSW50ZXJjaGFuZ2VCcnMgPSAoKSA9PiB7XG4gICAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCdicicsIG5vZGVzID0+IHtcbiAgICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbaV0uYXR0cignY2xhc3MnKSA9PT0gJ0FwcGxlLWludGVyY2hhbmdlLW5ld2xpbmUnKSB7XG4gICAgICAgICAgICAgIG5vZGVzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVmcmVzaENvbnRlbnRFZGl0YWJsZSA9IG5vb3A7XG4gICAgICBjb25zdCBpc0hpZGRlbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc0dlY2tvIHx8IGVkaXRvci5yZW1vdmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbCA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsKCk7XG4gICAgICAgIHJldHVybiAhc2VsIHx8ICFzZWwucmFuZ2VDb3VudCB8fCBzZWwucmFuZ2VDb3VudCA9PT0gMDtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZXR1cFJ0YyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzV2ViS2l0KSB7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50RWRpdGluZ0ZvY3VzKCk7XG4gICAgICAgICAgc2VsZWN0Q29udHJvbEVsZW1lbnRzKCk7XG4gICAgICAgICAgYmxvY2tGb3JtU3VibWl0SW5zaWRlRWRpdG9yKCk7XG4gICAgICAgICAgc2VsZWN0QWxsKCk7XG4gICAgICAgICAgaWYgKGlzaU9TKSB7XG4gICAgICAgICAgICByZXN0b3JlRm9jdXNPbktleURvd24oKTtcbiAgICAgICAgICAgIGJvZHlIZWlnaHQoKTtcbiAgICAgICAgICAgIHRhcExpbmtzQW5kSW1hZ2VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dlY2tvKSB7XG4gICAgICAgICAgZm9jdXNCb2R5KCk7XG4gICAgICAgICAgc2V0R2Vja29FZGl0aW5nT3B0aW9ucygpO1xuICAgICAgICAgIHNob3dCcm9rZW5JbWFnZUljb24oKTtcbiAgICAgICAgICBibG9ja0NtZEFycm93TmF2aWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZHJvcERyYWdFbmRFdmVudCA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLm9uKCdkcm9wJywgZXZlbnQgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gKF9hID0gZXZlbnQuZGF0YVRyYW5zZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGRhdGEpICYmIC9ePGltZ1tePl0qPiQvLnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnZHJhZ2VuZCcsIG5ldyB3aW5kb3cuRHJhZ0V2ZW50KCdkcmFnZW5kJywgZXZlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgICAgICByZW1vdmVCbG9ja1F1b3RlT25CYWNrU3BhY2UoKTtcbiAgICAgICAgZW1wdHlFZGl0b3JXaGVuRGVsZXRpbmcoKTtcbiAgICAgICAgaWYgKCFFbnYud2luZG93c1Bob25lKSB7XG4gICAgICAgICAgbm9ybWFsaXplU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzV2ViS2l0KSB7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50RWRpdGluZ0ZvY3VzKCk7XG4gICAgICAgICAgc2VsZWN0Q29udHJvbEVsZW1lbnRzKCk7XG4gICAgICAgICAgc2V0RGVmYXVsdEJsb2NrVHlwZSgpO1xuICAgICAgICAgIGJsb2NrRm9ybVN1Ym1pdEluc2lkZUVkaXRvcigpO1xuICAgICAgICAgIGRpc2FibGVCYWNrc3BhY2VJbnRvQVRhYmxlKCk7XG4gICAgICAgICAgcmVtb3ZlQXBwbGVJbnRlcmNoYW5nZUJycygpO1xuICAgICAgICAgIGlmIChpc2lPUykge1xuICAgICAgICAgICAgcmVzdG9yZUZvY3VzT25LZXlEb3duKCk7XG4gICAgICAgICAgICBib2R5SGVpZ2h0KCk7XG4gICAgICAgICAgICB0YXBMaW5rc0FuZEltYWdlcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RBbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzR2Vja28pIHtcbiAgICAgICAgICByZW1vdmVIck9uQmFja3NwYWNlKCk7XG4gICAgICAgICAgZm9jdXNCb2R5KCk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVzV2hlbkRlbGV0aW5nQWNyb3NzQmxvY2tFbGVtZW50cygpO1xuICAgICAgICAgIHNldEdlY2tvRWRpdGluZ09wdGlvbnMoKTtcbiAgICAgICAgICBhZGRCckFmdGVyTGFzdExpbmtzKCk7XG4gICAgICAgICAgc2hvd0Jyb2tlbkltYWdlSWNvbigpO1xuICAgICAgICAgIGJsb2NrQ21kQXJyb3dOYXZpZ2F0aW9uKCk7XG4gICAgICAgICAgZGlzYWJsZUJhY2tzcGFjZUludG9BVGFibGUoKTtcbiAgICAgICAgICBkcm9wRHJhZ0VuZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICBzZXR1cFJ0YygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0dXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnJlc2hDb250ZW50RWRpdGFibGUsXG4gICAgICAgIGlzSGlkZGVuXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBET00kNiA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBhcHBlbmRTdHlsZSA9IChlZGl0b3IsIHRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldFN0eWxlQ29udGFpbmVyKGdldFJvb3ROb2RlKGJvZHkpKTtcbiAgICAgIGNvbnN0IHN0eWxlID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ3N0eWxlJyk7XG4gICAgICBzZXQkMyhzdHlsZSwgJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgIGFwcGVuZCQxKHN0eWxlLCBTdWdhckVsZW1lbnQuZnJvbVRleHQodGV4dCkpO1xuICAgICAgYXBwZW5kJDEoY29udGFpbmVyLCBzdHlsZSk7XG4gICAgICBlZGl0b3Iub24oJ3JlbW92ZScsICgpID0+IHtcbiAgICAgICAgcmVtb3ZlJDUoc3R5bGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRSb290TmFtZSA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gZWRpdG9yLmdldEVsZW1lbnQoKS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlbW92ZVVuZGVmaW5lZCA9IG9iaiA9PiBmaWx0ZXIkNChvYmosIHYgPT4gaXNVbmRlZmluZWQodikgPT09IGZhbHNlKTtcbiAgICBjb25zdCBta1BhcnNlclNldHRpbmdzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGdldE9wdGlvbiA9IGVkaXRvci5vcHRpb25zLmdldDtcbiAgICAgIGNvbnN0IGJsb2JDYWNoZSA9IGVkaXRvci5lZGl0b3JVcGxvYWQuYmxvYkNhY2hlO1xuICAgICAgcmV0dXJuIHJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIGFsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzOiBnZXRPcHRpb24oJ2FsbG93X2NvbmRpdGlvbmFsX2NvbW1lbnRzJyksXG4gICAgICAgIGFsbG93X2h0bWxfZGF0YV91cmxzOiBnZXRPcHRpb24oJ2FsbG93X2h0bWxfZGF0YV91cmxzJyksXG4gICAgICAgIGFsbG93X3N2Z19kYXRhX3VybHM6IGdldE9wdGlvbignYWxsb3dfc3ZnX2RhdGFfdXJscycpLFxuICAgICAgICBhbGxvd19odG1sX2luX25hbWVkX2FuY2hvcjogZ2V0T3B0aW9uKCdhbGxvd19odG1sX2luX25hbWVkX2FuY2hvcicpLFxuICAgICAgICBhbGxvd19zY3JpcHRfdXJsczogZ2V0T3B0aW9uKCdhbGxvd19zY3JpcHRfdXJscycpLFxuICAgICAgICBhbGxvd191bnNhZmVfbGlua190YXJnZXQ6IGdldE9wdGlvbignYWxsb3dfdW5zYWZlX2xpbmtfdGFyZ2V0JyksXG4gICAgICAgIGNvbnZlcnRfZm9udHNfdG9fc3BhbnM6IGdldE9wdGlvbignY29udmVydF9mb250c190b19zcGFucycpLFxuICAgICAgICBmaXhfbGlzdF9lbGVtZW50czogZ2V0T3B0aW9uKCdmaXhfbGlzdF9lbGVtZW50cycpLFxuICAgICAgICBmb250X3NpemVfbGVnYWN5X3ZhbHVlczogZ2V0T3B0aW9uKCdmb250X3NpemVfbGVnYWN5X3ZhbHVlcycpLFxuICAgICAgICBmb3JjZWRfcm9vdF9ibG9jazogZ2V0T3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9jaycpLFxuICAgICAgICBmb3JjZWRfcm9vdF9ibG9ja19hdHRyczogZ2V0T3B0aW9uKCdmb3JjZWRfcm9vdF9ibG9ja19hdHRycycpLFxuICAgICAgICBwcmVzZXJ2ZV9jZGF0YTogZ2V0T3B0aW9uKCdwcmVzZXJ2ZV9jZGF0YScpLFxuICAgICAgICBpbmxpbmVfc3R5bGVzOiBnZXRPcHRpb24oJ2lubGluZV9zdHlsZXMnKSxcbiAgICAgICAgcm9vdF9uYW1lOiBnZXRSb290TmFtZShlZGl0b3IpLFxuICAgICAgICBzYW5pdGl6ZTogZ2V0T3B0aW9uKCd4c3Nfc2FuaXRpemF0aW9uJyksXG4gICAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgICBibG9iX2NhY2hlOiBibG9iQ2FjaGUsXG4gICAgICAgIGRvY3VtZW50OiBlZGl0b3IuZ2V0RG9jKClcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbWtTY2hlbWFTZXR0aW5ncyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBnZXRPcHRpb24gPSBlZGl0b3Iub3B0aW9ucy5nZXQ7XG4gICAgICByZXR1cm4gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgY3VzdG9tX2VsZW1lbnRzOiBnZXRPcHRpb24oJ2N1c3RvbV9lbGVtZW50cycpLFxuICAgICAgICBleHRlbmRlZF92YWxpZF9lbGVtZW50czogZ2V0T3B0aW9uKCdleHRlbmRlZF92YWxpZF9lbGVtZW50cycpLFxuICAgICAgICBpbnZhbGlkX2VsZW1lbnRzOiBnZXRPcHRpb24oJ2ludmFsaWRfZWxlbWVudHMnKSxcbiAgICAgICAgaW52YWxpZF9zdHlsZXM6IGdldE9wdGlvbignaW52YWxpZF9zdHlsZXMnKSxcbiAgICAgICAgc2NoZW1hOiBnZXRPcHRpb24oJ3NjaGVtYScpLFxuICAgICAgICB2YWxpZF9jaGlsZHJlbjogZ2V0T3B0aW9uKCd2YWxpZF9jaGlsZHJlbicpLFxuICAgICAgICB2YWxpZF9jbGFzc2VzOiBnZXRPcHRpb24oJ3ZhbGlkX2NsYXNzZXMnKSxcbiAgICAgICAgdmFsaWRfZWxlbWVudHM6IGdldE9wdGlvbigndmFsaWRfZWxlbWVudHMnKSxcbiAgICAgICAgdmFsaWRfc3R5bGVzOiBnZXRPcHRpb24oJ3ZhbGlkX3N0eWxlcycpLFxuICAgICAgICB2ZXJpZnlfaHRtbDogZ2V0T3B0aW9uKCd2ZXJpZnlfaHRtbCcpLFxuICAgICAgICBwYWRkX2VtcHR5X2Jsb2NrX2lubGluZV9jaGlsZHJlbjogZ2V0T3B0aW9uKCdmb3JtYXRfZW1wdHlfbGluZXMnKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBta1NlcmlhbGl6ZXJTZXR0aW5ncyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBnZXRPcHRpb24gPSBlZGl0b3Iub3B0aW9ucy5nZXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ta1BhcnNlclNldHRpbmdzKGVkaXRvciksXG4gICAgICAgIC4uLm1rU2NoZW1hU2V0dGluZ3MoZWRpdG9yKSxcbiAgICAgICAgLi4ucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgICByZW1vdmVfdHJhaWxpbmdfYnJzOiBnZXRPcHRpb24oJ3JlbW92ZV90cmFpbGluZ19icnMnKSxcbiAgICAgICAgICBwYWRfZW1wdHlfd2l0aF9icjogZ2V0T3B0aW9uKCdwYWRfZW1wdHlfd2l0aF9icicpLFxuICAgICAgICAgIHVybF9jb252ZXJ0ZXI6IGdldE9wdGlvbigndXJsX2NvbnZlcnRlcicpLFxuICAgICAgICAgIHVybF9jb252ZXJ0ZXJfc2NvcGU6IGdldE9wdGlvbigndXJsX2NvbnZlcnRlcl9zY29wZScpLFxuICAgICAgICAgIGVsZW1lbnRfZm9ybWF0OiBnZXRPcHRpb24oJ2VsZW1lbnRfZm9ybWF0JyksXG4gICAgICAgICAgZW50aXRpZXM6IGdldE9wdGlvbignZW50aXRpZXMnKSxcbiAgICAgICAgICBlbnRpdHlfZW5jb2Rpbmc6IGdldE9wdGlvbignZW50aXR5X2VuY29kaW5nJyksXG4gICAgICAgICAgaW5kZW50OiBnZXRPcHRpb24oJ2luZGVudCcpLFxuICAgICAgICAgIGluZGVudF9hZnRlcjogZ2V0T3B0aW9uKCdpbmRlbnRfYWZ0ZXInKSxcbiAgICAgICAgICBpbmRlbnRfYmVmb3JlOiBnZXRPcHRpb24oJ2luZGVudF9iZWZvcmUnKVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBhcnNlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBEb21QYXJzZXIobWtQYXJzZXJTZXR0aW5ncyhlZGl0b3IpLCBlZGl0b3Iuc2NoZW1hKTtcbiAgICAgIHBhcnNlci5hZGRBdHRyaWJ1dGVGaWx0ZXIoJ3NyYyxocmVmLHN0eWxlLHRhYmluZGV4JywgKG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5kb207XG4gICAgICAgIGNvbnN0IGludGVybmFsTmFtZSA9ICdkYXRhLW1jZS0nICsgbmFtZTtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gbm9kZS5hdHRyKG5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAmJiAhbm9kZS5hdHRyKGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdkYXRhOicpID09PSAwIHx8IHZhbHVlLmluZGV4T2YoJ2Jsb2I6JykgPT09IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGRvbS5zZXJpYWxpemVTdHlsZShkb20ucGFyc2VTdHlsZSh2YWx1ZSksIG5vZGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihpbnRlcm5hbE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgbm9kZS5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICBub2RlLmF0dHIoaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihuYW1lLCBudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUuYXR0cihpbnRlcm5hbE5hbWUsIGVkaXRvci5jb252ZXJ0VVJMKHZhbHVlLCBuYW1lLCBub2RlLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGFyc2VyLmFkZE5vZGVGaWx0ZXIoJ3NjcmlwdCcsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuYXR0cigndHlwZScpIHx8ICduby90eXBlJztcbiAgICAgICAgICBpZiAodHlwZS5pbmRleE9mKCdtY2UtJykgIT09IDApIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cigndHlwZScsICdtY2UtJyArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkUHJlc2VydmVDRGF0YShlZGl0b3IpKSB7XG4gICAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCcjY2RhdGEnLCBub2RlcyA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIG5vZGUudHlwZSA9IDg7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSAnI2NvbW1lbnQnO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9ICdbQ0RBVEFbJyArIGVkaXRvci5kb20uZW5jb2RlKChfYSA9IG5vZGUudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKSArICddXSc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKCdwLGgxLGgyLGgzLGg0LGg1LGg2LGRpdicsIG5vZGVzID0+IHtcbiAgICAgICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5vbkVtcHR5RWxlbWVudHMgPSBlZGl0b3Iuc2NoZW1hLmdldE5vbkVtcHR5RWxlbWVudHMoKTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBpZiAobm9kZS5pc0VtcHR5KG5vbkVtcHR5RWxlbWVudHMpICYmIG5vZGUuZ2V0QWxsKCdicicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmQobmV3IEFzdE5vZGUoJ2JyJywgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyc2VyO1xuICAgIH07XG4gICAgY29uc3QgYXV0b0ZvY3VzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGF1dG9Gb2N1cyA9IGdldEF1dG9Gb2N1cyhlZGl0b3IpO1xuICAgICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgICBEZWxheS5zZXRFZGl0b3JUaW1lb3V0KGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGxldCBmb2N1c0VkaXRvcjtcbiAgICAgICAgICBpZiAoYXV0b0ZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb2N1c0VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9jdXNFZGl0b3IgPSBlZGl0b3IuZWRpdG9yTWFuYWdlci5nZXQoYXV0b0ZvY3VzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvY3VzRWRpdG9yICYmICFmb2N1c0VkaXRvci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGZvY3VzRWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICBmb2N1c0VkaXRvci5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0aW9uVG9GaXJzdENhcmV0UG9zaXRpb24gPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IGVkaXRvci5kb20uZ2V0Um9vdCgpO1xuICAgICAgaWYgKCFlZGl0b3IuaW5saW5lICYmICghaGFzQW55UmFuZ2VzKGVkaXRvcikgfHwgZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSA9PT0gcm9vdCkpIHtcbiAgICAgICAgZmlyc3RQb3NpdGlvbkluKHJvb3QpLmVhY2gocG9zID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gcG9zLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBjYXJldFBvcyA9IGlzVGFibGUkMihub2RlKSA/IGZpcnN0UG9zaXRpb25Jbihub2RlKS5nZXRPcihwb3MpIDogcG9zO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGNhcmV0UG9zLnRvUmFuZ2UoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5pdEVkaXRvciA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuYmluZFBlbmRpbmdFdmVudERlbGVnYXRlcygpO1xuICAgICAgZWRpdG9yLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZpcmVJbml0KGVkaXRvcik7XG4gICAgICBlZGl0b3IuZm9jdXModHJ1ZSk7XG4gICAgICBtb3ZlU2VsZWN0aW9uVG9GaXJzdENhcmV0UG9zaXRpb24oZWRpdG9yKTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCh7IGluaXRpYWw6IHRydWUgfSk7XG4gICAgICBjb25zdCBpbml0SW5zdGFuY2VDYWxsYmFjayA9IGdldEluaXRJbnN0YW5jZUNhbGxiYWNrKGVkaXRvcik7XG4gICAgICBpZiAoaXNGdW5jdGlvbihpbml0SW5zdGFuY2VDYWxsYmFjaykpIHtcbiAgICAgICAgaW5pdEluc3RhbmNlQ2FsbGJhY2suY2FsbChlZGl0b3IsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBhdXRvRm9jdXMoZWRpdG9yKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFN0eWxlU2hlZXRMb2FkZXIkMSA9IGVkaXRvciA9PiBlZGl0b3IuaW5saW5lID8gZWRpdG9yLnVpLnN0eWxlU2hlZXRMb2FkZXIgOiBlZGl0b3IuZG9tLnN0eWxlU2hlZXRMb2FkZXI7XG4gICAgY29uc3QgbWFrZVN0eWxlc2hlZXRMb2FkaW5nUHJvbWlzZXMgPSAoZWRpdG9yLCBjc3MsIGZyYW1lZEZvbnRzKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtnZXRTdHlsZVNoZWV0TG9hZGVyJDEoZWRpdG9yKS5sb2FkQWxsKGNzcyldO1xuICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VzLmNvbmNhdChbZWRpdG9yLnVpLnN0eWxlU2hlZXRMb2FkZXIubG9hZEFsbChmcmFtZWRGb250cyldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvYWRDb250ZW50Q3NzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHN0eWxlU2hlZXRMb2FkZXIgPSBnZXRTdHlsZVNoZWV0TG9hZGVyJDEoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGZvbnRDc3MgPSBnZXRGb250Q3NzKGVkaXRvcik7XG4gICAgICBjb25zdCBjc3MgPSBlZGl0b3IuY29udGVudENTUztcbiAgICAgIGNvbnN0IHJlbW92ZUNzcyA9ICgpID0+IHtcbiAgICAgICAgc3R5bGVTaGVldExvYWRlci51bmxvYWRBbGwoY3NzKTtcbiAgICAgICAgaWYgKCFlZGl0b3IuaW5saW5lKSB7XG4gICAgICAgICAgZWRpdG9yLnVpLnN0eWxlU2hlZXRMb2FkZXIudW5sb2FkQWxsKGZvbnRDc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZGVkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZW1vdmVDc3MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3Iub24oJ3JlbW92ZScsIHJlbW92ZUNzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZWRpdG9yLmNvbnRlbnRTdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgY29udGVudENzc1RleHQgPSAnJztcbiAgICAgICAgVG9vbHMuZWFjaChlZGl0b3IuY29udGVudFN0eWxlcywgc3R5bGUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRDc3NUZXh0ICs9IHN0eWxlICsgJ1xcclxcbic7XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZG9tLmFkZFN0eWxlKGNvbnRlbnRDc3NUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsbFN0eWxlc2hlZXRzID0gUHJvbWlzZS5hbGwobWFrZVN0eWxlc2hlZXRMb2FkaW5nUHJvbWlzZXMoZWRpdG9yLCBjc3MsIGZvbnRDc3MpKS50aGVuKGxvYWRlZCkuY2F0Y2gobG9hZGVkKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRTdHlsZSA9IGdldENvbnRlbnRTdHlsZShlZGl0b3IpO1xuICAgICAgaWYgKGNvbnRlbnRTdHlsZSkge1xuICAgICAgICBhcHBlbmRTdHlsZShlZGl0b3IsIGNvbnRlbnRTdHlsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsU3R5bGVzaGVldHM7XG4gICAgfTtcbiAgICBjb25zdCBwcmVJbml0ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGRvYyA9IGVkaXRvci5nZXREb2MoKSwgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBmaXJlUHJlSW5pdChlZGl0b3IpO1xuICAgICAgaWYgKCFzaG91bGRCcm93c2VyU3BlbGxjaGVjayhlZGl0b3IpKSB7XG4gICAgICAgIGRvYy5ib2R5LnNwZWxsY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgRE9NJDYuc2V0QXR0cmliKGJvZHksICdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgICB9XG4gICAgICBlZGl0b3IucXVpcmtzID0gUXVpcmtzKGVkaXRvcik7XG4gICAgICBmaXJlUG9zdFJlbmRlcihlZGl0b3IpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uYWxpdHkgPSBnZXREaXJlY3Rpb25hbGl0eShlZGl0b3IpO1xuICAgICAgaWYgKGRpcmVjdGlvbmFsaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYm9keS5kaXIgPSBkaXJlY3Rpb25hbGl0eTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3RlY3QgPSBnZXRQcm90ZWN0KGVkaXRvcik7XG4gICAgICBpZiAocHJvdGVjdCkge1xuICAgICAgICBlZGl0b3Iub24oJ0JlZm9yZVNldENvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgICBUb29scy5lYWNoKHByb3RlY3QsIHBhdHRlcm4gPT4ge1xuICAgICAgICAgICAgZS5jb250ZW50ID0gZS5jb250ZW50LnJlcGxhY2UocGF0dGVybiwgc3RyID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuICc8IS0tbWNlOnByb3RlY3RlZCAnICsgZXNjYXBlKHN0cikgKyAnLS0+JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5vbignU2V0Q29udGVudCcsICgpID0+IHtcbiAgICAgICAgZWRpdG9yLmFkZFZpc3VhbChlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdjb21wb3NpdGlvbnN0YXJ0IGNvbXBvc2l0aW9uZW5kJywgZSA9PiB7XG4gICAgICAgIGVkaXRvci5jb21wb3NpbmcgPSBlLnR5cGUgPT09ICdjb21wb3NpdGlvbnN0YXJ0JztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgbG9hZEluaXRpYWxDb250ZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGlmICghaXNSdGMoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3IubG9hZCh7XG4gICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICBmb3JtYXQ6ICdodG1sJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5zdGFydENvbnRlbnQgPSBlZGl0b3IuZ2V0Q29udGVudCh7IGZvcm1hdDogJ3JhdycgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0RWRpdG9yV2l0aEluaXRpYWxDb250ZW50ID0gZWRpdG9yID0+IHtcbiAgICAgIGlmIChlZGl0b3IucmVtb3ZlZCAhPT0gdHJ1ZSkge1xuICAgICAgICBsb2FkSW5pdGlhbENvbnRlbnQoZWRpdG9yKTtcbiAgICAgICAgaW5pdEVkaXRvcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3RhcnRQcm9ncmVzcyA9IGVkaXRvciA9PiB7XG4gICAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHByb2dyZXNzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XG4gICAgICAgICAgZWRpdG9yLnNldFByb2dyZXNzU3RhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQocHJvZ3Jlc3NUaW1lb3V0KTtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBlZGl0b3Iuc2V0UHJvZ3Jlc3NTdGF0ZShmYWxzZSk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY29udGVudEJvZHlMb2FkZWQgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0RWxtID0gZWRpdG9yLmdldEVsZW1lbnQoKTtcbiAgICAgIGxldCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICBpZiAoZWRpdG9yLmlubGluZSkge1xuICAgICAgICBET00kNi5hZGRDbGFzcyh0YXJnZXRFbG0sICdtY2UtY29udGVudC1ib2R5Jyk7XG4gICAgICAgIGVkaXRvci5jb250ZW50RG9jdW1lbnQgPSBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnRXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIGVkaXRvci5ib2R5RWxlbWVudCA9IHRhcmdldEVsbTtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnRBcmVhQ29udGFpbmVyID0gdGFyZ2V0RWxtO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGVkaXRvci5nZXRCb2R5KCk7XG4gICAgICBib2R5LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIGVkaXRvci5yZWFkb25seSA9IGlzUmVhZE9ubHkkMShlZGl0b3IpO1xuICAgICAgZWRpdG9yLl9lZGl0YWJsZVJvb3QgPSBoYXNFZGl0YWJsZVJvb3QkMShlZGl0b3IpO1xuICAgICAgaWYgKCFlZGl0b3IucmVhZG9ubHkgJiYgZWRpdG9yLmhhc0VkaXRhYmxlUm9vdCgpKSB7XG4gICAgICAgIGlmIChlZGl0b3IuaW5saW5lICYmIERPTSQ2LmdldFN0eWxlKGJvZHksICdwb3NpdGlvbicsIHRydWUpID09PSAnc3RhdGljJykge1xuICAgICAgICAgIGJvZHkuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkuY29udGVudEVkaXRhYmxlID0gJ3RydWUnO1xuICAgICAgfVxuICAgICAgYm9keS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmVkaXRvclVwbG9hZCA9IEVkaXRvclVwbG9hZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNjaGVtYSA9IFNjaGVtYShta1NjaGVtYVNldHRpbmdzKGVkaXRvcikpO1xuICAgICAgZWRpdG9yLmRvbSA9IERPTVV0aWxzKGRvYywge1xuICAgICAgICBrZWVwX3ZhbHVlczogdHJ1ZSxcbiAgICAgICAgdXJsX2NvbnZlcnRlcjogZWRpdG9yLmNvbnZlcnRVUkwsXG4gICAgICAgIHVybF9jb252ZXJ0ZXJfc2NvcGU6IGVkaXRvcixcbiAgICAgICAgdXBkYXRlX3N0eWxlczogdHJ1ZSxcbiAgICAgICAgcm9vdF9lbGVtZW50OiBlZGl0b3IuaW5saW5lID8gZWRpdG9yLmdldEJvZHkoKSA6IG51bGwsXG4gICAgICAgIGNvbGxlY3Q6IGVkaXRvci5pbmxpbmUsXG4gICAgICAgIHNjaGVtYTogZWRpdG9yLnNjaGVtYSxcbiAgICAgICAgY29udGVudENzc0NvcnM6IHNob3VsZFVzZUNvbnRlbnRDc3NDb3JzKGVkaXRvciksXG4gICAgICAgIHJlZmVycmVyUG9saWN5OiBnZXRSZWZlcnJlclBvbGljeShlZGl0b3IpLFxuICAgICAgICBvblNldEF0dHJpYjogZSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoKCdTZXRBdHRyaWInLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3IucGFyc2VyID0gY3JlYXRlUGFyc2VyKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplciA9IERvbVNlcmlhbGl6ZXIobWtTZXJpYWxpemVyU2V0dGluZ3MoZWRpdG9yKSwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24oZWRpdG9yLmRvbSwgZWRpdG9yLmdldFdpbigpLCBlZGl0b3Iuc2VyaWFsaXplciwgZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0b3IgPSBBbm5vdGF0b3IoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5mb3JtYXR0ZXIgPSBGb3JtYXR0ZXIoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyKGVkaXRvcik7XG4gICAgICBlZGl0b3IuX25vZGVDaGFuZ2VEaXNwYXRjaGVyID0gbmV3IE5vZGVDaGFuZ2UoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5fc2VsZWN0aW9uT3ZlcnJpZGVzID0gU2VsZWN0aW9uT3ZlcnJpZGVzKGVkaXRvcik7XG4gICAgICBzZXR1cCRvKGVkaXRvcik7XG4gICAgICBzZXR1cCQ2KGVkaXRvcik7XG4gICAgICBzZXR1cCRtKGVkaXRvcik7XG4gICAgICBpZiAoIWlzUnRjKGVkaXRvcikpIHtcbiAgICAgICAgc2V0dXAkNShlZGl0b3IpO1xuICAgICAgICBzZXR1cCQxKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjYXJldCA9IHNldHVwJGIoZWRpdG9yKTtcbiAgICAgIHNldHVwJHAoZWRpdG9yLCBjYXJldCk7XG4gICAgICBzZXR1cCRuKGVkaXRvcik7XG4gICAgICBzZXR1cCRxKGVkaXRvcik7XG4gICAgICBzZXR1cCQ3KGVkaXRvcik7XG4gICAgICBjb25zdCBzZXR1cFJ0Y1RodW5rID0gc2V0dXAkcyhlZGl0b3IpO1xuICAgICAgcHJlSW5pdChlZGl0b3IpO1xuICAgICAgc2V0dXBSdGNUaHVuay5mb2xkKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvZ3Jlc3MgPSBzdGFydFByb2dyZXNzKGVkaXRvcik7XG4gICAgICAgIGxvYWRDb250ZW50Q3NzKGVkaXRvcikudGhlbigoKSA9PiB7XG4gICAgICAgICAgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICAgIGNhbmNlbFByb2dyZXNzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgc2V0dXBSdGMgPT4ge1xuICAgICAgICBlZGl0b3Iuc2V0UHJvZ3Jlc3NTdGF0ZSh0cnVlKTtcbiAgICAgICAgbG9hZENvbnRlbnRDc3MoZWRpdG9yKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBzZXR1cFJ0YygpLnRoZW4oX3J0Y01vZGUgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLnNldFByb2dyZXNzU3RhdGUoZmFsc2UpO1xuICAgICAgICAgICAgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICAgICAgYmluZEV2ZW50cyhlZGl0b3IpO1xuICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBlZGl0b3Iubm90aWZpY2F0aW9uTWFuYWdlci5vcGVuKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgdGV4dDogU3RyaW5nKGVycilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5pdEVkaXRvcldpdGhJbml0aWFsQ29udGVudChlZGl0b3IpO1xuICAgICAgICAgICAgYmluZEV2ZW50cyhlZGl0b3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWx0ZXIgPSBhbHdheXM7XG4gICAgY29uc3QgYmluZCA9IChlbGVtZW50LCBldmVudCwgaGFuZGxlcikgPT4gYmluZCQyKGVsZW1lbnQsIGV2ZW50LCBmaWx0ZXIsIGhhbmRsZXIpO1xuXG4gICAgY29uc3QgRE9NJDUgPSBET01VdGlscy5ET007XG4gICAgY29uc3QgY3JlYXRlSWZyYW1lRWxlbWVudCA9IChpZCwgdGl0bGUsIGN1c3RvbUF0dHJzLCB0YWJpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaWZyYW1lID0gU3VnYXJFbGVtZW50LmZyb21UYWcoJ2lmcmFtZScpO1xuICAgICAgdGFiaW5kZXguZWFjaCh0ID0+IHNldCQzKGlmcmFtZSwgJ3RhYmluZGV4JywgdCkpO1xuICAgICAgc2V0QWxsJDEoaWZyYW1lLCBjdXN0b21BdHRycyk7XG4gICAgICBzZXRBbGwkMShpZnJhbWUsIHtcbiAgICAgICAgaWQ6IGlkICsgJ19pZnInLFxuICAgICAgICBmcmFtZUJvcmRlcjogJzAnLFxuICAgICAgICBhbGxvd1RyYW5zcGFyZW5jeTogJ3RydWUnLFxuICAgICAgICB0aXRsZVxuICAgICAgfSk7XG4gICAgICBhZGQkMihpZnJhbWUsICd0b3gtZWRpdC1hcmVhX19pZnJhbWUnKTtcbiAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRJZnJhbWVIdG1sID0gZWRpdG9yID0+IHtcbiAgICAgIGxldCBpZnJhbWVIVE1MID0gZ2V0RG9jVHlwZShlZGl0b3IpICsgJzxodG1sPjxoZWFkPic7XG4gICAgICBpZiAoZ2V0RG9jdW1lbnRCYXNlVXJsKGVkaXRvcikgIT09IGVkaXRvci5kb2N1bWVudEJhc2VVcmwpIHtcbiAgICAgICAgaWZyYW1lSFRNTCArPSAnPGJhc2UgaHJlZj1cIicgKyBlZGl0b3IuZG9jdW1lbnRCYXNlVVJJLmdldFVSSSgpICsgJ1wiIC8+JztcbiAgICAgIH1cbiAgICAgIGlmcmFtZUhUTUwgKz0gJzxtZXRhIGh0dHAtZXF1aXY9XCJDb250ZW50LVR5cGVcIiBjb250ZW50PVwidGV4dC9odG1sOyBjaGFyc2V0PVVURi04XCIgLz4nO1xuICAgICAgY29uc3QgYm9keUlkID0gZ2V0Qm9keUlkKGVkaXRvcik7XG4gICAgICBjb25zdCBib2R5Q2xhc3MgPSBnZXRCb2R5Q2xhc3MoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZWRBcmlhVGV4dCA9IGVkaXRvci50cmFuc2xhdGUoZ2V0SWZyYW1lQXJpYVRleHQoZWRpdG9yKSk7XG4gICAgICBpZiAoZ2V0Q29udGVudFNlY3VyaXR5UG9saWN5KGVkaXRvcikpIHtcbiAgICAgICAgaWZyYW1lSFRNTCArPSAnPG1ldGEgaHR0cC1lcXVpdj1cIkNvbnRlbnQtU2VjdXJpdHktUG9saWN5XCIgY29udGVudD1cIicgKyBnZXRDb250ZW50U2VjdXJpdHlQb2xpY3koZWRpdG9yKSArICdcIiAvPic7XG4gICAgICB9XG4gICAgICBpZnJhbWVIVE1MICs9ICc8L2hlYWQ+JyArIGA8Ym9keSBpZD1cIiR7IGJvZHlJZCB9XCIgY2xhc3M9XCJtY2UtY29udGVudC1ib2R5ICR7IGJvZHlDbGFzcyB9XCIgZGF0YS1pZD1cIiR7IGVkaXRvci5pZCB9XCIgYXJpYS1sYWJlbD1cIiR7IHRyYW5zbGF0ZWRBcmlhVGV4dCB9XCI+YCArICc8YnI+JyArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICByZXR1cm4gaWZyYW1lSFRNTDtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUlmcmFtZSA9IChlZGl0b3IsIGJveEluZm8pID0+IHtcbiAgICAgIGNvbnN0IGlmcmFtZVRpdGxlID0gZWRpdG9yLnRyYW5zbGF0ZSgnUmljaCBUZXh0IEFyZWEnKTtcbiAgICAgIGNvbnN0IHRhYmluZGV4ID0gZ2V0T3B0KFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRFbGVtZW50KCkpLCAndGFiaW5kZXgnKS5iaW5kKHRvSW50KTtcbiAgICAgIGNvbnN0IGlmciA9IGNyZWF0ZUlmcmFtZUVsZW1lbnQoZWRpdG9yLmlkLCBpZnJhbWVUaXRsZSwgZ2V0SWZyYW1lQXR0cnMoZWRpdG9yKSwgdGFiaW5kZXgpLmRvbTtcbiAgICAgIGlmci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmci5vbmxvYWQgPSBudWxsO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2xvYWQnKTtcbiAgICAgIH07XG4gICAgICBlZGl0b3IuY29udGVudEFyZWFDb250YWluZXIgPSBib3hJbmZvLmlmcmFtZUNvbnRhaW5lcjtcbiAgICAgIGVkaXRvci5pZnJhbWVFbGVtZW50ID0gaWZyO1xuICAgICAgZWRpdG9yLmlmcmFtZUhUTUwgPSBnZXRJZnJhbWVIdG1sKGVkaXRvcik7XG4gICAgICBET00kNS5hZGQoYm94SW5mby5pZnJhbWVDb250YWluZXIsIGlmcik7XG4gICAgfTtcbiAgICBjb25zdCBzZXR1cElmcmFtZUJvZHkgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaWZyYW1lID0gZWRpdG9yLmlmcmFtZUVsZW1lbnQ7XG4gICAgICBjb25zdCByZWFkeSA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yLmNvbnRlbnREb2N1bWVudCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGNvbnRlbnRCb2R5TG9hZGVkKGVkaXRvcik7XG4gICAgICB9O1xuICAgICAgaWYgKHNob3VsZFVzZURvY3VtZW50V3JpdGUoZWRpdG9yKSB8fCBFbnYuYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICBjb25zdCBkb2MgPSBlZGl0b3IuZ2V0RG9jKCk7XG4gICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgIGRvYy53cml0ZShlZGl0b3IuaWZyYW1lSFRNTCk7XG4gICAgICAgIGRvYy5jbG9zZSgpO1xuICAgICAgICByZWFkeSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmluZGVyID0gYmluZChTdWdhckVsZW1lbnQuZnJvbURvbShpZnJhbWUpLCAnbG9hZCcsICgpID0+IHtcbiAgICAgICAgICBiaW5kZXIudW5iaW5kKCk7XG4gICAgICAgICAgcmVhZHkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmcmFtZS5zcmNkb2MgPSBlZGl0b3IuaWZyYW1lSFRNTDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXQkMSA9IChlZGl0b3IsIGJveEluZm8pID0+IHtcbiAgICAgIGNyZWF0ZUlmcmFtZShlZGl0b3IsIGJveEluZm8pO1xuICAgICAgaWYgKGJveEluZm8uZWRpdG9yQ29udGFpbmVyKSB7XG4gICAgICAgIGJveEluZm8uZWRpdG9yQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBlZGl0b3Iub3JnRGlzcGxheTtcbiAgICAgICAgZWRpdG9yLmhpZGRlbiA9IERPTSQ1LmlzSGlkZGVuKGJveEluZm8uZWRpdG9yQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIERPTSQ1LnNldEF0dHJpYihlZGl0b3IuaWQsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICBlZGl0b3IuZ2V0RWxlbWVudCgpLnN0eWxlLnZpc2liaWxpdHkgPSBlZGl0b3Iub3JnVmlzaWJpbGl0eTtcbiAgICAgIHNldHVwSWZyYW1lQm9keShlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBET00kNCA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBpbml0UGx1Z2luID0gKGVkaXRvciwgaW5pdGlhbGl6ZWRQbHVnaW5zLCBwbHVnaW4pID0+IHtcbiAgICAgIGNvbnN0IFBsdWdpbiA9IFBsdWdpbk1hbmFnZXIuZ2V0KHBsdWdpbik7XG4gICAgICBjb25zdCBwbHVnaW5VcmwgPSBQbHVnaW5NYW5hZ2VyLnVybHNbcGx1Z2luXSB8fCBlZGl0b3IuZG9jdW1lbnRCYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICBwbHVnaW4gPSBUb29scy50cmltKHBsdWdpbik7XG4gICAgICBpZiAoUGx1Z2luICYmIFRvb2xzLmluQXJyYXkoaW5pdGlhbGl6ZWRQbHVnaW5zLCBwbHVnaW4pID09PSAtMSkge1xuICAgICAgICBpZiAoZWRpdG9yLnBsdWdpbnNbcGx1Z2luXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBsdWdpbkluc3RhbmNlID0gUGx1Z2luKGVkaXRvciwgcGx1Z2luVXJsKSB8fCB7fTtcbiAgICAgICAgICBlZGl0b3IucGx1Z2luc1twbHVnaW5dID0gcGx1Z2luSW5zdGFuY2U7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGx1Z2luSW5zdGFuY2UuaW5pdCkpIHtcbiAgICAgICAgICAgIHBsdWdpbkluc3RhbmNlLmluaXQoZWRpdG9yLCBwbHVnaW5VcmwpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwbHVnaW5Jbml0RXJyb3IoZWRpdG9yLCBwbHVnaW4sIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0cmltTGVnYWN5UHJlZml4ID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFwtLywgJycpO1xuICAgIH07XG4gICAgY29uc3QgaW5pdFBsdWdpbnMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZWRQbHVnaW5zID0gW107XG4gICAgICBlYWNoJGUoZ2V0UGx1Z2lucyhlZGl0b3IpLCBuYW1lID0+IHtcbiAgICAgICAgaW5pdFBsdWdpbihlZGl0b3IsIGluaXRpYWxpemVkUGx1Z2lucywgdHJpbUxlZ2FjeVByZWZpeChuYW1lKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRJY29ucyA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpY29uUGFja05hbWUgPSBUb29scy50cmltKGdldEljb25QYWNrTmFtZShlZGl0b3IpKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJY29ucyA9IGVkaXRvci51aS5yZWdpc3RyeS5nZXRBbGwoKS5pY29ucztcbiAgICAgIGNvbnN0IGxvYWRJY29ucyA9IHtcbiAgICAgICAgLi4uSWNvbk1hbmFnZXIuZ2V0KCdkZWZhdWx0JykuaWNvbnMsXG4gICAgICAgIC4uLkljb25NYW5hZ2VyLmdldChpY29uUGFja05hbWUpLmljb25zXG4gICAgICB9O1xuICAgICAgZWFjaCRkKGxvYWRJY29ucywgKHN2Z0RhdGEsIGljb24pID0+IHtcbiAgICAgICAgaWYgKCFoYXMkMihjdXJyZW50SWNvbnMsIGljb24pKSB7XG4gICAgICAgICAgZWRpdG9yLnVpLnJlZ2lzdHJ5LmFkZEljb24oaWNvbiwgc3ZnRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdFRoZW1lID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUoZWRpdG9yKTtcbiAgICAgIGlmIChpc1N0cmluZyh0aGVtZSkpIHtcbiAgICAgICAgY29uc3QgVGhlbWUgPSBUaGVtZU1hbmFnZXIuZ2V0KHRoZW1lKTtcbiAgICAgICAgZWRpdG9yLnRoZW1lID0gVGhlbWUoZWRpdG9yLCBUaGVtZU1hbmFnZXIudXJsc1t0aGVtZV0pIHx8IHt9O1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihlZGl0b3IudGhlbWUuaW5pdCkpIHtcbiAgICAgICAgICBlZGl0b3IudGhlbWUuaW5pdChlZGl0b3IsIFRoZW1lTWFuYWdlci51cmxzW3RoZW1lXSB8fCBlZGl0b3IuZG9jdW1lbnRCYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IudGhlbWUgPSB7fTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRNb2RlbCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGdldE1vZGVsKGVkaXRvcik7XG4gICAgICBjb25zdCBNb2RlbCA9IE1vZGVsTWFuYWdlci5nZXQobW9kZWwpO1xuICAgICAgZWRpdG9yLm1vZGVsID0gTW9kZWwoZWRpdG9yLCBNb2RlbE1hbmFnZXIudXJsc1ttb2RlbF0pO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyRnJvbUxvYWRlZFRoZW1lID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlciA9IGVkaXRvci50aGVtZS5yZW5kZXJVSTtcbiAgICAgIHJldHVybiByZW5kZXIgPyByZW5kZXIoKSA6IHJlbmRlclRoZW1lRmFsc2UoZWRpdG9yKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckZyb21UaGVtZUZ1bmMgPSBlZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZWxtID0gZWRpdG9yLmdldEVsZW1lbnQoKTtcbiAgICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUoZWRpdG9yKTtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGVtZShlZGl0b3IsIGVsbSk7XG4gICAgICBpZiAoaW5mby5lZGl0b3JDb250YWluZXIubm9kZVR5cGUpIHtcbiAgICAgICAgaW5mby5lZGl0b3JDb250YWluZXIuaWQgPSBpbmZvLmVkaXRvckNvbnRhaW5lci5pZCB8fCBlZGl0b3IuaWQgKyAnX3BhcmVudCc7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5pZnJhbWVDb250YWluZXIgJiYgaW5mby5pZnJhbWVDb250YWluZXIubm9kZVR5cGUpIHtcbiAgICAgICAgaW5mby5pZnJhbWVDb250YWluZXIuaWQgPSBpbmZvLmlmcmFtZUNvbnRhaW5lci5pZCB8fCBlZGl0b3IuaWQgKyAnX2lmcmFtZWNvbnRhaW5lcic7XG4gICAgICB9XG4gICAgICBpbmZvLmhlaWdodCA9IGluZm8uaWZyYW1lSGVpZ2h0ID8gaW5mby5pZnJhbWVIZWlnaHQgOiBlbG0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVUaGVtZUZhbHNlUmVzdWx0ID0gKGVsZW1lbnQsIGlmcmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRpdG9yQ29udGFpbmVyOiBlbGVtZW50LFxuICAgICAgICBpZnJhbWVDb250YWluZXI6IGlmcmFtZSxcbiAgICAgICAgYXBpOiB7fVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclRoZW1lRmFsc2VJZnJhbWUgPSB0YXJnZXRFbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGlmcmFtZUNvbnRhaW5lciA9IERPTSQ0LmNyZWF0ZSgnZGl2Jyk7XG4gICAgICBET00kNC5pbnNlcnRBZnRlcihpZnJhbWVDb250YWluZXIsIHRhcmdldEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRoZW1lRmFsc2VSZXN1bHQoaWZyYW1lQ29udGFpbmVyLCBpZnJhbWVDb250YWluZXIpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyVGhlbWVGYWxzZSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnQoKTtcbiAgICAgIHJldHVybiBlZGl0b3IuaW5saW5lID8gY3JlYXRlVGhlbWVGYWxzZVJlc3VsdChudWxsKSA6IHJlbmRlclRoZW1lRmFsc2VJZnJhbWUodGFyZ2V0RWxlbWVudCk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJUaGVtZVVpID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5nZXRFbGVtZW50KCk7XG4gICAgICBlZGl0b3Iub3JnRGlzcGxheSA9IGVsbS5zdHlsZS5kaXNwbGF5O1xuICAgICAgaWYgKGlzU3RyaW5nKGdldFRoZW1lKGVkaXRvcikpKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJGcm9tTG9hZGVkVGhlbWUoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihnZXRUaGVtZShlZGl0b3IpKSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyRnJvbVRoZW1lRnVuYyhlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclRoZW1lRmFsc2UoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF1Z21lbnRFZGl0b3JVaUFwaSA9IChlZGl0b3IsIGFwaSkgPT4ge1xuICAgICAgY29uc3QgdWlBcGlGYWNhZGUgPSB7XG4gICAgICAgIHNob3c6IE9wdGlvbmFsLmZyb20oYXBpLnNob3cpLmdldE9yKG5vb3ApLFxuICAgICAgICBoaWRlOiBPcHRpb25hbC5mcm9tKGFwaS5oaWRlKS5nZXRPcihub29wKSxcbiAgICAgICAgaXNFbmFibGVkOiBPcHRpb25hbC5mcm9tKGFwaS5pc0VuYWJsZWQpLmdldE9yKGFsd2F5cyksXG4gICAgICAgIHNldEVuYWJsZWQ6IHN0YXRlID0+IHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5tb2RlLmlzUmVhZE9ubHkoKSkge1xuICAgICAgICAgICAgT3B0aW9uYWwuZnJvbShhcGkuc2V0RW5hYmxlZCkuZWFjaChmID0+IGYoc3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlZGl0b3IudWkgPSB7XG4gICAgICAgIC4uLmVkaXRvci51aSxcbiAgICAgICAgLi4udWlBcGlGYWNhZGVcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBpbml0ID0gYXN5bmMgZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaCgnU2NyaXB0c0xvYWRlZCcpO1xuICAgICAgaW5pdEljb25zKGVkaXRvcik7XG4gICAgICBpbml0VGhlbWUoZWRpdG9yKTtcbiAgICAgIGluaXRNb2RlbChlZGl0b3IpO1xuICAgICAgaW5pdFBsdWdpbnMoZWRpdG9yKTtcbiAgICAgIGNvbnN0IHJlbmRlckluZm8gPSBhd2FpdCByZW5kZXJUaGVtZVVpKGVkaXRvcik7XG4gICAgICBhdWdtZW50RWRpdG9yVWlBcGkoZWRpdG9yLCBPcHRpb25hbC5mcm9tKHJlbmRlckluZm8uYXBpKS5nZXRPcih7fSkpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbnRhaW5lciA9IHJlbmRlckluZm8uZWRpdG9yQ29udGFpbmVyO1xuICAgICAgYXBwZW5kQ29udGVudENzc0Zyb21TZXR0aW5ncyhlZGl0b3IpO1xuICAgICAgaWYgKGVkaXRvci5pbmxpbmUpIHtcbiAgICAgICAgY29udGVudEJvZHlMb2FkZWQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXQkMShlZGl0b3IsIHtcbiAgICAgICAgICBlZGl0b3JDb250YWluZXI6IHJlbmRlckluZm8uZWRpdG9yQ29udGFpbmVyLFxuICAgICAgICAgIGlmcmFtZUNvbnRhaW5lcjogcmVuZGVySW5mby5pZnJhbWVDb250YWluZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQzID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGhhc1NraXBMb2FkUHJlZml4ID0gbmFtZSA9PiBuYW1lLmNoYXJBdCgwKSA9PT0gJy0nO1xuICAgIGNvbnN0IGxvYWRMYW5ndWFnZSA9IChzY3JpcHRMb2FkZXIsIGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gZ2V0TGFuZ3VhZ2VDb2RlKGVkaXRvcik7XG4gICAgICBjb25zdCBsYW5ndWFnZVVybCA9IGdldExhbmd1YWdlVXJsKGVkaXRvcik7XG4gICAgICBpZiAoIUkxOG4uaGFzQ29kZShsYW5ndWFnZUNvZGUpICYmIGxhbmd1YWdlQ29kZSAhPT0gJ2VuJykge1xuICAgICAgICBjb25zdCB1cmwgPSBpc05vdEVtcHR5KGxhbmd1YWdlVXJsKSA/IGxhbmd1YWdlVXJsIDogYCR7IGVkaXRvci5lZGl0b3JNYW5hZ2VyLmJhc2VVUkwgfS9sYW5ncy8keyBsYW5ndWFnZUNvZGUgfS5qc2A7XG4gICAgICAgIHNjcmlwdExvYWRlci5hZGQodXJsKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgbGFuZ3VhZ2VMb2FkRXJyb3IoZWRpdG9yLCB1cmwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9hZFRoZW1lID0gKGVkaXRvciwgc3VmZml4KSA9PiB7XG4gICAgICBjb25zdCB0aGVtZSA9IGdldFRoZW1lKGVkaXRvcik7XG4gICAgICBpZiAoaXNTdHJpbmcodGhlbWUpICYmICFoYXNTa2lwTG9hZFByZWZpeCh0aGVtZSkgJiYgIWhhcyQyKFRoZW1lTWFuYWdlci51cmxzLCB0aGVtZSkpIHtcbiAgICAgICAgY29uc3QgdGhlbWVVcmwgPSBnZXRUaGVtZVVybChlZGl0b3IpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGVtZVVybCA/IGVkaXRvci5kb2N1bWVudEJhc2VVUkkudG9BYnNvbHV0ZSh0aGVtZVVybCkgOiBgdGhlbWVzLyR7IHRoZW1lIH0vdGhlbWUkeyBzdWZmaXggfS5qc2A7XG4gICAgICAgIFRoZW1lTWFuYWdlci5sb2FkKHRoZW1lLCB1cmwpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICB0aGVtZUxvYWRFcnJvcihlZGl0b3IsIHVybCwgdGhlbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvYWRNb2RlbCA9IChlZGl0b3IsIHN1ZmZpeCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRNb2RlbChlZGl0b3IpO1xuICAgICAgaWYgKG1vZGVsICE9PSAncGx1Z2luJyAmJiAhaGFzJDIoTW9kZWxNYW5hZ2VyLnVybHMsIG1vZGVsKSkge1xuICAgICAgICBjb25zdCBtb2RlbFVybCA9IGdldE1vZGVsVXJsKGVkaXRvcik7XG4gICAgICAgIGNvbnN0IHVybCA9IGlzU3RyaW5nKG1vZGVsVXJsKSA/IGVkaXRvci5kb2N1bWVudEJhc2VVUkkudG9BYnNvbHV0ZShtb2RlbFVybCkgOiBgbW9kZWxzLyR7IG1vZGVsIH0vbW9kZWwkeyBzdWZmaXggfS5qc2A7XG4gICAgICAgIE1vZGVsTWFuYWdlci5sb2FkKG1vZGVsLCB1cmwpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBtb2RlbExvYWRFcnJvcihlZGl0b3IsIHVybCwgbW9kZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEljb25zVXJsTWV0YUZyb21VcmwgPSBlZGl0b3IgPT4gT3B0aW9uYWwuZnJvbShnZXRJY29uc1VybChlZGl0b3IpKS5maWx0ZXIoaXNOb3RFbXB0eSkubWFwKHVybCA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgbmFtZTogT3B0aW9uYWwubm9uZSgpXG4gICAgfSkpO1xuICAgIGNvbnN0IGdldEljb25zVXJsTWV0YUZyb21OYW1lID0gKGVkaXRvciwgbmFtZSwgc3VmZml4KSA9PiBPcHRpb25hbC5mcm9tKG5hbWUpLmZpbHRlcihuYW1lID0+IGlzTm90RW1wdHkobmFtZSkgJiYgIUljb25NYW5hZ2VyLmhhcyhuYW1lKSkubWFwKG5hbWUgPT4gKHtcbiAgICAgIHVybDogYCR7IGVkaXRvci5lZGl0b3JNYW5hZ2VyLmJhc2VVUkwgfS9pY29ucy8keyBuYW1lIH0vaWNvbnMkeyBzdWZmaXggfS5qc2AsXG4gICAgICBuYW1lOiBPcHRpb25hbC5zb21lKG5hbWUpXG4gICAgfSkpO1xuICAgIGNvbnN0IGxvYWRJY29ucyA9IChzY3JpcHRMb2FkZXIsIGVkaXRvciwgc3VmZml4KSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0SWNvbnNVcmwgPSBnZXRJY29uc1VybE1ldGFGcm9tTmFtZShlZGl0b3IsICdkZWZhdWx0Jywgc3VmZml4KTtcbiAgICAgIGNvbnN0IGN1c3RvbUljb25zVXJsID0gZ2V0SWNvbnNVcmxNZXRhRnJvbVVybChlZGl0b3IpLm9yVGh1bmsoKCkgPT4gZ2V0SWNvbnNVcmxNZXRhRnJvbU5hbWUoZWRpdG9yLCBnZXRJY29uUGFja05hbWUoZWRpdG9yKSwgJycpKTtcbiAgICAgIGVhY2gkZShjYXQoW1xuICAgICAgICBkZWZhdWx0SWNvbnNVcmwsXG4gICAgICAgIGN1c3RvbUljb25zVXJsXG4gICAgICBdKSwgdXJsTWV0YSA9PiB7XG4gICAgICAgIHNjcmlwdExvYWRlci5hZGQodXJsTWV0YS51cmwpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBpY29uc0xvYWRFcnJvcihlZGl0b3IsIHVybE1ldGEudXJsLCB1cmxNZXRhLm5hbWUuZ2V0T3JVbmRlZmluZWQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkUGx1Z2lucyA9IChlZGl0b3IsIHN1ZmZpeCkgPT4ge1xuICAgICAgY29uc3QgbG9hZFBsdWdpbiA9IChuYW1lLCB1cmwpID0+IHtcbiAgICAgICAgUGx1Z2luTWFuYWdlci5sb2FkKG5hbWUsIHVybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIHBsdWdpbkxvYWRFcnJvcihlZGl0b3IsIHVybCwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGVhY2gkZChnZXRFeHRlcm5hbFBsdWdpbnMkMShlZGl0b3IpLCAodXJsLCBuYW1lKSA9PiB7XG4gICAgICAgIGxvYWRQbHVnaW4obmFtZSwgdXJsKTtcbiAgICAgICAgZWRpdG9yLm9wdGlvbnMuc2V0KCdwbHVnaW5zJywgZ2V0UGx1Z2lucyhlZGl0b3IpLmNvbmNhdChuYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIGVhY2gkZShnZXRQbHVnaW5zKGVkaXRvciksIHBsdWdpbiA9PiB7XG4gICAgICAgIHBsdWdpbiA9IFRvb2xzLnRyaW0ocGx1Z2luKTtcbiAgICAgICAgaWYgKHBsdWdpbiAmJiAhUGx1Z2luTWFuYWdlci51cmxzW3BsdWdpbl0gJiYgIWhhc1NraXBMb2FkUHJlZml4KHBsdWdpbikpIHtcbiAgICAgICAgICBsb2FkUGx1Z2luKHBsdWdpbiwgYHBsdWdpbnMvJHsgcGx1Z2luIH0vcGx1Z2luJHsgc3VmZml4IH0uanNgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc1RoZW1lTG9hZGVkID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUoZWRpdG9yKTtcbiAgICAgIHJldHVybiAhaXNTdHJpbmcodGhlbWUpIHx8IGlzTm9uTnVsbGFibGUoVGhlbWVNYW5hZ2VyLmdldCh0aGVtZSkpO1xuICAgIH07XG4gICAgY29uc3QgaXNNb2RlbExvYWRlZCA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGdldE1vZGVsKGVkaXRvcik7XG4gICAgICByZXR1cm4gaXNOb25OdWxsYWJsZShNb2RlbE1hbmFnZXIuZ2V0KG1vZGVsKSk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkU2NyaXB0cyA9IChlZGl0b3IsIHN1ZmZpeCkgPT4ge1xuICAgICAgY29uc3Qgc2NyaXB0TG9hZGVyID0gU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlcjtcbiAgICAgIGNvbnN0IGluaXRFZGl0b3IgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLnJlbW92ZWQgJiYgaXNUaGVtZUxvYWRlZChlZGl0b3IpICYmIGlzTW9kZWxMb2FkZWQoZWRpdG9yKSkge1xuICAgICAgICAgIGluaXQoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxvYWRUaGVtZShlZGl0b3IsIHN1ZmZpeCk7XG4gICAgICBsb2FkTW9kZWwoZWRpdG9yLCBzdWZmaXgpO1xuICAgICAgbG9hZExhbmd1YWdlKHNjcmlwdExvYWRlciwgZWRpdG9yKTtcbiAgICAgIGxvYWRJY29ucyhzY3JpcHRMb2FkZXIsIGVkaXRvciwgc3VmZml4KTtcbiAgICAgIGxvYWRQbHVnaW5zKGVkaXRvciwgc3VmZml4KTtcbiAgICAgIHNjcmlwdExvYWRlci5sb2FkUXVldWUoKS50aGVuKGluaXRFZGl0b3IsIGluaXRFZGl0b3IpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U3R5bGVTaGVldExvYWRlciA9IChlbGVtZW50LCBlZGl0b3IpID0+IGluc3RhbmNlLmZvckVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgY29udGVudENzc0NvcnM6IGhhc0NvbnRlbnRDc3NDb3JzKGVkaXRvciksXG4gICAgICByZWZlcnJlclBvbGljeTogZ2V0UmVmZXJyZXJQb2xpY3koZWRpdG9yKVxuICAgIH0pO1xuICAgIGNvbnN0IHJlbmRlciA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBpZCA9IGVkaXRvci5pZDtcbiAgICAgIEkxOG4uc2V0Q29kZShnZXRMYW5ndWFnZUNvZGUoZWRpdG9yKSk7XG4gICAgICBjb25zdCByZWFkeUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIERPTSQzLnVuYmluZCh3aW5kb3csICdyZWFkeScsIHJlYWR5SGFuZGxlcik7XG4gICAgICAgIGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIH07XG4gICAgICBpZiAoIUV2ZW50VXRpbHMuRXZlbnQuZG9tTG9hZGVkKSB7XG4gICAgICAgIERPTSQzLmJpbmQod2luZG93LCAncmVhZHknLCByZWFkeUhhbmRsZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWVkaXRvci5nZXRFbGVtZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRFbGVtZW50KCkpO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZSQ0KGVsZW1lbnQpO1xuICAgICAgZWRpdG9yLm9uKCdyZW1vdmUnLCAoKSA9PiB7XG4gICAgICAgIGVhY2hyKGVsZW1lbnQuZG9tLmF0dHJpYnV0ZXMsIGF0dHIgPT4gcmVtb3ZlJGEoZWxlbWVudCwgYXR0ci5uYW1lKSk7XG4gICAgICAgIHNldEFsbCQxKGVsZW1lbnQsIHNuYXBzaG90KTtcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnVpLnN0eWxlU2hlZXRMb2FkZXIgPSBnZXRTdHlsZVNoZWV0TG9hZGVyKGVsZW1lbnQsIGVkaXRvcik7XG4gICAgICBpZiAoIWlzSW5saW5lKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9yZ1Zpc2liaWxpdHkgPSBlZGl0b3IuZ2V0RWxlbWVudCgpLnN0eWxlLnZpc2liaWxpdHk7XG4gICAgICAgIGVkaXRvci5nZXRFbGVtZW50KCkuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmlubGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtID0gZWRpdG9yLmdldEVsZW1lbnQoKS5mb3JtIHx8IERPTSQzLmdldFBhcmVudChpZCwgJ2Zvcm0nKTtcbiAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgIGVkaXRvci5mb3JtRWxlbWVudCA9IGZvcm07XG4gICAgICAgIGlmIChoYXNIaWRkZW5JbnB1dChlZGl0b3IpICYmICFpc1RleHRhcmVhT3JJbnB1dChlZGl0b3IuZ2V0RWxlbWVudCgpKSkge1xuICAgICAgICAgIERPTSQzLmluc2VydEFmdGVyKERPTSQzLmNyZWF0ZSgnaW5wdXQnLCB7XG4gICAgICAgICAgICB0eXBlOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIG5hbWU6IGlkXG4gICAgICAgICAgfSksIGlkKTtcbiAgICAgICAgICBlZGl0b3IuaGFzSGlkZGVuSW5wdXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5mb3JtRXZlbnREZWxlZ2F0ZSA9IGUgPT4ge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaChlLnR5cGUsIGUpO1xuICAgICAgICB9O1xuICAgICAgICBET00kMy5iaW5kKGZvcm0sICdzdWJtaXQgcmVzZXQnLCBlZGl0b3IuZm9ybUV2ZW50RGVsZWdhdGUpO1xuICAgICAgICBlZGl0b3Iub24oJ3Jlc2V0JywgKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5yZXNldENvbnRlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRQYXRjaFN1Ym1pdChlZGl0b3IpICYmICFmb3JtLnN1Ym1pdC5ub2RlVHlwZSAmJiAhZm9ybS5zdWJtaXQubGVuZ3RoICYmICFmb3JtLl9tY2VPbGRTdWJtaXQpIHtcbiAgICAgICAgICBmb3JtLl9tY2VPbGRTdWJtaXQgPSBmb3JtLnN1Ym1pdDtcbiAgICAgICAgICBmb3JtLnN1Ym1pdCA9ICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5lZGl0b3JNYW5hZ2VyLnRyaWdnZXJTYXZlKCk7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0RGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm0uX21jZU9sZFN1Ym1pdChmb3JtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlZGl0b3Iud2luZG93TWFuYWdlciA9IFdpbmRvd01hbmFnZXIoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyID0gTm90aWZpY2F0aW9uTWFuYWdlcihlZGl0b3IpO1xuICAgICAgaWYgKGlzRW5jb2RpbmdYbWwoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub24oJ0dldENvbnRlbnQnLCBlID0+IHtcbiAgICAgICAgICBpZiAoZS5zYXZlKSB7XG4gICAgICAgICAgICBlLmNvbnRlbnQgPSBET00kMy5lbmNvZGUoZS5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEFkZEZvcm1TdWJtaXRUcmlnZ2VyKGVkaXRvcikpIHtcbiAgICAgICAgZWRpdG9yLm9uKCdzdWJtaXQnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgZWRpdG9yLnNhdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEFkZFVubG9hZFRyaWdnZXIoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3IuX2JlZm9yZVVubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZWRpdG9yLmluaXRpYWxpemVkICYmICFlZGl0b3IuZGVzdHJveWVkICYmICFlZGl0b3IuaXNIaWRkZW4oKSkge1xuICAgICAgICAgICAgZWRpdG9yLnNhdmUoe1xuICAgICAgICAgICAgICBmb3JtYXQ6ICdyYXcnLFxuICAgICAgICAgICAgICBub19ldmVudHM6IHRydWUsXG4gICAgICAgICAgICAgIHNldF9kaXJ0eTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIub24oJ0JlZm9yZVVubG9hZCcsIGVkaXRvci5fYmVmb3JlVW5sb2FkKTtcbiAgICAgIH1cbiAgICAgIGVkaXRvci5lZGl0b3JNYW5hZ2VyLmFkZChlZGl0b3IpO1xuICAgICAgbG9hZFNjcmlwdHMoZWRpdG9yLCBlZGl0b3Iuc3VmZml4KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0RWRpdGFibGVSb290ID0gKGVkaXRvciwgc3RhdGUpID0+IHtcbiAgICAgIGlmIChlZGl0b3IuX2VkaXRhYmxlUm9vdCAhPT0gc3RhdGUpIHtcbiAgICAgICAgZWRpdG9yLl9lZGl0YWJsZVJvb3QgPSBzdGF0ZTtcbiAgICAgICAgaWYgKCFlZGl0b3IucmVhZG9ubHkpIHtcbiAgICAgICAgICBlZGl0b3IuZ2V0Qm9keSgpLmNvbnRlbnRFZGl0YWJsZSA9IFN0cmluZyhlZGl0b3IuaGFzRWRpdGFibGVSb290KCkpO1xuICAgICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpcmVFZGl0YWJsZVJvb3RTdGF0ZUNoYW5nZShlZGl0b3IsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGhhc0VkaXRhYmxlUm9vdCA9IGVkaXRvciA9PiBlZGl0b3IuX2VkaXRhYmxlUm9vdDtcblxuICAgIGNvbnN0IHNlY3Rpb25SZXN1bHQgPSAoc2VjdGlvbnMsIHNldHRpbmdzKSA9PiAoe1xuICAgICAgc2VjdGlvbnM6IGNvbnN0YW50KHNlY3Rpb25zKSxcbiAgICAgIG9wdGlvbnM6IGNvbnN0YW50KHNldHRpbmdzKVxuICAgIH0pO1xuICAgIGNvbnN0IGRldmljZURldGVjdGlvbiA9IGRldGVjdCQyKCkuZGV2aWNlVHlwZTtcbiAgICBjb25zdCBpc1Bob25lID0gZGV2aWNlRGV0ZWN0aW9uLmlzUGhvbmUoKTtcbiAgICBjb25zdCBpc1RhYmxldCA9IGRldmljZURldGVjdGlvbi5pc1RhYmxldCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZVBsdWdpbnMgPSBwbHVnaW5zID0+IHtcbiAgICAgIGlmIChpc051bGxhYmxlKHBsdWdpbnMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbk5hbWVzID0gaXNBcnJheSQxKHBsdWdpbnMpID8gcGx1Z2lucyA6IHBsdWdpbnMuc3BsaXQoL1sgLF0vKTtcbiAgICAgICAgY29uc3QgdHJpbW1lZFBsdWdpbnMgPSBtYXAkMyhwbHVnaW5OYW1lcywgdHJpbSQzKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlciQ1KHRyaW1tZWRQbHVnaW5zLCBpc05vdEVtcHR5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RTZWN0aW9ucyA9IChrZXlzLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBiaWZpbHRlcihvcHRpb25zLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY29udGFpbnMkMihrZXlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VjdGlvblJlc3VsdChyZXN1bHQudCwgcmVzdWx0LmYpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VjdGlvbiA9IChzZWN0aW9uUmVzdWx0LCBuYW1lLCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBzZWN0aW9ucyA9IHNlY3Rpb25SZXN1bHQuc2VjdGlvbnMoKTtcbiAgICAgIGNvbnN0IHNlY3Rpb25PcHRpb25zID0gZ2V0JGEoc2VjdGlvbnMsIG5hbWUpLmdldE9yKHt9KTtcbiAgICAgIHJldHVybiBUb29scy5leHRlbmQoe30sIGRlZmF1bHRzLCBzZWN0aW9uT3B0aW9ucyk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNTZWN0aW9uID0gKHNlY3Rpb25SZXN1bHQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiBoYXMkMihzZWN0aW9uUmVzdWx0LnNlY3Rpb25zKCksIG5hbWUpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0U2VjdGlvbkNvbmZpZyA9IChzZWN0aW9uUmVzdWx0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gaGFzU2VjdGlvbihzZWN0aW9uUmVzdWx0LCBuYW1lKSA/IHNlY3Rpb25SZXN1bHQuc2VjdGlvbnMoKVtuYW1lXSA6IHt9O1xuICAgIH07XG4gICAgY29uc3QgZ2V0TW9iaWxlT3ZlcnJpZGVPcHRpb25zID0gKG1vYmlsZU9wdGlvbnMsIGlzUGhvbmUpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRNb2JpbGVPcHRpb25zID0ge1xuICAgICAgICB0YWJsZV9ncmlkOiBmYWxzZSxcbiAgICAgICAgb2JqZWN0X3Jlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgcmVzaXplOiBmYWxzZSxcbiAgICAgICAgdG9vbGJhcl9tb2RlOiBnZXQkYShtb2JpbGVPcHRpb25zLCAndG9vbGJhcl9tb2RlJykuZ2V0T3IoJ3Njcm9sbGluZycpLFxuICAgICAgICB0b29sYmFyX3N0aWNreTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb25zdCBkZWZhdWx0UGhvbmVPcHRpb25zID0geyBtZW51YmFyOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdE1vYmlsZU9wdGlvbnMsXG4gICAgICAgIC4uLmlzUGhvbmUgPyBkZWZhdWx0UGhvbmVPcHRpb25zIDoge31cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBnZXRFeHRlcm5hbFBsdWdpbnMgPSAob3ZlcnJpZGVPcHRpb25zLCBvcHRpb25zKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1c2VyRGVmaW5lZEV4dGVybmFsUGx1Z2lucyA9IChfYSA9IG9wdGlvbnMuZXh0ZXJuYWxfcGx1Z2lucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICBpZiAob3ZlcnJpZGVPcHRpb25zICYmIG92ZXJyaWRlT3B0aW9ucy5leHRlcm5hbF9wbHVnaW5zKSB7XG4gICAgICAgIHJldHVybiBUb29scy5leHRlbmQoe30sIG92ZXJyaWRlT3B0aW9ucy5leHRlcm5hbF9wbHVnaW5zLCB1c2VyRGVmaW5lZEV4dGVybmFsUGx1Z2lucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXNlckRlZmluZWRFeHRlcm5hbFBsdWdpbnM7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjb21iaW5lUGx1Z2lucyA9IChmb3JjZWRQbHVnaW5zLCBwbHVnaW5zKSA9PiBbXG4gICAgICAuLi5ub3JtYWxpemVQbHVnaW5zKGZvcmNlZFBsdWdpbnMpLFxuICAgICAgLi4ubm9ybWFsaXplUGx1Z2lucyhwbHVnaW5zKVxuICAgIF07XG4gICAgY29uc3QgZ2V0UGxhdGZvcm1QbHVnaW5zID0gKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0LCBkZXNrdG9wUGx1Z2lucywgbW9iaWxlUGx1Z2lucykgPT4ge1xuICAgICAgaWYgKGlzTW9iaWxlRGV2aWNlICYmIGhhc1NlY3Rpb24oc2VjdGlvblJlc3VsdCwgJ21vYmlsZScpKSB7XG4gICAgICAgIHJldHVybiBtb2JpbGVQbHVnaW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlc2t0b3BQbHVnaW5zO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc1BsdWdpbnMgPSAoaXNNb2JpbGVEZXZpY2UsIHNlY3Rpb25SZXN1bHQsIGRlZmF1bHRPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGZvcmNlZFBsdWdpbnMgPSBub3JtYWxpemVQbHVnaW5zKGRlZmF1bHRPdmVycmlkZU9wdGlvbnMuZm9yY2VkX3BsdWdpbnMpO1xuICAgICAgY29uc3QgZGVza3RvcFBsdWdpbnMgPSBub3JtYWxpemVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gICAgICBjb25zdCBtb2JpbGVDb25maWcgPSBnZXRTZWN0aW9uQ29uZmlnKHNlY3Rpb25SZXN1bHQsICdtb2JpbGUnKTtcbiAgICAgIGNvbnN0IG1vYmlsZVBsdWdpbnMgPSBtb2JpbGVDb25maWcucGx1Z2lucyA/IG5vcm1hbGl6ZVBsdWdpbnMobW9iaWxlQ29uZmlnLnBsdWdpbnMpIDogZGVza3RvcFBsdWdpbnM7XG4gICAgICBjb25zdCBwbGF0Zm9ybVBsdWdpbnMgPSBnZXRQbGF0Zm9ybVBsdWdpbnMoaXNNb2JpbGVEZXZpY2UsIHNlY3Rpb25SZXN1bHQsIGRlc2t0b3BQbHVnaW5zLCBtb2JpbGVQbHVnaW5zKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkUGx1Z2lucyA9IGNvbWJpbmVQbHVnaW5zKGZvcmNlZFBsdWdpbnMsIHBsYXRmb3JtUGx1Z2lucyk7XG4gICAgICByZXR1cm4gVG9vbHMuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgZm9yY2VkX3BsdWdpbnM6IGZvcmNlZFBsdWdpbnMsXG4gICAgICAgIHBsdWdpbnM6IGNvbWJpbmVkUGx1Z2luc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc09uTW9iaWxlID0gKGlzTW9iaWxlRGV2aWNlLCBzZWN0aW9uUmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gaXNNb2JpbGVEZXZpY2UgJiYgaGFzU2VjdGlvbihzZWN0aW9uUmVzdWx0LCAnbW9iaWxlJyk7XG4gICAgfTtcbiAgICBjb25zdCBjb21iaW5lT3B0aW9ucyA9IChpc01vYmlsZURldmljZSwgaXNQaG9uZSwgZGVmYXVsdE9wdGlvbnMsIGRlZmF1bHRPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGRldmljZU92ZXJyaWRlT3B0aW9ucyA9IGlzTW9iaWxlRGV2aWNlID8geyBtb2JpbGU6IGdldE1vYmlsZU92ZXJyaWRlT3B0aW9ucygoX2EgPSBvcHRpb25zLm1vYmlsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIGlzUGhvbmUpIH0gOiB7fTtcbiAgICAgIGNvbnN0IHNlY3Rpb25SZXN1bHQgPSBleHRyYWN0U2VjdGlvbnMoWydtb2JpbGUnXSwgZGVlcE1lcmdlKGRldmljZU92ZXJyaWRlT3B0aW9ucywgb3B0aW9ucykpO1xuICAgICAgY29uc3QgZXh0ZW5kZWRPcHRpb25zID0gVG9vbHMuZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBzZWN0aW9uUmVzdWx0Lm9wdGlvbnMoKSwgaXNPbk1vYmlsZShpc01vYmlsZURldmljZSwgc2VjdGlvblJlc3VsdCkgPyBnZXRTZWN0aW9uKHNlY3Rpb25SZXN1bHQsICdtb2JpbGUnKSA6IHt9LCB7IGV4dGVybmFsX3BsdWdpbnM6IGdldEV4dGVybmFsUGx1Z2lucyhkZWZhdWx0T3ZlcnJpZGVPcHRpb25zLCBzZWN0aW9uUmVzdWx0Lm9wdGlvbnMoKSkgfSk7XG4gICAgICByZXR1cm4gcHJvY2Vzc1BsdWdpbnMoaXNNb2JpbGVEZXZpY2UsIHNlY3Rpb25SZXN1bHQsIGRlZmF1bHRPdmVycmlkZU9wdGlvbnMsIGV4dGVuZGVkT3B0aW9ucyk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVPcHRpb25zID0gKGRlZmF1bHRPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpID0+IGNvbWJpbmVPcHRpb25zKGlzUGhvbmUgfHwgaXNUYWJsZXQsIGlzUGhvbmUsIG9wdGlvbnMsIGRlZmF1bHRPdmVycmlkZU9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYWRkVmlzdWFsID0gKGVkaXRvciwgZWxtKSA9PiBhZGRWaXN1YWwkMShlZGl0b3IsIGVsbSk7XG5cbiAgICBjb25zdCByZWdpc3RlckV4ZWNDb21tYW5kcyQzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRvZ2dsZUZvcm1hdCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHRvZ2dsZUFsaWduID0gYWxpZ24gPT4gKCkgPT4ge1xuICAgICAgICBlYWNoJGUoJ2xlZnQsY2VudGVyLHJpZ2h0LGp1c3RpZnknLnNwbGl0KCcsJyksIG5hbWUgPT4ge1xuICAgICAgICAgIGlmIChhbGlnbiAhPT0gbmFtZSkge1xuICAgICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoJ2FsaWduJyArIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhbGlnbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KCdhbGlnbicgKyBhbGlnbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBKdXN0aWZ5TGVmdDogdG9nZ2xlQWxpZ24oJ2xlZnQnKSxcbiAgICAgICAgSnVzdGlmeUNlbnRlcjogdG9nZ2xlQWxpZ24oJ2NlbnRlcicpLFxuICAgICAgICBKdXN0aWZ5UmlnaHQ6IHRvZ2dsZUFsaWduKCdyaWdodCcpLFxuICAgICAgICBKdXN0aWZ5RnVsbDogdG9nZ2xlQWxpZ24oJ2p1c3RpZnknKSxcbiAgICAgICAgSnVzdGlmeU5vbmU6IHRvZ2dsZUFsaWduKCdub25lJylcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJRdWVyeVN0YXRlQ29tbWFuZHMkMSA9IGVkaXRvciA9PiB7XG4gICAgICBjb25zdCBhbGlnblN0YXRlcyA9IG5hbWUgPT4gKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpID8gW2VkaXRvci5kb20uZ2V0UGFyZW50KHNlbGVjdGlvbi5nZXROb2RlKCksIGVkaXRvci5kb20uaXNCbG9jayldIDogc2VsZWN0aW9uLmdldFNlbGVjdGVkQmxvY2tzKCk7XG4gICAgICAgIHJldHVybiBleGlzdHMobm9kZXMsIG5vZGUgPT4gaXNOb25OdWxsYWJsZShlZGl0b3IuZm9ybWF0dGVyLm1hdGNoTm9kZShub2RlLCBuYW1lKSkpO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIEp1c3RpZnlMZWZ0OiBhbGlnblN0YXRlcygnYWxpZ25sZWZ0JyksXG4gICAgICAgIEp1c3RpZnlDZW50ZXI6IGFsaWduU3RhdGVzKCdhbGlnbmNlbnRlcicpLFxuICAgICAgICBKdXN0aWZ5UmlnaHQ6IGFsaWduU3RhdGVzKCdhbGlnbnJpZ2h0JyksXG4gICAgICAgIEp1c3RpZnlGdWxsOiBhbGlnblN0YXRlcygnYWxpZ25qdXN0aWZ5JylcbiAgICAgIH0sICdzdGF0ZScpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyRiID0gZWRpdG9yID0+IHtcbiAgICAgIHJlZ2lzdGVyRXhlY0NvbW1hbmRzJDMoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyUXVlcnlTdGF0ZUNvbW1hbmRzJDEoZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyRhID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgICdDdXQsQ29weSxQYXN0ZSc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvYyA9IGVkaXRvci5nZXREb2MoKTtcbiAgICAgICAgICBsZXQgZmFpbGVkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYW5kID09PSAncGFzdGUnICYmICFkb2MucXVlcnlDb21tYW5kRW5hYmxlZChjb21tYW5kKSkge1xuICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZhaWxlZCB8fCAhZG9jLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKSkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IGVkaXRvci50cmFuc2xhdGUoYFlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgZGlyZWN0IGFjY2VzcyB0byB0aGUgY2xpcGJvYXJkLiBgICsgJ1BsZWFzZSB1c2UgdGhlIEN0cmwrWC9DL1Yga2V5Ym9hcmQgc2hvcnRjdXRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBpZiAoRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKSkge1xuICAgICAgICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvQ3RybFxcKy9nLCAnXFx1MjMxOCsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5ub3RpZmljYXRpb25NYW5hZ2VyLm9wZW4oe1xuICAgICAgICAgICAgICB0ZXh0OiBtc2csXG4gICAgICAgICAgICAgIHR5cGU6ICdlcnJvcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaW1PclBhZExlZnRSaWdodCA9IChkb20sIHJuZywgaHRtbCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvbS5nZXRSb290KCkpO1xuICAgICAgaWYgKG5lZWRzVG9CZU5ic3BMZWZ0KHJvb3QsIENhcmV0UG9zaXRpb24uZnJvbVJhbmdlU3RhcnQocm5nKSkpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXiAvLCAnJm5ic3A7Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9eJm5ic3A7LywgJyAnKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc1RvQmVOYnNwUmlnaHQocm9vdCwgQ2FyZXRQb3NpdGlvbi5mcm9tUmFuZ2VFbmQocm5nKSkpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvKCZuYnNwO3wgKSg8YnIoIFxcLyk+KT8kLywgJyZuYnNwOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvJm5ic3A7KDxiciggXFwvKT8+KT8kLywgJyAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sO1xuICAgIH07XG5cbiAgICBjb25zdCBwcm9jZXNzVmFsdWUkMSA9IHZhbHVlID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBUb29scy5leHRlbmQoe1xuICAgICAgICAgIHBhc3RlOiB2YWx1ZS5wYXN0ZSxcbiAgICAgICAgICBkYXRhOiB7IHBhc3RlOiB2YWx1ZS5wYXN0ZSB9XG4gICAgICAgIH0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxuICAgICAgICAgIGRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICBkZXRhaWxzOiB7fVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHRyaW1PclBhZCA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGlmICgvXiB8ICQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cmltT3JQYWRMZWZ0UmlnaHQoZG9tLCBzZWxlY3Rpb24uZ2V0Um5nKCksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluc2VydEF0Q2FyZXQgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIGNvbnN0IHtjb250ZW50LCBkZXRhaWxzfSA9IHByb2Nlc3NWYWx1ZSQxKHZhbHVlKTtcbiAgICAgICAgcHJlUHJvY2Vzc1NldENvbnRlbnQoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgICBjb250ZW50OiB0cmltT3JQYWQoZWRpdG9yLCBjb250ZW50KSxcbiAgICAgICAgICBmb3JtYXQ6ICdodG1sJyxcbiAgICAgICAgICBzZXQ6IGZhbHNlLFxuICAgICAgICAgIHNlbGVjdGlvbjogdHJ1ZVxuICAgICAgICB9KS5lYWNoKGFyZ3MgPT4ge1xuICAgICAgICAgIGNvbnN0IGluc2VydGVkQ29udGVudCA9IGluc2VydENvbnRlbnQkMShlZGl0b3IsIGFyZ3MuY29udGVudCwgZGV0YWlscyk7XG4gICAgICAgICAgcG9zdFByb2Nlc3NTZXRDb250ZW50KGVkaXRvciwgaW5zZXJ0ZWRDb250ZW50LCBhcmdzKTtcbiAgICAgICAgICBlZGl0b3IuYWRkVmlzdWFsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzJDkgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgbWNlQ2xlYW51cDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJtID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50KGVkaXRvci5nZXRDb250ZW50KCkpO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm0pO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnRJbWFnZTogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QXRDYXJldChlZGl0b3IsIGVkaXRvci5kb20uY3JlYXRlSFRNTCgnaW1nJywgeyBzcmM6IHZhbHVlIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0SG9yaXpvbnRhbFJ1bGU6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoJ21jZUluc2VydENvbnRlbnQnLCBmYWxzZSwgJzxocj4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zZXJ0VGV4dDogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QXRDYXJldChlZGl0b3IsIGVkaXRvci5kb20uZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydEhUTUw6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUluc2VydENvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGluc2VydEF0Q2FyZXQoZWRpdG9yLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVNldENvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5zZXRDb250ZW50KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlUmVwbGFjZUNvbnRlbnQ6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGVkaXRvci5leGVjQ29tbWFuZCgnbWNlSW5zZXJ0Q29udGVudCcsIGZhbHNlLCB2YWx1ZS5yZXBsYWNlKC9cXHtcXCRzZWxlY3Rpb25cXH0vZywgZWRpdG9yLnNlbGVjdGlvbi5nZXRDb250ZW50KHsgZm9ybWF0OiAndGV4dCcgfSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlTmV3RG9jdW1lbnQ6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2V0Q29udGVudChnZXROZXdEb2N1bWVudENvbnRlbnQoZWRpdG9yKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZWdhY3lQcm9wTmFtZXMgPSB7XG4gICAgICAnZm9udC1zaXplJzogJ3NpemUnLFxuICAgICAgJ2ZvbnQtZmFtaWx5JzogJ2ZhY2UnXG4gICAgfTtcbiAgICBjb25zdCBpc0ZvbnQgPSBpc1RhZygnZm9udCcpO1xuICAgIGNvbnN0IGdldFNwZWNpZmllZEZvbnRQcm9wID0gKHByb3BOYW1lLCByb290RWxtLCBlbG0pID0+IHtcbiAgICAgIGNvbnN0IGdldFByb3BlcnR5ID0gZWxtID0+IGdldFJhdyhlbG0sIHByb3BOYW1lKS5vclRodW5rKCgpID0+IHtcbiAgICAgICAgaWYgKGlzRm9udChlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuIGdldCRhKGxlZ2FjeVByb3BOYW1lcywgcHJvcE5hbWUpLmJpbmQobGVnYWN5UHJvcE5hbWUgPT4gZ2V0T3B0KGVsbSwgbGVnYWN5UHJvcE5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzUm9vdCA9IGVsbSA9PiBlcShTdWdhckVsZW1lbnQuZnJvbURvbShyb290RWxtKSwgZWxtKTtcbiAgICAgIHJldHVybiBjbG9zZXN0JDEoU3VnYXJFbGVtZW50LmZyb21Eb20oZWxtKSwgZWxtID0+IGdldFByb3BlcnR5KGVsbSksIGlzUm9vdCk7XG4gICAgfTtcbiAgICBjb25zdCBub3JtYWxpemVGb250RmFtaWx5ID0gZm9udEZhbWlseSA9PiBmb250RmFtaWx5LnJlcGxhY2UoL1tcXCdcXFwiXFxcXF0vZywgJycpLnJlcGxhY2UoLyxcXHMrL2csICcsJyk7XG4gICAgY29uc3QgZ2V0Q29tcHV0ZWRGb250UHJvcCA9IChwcm9wTmFtZSwgZWxtKSA9PiBPcHRpb25hbC5mcm9tKERPTVV0aWxzLkRPTS5nZXRTdHlsZShlbG0sIHByb3BOYW1lLCB0cnVlKSk7XG4gICAgY29uc3QgZ2V0Rm9udFByb3AgPSBwcm9wTmFtZSA9PiAocm9vdEVsbSwgZWxtKSA9PiBPcHRpb25hbC5mcm9tKGVsbSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKS5maWx0ZXIoaXNFbGVtZW50JDcpLmJpbmQoZWxlbWVudCA9PiBnZXRTcGVjaWZpZWRGb250UHJvcChwcm9wTmFtZSwgcm9vdEVsbSwgZWxlbWVudC5kb20pLm9yKGdldENvbXB1dGVkRm9udFByb3AocHJvcE5hbWUsIGVsZW1lbnQuZG9tKSkpLmdldE9yKCcnKTtcbiAgICBjb25zdCBnZXRGb250U2l6ZSA9IGdldEZvbnRQcm9wKCdmb250LXNpemUnKTtcbiAgICBjb25zdCBnZXRGb250RmFtaWx5ID0gY29tcG9zZShub3JtYWxpemVGb250RmFtaWx5LCBnZXRGb250UHJvcCgnZm9udC1mYW1pbHknKSk7XG5cbiAgICBjb25zdCBmaW5kRmlyc3RDYXJldEVsZW1lbnQgPSBlZGl0b3IgPT4gZmlyc3RQb3NpdGlvbkluKGVkaXRvci5nZXRCb2R5KCkpLmJpbmQoY2FyZXQgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY2FyZXQuY29udGFpbmVyKCk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbShpc1RleHQkYShjb250YWluZXIpID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldENhcmV0RWxlbWVudCA9IGVkaXRvciA9PiBPcHRpb25hbC5mcm9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpLmJpbmQocm5nID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgICAgY29uc3QgYXRTdGFydE9mTm9kZSA9IHJuZy5zdGFydENvbnRhaW5lciA9PT0gcm9vdCAmJiBybmcuc3RhcnRPZmZzZXQgPT09IDA7XG4gICAgICByZXR1cm4gYXRTdGFydE9mTm9kZSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLmZyb20oZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCh0cnVlKSk7XG4gICAgfSk7XG4gICAgY29uc3QgYmluZFJhbmdlID0gKGVkaXRvciwgYmluZGVyKSA9PiBnZXRDYXJldEVsZW1lbnQoZWRpdG9yKS5vclRodW5rKGN1cnJ5KGZpbmRGaXJzdENhcmV0RWxlbWVudCwgZWRpdG9yKSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKS5maWx0ZXIoaXNFbGVtZW50JDcpLmJpbmQoYmluZGVyKTtcbiAgICBjb25zdCBtYXBSYW5nZSA9IChlZGl0b3IsIG1hcHBlcikgPT4gYmluZFJhbmdlKGVkaXRvciwgY29tcG9zZTEoT3B0aW9uYWwuc29tZSwgbWFwcGVyKSk7XG5cbiAgICBjb25zdCBmcm9tRm9udFNpemVOdW1iZXIgPSAoZWRpdG9yLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKC9eWzAtOS5dKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplTnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKGZvbnRTaXplTnVtYmVyID49IDEgJiYgZm9udFNpemVOdW1iZXIgPD0gNykge1xuICAgICAgICAgIGNvbnN0IGZvbnRTaXplcyA9IGdldEZvbnRTdHlsZVZhbHVlcyhlZGl0b3IpO1xuICAgICAgICAgIGNvbnN0IGZvbnRDbGFzc2VzID0gZ2V0Rm9udFNpemVDbGFzc2VzKGVkaXRvcik7XG4gICAgICAgICAgaWYgKGZvbnRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmb250Q2xhc3Nlc1tmb250U2l6ZU51bWJlciAtIDFdIHx8IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9udFNpemVzW2ZvbnRTaXplTnVtYmVyIC0gMV0gfHwgdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXplRm9udE5hbWVzID0gZm9udCA9PiB7XG4gICAgICBjb25zdCBmb250cyA9IGZvbnQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgcmV0dXJuIG1hcCQzKGZvbnRzLCBmb250ID0+IHtcbiAgICAgICAgaWYgKGZvbnQuaW5kZXhPZignICcpICE9PSAtMSAmJiAhKHN0YXJ0c1dpdGgoZm9udCwgJ1wiJykgfHwgc3RhcnRzV2l0aChmb250LCBgJ2ApKSkge1xuICAgICAgICAgIHJldHVybiBgJyR7IGZvbnQgfSdgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmb250O1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcsJyk7XG4gICAgfTtcbiAgICBjb25zdCBmb250TmFtZUFjdGlvbiA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBmb250ID0gZnJvbUZvbnRTaXplTnVtYmVyKGVkaXRvciwgdmFsdWUpO1xuICAgICAgZWRpdG9yLmZvcm1hdHRlci50b2dnbGUoJ2ZvbnRuYW1lJywgeyB2YWx1ZTogbm9ybWFsaXplRm9udE5hbWVzKGZvbnQpIH0pO1xuICAgICAgZWRpdG9yLm5vZGVDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBjb25zdCBmb250TmFtZVF1ZXJ5ID0gZWRpdG9yID0+IG1hcFJhbmdlKGVkaXRvciwgZWxtID0+IGdldEZvbnRGYW1pbHkoZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSkpLmdldE9yKCcnKTtcbiAgICBjb25zdCBmb250U2l6ZUFjdGlvbiA9IChlZGl0b3IsIHZhbHVlKSA9PiB7XG4gICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZSgnZm9udHNpemUnLCB7IHZhbHVlOiBmcm9tRm9udFNpemVOdW1iZXIoZWRpdG9yLCB2YWx1ZSkgfSk7XG4gICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvbnRTaXplUXVlcnkgPSBlZGl0b3IgPT4gbWFwUmFuZ2UoZWRpdG9yLCBlbG0gPT4gZ2V0Rm9udFNpemUoZWRpdG9yLmdldEJvZHkoKSwgZWxtLmRvbSkpLmdldE9yKCcnKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHRRdWVyeSA9IGVkaXRvciA9PiBtYXBSYW5nZShlZGl0b3IsIGVsbSA9PiB7XG4gICAgICBjb25zdCByb290ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gICAgICBjb25zdCBzcGVjaWZpZWRTdHlsZSA9IGNsb3Nlc3QkMShlbG0sIGVsbSA9PiBnZXRSYXcoZWxtLCAnbGluZS1oZWlnaHQnKSwgY3VycnkoZXEsIHJvb3QpKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBwYXJzZUZsb2F0KGdldCQ3KGVsbSwgJ2xpbmUtaGVpZ2h0JykpO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcnNlRmxvYXQoZ2V0JDcoZWxtLCAnZm9udC1zaXplJykpO1xuICAgICAgICByZXR1cm4gU3RyaW5nKGxpbmVIZWlnaHQgLyBmb250U2l6ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNwZWNpZmllZFN0eWxlLmdldE9yVGh1bmsoY29tcHV0ZWRTdHlsZSk7XG4gICAgfSkuZ2V0T3IoJycpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHRBY3Rpb24gPSAoZWRpdG9yLCBsaW5lSGVpZ2h0KSA9PiB7XG4gICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZSgnbGluZWhlaWdodCcsIHsgdmFsdWU6IFN0cmluZyhsaW5lSGVpZ2h0KSB9KTtcbiAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckV4ZWNDb21tYW5kcyQyID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IHRvZ2dsZUZvcm1hdCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnRvZ2dsZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGVkaXRvci5ub2RlQ2hhbmdlZCgpO1xuICAgICAgfTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgICdCb2xkLEl0YWxpYyxVbmRlcmxpbmUsU3RyaWtldGhyb3VnaCxTdXBlcnNjcmlwdCxTdWJzY3JpcHQnOiBjb21tYW5kID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQoY29tbWFuZCk7XG4gICAgICAgIH0sXG4gICAgICAgICdGb3JlQ29sb3IsSGlsaXRlQ29sb3InOiAoY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdChjb21tYW5kLCB7IHZhbHVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICAnQmFja0NvbG9yJzogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KCdoaWxpdGVjb2xvcicsIHsgdmFsdWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICdGb250TmFtZSc6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIGZvbnROYW1lQWN0aW9uKGVkaXRvciwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAnRm9udFNpemUnOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBmb250U2l6ZUFjdGlvbihlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ0xpbmVIZWlnaHQnOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBsaW5lSGVpZ2h0QWN0aW9uKGVkaXRvciwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAnTGFuZyc6IChjb21tYW5kLCBfdWksIGxhbmcpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KGNvbW1hbmQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBsYW5nLmNvZGUsXG4gICAgICAgICAgICBjdXN0b21WYWx1ZTogKF9hID0gbGFuZy5jdXN0b21Db2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICdSZW1vdmVGb3JtYXQnOiBjb21tYW5kID0+IHtcbiAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLnJlbW92ZShjb21tYW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ21jZUJsb2NrUXVvdGUnOiAoKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlRm9ybWF0KCdibG9ja3F1b3RlJyk7XG4gICAgICAgIH0sXG4gICAgICAgICdGb3JtYXRCbG9jayc6IChfY29tbWFuZCwgX3VpLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRvZ2dsZUZvcm1hdChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6ICdwJyk7XG4gICAgICAgIH0sXG4gICAgICAgICdtY2VUb2dnbGVGb3JtYXQnOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICB0b2dnbGVGb3JtYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUXVlcnlWYWx1ZUNvbW1hbmRzID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGlzRm9ybWF0TWF0Y2ggPSBuYW1lID0+IGVkaXRvci5mb3JtYXR0ZXIubWF0Y2gobmFtZSk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnQm9sZCxJdGFsaWMsVW5kZXJsaW5lLFN0cmlrZXRocm91Z2gsU3VwZXJzY3JpcHQsU3Vic2NyaXB0JzogY29tbWFuZCA9PiBpc0Zvcm1hdE1hdGNoKGNvbW1hbmQpLFxuICAgICAgICAnbWNlQmxvY2tRdW90ZSc6ICgpID0+IGlzRm9ybWF0TWF0Y2goJ2Jsb2NrcXVvdGUnKVxuICAgICAgfSwgJ3N0YXRlJyk7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkUXVlcnlWYWx1ZUhhbmRsZXIoJ0ZvbnROYW1lJywgKCkgPT4gZm9udE5hbWVRdWVyeShlZGl0b3IpKTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRRdWVyeVZhbHVlSGFuZGxlcignRm9udFNpemUnLCAoKSA9PiBmb250U2l6ZVF1ZXJ5KGVkaXRvcikpO1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZFF1ZXJ5VmFsdWVIYW5kbGVyKCdMaW5lSGVpZ2h0JywgKCkgPT4gbGluZUhlaWdodFF1ZXJ5KGVkaXRvcikpO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQ4ID0gZWRpdG9yID0+IHtcbiAgICAgIHJlZ2lzdGVyRXhlY0NvbW1hbmRzJDIoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyUXVlcnlWYWx1ZUNvbW1hbmRzKGVkaXRvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBtY2VBZGRVbmRvTGV2ZWw6ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIuYWRkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUVuZFVuZG9MZXZlbDogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci5hZGQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgVW5kbzogKCkgPT4ge1xuICAgICAgICAgIGVkaXRvci51bmRvTWFuYWdlci51bmRvKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFJlZG86ICgpID0+IHtcbiAgICAgICAgICBlZGl0b3IudW5kb01hbmFnZXIucmVkbygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQ2ID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIEluZGVudDogKCkgPT4ge1xuICAgICAgICAgIGluZGVudChlZGl0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBPdXRkZW50OiAoKSA9PiB7XG4gICAgICAgICAgb3V0ZGVudChlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7IE91dGRlbnQ6ICgpID0+IGNhbk91dGRlbnQoZWRpdG9yKSB9LCAnc3RhdGUnKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQ1ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFwcGx5TGlua1RvU2VsZWN0aW9uID0gKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmtEZXRhaWxzID0gaXNTdHJpbmcodmFsdWUpID8geyBocmVmOiB2YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCAnYScpO1xuICAgICAgICBpZiAoaXNPYmplY3QobGlua0RldGFpbHMpICYmIGlzU3RyaW5nKGxpbmtEZXRhaWxzLmhyZWYpKSB7XG4gICAgICAgICAgbGlua0RldGFpbHMuaHJlZiA9IGxpbmtEZXRhaWxzLmhyZWYucmVwbGFjZSgvIC9nLCAnJTIwJyk7XG4gICAgICAgICAgaWYgKCFhbmNob3IgfHwgIWxpbmtEZXRhaWxzLmhyZWYpIHtcbiAgICAgICAgICAgIGVkaXRvci5mb3JtYXR0ZXIucmVtb3ZlKCdsaW5rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5rRGV0YWlscy5ocmVmKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9ybWF0dGVyLmFwcGx5KCdsaW5rJywgbGlua0RldGFpbHMsIGFuY2hvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgdW5saW5rOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsbSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgJ2EnKTtcbiAgICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5kb20ucmVtb3ZlKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLmZvcm1hdHRlci5yZW1vdmUoJ2xpbmsnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUluc2VydExpbms6IGFwcGx5TGlua1RvU2VsZWN0aW9uLFxuICAgICAgICBjcmVhdGVMaW5rOiBhcHBseUxpbmtUb1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyRXhlY0NvbW1hbmRzJDEgPSBlZGl0b3IgPT4ge1xuICAgICAgZWRpdG9yLmVkaXRvckNvbW1hbmRzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgJ0luc2VydFVub3JkZXJlZExpc3QsSW5zZXJ0T3JkZXJlZExpc3QnOiBjb21tYW5kID0+IHtcbiAgICAgICAgICBlZGl0b3IuZ2V0RG9jKCkuZXhlY0NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgY29uc3QgbGlzdEVsbSA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCAnb2wsdWwnKTtcbiAgICAgICAgICBpZiAobGlzdEVsbSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdFBhcmVudCA9IGxpc3RFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChsaXN0UGFyZW50ICYmIC9eKEhbMS02XXxQfEFERFJFU1N8UFJFKSQvLnRlc3QobGlzdFBhcmVudC5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgYm0gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgICAgIGVkaXRvci5kb20uc3BsaXQobGlzdFBhcmVudCwgbGlzdEVsbSk7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvQm9va21hcmsoYm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICAnSW5zZXJ0VW5vcmRlcmVkTGlzdCxJbnNlcnRPcmRlcmVkTGlzdCc6IGNvbW1hbmQgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3QgPSBlZGl0b3IuZG9tLmdldFBhcmVudChlZGl0b3Iuc2VsZWN0aW9uLmdldE5vZGUoKSwgJ3VsLG9sJyk7XG4gICAgICAgICAgcmV0dXJuIGxpc3QgJiYgKGNvbW1hbmQgPT09ICdpbnNlcnR1bm9yZGVyZWRsaXN0JyAmJiBsaXN0LnRhZ05hbWUgPT09ICdVTCcgfHwgY29tbWFuZCA9PT0gJ2luc2VydG9yZGVyZWRsaXN0JyAmJiBsaXN0LnRhZ05hbWUgPT09ICdPTCcpO1xuICAgICAgICB9XG4gICAgICB9LCAnc3RhdGUnKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkNCA9IGVkaXRvciA9PiB7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyQxKGVkaXRvcik7XG4gICAgICByZWdpc3RlclF1ZXJ5U3RhdGVDb21tYW5kcyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRUb3BQYXJlbnRCbG9jayA9IChlZGl0b3IsIG5vZGUsIHJvb3QsIGNvbnRhaW5lcikgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gbm9kZSA9PiBkb20uaXNCbG9jayhub2RlKSAmJiBub2RlLnBhcmVudEVsZW1lbnQgPT09IHJvb3Q7XG4gICAgICBjb25zdCB0b3BQYXJlbnRCbG9jayA9IHNlbGVjdG9yKG5vZGUpID8gbm9kZSA6IGRvbS5nZXRQYXJlbnQoY29udGFpbmVyLCBzZWxlY3Rvciwgcm9vdCk7XG4gICAgICByZXR1cm4gT3B0aW9uYWwuZnJvbSh0b3BQYXJlbnRCbG9jaykubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc2VydCA9IChlZGl0b3IsIGJlZm9yZSkgPT4ge1xuICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmRvbTtcbiAgICAgIGNvbnN0IHJuZyA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCk7XG4gICAgICBjb25zdCBub2RlID0gYmVmb3JlID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRTdGFydCgpIDogZWRpdG9yLnNlbGVjdGlvbi5nZXRFbmQoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGJlZm9yZSA/IHJuZy5zdGFydENvbnRhaW5lciA6IHJuZy5lbmRDb250YWluZXI7XG4gICAgICBjb25zdCByb290ID0gZ2V0RWRpdGFibGVSb290KGRvbSwgY29udGFpbmVyKTtcbiAgICAgIGlmICghcm9vdCB8fCAhcm9vdC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbnNlcnRGbiA9IGJlZm9yZSA/IGJlZm9yZSQzIDogYWZ0ZXIkNDtcbiAgICAgIGNvbnN0IG5ld0Jsb2NrTmFtZSA9IGdldEZvcmNlZFJvb3RCbG9jayhlZGl0b3IpO1xuICAgICAgZ2V0VG9wUGFyZW50QmxvY2soZWRpdG9yLCBub2RlLCByb290LCBjb250YWluZXIpLmVhY2gocGFyZW50QmxvY2sgPT4ge1xuICAgICAgICBjb25zdCBuZXdCbG9jayA9IGNyZWF0ZU5ld0Jsb2NrKGVkaXRvciwgY29udGFpbmVyLCBwYXJlbnRCbG9jay5kb20sIHJvb3QsIGZhbHNlLCBuZXdCbG9ja05hbWUpO1xuICAgICAgICBpbnNlcnRGbihwYXJlbnRCbG9jaywgU3VnYXJFbGVtZW50LmZyb21Eb20obmV3QmxvY2spKTtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRDdXJzb3JMb2NhdGlvbihuZXdCbG9jaywgMCk7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaCgnTmV3QmxvY2snLCB7IG5ld0Jsb2NrIH0pO1xuICAgICAgICBmaXJlSW5wdXRFdmVudChlZGl0b3IsICdpbnNlcnRQYXJhZ3JhcGgnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0QmVmb3JlID0gZWRpdG9yID0+IGluc2VydChlZGl0b3IsIHRydWUpO1xuICAgIGNvbnN0IGluc2VydEFmdGVyID0gZWRpdG9yID0+IGluc2VydChlZGl0b3IsIGZhbHNlKTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBJbnNlcnROZXdCbG9ja0JlZm9yZTogKCkgPT4ge1xuICAgICAgICAgIGluc2VydEJlZm9yZShlZGl0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBJbnNlcnROZXdCbG9ja0FmdGVyOiAoKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyQ29tbWFuZHMkMiA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBpbnNlcnRQYXJhZ3JhcGg6ICgpID0+IHtcbiAgICAgICAgICBpbnNlcnRCcmVhayhibG9ja2JyZWFrLCBlZGl0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBtY2VJbnNlcnROZXdMaW5lOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBpbnNlcnQkMShlZGl0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgSW5zZXJ0TGluZUJyZWFrOiAoX2NvbW1hbmQsIF91aSwgX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgaW5zZXJ0QnJlYWsobGluZWJyZWFrLCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0ZXJDb21tYW5kcyQxID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIG1jZVNlbGVjdE5vZGVEZXB0aDogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICAgIGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQkNihub2RlKSAmJiBjb3VudGVyKysgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBlZGl0b3IuZ2V0Qm9keSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlU2VsZWN0Tm9kZTogKF9jb21tYW5kLCBfdWksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RBbGw6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBlZGl0aW5nSG9zdCA9IGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0U3RhcnQoKSwgaXNDb250ZW50RWRpdGFibGVUcnVlJDMpO1xuICAgICAgICAgIGlmIChlZGl0aW5nSG9zdCkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLmRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgICAgIHJuZy5zZWxlY3ROb2RlQ29udGVudHMoZWRpdGluZ0hvc3QpO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSbmcocm5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCByZWdpc3RlckV4ZWNDb21tYW5kcyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IuZWRpdG9yQ29tbWFuZHMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBtY2VSZW1vdmVOb2RlOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogZWRpdG9yLnNlbGVjdGlvbi5nZXROb2RlKCk7XG4gICAgICAgICAgaWYgKG5vZGUgIT09IGVkaXRvci5nZXRCb2R5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJtID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgICAgZWRpdG9yLmRvbS5yZW1vdmUobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1jZVByaW50OiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmdldFdpbigpLnByaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1jZUZvY3VzOiAoX2NvbW1hbmQsIF91aSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBmb2N1cyhlZGl0b3IsIHZhbHVlID09PSB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWNlVG9nZ2xlVmlzdWFsQWlkOiAoKSA9PiB7XG4gICAgICAgICAgZWRpdG9yLmhhc1Zpc3VhbCA9ICFlZGl0b3IuaGFzVmlzdWFsO1xuICAgICAgICAgIGVkaXRvci5hZGRWaXN1YWwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlckNvbW1hbmRzID0gZWRpdG9yID0+IHtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkYihlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyRhKGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDcoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkMShlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ5KGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDUoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkNihlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQzKGVkaXRvcik7XG4gICAgICByZWdpc3RlckNvbW1hbmRzJDIoZWRpdG9yKTtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZHMkNChlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJDb21tYW5kcyQ4KGVkaXRvcik7XG4gICAgICByZWdpc3RlckV4ZWNDb21tYW5kcyhlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBzZWxlY3Rpb25TYWZlQ29tbWFuZHMgPSBbJ3RvZ2dsZXZpZXcnXTtcbiAgICBjb25zdCBpc1NlbGVjdGlvblNhZmVDb21tYW5kID0gY29tbWFuZCA9PiBjb250YWlucyQyKHNlbGVjdGlvblNhZmVDb21tYW5kcywgY29tbWFuZC50b0xvd2VyQ2FzZSgpKTtcbiAgICBjbGFzcyBFZGl0b3JDb21tYW5kcyB7XG4gICAgICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IHtcbiAgICAgICAgICBzdGF0ZToge30sXG4gICAgICAgICAgZXhlYzoge30sXG4gICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgfVxuICAgICAgZXhlY0NvbW1hbmQoY29tbWFuZCwgdWkgPSBmYWxzZSwgdmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUNvbW1hbmQgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHNraXBGb2N1cyA9IGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5za2lwX2ZvY3VzO1xuICAgICAgICBpZiAoZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyQ2FzZUNvbW1hbmQgIT09ICdtY2Vmb2N1cycpIHtcbiAgICAgICAgICBpZiAoIS9eKG1jZUFkZFVuZG9MZXZlbHxtY2VFbmRVbmRvTGV2ZWwpJC9pLnRlc3QobG93ZXJDYXNlQ29tbWFuZCkgJiYgIXNraXBGb2N1cykge1xuICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3RvcmUoZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0gZWRpdG9yLmRpc3BhdGNoKCdCZWZvcmVFeGVjQ29tbWFuZCcsIHtcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIHVpLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSB0aGlzLmNvbW1hbmRzLmV4ZWNbbG93ZXJDYXNlQ29tbWFuZF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgZnVuYyhsb3dlckNhc2VDb21tYW5kLCB1aSwgdmFsdWUpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnRXhlY0NvbW1hbmQnLCB7XG4gICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgdWksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFN0YXRlKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvblNhZmVDb21tYW5kKGNvbW1hbmQpICYmIHRoaXMuZWRpdG9yLnF1aXJrcy5pc0hpZGRlbigpIHx8IHRoaXMuZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29tbWFuZCA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuY29tbWFuZHMuc3RhdGVbbG93ZXJDYXNlQ29tbWFuZF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMobG93ZXJDYXNlQ29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kVmFsdWUoY29tbWFuZCkge1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uU2FmZUNvbW1hbmQoY29tbWFuZCkgJiYgdGhpcy5lZGl0b3IucXVpcmtzLmlzSGlkZGVuKCkgfHwgdGhpcy5lZGl0b3IucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5jb21tYW5kcy52YWx1ZVtsb3dlckNhc2VDb21tYW5kXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYyhsb3dlckNhc2VDb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBhZGRDb21tYW5kcyhjb21tYW5kTGlzdCwgdHlwZSA9ICdleGVjJykge1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgICAgIGVhY2gkZChjb21tYW5kTGlzdCwgKGNhbGxiYWNrLCBjb21tYW5kKSA9PiB7XG4gICAgICAgICAgZWFjaCRlKGNvbW1hbmQudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLCBjb21tYW5kID0+IHtcbiAgICAgICAgICAgIGNvbW1hbmRzW3R5cGVdW2NvbW1hbmRdID0gY2FsbGJhY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYWRkQ29tbWFuZChjb21tYW5kLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlQ29tbWFuZCA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5leGVjW2xvd2VyQ2FzZUNvbW1hbmRdID0gKF9jb21tYW5kLCB1aSwgdmFsdWUpID0+IGNhbGxiYWNrLmNhbGwoc2NvcGUgIT09IG51bGwgJiYgc2NvcGUgIT09IHZvaWQgMCA/IHNjb3BlIDogdGhpcy5lZGl0b3IsIHVpLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY29tbWFuZCkge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VDb21tYW5kID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kcy5leGVjW2xvd2VyQ2FzZUNvbW1hbmRdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRRdWVyeVN0YXRlSGFuZGxlcihjb21tYW5kLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5zdGF0ZVtjb21tYW5kLnRvTG93ZXJDYXNlKCldID0gKCkgPT4gY2FsbGJhY2suY2FsbChzY29wZSAhPT0gbnVsbCAmJiBzY29wZSAhPT0gdm9pZCAwID8gc2NvcGUgOiB0aGlzLmVkaXRvcik7XG4gICAgICB9XG4gICAgICBhZGRRdWVyeVZhbHVlSGFuZGxlcihjb21tYW5kLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy52YWx1ZVtjb21tYW5kLnRvTG93ZXJDYXNlKCldID0gKCkgPT4gY2FsbGJhY2suY2FsbChzY29wZSAhPT0gbnVsbCAmJiBzY29wZSAhPT0gdm9pZCAwID8gc2NvcGUgOiB0aGlzLmVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyID0gJ2RhdGEtbWNlLWNvbnRlbnRlZGl0YWJsZSc7XG4gICAgY29uc3QgdG9nZ2xlQ2xhc3MgPSAoZWxtLCBjbHMsIHN0YXRlKSA9PiB7XG4gICAgICBpZiAoaGFzKGVsbSwgY2xzKSAmJiAhc3RhdGUpIHtcbiAgICAgICAgcmVtb3ZlJDcoZWxtLCBjbHMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSkge1xuICAgICAgICBhZGQkMihlbG0sIGNscyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRFZGl0b3JDb21tYW5kU3RhdGUgPSAoZWRpdG9yLCBjbWQsIHN0YXRlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlZGl0b3IuZ2V0RG9jKCkuZXhlY0NvbW1hbmQoY21kLCBmYWxzZSwgU3RyaW5nKHN0YXRlKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29udGVudEVkaXRhYmxlID0gKGVsbSwgc3RhdGUpID0+IHtcbiAgICAgIGVsbS5kb20uY29udGVudEVkaXRhYmxlID0gc3RhdGUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH07XG4gICAgY29uc3Qgc3dpdGNoT2ZmQ29udGVudEVkaXRhYmxlVHJ1ZSA9IGVsbSA9PiB7XG4gICAgICBlYWNoJGUoZGVzY2VuZGFudHMoZWxtLCAnKltjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJyksIGVsbSA9PiB7XG4gICAgICAgIHNldCQzKGVsbSwgaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyLCAndHJ1ZScpO1xuICAgICAgICBzZXRDb250ZW50RWRpdGFibGUoZWxtLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHN3aXRjaE9uQ29udGVudEVkaXRhYmxlVHJ1ZSA9IGVsbSA9PiB7XG4gICAgICBlYWNoJGUoZGVzY2VuZGFudHMoZWxtLCBgKlskeyBpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIgfT1cInRydWVcIl1gKSwgZWxtID0+IHtcbiAgICAgICAgcmVtb3ZlJGEoZWxtLCBpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIpO1xuICAgICAgICBzZXRDb250ZW50RWRpdGFibGUoZWxtLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRmFrZVNlbGVjdGlvbiA9IGVkaXRvciA9PiB7XG4gICAgICBPcHRpb25hbC5mcm9tKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpKS5lYWNoKGVsbSA9PiB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWNlLXNlbGVjdGVkJyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3RvcmVGYWtlU2VsZWN0aW9uID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKGVkaXRvci5zZWxlY3Rpb24uZ2V0Um5nKCkpO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlUmVhZE9ubHkgPSAoZWRpdG9yLCBzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVkaXRvci5nZXRCb2R5KCkpO1xuICAgICAgdG9nZ2xlQ2xhc3MoYm9keSwgJ21jZS1jb250ZW50LXJlYWRvbmx5Jywgc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY29udHJvbFNlbGVjdGlvbi5oaWRlUmVzaXplUmVjdCgpO1xuICAgICAgICBlZGl0b3IuX3NlbGVjdGlvbk92ZXJyaWRlcy5oaWRlRmFrZUNhcmV0KCk7XG4gICAgICAgIHJlbW92ZUZha2VTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgc2V0Q29udGVudEVkaXRhYmxlKGJvZHksIGZhbHNlKTtcbiAgICAgICAgc3dpdGNoT2ZmQ29udGVudEVkaXRhYmxlVHJ1ZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICBpZiAoZWRpdG9yLmhhc0VkaXRhYmxlUm9vdCgpKSB7XG4gICAgICAgICAgc2V0Q29udGVudEVkaXRhYmxlKGJvZHksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaE9uQ29udGVudEVkaXRhYmxlVHJ1ZShib2R5KTtcbiAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKGVkaXRvciwgJ1N0eWxlV2l0aENTUycsIGZhbHNlKTtcbiAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKGVkaXRvciwgJ2VuYWJsZUlubGluZVRhYmxlRWRpdGluZycsIGZhbHNlKTtcbiAgICAgICAgc2V0RWRpdG9yQ29tbWFuZFN0YXRlKGVkaXRvciwgJ2VuYWJsZU9iamVjdFJlc2l6aW5nJywgZmFsc2UpO1xuICAgICAgICBpZiAoaGFzRWRpdG9yT3JVaUZvY3VzKGVkaXRvcikpIHtcbiAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0b3JlRmFrZVNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgICBlZGl0b3Iubm9kZUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGlzUmVhZE9ubHkgPSBlZGl0b3IgPT4gZWRpdG9yLnJlYWRvbmx5O1xuICAgIGNvbnN0IHJlZ2lzdGVyRmlsdGVycyA9IGVkaXRvciA9PiB7XG4gICAgICBlZGl0b3IucGFyc2VyLmFkZEF0dHJpYnV0ZUZpbHRlcignY29udGVudGVkaXRhYmxlJywgbm9kZXMgPT4ge1xuICAgICAgICBpZiAoaXNSZWFkT25seShlZGl0b3IpKSB7XG4gICAgICAgICAgZWFjaCRlKG5vZGVzLCBub2RlID0+IHtcbiAgICAgICAgICAgIG5vZGUuYXR0cihpbnRlcm5hbENvbnRlbnRFZGl0YWJsZUF0dHIsIG5vZGUuYXR0cignY29udGVudGVkaXRhYmxlJykpO1xuICAgICAgICAgICAgbm9kZS5hdHRyKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlZGl0b3Iuc2VyaWFsaXplci5hZGRBdHRyaWJ1dGVGaWx0ZXIoaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyLCBub2RlcyA9PiB7XG4gICAgICAgIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgICBlYWNoJGUobm9kZXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS5hdHRyKCdjb250ZW50ZWRpdGFibGUnLCBub2RlLmF0dHIoaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLnNlcmlhbGl6ZXIuYWRkVGVtcEF0dHIoaW50ZXJuYWxDb250ZW50RWRpdGFibGVBdHRyKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUmVhZE9ubHlDb250ZW50RmlsdGVycyA9IGVkaXRvciA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlcmlhbGl6ZXIpIHtcbiAgICAgICAgcmVnaXN0ZXJGaWx0ZXJzKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iub24oJ1ByZUluaXQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJGaWx0ZXJzKGVkaXRvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZSA9PiBlLnR5cGUgPT09ICdjbGljayc7XG4gICAgY29uc3QgYWxsb3dlZEV2ZW50cyA9IFsnY29weSddO1xuICAgIGNvbnN0IGlzUmVhZE9ubHlBbGxvd2VkRXZlbnQgPSBlID0+IGNvbnRhaW5zJDIoYWxsb3dlZEV2ZW50cywgZS50eXBlKTtcbiAgICBjb25zdCBnZXRBbmNob3JIcmVmT3B0ID0gKGVkaXRvciwgZWxtKSA9PiB7XG4gICAgICBjb25zdCBpc1Jvb3QgPSBlbG0gPT4gZXEoZWxtLCBTdWdhckVsZW1lbnQuZnJvbURvbShlZGl0b3IuZ2V0Qm9keSgpKSk7XG4gICAgICByZXR1cm4gY2xvc2VzdCQzKGVsbSwgJ2EnLCBpc1Jvb3QpLmJpbmQoYSA9PiBnZXRPcHQoYSwgJ2hyZWYnKSk7XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzUmVhZG9ubHlFdmVudHMgPSAoZWRpdG9yLCBlKSA9PiB7XG4gICAgICBpZiAoaXNDbGlja0V2ZW50KGUpICYmICFWSy5tZXRhS2V5UHJlc3NlZChlKSkge1xuICAgICAgICBjb25zdCBlbG0gPSBTdWdhckVsZW1lbnQuZnJvbURvbShlLnRhcmdldCk7XG4gICAgICAgIGdldEFuY2hvckhyZWZPcHQoZWRpdG9yLCBlbG0pLmVhY2goaHJlZiA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICgvXiMvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsID0gZWRpdG9yLmRvbS5zZWxlY3QoYCR7IGhyZWYgfSxbbmFtZT1cIiR7IHJlbW92ZUxlYWRpbmcoaHJlZiwgJyMnKSB9XCJdYCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGFyZ2V0RWxbMF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cub3BlbihocmVmLCAnX2JsYW5rJywgJ3JlbD1ub29wZW5lciBub3JlZmVycmVyLG1lbnViYXI9eWVzLHRvb2xiYXI9eWVzLGxvY2F0aW9uPXllcyxzdGF0dXM9eWVzLHJlc2l6YWJsZT15ZXMsc2Nyb2xsYmFycz15ZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRPbmx5QWxsb3dlZEV2ZW50KGUpKSB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlLnR5cGUsIGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJSZWFkT25seVNlbGVjdGlvbkJsb2NrZXJzID0gZWRpdG9yID0+IHtcbiAgICAgIGVkaXRvci5vbignU2hvd0NhcmV0JywgZSA9PiB7XG4gICAgICAgIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9uKCdPYmplY3RTZWxlY3RlZCcsIGUgPT4ge1xuICAgICAgICBpZiAoaXNSZWFkT25seShlZGl0b3IpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmF0aXZlRXZlbnRzID0gVG9vbHMubWFrZU1hcCgnZm9jdXMgYmx1ciBmb2N1c2luIGZvY3Vzb3V0IGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgYmVmb3JlcGFzdGUgcGFzdGUgY3V0IGNvcHkgc2VsZWN0aW9uY2hhbmdlICcgKyAnbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIHdoZWVsIGtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXQgYmVmb3JlaW5wdXQgY29udGV4dG1lbnUgZHJhZ3N0YXJ0IGRyYWdlbmQgZHJhZ292ZXIgJyArICdkcmFnZ2VzdHVyZSBkcmFnZHJvcCBkcm9wIGRyYWcgc3VibWl0ICcgKyAnY29tcG9zaXRpb25zdGFydCBjb21wb3NpdGlvbmVuZCBjb21wb3NpdGlvbnVwZGF0ZSB0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsICcgJyk7XG4gICAgY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcbiAgICAgIHN0YXRpYyBpc05hdGl2ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIW5hdGl2ZUV2ZW50c1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfVxuICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIHRoaXMuc2NvcGUgPSB0aGlzLnNldHRpbmdzLnNjb3BlIHx8IHRoaXM7XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnQgPSB0aGlzLnNldHRpbmdzLnRvZ2dsZUV2ZW50IHx8IG5ldmVyO1xuICAgICAgfVxuICAgICAgZmlyZShuYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKG5hbWUsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2gobmFtZSwgYXJncykge1xuICAgICAgICBjb25zdCBsY05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbm9ybWFsaXplJDMobGNOYW1lLCBhcmdzICE9PSBudWxsICYmIGFyZ3MgIT09IHZvaWQgMCA/IGFyZ3MgOiB7fSwgdGhpcy5zY29wZSk7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmJlZm9yZUZpcmUpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmJlZm9yZUZpcmUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5iaW5kaW5nc1tsY05hbWVdO1xuICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLm9uY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5vZmYobGNOYW1lLCBjYWxsYmFjay5mdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5mdW5jLmNhbGwodGhpcy5zY29wZSwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICAgIG9uKG5hbWUsIGNhbGxiYWNrLCBwcmVwZW5kLCBleHRyYSkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSB7XG4gICAgICAgICAgICBmdW5jOiBjYWxsYmFjayxcbiAgICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgIFRvb2xzLmV4dGVuZCh3cmFwcGVkQ2FsbGJhY2ssIGV4dHJhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmFtZXMgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICBsZXQgaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgIHRoaXMudG9nZ2xlRXZlbnQoY3VycmVudE5hbWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIC4uLmhhbmRsZXJzXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgICAgICAuLi5oYW5kbGVycyxcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbY3VycmVudE5hbWVdID0gaGFuZGxlcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgb2ZmKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgY29uc3QgbmFtZXMgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICBsZXQgaSA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXJzID0gdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnROYW1lKSB7XG4gICAgICAgICAgICAgIGVhY2gkZCh0aGlzLmJpbmRpbmdzLCAoX3ZhbHVlLCBiaW5kaW5nTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlRXZlbnQoYmluZGluZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tiaW5kaW5nTmFtZV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEhhbmRsZXJzID0gcGFydGl0aW9uJDIoaGFuZGxlcnMsIGhhbmRsZXIgPT4gaGFuZGxlci5mdW5jID09PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBmaWx0ZXJlZEhhbmRsZXJzLmZhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV0gPSBoYW5kbGVycztcbiAgICAgICAgICAgICAgICBlYWNoJGUoZmlsdGVyZWRIYW5kbGVycy5wYXNzLCBoYW5kbGVyID0+IHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXIucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUV2ZW50KG5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tjdXJyZW50TmFtZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWFjaCRkKHRoaXMuYmluZGluZ3MsIChfdmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRXZlbnQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIG9uY2UobmFtZSwgY2FsbGJhY2ssIHByZXBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgY2FsbGJhY2ssIHByZXBlbmQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgICAgICByZXR1cm4gISghYmluZGluZyB8fCBiaW5kaW5nLmxlbmd0aCA9PT0gMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0RXZlbnREaXNwYXRjaGVyID0gb2JqID0+IHtcbiAgICAgIGlmICghb2JqLl9ldmVudERpc3BhdGNoZXIpIHtcbiAgICAgICAgb2JqLl9ldmVudERpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICAgICAgICBzY29wZTogb2JqLFxuICAgICAgICAgIHRvZ2dsZUV2ZW50OiAobmFtZSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChFdmVudERpc3BhdGNoZXIuaXNOYXRpdmUobmFtZSkgJiYgb2JqLnRvZ2dsZU5hdGl2ZUV2ZW50KSB7XG4gICAgICAgICAgICAgIG9iai50b2dnbGVOYXRpdmVFdmVudChuYW1lLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmouX2V2ZW50RGlzcGF0Y2hlcjtcbiAgICB9O1xuICAgIGNvbnN0IE9ic2VydmFibGUgPSB7XG4gICAgICBmaXJlKG5hbWUsIGFyZ3MsIGJ1YmJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChuYW1lLCBhcmdzLCBidWJibGUpO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoKG5hbWUsIGFyZ3MsIGJ1YmJsZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYucmVtb3ZlZCAmJiBuYW1lICE9PSAncmVtb3ZlJyAmJiBuYW1lICE9PSAnZGV0YWNoJykge1xuICAgICAgICAgIHJldHVybiBub3JtYWxpemUkMyhuYW1lLnRvTG93ZXJDYXNlKCksIGFyZ3MgIT09IG51bGwgJiYgYXJncyAhPT0gdm9pZCAwID8gYXJncyA6IHt9LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaGVyQXJncyA9IGdldEV2ZW50RGlzcGF0Y2hlcihzZWxmKS5kaXNwYXRjaChuYW1lLCBhcmdzKTtcbiAgICAgICAgaWYgKGJ1YmJsZSAhPT0gZmFsc2UgJiYgc2VsZi5wYXJlbnQpIHtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gc2VsZi5wYXJlbnQoKTtcbiAgICAgICAgICB3aGlsZSAocGFyZW50ICYmICFkaXNwYXRjaGVyQXJncy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICBwYXJlbnQuZGlzcGF0Y2gobmFtZSwgZGlzcGF0Y2hlckFyZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgPyBwYXJlbnQucGFyZW50KCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyQXJncztcbiAgICAgIH0sXG4gICAgICBvbihuYW1lLCBjYWxsYmFjaywgcHJlcGVuZCkge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnREaXNwYXRjaGVyKHRoaXMpLm9uKG5hbWUsIGNhbGxiYWNrLCBwcmVwZW5kKTtcbiAgICAgIH0sXG4gICAgICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50RGlzcGF0Y2hlcih0aGlzKS5vZmYobmFtZSwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIG9uY2UobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50RGlzcGF0Y2hlcih0aGlzKS5vbmNlKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBoYXNFdmVudExpc3RlbmVycyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBnZXRFdmVudERpc3BhdGNoZXIodGhpcykuaGFzKG5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBET00kMiA9IERPTVV0aWxzLkRPTTtcbiAgICBsZXQgY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzO1xuICAgIGNvbnN0IGdldEV2ZW50VGFyZ2V0ID0gKGVkaXRvciwgZXZlbnROYW1lKSA9PiB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJykge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmdldERvYygpO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3IuaW5saW5lICYmIC9eKD86bW91c2V8dG91Y2h8Y2xpY2t8Y29udGV4dG1lbnV8ZHJvcHxkcmFnb3ZlcnxkcmFnZW5kKS8udGVzdChldmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZ2V0RG9jKCkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnRSb290ID0gZ2V0RXZlbnRSb290KGVkaXRvcik7XG4gICAgICBpZiAoZXZlbnRSb290KSB7XG4gICAgICAgIGlmICghZWRpdG9yLmV2ZW50Um9vdCkge1xuICAgICAgICAgIGVkaXRvci5ldmVudFJvb3QgPSBET00kMi5zZWxlY3QoZXZlbnRSb290KVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWRpdG9yLmV2ZW50Um9vdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0b3IuZ2V0Qm9keSgpO1xuICAgIH07XG4gICAgY29uc3QgaXNMaXN0ZW5pbmcgPSBlZGl0b3IgPT4gIWVkaXRvci5oaWRkZW4gJiYgIWlzUmVhZE9ubHkoZWRpdG9yKTtcbiAgICBjb25zdCBmaXJlRXZlbnQgPSAoZWRpdG9yLCBldmVudE5hbWUsIGUpID0+IHtcbiAgICAgIGlmIChpc0xpc3RlbmluZyhlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChldmVudE5hbWUsIGUpO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRPbmx5KGVkaXRvcikpIHtcbiAgICAgICAgcHJvY2Vzc1JlYWRvbmx5RXZlbnRzKGVkaXRvciwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBiaW5kRXZlbnREZWxlZ2F0ZSA9IChlZGl0b3IsIGV2ZW50TmFtZSkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3IuZGVsZWdhdGVzKSB7XG4gICAgICAgIGVkaXRvci5kZWxlZ2F0ZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuZGVsZWdhdGVzW2V2ZW50TmFtZV0gfHwgZWRpdG9yLnJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnRSb290RWxtID0gZ2V0RXZlbnRUYXJnZXQoZWRpdG9yLCBldmVudE5hbWUpO1xuICAgICAgaWYgKGdldEV2ZW50Um9vdChlZGl0b3IpKSB7XG4gICAgICAgIGlmICghY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzKSB7XG4gICAgICAgICAgY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzID0ge307XG4gICAgICAgICAgZWRpdG9yLmVkaXRvck1hbmFnZXIub24oJ3JlbW92ZUVkaXRvcicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmVkaXRvck1hbmFnZXIuYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgICAgIGlmIChjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMpIHtcbiAgICAgICAgICAgICAgICBlYWNoJGQoY3VzdG9tRXZlbnRSb290RGVsZWdhdGVzLCAoX3ZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICBlZGl0b3IuZG9tLnVuYmluZChnZXRFdmVudFRhcmdldChlZGl0b3IsIG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXN0b21FdmVudFJvb3REZWxlZ2F0ZXMgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgY29uc3QgZWRpdG9ycyA9IGVkaXRvci5lZGl0b3JNYW5hZ2VyLmdldCgpO1xuICAgICAgICAgIGxldCBpID0gZWRpdG9ycy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVkaXRvcnNbaV0uZ2V0Qm9keSgpO1xuICAgICAgICAgICAgaWYgKGJvZHkgPT09IHRhcmdldCB8fCBET00kMi5pc0NoaWxkT2YodGFyZ2V0LCBib2R5KSkge1xuICAgICAgICAgICAgICBmaXJlRXZlbnQoZWRpdG9yc1tpXSwgZXZlbnROYW1lLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGN1c3RvbUV2ZW50Um9vdERlbGVnYXRlc1tldmVudE5hbWVdID0gZGVsZWdhdGU7XG4gICAgICAgIERPTSQyLmJpbmQoZXZlbnRSb290RWxtLCBldmVudE5hbWUsIGRlbGVnYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gZSA9PiB7XG4gICAgICAgICAgZmlyZUV2ZW50KGVkaXRvciwgZXZlbnROYW1lLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRE9NJDIuYmluZChldmVudFJvb3RFbG0sIGV2ZW50TmFtZSwgZGVsZWdhdGUpO1xuICAgICAgICBlZGl0b3IuZGVsZWdhdGVzW2V2ZW50TmFtZV0gPSBkZWxlZ2F0ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IEVkaXRvck9ic2VydmFibGUgPSB7XG4gICAgICAuLi5PYnNlcnZhYmxlLFxuICAgICAgYmluZFBlbmRpbmdFdmVudERlbGVnYXRlcygpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIFRvb2xzLmVhY2goc2VsZi5fcGVuZGluZ05hdGl2ZUV2ZW50cywgbmFtZSA9PiB7XG4gICAgICAgICAgYmluZEV2ZW50RGVsZWdhdGUoc2VsZiwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZU5hdGl2ZUV2ZW50KG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZvY3VzJyB8fCBuYW1lID09PSAnYmx1cicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgYmluZEV2ZW50RGVsZWdhdGUoc2VsZiwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5fcGVuZGluZ05hdGl2ZUV2ZW50cykge1xuICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nTmF0aXZlRXZlbnRzID0gW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5fcGVuZGluZ05hdGl2ZUV2ZW50cy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmluaXRpYWxpemVkICYmIHNlbGYuZGVsZWdhdGVzKSB7XG4gICAgICAgICAgc2VsZi5kb20udW5iaW5kKGdldEV2ZW50VGFyZ2V0KHNlbGYsIG5hbWUpLCBuYW1lLCBzZWxmLmRlbGVnYXRlc1tuYW1lXSk7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuZGVsZWdhdGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5iaW5kQWxsTmF0aXZlRXZlbnRzKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgYm9keSA9IHNlbGYuZ2V0Qm9keSgpO1xuICAgICAgICBjb25zdCBkb20gPSBzZWxmLmRvbTtcbiAgICAgICAgaWYgKHNlbGYuZGVsZWdhdGVzKSB7XG4gICAgICAgICAgZWFjaCRkKHNlbGYuZGVsZWdhdGVzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIHNlbGYuZG9tLnVuYmluZChnZXRFdmVudFRhcmdldChzZWxmLCBuYW1lKSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmRlbGVnYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGYuaW5saW5lICYmIGJvZHkgJiYgZG9tKSB7XG4gICAgICAgICAgYm9keS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIGRvbS51bmJpbmQoc2VsZi5nZXRXaW4oKSk7XG4gICAgICAgICAgZG9tLnVuYmluZChzZWxmLmdldERvYygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgZG9tLnVuYmluZChib2R5KTtcbiAgICAgICAgICBkb20udW5iaW5kKHNlbGYuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHN0cmluZ0xpc3RQcm9jZXNzb3IgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnNwbGl0KC9bICxdLyksXG4gICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheU9mKHZhbHVlLCBpc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogYFRoZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nW10gb3IgYSBjb21tYS9zcGFjZSBzZXBhcmF0ZWQgc3RyaW5nLmBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldEJ1aWx0SW5Qcm9jZXNzb3IgPSB0eXBlID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkkMTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuIGlzQm9vbGVhbjtcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiBpc051bWJlcjtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3Q7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcmV0dXJuIGlzU3RyaW5nO1xuICAgICAgICBjYXNlICdzdHJpbmdbXSc6XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ0xpc3RQcm9jZXNzb3I7XG4gICAgICAgIGNhc2UgJ29iamVjdFtdJzpcbiAgICAgICAgICByZXR1cm4gdmFsID0+IGlzQXJyYXlPZih2YWwsIGlzT2JqZWN0KTtcbiAgICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgICByZXR1cm4gdmFsID0+IGlzJDQodmFsLCBSZWdFeHApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBhbHdheXM7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPT4gcHJvY2Vzc1ZhbHVlKHZhbHVlLCB2YWxpZGF0b3IsIGBUaGUgdmFsdWUgbXVzdCBiZSBhICR7IHR5cGUgfS5gKTtcbiAgICB9O1xuICAgIGNvbnN0IGlzQnVpbHRJblNwZWMgPSBzcGVjID0+IGlzU3RyaW5nKHNwZWMucHJvY2Vzc29yKTtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAobWVzc2FnZSwgcmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBhZGRpdGlvbmFsVGV4dCA9IGlzRW1wdHkkMyhyZXN1bHQubWVzc2FnZSkgPyAnJyA6IGAuICR7IHJlc3VsdC5tZXNzYWdlIH1gO1xuICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBhZGRpdGlvbmFsVGV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGlzVmFsaWRSZXN1bHQgPSByZXN1bHQgPT4gcmVzdWx0LnZhbGlkO1xuICAgIGNvbnN0IHByb2Nlc3NWYWx1ZSA9ICh2YWx1ZSwgcHJvY2Vzc29yLCBtZXNzYWdlID0gJycpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3Nvcih2YWx1ZSk7XG4gICAgICBpZiAoaXNCb29sZWFuKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NEZWZhdWx0VmFsdWUgPSAobmFtZSwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzb3IpID0+IHtcbiAgICAgIGlmICghaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzVmFsdWUoZGVmYXVsdFZhbHVlLCBwcm9jZXNzb3IpO1xuICAgICAgICBpZiAoaXNWYWxpZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGdldEVycm9yTWVzc2FnZShgSW52YWxpZCBkZWZhdWx0IHZhbHVlIHBhc3NlZCBmb3IgdGhlIFwiJHsgbmFtZSB9XCIgb3B0aW9uYCwgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUkNSA9IChlZGl0b3IsIGluaXRpYWxPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHt9O1xuICAgICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgcHJvY2Vzc29yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NWYWx1ZSh2YWx1ZSwgcHJvY2Vzc29yKTtcbiAgICAgICAgaWYgKGlzVmFsaWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0RXJyb3JNZXNzYWdlKGBJbnZhbGlkIHZhbHVlIHBhc3NlZCBmb3IgdGhlICR7IG5hbWUgfSBvcHRpb25gLCByZXN1bHQpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZWdpc3RlciA9IChuYW1lLCBzcGVjKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGlzQnVpbHRJblNwZWMoc3BlYykgPyBnZXRCdWlsdEluUHJvY2Vzc29yKHNwZWMucHJvY2Vzc29yKSA6IHNwZWMucHJvY2Vzc29yO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBwcm9jZXNzRGVmYXVsdFZhbHVlKG5hbWUsIHNwZWMuZGVmYXVsdCwgcHJvY2Vzc29yKTtcbiAgICAgICAgcmVnaXN0cnlbbmFtZV0gPSB7XG4gICAgICAgICAgLi4uc3BlYyxcbiAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvY2Vzc29yXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluaXRWYWx1ZSA9IGdldCRhKHZhbHVlcywgbmFtZSkub3JUaHVuaygoKSA9PiBnZXQkYShpbml0aWFsT3B0aW9ucywgbmFtZSkpO1xuICAgICAgICBpbml0VmFsdWUuZWFjaCh2YWx1ZSA9PiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgcHJvY2Vzc29yKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgaXNSZWdpc3RlcmVkID0gbmFtZSA9PiBoYXMkMihyZWdpc3RyeSwgbmFtZSk7XG4gICAgICBjb25zdCBnZXQgPSBuYW1lID0+IGdldCRhKHZhbHVlcywgbmFtZSkub3JUaHVuaygoKSA9PiBnZXQkYShyZWdpc3RyeSwgbmFtZSkubWFwKHNwZWMgPT4gc3BlYy5kZWZhdWx0KSkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgIGNvbnN0IHNldCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoIWlzUmVnaXN0ZXJlZChuYW1lKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgXCIkeyBuYW1lIH1cIiBpcyBub3QgYSByZWdpc3RlcmVkIG9wdGlvbi4gRW5zdXJlIHRoZSBvcHRpb24gaGFzIGJlZW4gcmVnaXN0ZXJlZCBiZWZvcmUgc2V0dGluZyBhIHZhbHVlLmApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzcGVjID0gcmVnaXN0cnlbbmFtZV07XG4gICAgICAgICAgaWYgKHNwZWMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBcIiR7IG5hbWUgfVwiIGlzIGFuIGltbXV0YWJsZSBvcHRpb24gYW5kIGNhbm5vdCBiZSB1cGRhdGVkYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgc3BlYy5wcm9jZXNzb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc2V0ID0gbmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWQgPSBpc1JlZ2lzdGVyZWQobmFtZSk7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZDtcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1NldCA9IG5hbWUgPT4gaGFzJDIodmFsdWVzLCBuYW1lKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBpc1JlZ2lzdGVyZWQsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICB1bnNldCxcbiAgICAgICAgaXNTZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZmF1bHRNb2RlcyA9IFtcbiAgICAgICdkZXNpZ24nLFxuICAgICAgJ3JlYWRvbmx5J1xuICAgIF07XG4gICAgY29uc3Qgc3dpdGNoVG9Nb2RlID0gKGVkaXRvciwgYWN0aXZlTW9kZSwgYXZhaWxhYmxlTW9kZXMsIG1vZGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZE1vZGUgPSBhdmFpbGFibGVNb2Rlc1thY3RpdmVNb2RlLmdldCgpXTtcbiAgICAgIGNvbnN0IG5ld01vZGUgPSBhdmFpbGFibGVNb2Rlc1ttb2RlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld01vZGUuYWN0aXZhdGUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgcHJvYmxlbSB3aGlsZSBhY3RpdmF0aW5nIGVkaXRvciBtb2RlICR7IG1vZGUgfTpgLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb2xkTW9kZS5kZWFjdGl2YXRlKCk7XG4gICAgICBpZiAob2xkTW9kZS5lZGl0b3JSZWFkT25seSAhPT0gbmV3TW9kZS5lZGl0b3JSZWFkT25seSkge1xuICAgICAgICB0b2dnbGVSZWFkT25seShlZGl0b3IsIG5ld01vZGUuZWRpdG9yUmVhZE9ubHkpO1xuICAgICAgfVxuICAgICAgYWN0aXZlTW9kZS5zZXQobW9kZSk7XG4gICAgICBmaXJlU3dpdGNoTW9kZShlZGl0b3IsIG1vZGUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TW9kZSA9IChlZGl0b3IsIGF2YWlsYWJsZU1vZGVzLCBhY3RpdmVNb2RlLCBtb2RlKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gYWN0aXZlTW9kZS5nZXQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFoYXMkMihhdmFpbGFibGVNb2RlcywgbW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFZGl0b3IgbW9kZSAnJHsgbW9kZSB9JyBpcyBpbnZhbGlkYCk7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHN3aXRjaFRvTW9kZShlZGl0b3IsIGFjdGl2ZU1vZGUsIGF2YWlsYWJsZU1vZGVzLCBtb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5vbignaW5pdCcsICgpID0+IHN3aXRjaFRvTW9kZShlZGl0b3IsIGFjdGl2ZU1vZGUsIGF2YWlsYWJsZU1vZGVzLCBtb2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3Rlck1vZGUgPSAoYXZhaWxhYmxlTW9kZXMsIG1vZGUsIGFwaSkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5zJDIoZGVmYXVsdE1vZGVzLCBtb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVycmlkZSBkZWZhdWx0IG1vZGUgJHsgbW9kZSB9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hdmFpbGFibGVNb2RlcyxcbiAgICAgICAgW21vZGVdOiB7XG4gICAgICAgICAgLi4uYXBpLFxuICAgICAgICAgIGRlYWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFwaS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHByb2JsZW0gd2hpbGUgZGVhY3RpdmF0aW5nIGVkaXRvciBtb2RlICR7IG1vZGUgfTpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZSQ0ID0gZWRpdG9yID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZU1vZGUgPSBDZWxsKCdkZXNpZ24nKTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZU1vZGVzID0gQ2VsbCh7XG4gICAgICAgIGRlc2lnbjoge1xuICAgICAgICAgIGFjdGl2YXRlOiBub29wLFxuICAgICAgICAgIGRlYWN0aXZhdGU6IG5vb3AsXG4gICAgICAgICAgZWRpdG9yUmVhZE9ubHk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgICAgYWN0aXZhdGU6IG5vb3AsXG4gICAgICAgICAgZGVhY3RpdmF0ZTogbm9vcCxcbiAgICAgICAgICBlZGl0b3JSZWFkT25seTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlZ2lzdGVyUmVhZE9ubHlDb250ZW50RmlsdGVycyhlZGl0b3IpO1xuICAgICAgcmVnaXN0ZXJSZWFkT25seVNlbGVjdGlvbkJsb2NrZXJzKGVkaXRvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1JlYWRPbmx5OiAoKSA9PiBpc1JlYWRPbmx5KGVkaXRvciksXG4gICAgICAgIHNldDogbW9kZSA9PiBzZXRNb2RlKGVkaXRvciwgYXZhaWxhYmxlTW9kZXMuZ2V0KCksIGFjdGl2ZU1vZGUsIG1vZGUpLFxuICAgICAgICBnZXQ6ICgpID0+IGFjdGl2ZU1vZGUuZ2V0KCksXG4gICAgICAgIHJlZ2lzdGVyOiAobW9kZSwgYXBpKSA9PiB7XG4gICAgICAgICAgYXZhaWxhYmxlTW9kZXMuc2V0KHJlZ2lzdGVyTW9kZShhdmFpbGFibGVNb2Rlcy5nZXQoKSwgbW9kZSwgYXBpKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGVhY2gkMiA9IFRvb2xzLmVhY2gsIGV4cGxvZGUgPSBUb29scy5leHBsb2RlO1xuICAgIGNvbnN0IGtleUNvZGVMb29rdXAgPSB7XG4gICAgICBmMTogMTEyLFxuICAgICAgZjI6IDExMyxcbiAgICAgIGYzOiAxMTQsXG4gICAgICBmNDogMTE1LFxuICAgICAgZjU6IDExNixcbiAgICAgIGY2OiAxMTcsXG4gICAgICBmNzogMTE4LFxuICAgICAgZjg6IDExOSxcbiAgICAgIGY5OiAxMjAsXG4gICAgICBmMTA6IDEyMSxcbiAgICAgIGYxMTogMTIyLFxuICAgICAgZjEyOiAxMjNcbiAgICB9O1xuICAgIGNvbnN0IG1vZGlmaWVyTmFtZXMgPSBUb29scy5tYWtlTWFwKCdhbHQsY3RybCxzaGlmdCxtZXRhLGFjY2VzcycpO1xuICAgIGNvbnN0IGlzTW9kaWZpZXIgPSBrZXkgPT4ga2V5IGluIG1vZGlmaWVyTmFtZXM7XG4gICAgY29uc3QgcGFyc2VTaG9ydGN1dCA9IHBhdHRlcm4gPT4ge1xuICAgICAgY29uc3Qgc2hvcnRjdXQgPSB7fTtcbiAgICAgIGNvbnN0IGlzTWFjID0gRW52Lm9zLmlzTWFjT1MoKSB8fCBFbnYub3MuaXNpT1MoKTtcbiAgICAgIGVhY2gkMihleHBsb2RlKHBhdHRlcm4udG9Mb3dlckNhc2UoKSwgJysnKSwgdmFsdWUgPT4ge1xuICAgICAgICBpZiAoaXNNb2RpZmllcih2YWx1ZSkpIHtcbiAgICAgICAgICBzaG9ydGN1dFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgvXlswLTldezIsfSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBzaG9ydGN1dC5rZXlDb2RlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hvcnRjdXQuY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgc2hvcnRjdXQua2V5Q29kZSA9IGtleUNvZGVMb29rdXBbdmFsdWVdIHx8IHZhbHVlLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgaWQgPSBbc2hvcnRjdXQua2V5Q29kZV07XG4gICAgICBsZXQga2V5O1xuICAgICAgZm9yIChrZXkgaW4gbW9kaWZpZXJOYW1lcykge1xuICAgICAgICBpZiAoc2hvcnRjdXRba2V5XSkge1xuICAgICAgICAgIGlkLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG9ydGN1dFtrZXldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNob3J0Y3V0LmlkID0gaWQuam9pbignLCcpO1xuICAgICAgaWYgKHNob3J0Y3V0LmFjY2Vzcykge1xuICAgICAgICBzaG9ydGN1dC5hbHQgPSB0cnVlO1xuICAgICAgICBpZiAoaXNNYWMpIHtcbiAgICAgICAgICBzaG9ydGN1dC5jdHJsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG9ydGN1dC5zaGlmdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaG9ydGN1dC5tZXRhKSB7XG4gICAgICAgIGlmIChpc01hYykge1xuICAgICAgICAgIHNob3J0Y3V0Lm1ldGEgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3J0Y3V0LmN0cmwgPSB0cnVlO1xuICAgICAgICAgIHNob3J0Y3V0Lm1ldGEgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3J0Y3V0O1xuICAgIH07XG4gICAgY2xhc3MgU2hvcnRjdXRzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLnNob3J0Y3V0cyA9IHt9O1xuICAgICAgICB0aGlzLnBlbmRpbmdQYXR0ZXJucyA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGVkaXRvci5vbigna2V5dXAga2V5cHJlc3Mga2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmICgoc2VsZi5oYXNNb2RpZmllcihlKSB8fCBzZWxmLmlzRnVuY3Rpb25LZXkoZSkpICYmICFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICBlYWNoJDIoc2VsZi5zaG9ydGN1dHMsIHNob3J0Y3V0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYubWF0Y2hTaG9ydGN1dChlLCBzaG9ydGN1dCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBlbmRpbmdQYXR0ZXJucyA9IHNob3J0Y3V0LnN1YnBhdHRlcm5zLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlU2hvcnRjdXRBY3Rpb24oc2hvcnRjdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tYXRjaFNob3J0Y3V0KGUsIHNlbGYucGVuZGluZ1BhdHRlcm5zWzBdKSkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5wZW5kaW5nUGF0dGVybnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVTaG9ydGN1dEFjdGlvbihzZWxmLnBlbmRpbmdQYXR0ZXJuc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYucGVuZGluZ1BhdHRlcm5zLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGFkZChwYXR0ZXJuLCBkZXNjLCBjbWRGdW5jLCBzY29wZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZnVuYyA9IHNlbGYubm9ybWFsaXplQ29tbWFuZEZ1bmMoY21kRnVuYyk7XG4gICAgICAgIGVhY2gkMihleHBsb2RlKFRvb2xzLnRyaW0ocGF0dGVybikpLCBwYXR0ZXJuID0+IHtcbiAgICAgICAgICBjb25zdCBzaG9ydGN1dCA9IHNlbGYuY3JlYXRlU2hvcnRjdXQocGF0dGVybiwgZGVzYywgZnVuYywgc2NvcGUpO1xuICAgICAgICAgIHNlbGYuc2hvcnRjdXRzW3Nob3J0Y3V0LmlkXSA9IHNob3J0Y3V0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZW1vdmUocGF0dGVybikge1xuICAgICAgICBjb25zdCBzaG9ydGN1dCA9IHRoaXMuY3JlYXRlU2hvcnRjdXQocGF0dGVybik7XG4gICAgICAgIGlmICh0aGlzLnNob3J0Y3V0c1tzaG9ydGN1dC5pZF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zaG9ydGN1dHNbc2hvcnRjdXQuaWRdO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZUNvbW1hbmRGdW5jKGNtZEZ1bmMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNtZCA9IGNtZEZ1bmM7XG4gICAgICAgIGlmICh0eXBlb2YgY21kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5leGVjQ29tbWFuZChjbWQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKFRvb2xzLmlzQXJyYXkoY21kKSkge1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVkaXRvci5leGVjQ29tbWFuZChjbWRbMF0sIGNtZFsxXSwgY21kWzJdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNyZWF0ZVNob3J0Y3V0KHBhdHRlcm4sIGRlc2MsIGNtZEZ1bmMsIHNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0cyA9IFRvb2xzLm1hcChleHBsb2RlKHBhdHRlcm4sICc+JyksIHBhcnNlU2hvcnRjdXQpO1xuICAgICAgICBzaG9ydGN1dHNbc2hvcnRjdXRzLmxlbmd0aCAtIDFdID0gVG9vbHMuZXh0ZW5kKHNob3J0Y3V0c1tzaG9ydGN1dHMubGVuZ3RoIC0gMV0sIHtcbiAgICAgICAgICBmdW5jOiBjbWRGdW5jLFxuICAgICAgICAgIHNjb3BlOiBzY29wZSB8fCB0aGlzLmVkaXRvclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmV4dGVuZChzaG9ydGN1dHNbMF0sIHtcbiAgICAgICAgICBkZXNjOiB0aGlzLmVkaXRvci50cmFuc2xhdGUoZGVzYyksXG4gICAgICAgICAgc3VicGF0dGVybnM6IHNob3J0Y3V0cy5zbGljZSgxKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGhhc01vZGlmaWVyKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG4gICAgICB9XG4gICAgICBpc0Z1bmN0aW9uS2V5KGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nICYmIGUua2V5Q29kZSA+PSAxMTIgJiYgZS5rZXlDb2RlIDw9IDEyMztcbiAgICAgIH1cbiAgICAgIG1hdGNoU2hvcnRjdXQoZSwgc2hvcnRjdXQpIHtcbiAgICAgICAgaWYgKCFzaG9ydGN1dCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRjdXQuY3RybCAhPT0gZS5jdHJsS2V5IHx8IHNob3J0Y3V0Lm1ldGEgIT09IGUubWV0YUtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvcnRjdXQuYWx0ICE9PSBlLmFsdEtleSB8fCBzaG9ydGN1dC5zaGlmdCAhPT0gZS5zaGlmdEtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBzaG9ydGN1dC5rZXlDb2RlIHx8IGUuY2hhckNvZGUgJiYgZS5jaGFyQ29kZSA9PT0gc2hvcnRjdXQuY2hhckNvZGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhlY3V0ZVNob3J0Y3V0QWN0aW9uKHNob3J0Y3V0KSB7XG4gICAgICAgIHJldHVybiBzaG9ydGN1dC5mdW5jID8gc2hvcnRjdXQuZnVuYy5jYWxsKHNob3J0Y3V0LnNjb3BlKSA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY3JlYXRlJDMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBidXR0b25zID0ge307XG4gICAgICBjb25zdCBtZW51SXRlbXMgPSB7fTtcbiAgICAgIGNvbnN0IHBvcHVwcyA9IHt9O1xuICAgICAgY29uc3QgaWNvbnMgPSB7fTtcbiAgICAgIGNvbnN0IGNvbnRleHRNZW51cyA9IHt9O1xuICAgICAgY29uc3QgY29udGV4dFRvb2xiYXJzID0ge307XG4gICAgICBjb25zdCBzaWRlYmFycyA9IHt9O1xuICAgICAgY29uc3Qgdmlld3MgPSB7fTtcbiAgICAgIGNvbnN0IGFkZCA9IChjb2xsZWN0aW9uLCB0eXBlKSA9PiAobmFtZSwgc3BlYykgPT4ge1xuICAgICAgICBjb2xsZWN0aW9uW25hbWUudG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgICAgLi4uc3BlYyxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkSWNvbiA9IChuYW1lLCBzdmdEYXRhKSA9PiBpY29uc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gc3ZnRGF0YTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZEJ1dHRvbjogYWRkKGJ1dHRvbnMsICdidXR0b24nKSxcbiAgICAgICAgYWRkR3JvdXBUb29sYmFyQnV0dG9uOiBhZGQoYnV0dG9ucywgJ2dyb3VwdG9vbGJhcmJ1dHRvbicpLFxuICAgICAgICBhZGRUb2dnbGVCdXR0b246IGFkZChidXR0b25zLCAndG9nZ2xlYnV0dG9uJyksXG4gICAgICAgIGFkZE1lbnVCdXR0b246IGFkZChidXR0b25zLCAnbWVudWJ1dHRvbicpLFxuICAgICAgICBhZGRTcGxpdEJ1dHRvbjogYWRkKGJ1dHRvbnMsICdzcGxpdGJ1dHRvbicpLFxuICAgICAgICBhZGRNZW51SXRlbTogYWRkKG1lbnVJdGVtcywgJ21lbnVpdGVtJyksXG4gICAgICAgIGFkZE5lc3RlZE1lbnVJdGVtOiBhZGQobWVudUl0ZW1zLCAnbmVzdGVkbWVudWl0ZW0nKSxcbiAgICAgICAgYWRkVG9nZ2xlTWVudUl0ZW06IGFkZChtZW51SXRlbXMsICd0b2dnbGVtZW51aXRlbScpLFxuICAgICAgICBhZGRBdXRvY29tcGxldGVyOiBhZGQocG9wdXBzLCAnYXV0b2NvbXBsZXRlcicpLFxuICAgICAgICBhZGRDb250ZXh0TWVudTogYWRkKGNvbnRleHRNZW51cywgJ2NvbnRleHRtZW51JyksXG4gICAgICAgIGFkZENvbnRleHRUb29sYmFyOiBhZGQoY29udGV4dFRvb2xiYXJzLCAnY29udGV4dHRvb2xiYXInKSxcbiAgICAgICAgYWRkQ29udGV4dEZvcm06IGFkZChjb250ZXh0VG9vbGJhcnMsICdjb250ZXh0Zm9ybScpLFxuICAgICAgICBhZGRTaWRlYmFyOiBhZGQoc2lkZWJhcnMsICdzaWRlYmFyJyksXG4gICAgICAgIGFkZFZpZXc6IGFkZCh2aWV3cywgJ3ZpZXdzJyksXG4gICAgICAgIGFkZEljb24sXG4gICAgICAgIGdldEFsbDogKCkgPT4gKHtcbiAgICAgICAgICBidXR0b25zLFxuICAgICAgICAgIG1lbnVJdGVtcyxcbiAgICAgICAgICBpY29ucyxcbiAgICAgICAgICBwb3B1cHMsXG4gICAgICAgICAgY29udGV4dE1lbnVzLFxuICAgICAgICAgIGNvbnRleHRUb29sYmFycyxcbiAgICAgICAgICBzaWRlYmFycyxcbiAgICAgICAgICB2aWV3c1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaXN0cnkgPSAoKSA9PiB7XG4gICAgICBjb25zdCBicmlkZ2UgPSBjcmVhdGUkMygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQXV0b2NvbXBsZXRlcjogYnJpZGdlLmFkZEF1dG9jb21wbGV0ZXIsXG4gICAgICAgIGFkZEJ1dHRvbjogYnJpZGdlLmFkZEJ1dHRvbixcbiAgICAgICAgYWRkQ29udGV4dEZvcm06IGJyaWRnZS5hZGRDb250ZXh0Rm9ybSxcbiAgICAgICAgYWRkQ29udGV4dE1lbnU6IGJyaWRnZS5hZGRDb250ZXh0TWVudSxcbiAgICAgICAgYWRkQ29udGV4dFRvb2xiYXI6IGJyaWRnZS5hZGRDb250ZXh0VG9vbGJhcixcbiAgICAgICAgYWRkSWNvbjogYnJpZGdlLmFkZEljb24sXG4gICAgICAgIGFkZE1lbnVCdXR0b246IGJyaWRnZS5hZGRNZW51QnV0dG9uLFxuICAgICAgICBhZGRNZW51SXRlbTogYnJpZGdlLmFkZE1lbnVJdGVtLFxuICAgICAgICBhZGROZXN0ZWRNZW51SXRlbTogYnJpZGdlLmFkZE5lc3RlZE1lbnVJdGVtLFxuICAgICAgICBhZGRTaWRlYmFyOiBicmlkZ2UuYWRkU2lkZWJhcixcbiAgICAgICAgYWRkU3BsaXRCdXR0b246IGJyaWRnZS5hZGRTcGxpdEJ1dHRvbixcbiAgICAgICAgYWRkVG9nZ2xlQnV0dG9uOiBicmlkZ2UuYWRkVG9nZ2xlQnV0dG9uLFxuICAgICAgICBhZGRHcm91cFRvb2xiYXJCdXR0b246IGJyaWRnZS5hZGRHcm91cFRvb2xiYXJCdXR0b24sXG4gICAgICAgIGFkZFRvZ2dsZU1lbnVJdGVtOiBicmlkZ2UuYWRkVG9nZ2xlTWVudUl0ZW0sXG4gICAgICAgIGFkZFZpZXc6IGJyaWRnZS5hZGRWaWV3LFxuICAgICAgICBnZXRBbGw6IGJyaWRnZS5nZXRBbGxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IERPTSQxID0gRE9NVXRpbHMuRE9NO1xuICAgIGNvbnN0IGV4dGVuZCA9IFRvb2xzLmV4dGVuZCwgZWFjaCQxID0gVG9vbHMuZWFjaDtcbiAgICBjbGFzcyBFZGl0b3Ige1xuICAgICAgY29uc3RydWN0b3IoaWQsIG9wdGlvbnMsIGVkaXRvck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMuY29udGVudENTUyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRTdHlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sb2FkZWRDU1MgPSB7fTtcbiAgICAgICAgdGhpcy5pc05vdERpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzSGlkZGVuSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZnJhbWVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0Q29udGVudCA9ICcnO1xuICAgICAgICB0aGlzLl9wZW5kaW5nTmF0aXZlRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX3NraW5Mb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZWRpdGFibGVSb290ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZGl0b3JNYW5hZ2VyID0gZWRpdG9yTWFuYWdlcjtcbiAgICAgICAgdGhpcy5kb2N1bWVudEJhc2VVcmwgPSBlZGl0b3JNYW5hZ2VyLmRvY3VtZW50QmFzZVVSTDtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIEVkaXRvck9ic2VydmFibGUpO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoZWRpdG9yTWFuYWdlci5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGNyZWF0ZSQ1KHNlbGYsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgcmVnaXN0ZXIkNyhzZWxmKTtcbiAgICAgICAgY29uc3QgZ2V0T3B0aW9uID0gdGhpcy5vcHRpb25zLmdldDtcbiAgICAgICAgaWYgKGdldE9wdGlvbignZGVwcmVjYXRpb25fd2FybmluZ3MnKSkge1xuICAgICAgICAgIGxvZ1dhcm5pbmdzKG9wdGlvbnMsIG5vcm1hbGl6ZWRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWZmaXggPSBnZXRPcHRpb24oJ3N1ZmZpeCcpO1xuICAgICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgICAgZWRpdG9yTWFuYWdlci5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWZmaXggPSBlZGl0b3JNYW5hZ2VyLnN1ZmZpeDtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldE9wdGlvbignYmFzZV91cmwnKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICBlZGl0b3JNYW5hZ2VyLl9zZXRCYXNlVXJsKGJhc2VVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZVVyaSA9IGVkaXRvck1hbmFnZXIuYmFzZVVSSTtcbiAgICAgICAgY29uc3QgcmVmZXJyZXJQb2xpY3kgPSBnZXRSZWZlcnJlclBvbGljeShzZWxmKTtcbiAgICAgICAgaWYgKHJlZmVycmVyUG9saWN5KSB7XG4gICAgICAgICAgU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlci5fc2V0UmVmZXJyZXJQb2xpY3kocmVmZXJyZXJQb2xpY3kpO1xuICAgICAgICAgIERPTVV0aWxzLkRPTS5zdHlsZVNoZWV0TG9hZGVyLl9zZXRSZWZlcnJlclBvbGljeShyZWZlcnJlclBvbGljeSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudENzc0NvcnMgPSBoYXNDb250ZW50Q3NzQ29ycyhzZWxmKTtcbiAgICAgICAgaWYgKGlzTm9uTnVsbGFibGUoY29udGVudENzc0NvcnMpKSB7XG4gICAgICAgICAgRE9NVXRpbHMuRE9NLnN0eWxlU2hlZXRMb2FkZXIuX3NldENvbnRlbnRDc3NDb3JzKGNvbnRlbnRDc3NDb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBBZGRPbk1hbmFnZXIubGFuZ3VhZ2VMb2FkID0gZ2V0T3B0aW9uKCdsYW5ndWFnZV9sb2FkJyk7XG4gICAgICAgIEFkZE9uTWFuYWdlci5iYXNlVVJMID0gZWRpdG9yTWFuYWdlci5iYXNlVVJMO1xuICAgICAgICB0aGlzLnNldERpcnR5KGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEJhc2VVUkkgPSBuZXcgVVJJKGdldERvY3VtZW50QmFzZVVybChzZWxmKSwgeyBiYXNlX3VyaTogdGhpcy5iYXNlVXJpIH0pO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSB0aGlzLmJhc2VVcmk7XG4gICAgICAgIHRoaXMuaW5saW5lID0gaXNJbmxpbmUoc2VsZik7XG4gICAgICAgIHRoaXMuaGFzVmlzdWFsID0gaXNWaXN1YWxBaWRzRW5hYmxlZChzZWxmKTtcbiAgICAgICAgdGhpcy5zaG9ydGN1dHMgPSBuZXcgU2hvcnRjdXRzKHRoaXMpO1xuICAgICAgICB0aGlzLmVkaXRvckNvbW1hbmRzID0gbmV3IEVkaXRvckNvbW1hbmRzKHRoaXMpO1xuICAgICAgICByZWdpc3RlckNvbW1hbmRzKHRoaXMpO1xuICAgICAgICBjb25zdCBjYWNoZVN1ZmZpeCA9IGdldE9wdGlvbignY2FjaGVfc3VmZml4Jyk7XG4gICAgICAgIGlmIChjYWNoZVN1ZmZpeCkge1xuICAgICAgICAgIEVudi5jYWNoZVN1ZmZpeCA9IGNhY2hlU3VmZml4LnJlcGxhY2UoL15bXFw/XFwmXSsvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aSA9IHtcbiAgICAgICAgICByZWdpc3RyeTogcmVnaXN0cnkoKSxcbiAgICAgICAgICBzdHlsZVNoZWV0TG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgc2hvdzogbm9vcCxcbiAgICAgICAgICBoaWRlOiBub29wLFxuICAgICAgICAgIHNldEVuYWJsZWQ6IG5vb3AsXG4gICAgICAgICAgaXNFbmFibGVkOiBhbHdheXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2RlID0gY3JlYXRlJDQoc2VsZik7XG4gICAgICAgIGVkaXRvck1hbmFnZXIuZGlzcGF0Y2goJ1NldHVwRWRpdG9yJywgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICAgIGNvbnN0IHNldHVwQ2FsbGJhY2sgPSBnZXRTZXR1cENhbGxiYWNrKHNlbGYpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihzZXR1cENhbGxiYWNrKSkge1xuICAgICAgICAgIHNldHVwQ2FsbGJhY2suY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVuZGVyKCkge1xuICAgICAgICByZW5kZXIodGhpcyk7XG4gICAgICB9XG4gICAgICBmb2N1cyhza2lwRm9jdXMpIHtcbiAgICAgICAgdGhpcy5leGVjQ29tbWFuZCgnbWNlRm9jdXMnLCBmYWxzZSwgc2tpcEZvY3VzKTtcbiAgICAgIH1cbiAgICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICByZXR1cm4gaGFzRm9jdXModGhpcyk7XG4gICAgICB9XG4gICAgICB0cmFuc2xhdGUodGV4dCkge1xuICAgICAgICByZXR1cm4gSTE4bi50cmFuc2xhdGUodGV4dCk7XG4gICAgICB9XG4gICAgICBnZXRQYXJhbShuYW1lLCBkZWZhdWx0VmFsLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghb3B0aW9ucy5pc1JlZ2lzdGVyZWQobmFtZSkpIHtcbiAgICAgICAgICBpZiAoaXNOb25OdWxsYWJsZSh0eXBlKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgICAgICAgIHByb2Nlc3NvcjogdHlwZSxcbiAgICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdFZhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVnaXN0ZXIobmFtZSwge1xuICAgICAgICAgICAgICBwcm9jZXNzb3I6IGFsd2F5cyxcbiAgICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdFZhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhb3B0aW9ucy5pc1NldChuYW1lKSAmJiAhaXNVbmRlZmluZWQoZGVmYXVsdFZhbCkgPyBkZWZhdWx0VmFsIDogb3B0aW9ucy5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgICBoYXNQbHVnaW4obmFtZSwgbG9hZGVkKSB7XG4gICAgICAgIGNvbnN0IGhhc1BsdWdpbiA9IGNvbnRhaW5zJDIoZ2V0UGx1Z2lucyh0aGlzKSwgbmFtZSk7XG4gICAgICAgIGlmIChoYXNQbHVnaW4pIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGVkID8gUGx1Z2luTWFuYWdlci5nZXQobmFtZSkgIT09IHVuZGVmaW5lZCA6IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlQ2hhbmdlZChhcmdzKSB7XG4gICAgICAgIHRoaXMuX25vZGVDaGFuZ2VEaXNwYXRjaGVyLm5vZGVDaGFuZ2VkKGFyZ3MpO1xuICAgICAgfVxuICAgICAgYWRkQ29tbWFuZChuYW1lLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JDb21tYW5kcy5hZGRDb21tYW5kKG5hbWUsIGNhbGxiYWNrLCBzY29wZSk7XG4gICAgICB9XG4gICAgICBhZGRRdWVyeVN0YXRlSGFuZGxlcihuYW1lLCBjYWxsYmFjaywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JDb21tYW5kcy5hZGRRdWVyeVN0YXRlSGFuZGxlcihuYW1lLCBjYWxsYmFjaywgc2NvcGUpO1xuICAgICAgfVxuICAgICAgYWRkUXVlcnlWYWx1ZUhhbmRsZXIobmFtZSwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yQ29tbWFuZHMuYWRkUXVlcnlWYWx1ZUhhbmRsZXIobmFtZSwgY2FsbGJhY2ssIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGFkZFNob3J0Y3V0KHBhdHRlcm4sIGRlc2MsIGNtZEZ1bmMsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2hvcnRjdXRzLmFkZChwYXR0ZXJuLCBkZXNjLCBjbWRGdW5jLCBzY29wZSk7XG4gICAgICB9XG4gICAgICBleGVjQ29tbWFuZChjbWQsIHVpLCB2YWx1ZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JDb21tYW5kcy5leGVjQ29tbWFuZChjbWQsIHVpLCB2YWx1ZSwgYXJncyk7XG4gICAgICB9XG4gICAgICBxdWVyeUNvbW1hbmRTdGF0ZShjbWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yQ29tbWFuZHMucXVlcnlDb21tYW5kU3RhdGUoY21kKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Q29tbWFuZFZhbHVlKGNtZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JDb21tYW5kcy5xdWVyeUNvbW1hbmRWYWx1ZShjbWQpO1xuICAgICAgfVxuICAgICAgcXVlcnlDb21tYW5kU3VwcG9ydGVkKGNtZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JDb21tYW5kcy5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoY21kKTtcbiAgICAgIH1cbiAgICAgIHNob3coKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5oaWRkZW4pIHtcbiAgICAgICAgICBzZWxmLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIGlmIChzZWxmLmlubGluZSkge1xuICAgICAgICAgICAgc2VsZi5nZXRCb2R5KCkuY29udGVudEVkaXRhYmxlID0gJ3RydWUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBET00kMS5zaG93KHNlbGYuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICAgICAgRE9NJDEuaGlkZShzZWxmLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaCgnc2hvdycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoaWRlKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmhpZGRlbikge1xuICAgICAgICAgIHNlbGYuc2F2ZSgpO1xuICAgICAgICAgIGlmIChzZWxmLmlubGluZSkge1xuICAgICAgICAgICAgc2VsZi5nZXRCb2R5KCkuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgICAgICAgICAgIGlmIChzZWxmID09PSBzZWxmLmVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvcikge1xuICAgICAgICAgICAgICBzZWxmLmVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIERPTSQxLmhpZGUoc2VsZi5nZXRDb250YWluZXIoKSk7XG4gICAgICAgICAgICBET00kMS5zZXRTdHlsZShzZWxmLmlkLCAnZGlzcGxheScsIHNlbGYub3JnRGlzcGxheSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdoaWRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzSGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRkZW47XG4gICAgICB9XG4gICAgICBzZXRQcm9ncmVzc1N0YXRlKHN0YXRlLCB0aW1lKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goJ1Byb2dyZXNzU3RhdGUnLCB7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgdGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvYWQoYXJncyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbG0gPSBzZWxmLmdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHNlbGYucmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgY29uc3QgbG9hZEFyZ3MgPSB7XG4gICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgbG9hZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1RleHRhcmVhT3JJbnB1dChlbG0pID8gZWxtLnZhbHVlIDogZWxtLmlubmVySFRNTDtcbiAgICAgICAgICBjb25zdCBodG1sID0gc2VsZi5zZXRDb250ZW50KHZhbHVlLCBsb2FkQXJncyk7XG4gICAgICAgICAgaWYgKCFsb2FkQXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ0xvYWRDb250ZW50Jywge1xuICAgICAgICAgICAgICAuLi5sb2FkQXJncyxcbiAgICAgICAgICAgICAgZWxlbWVudDogZWxtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzYXZlKGFyZ3MgPSB7fSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGVsbSA9IHNlbGYuZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoIWVsbSB8fCAhc2VsZi5pbml0aWFsaXplZCB8fCBzZWxmLnJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2V0QXJncyA9IHtcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIHNhdmU6IHRydWUsXG4gICAgICAgICAgZWxlbWVudDogZWxtXG4gICAgICAgIH07XG4gICAgICAgIGxldCBodG1sID0gc2VsZi5nZXRDb250ZW50KGdldEFyZ3MpO1xuICAgICAgICBjb25zdCBzYXZlQXJncyA9IHtcbiAgICAgICAgICAuLi5nZXRBcmdzLFxuICAgICAgICAgIGNvbnRlbnQ6IGh0bWxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzYXZlQXJncy5ub19ldmVudHMpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoKCdTYXZlQ29udGVudCcsIHNhdmVBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F2ZUFyZ3MuZm9ybWF0ID09PSAncmF3Jykge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2goJ1Jhd1NhdmVDb250ZW50Jywgc2F2ZUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgPSBzYXZlQXJncy5jb250ZW50O1xuICAgICAgICBpZiAoIWlzVGV4dGFyZWFPcklucHV0KGVsbSkpIHtcbiAgICAgICAgICBpZiAoYXJncy5pc19yZW1vdmluZyB8fCAhc2VsZi5pbmxpbmUpIHtcbiAgICAgICAgICAgIGVsbS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmb3JtID0gRE9NJDEuZ2V0UGFyZW50KHNlbGYuaWQsICdmb3JtJyk7XG4gICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgIGVhY2gkMShmb3JtLmVsZW1lbnRzLCBlbG0gPT4ge1xuICAgICAgICAgICAgICBpZiAoZWxtLm5hbWUgPT09IHNlbGYuaWQpIHtcbiAgICAgICAgICAgICAgICBlbG0udmFsdWUgPSBodG1sO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IGh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgc2F2ZUFyZ3MuZWxlbWVudCA9IGdldEFyZ3MuZWxlbWVudCA9IGVsbSA9IG51bGw7XG4gICAgICAgIGlmIChzYXZlQXJncy5zZXRfZGlydHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5zZXREaXJ0eShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9XG4gICAgICBzZXRDb250ZW50KGNvbnRlbnQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNldENvbnRlbnQodGhpcywgY29udGVudCwgYXJncyk7XG4gICAgICB9XG4gICAgICBnZXRDb250ZW50KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRlbnQodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICBpbnNlcnRDb250ZW50KGNvbnRlbnQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICBjb250ZW50ID0gZXh0ZW5kKHsgY29udGVudCB9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4ZWNDb21tYW5kKCdtY2VJbnNlcnRDb250ZW50JywgZmFsc2UsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgcmVzZXRDb250ZW50KGluaXRpYWxDb250ZW50KSB7XG4gICAgICAgIGlmIChpbml0aWFsQ29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0Q29udGVudCh0aGlzLCB0aGlzLnN0YXJ0Q29udGVudCwgeyBmb3JtYXQ6ICdyYXcnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldENvbnRlbnQodGhpcywgaW5pdGlhbENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5kb01hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5zZXREaXJ0eShmYWxzZSk7XG4gICAgICAgIHRoaXMubm9kZUNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICAgIGlzRGlydHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc05vdERpcnR5O1xuICAgICAgfVxuICAgICAgc2V0RGlydHkoc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSAhdGhpcy5pc05vdERpcnR5O1xuICAgICAgICB0aGlzLmlzTm90RGlydHkgPSAhc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdkaXJ0eScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYuY29udGFpbmVyKSB7XG4gICAgICAgICAgc2VsZi5jb250YWluZXIgPSBzZWxmLmVkaXRvckNvbnRhaW5lciB8fCBET00kMS5nZXQoc2VsZi5pZCArICdfcGFyZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuY29udGFpbmVyO1xuICAgICAgfVxuICAgICAgZ2V0Q29udGVudEFyZWFDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRBcmVhQ29udGFpbmVyO1xuICAgICAgfVxuICAgICAgZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldEVsbSkge1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWxtID0gRE9NJDEuZ2V0KHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldEVsbTtcbiAgICAgIH1cbiAgICAgIGdldFdpbigpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgY29uc3QgZWxtID0gc2VsZi5pZnJhbWVFbGVtZW50O1xuICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgIHNlbGYuY29udGVudFdpbmRvdyA9IGVsbS5jb250ZW50V2luZG93O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5jb250ZW50V2luZG93O1xuICAgICAgfVxuICAgICAgZ2V0RG9jKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgICAgIGNvbnN0IHdpbiA9IHNlbGYuZ2V0V2luKCk7XG4gICAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgc2VsZi5jb250ZW50RG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmNvbnRlbnREb2N1bWVudDtcbiAgICAgIH1cbiAgICAgIGdldEJvZHkoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuZ2V0RG9jKCk7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmJvZHlFbGVtZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuYm9keSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnZlcnRVUkwodXJsLCBuYW1lLCBlbG0pIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXMsIGdldE9wdGlvbiA9IHNlbGYub3B0aW9ucy5nZXQ7XG4gICAgICAgIGNvbnN0IHVybENvbnZlcnRlckNhbGxiYWNrID0gZ2V0VXJsQ29udmVydGVyQ2FsbGJhY2soc2VsZik7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHVybENvbnZlcnRlckNhbGxiYWNrKSkge1xuICAgICAgICAgIHJldHVybiB1cmxDb252ZXJ0ZXJDYWxsYmFjay5jYWxsKHNlbGYsIHVybCwgZWxtLCB0cnVlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldE9wdGlvbignY29udmVydF91cmxzJykgfHwgZWxtID09PSAnbGluaycgfHwgaXNPYmplY3QoZWxtKSAmJiBlbG0ubm9kZU5hbWUgPT09ICdMSU5LJyB8fCB1cmwuaW5kZXhPZignZmlsZTonKSA9PT0gMCB8fCB1cmwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0T3B0aW9uKCdyZWxhdGl2ZV91cmxzJykpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5kb2N1bWVudEJhc2VVUkkudG9SZWxhdGl2ZSh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHNlbGYuZG9jdW1lbnRCYXNlVVJJLnRvQWJzb2x1dGUodXJsLCBnZXRPcHRpb24oJ3JlbW92ZV9zY3JpcHRfaG9zdCcpKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH1cbiAgICAgIGFkZFZpc3VhbChlbG0pIHtcbiAgICAgICAgYWRkVmlzdWFsKHRoaXMsIGVsbSk7XG4gICAgICB9XG4gICAgICBzZXRFZGl0YWJsZVJvb3Qoc3RhdGUpIHtcbiAgICAgICAgc2V0RWRpdGFibGVSb290KHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGhhc0VkaXRhYmxlUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0VkaXRhYmxlUm9vdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgcmVtb3ZlJDEodGhpcyk7XG4gICAgICB9XG4gICAgICBkZXN0cm95KGF1dG9tYXRpYykge1xuICAgICAgICBkZXN0cm95KHRoaXMsIGF1dG9tYXRpYyk7XG4gICAgICB9XG4gICAgICB1cGxvYWRJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvclVwbG9hZC51cGxvYWRJbWFnZXMoKTtcbiAgICAgIH1cbiAgICAgIF9zY2FuRm9ySW1hZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3JVcGxvYWQuc2NhbkZvckltYWdlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IERPTSA9IERPTVV0aWxzLkRPTTtcbiAgICBjb25zdCBlYWNoID0gVG9vbHMuZWFjaDtcbiAgICBsZXQgYm91bmRHbG9iYWxFdmVudHMgPSBmYWxzZTtcbiAgICBsZXQgYmVmb3JlVW5sb2FkRGVsZWdhdGU7XG4gICAgbGV0IGVkaXRvcnMgPSBbXTtcbiAgICBjb25zdCBnbG9iYWxFdmVudERlbGVnYXRlID0gZSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gZS50eXBlO1xuICAgICAgZWFjaChFZGl0b3JNYW5hZ2VyLmdldCgpLCBlZGl0b3IgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ1Njcm9sbFdpbmRvdycsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXNpemUnOlxuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaCgnUmVzaXplV2luZG93JywgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlR2xvYmFsRXZlbnRzID0gc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlICE9PSBib3VuZEdsb2JhbEV2ZW50cykge1xuICAgICAgICBjb25zdCBET00gPSBET01VdGlscy5ET007XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICAgIERPTS5iaW5kKHdpbmRvdywgJ3Njcm9sbCcsIGdsb2JhbEV2ZW50RGVsZWdhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ2xvYmFsRXZlbnREZWxlZ2F0ZSk7XG4gICAgICAgICAgRE9NLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBnbG9iYWxFdmVudERlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZEdsb2JhbEV2ZW50cyA9IHN0YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRWRpdG9yRnJvbUxpc3QgPSB0YXJnZXRFZGl0b3IgPT4ge1xuICAgICAgY29uc3Qgb2xkRWRpdG9ycyA9IGVkaXRvcnM7XG4gICAgICBlZGl0b3JzID0gZmlsdGVyJDUoZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVkaXRvciAhPT0gZWRpdG9yO1xuICAgICAgfSk7XG4gICAgICBpZiAoRWRpdG9yTWFuYWdlci5hY3RpdmVFZGl0b3IgPT09IHRhcmdldEVkaXRvcikge1xuICAgICAgICBFZGl0b3JNYW5hZ2VyLmFjdGl2ZUVkaXRvciA9IGVkaXRvcnMubGVuZ3RoID4gMCA/IGVkaXRvcnNbMF0gOiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9PT0gdGFyZ2V0RWRpdG9yKSB7XG4gICAgICAgIEVkaXRvck1hbmFnZXIuZm9jdXNlZEVkaXRvciA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2xkRWRpdG9ycy5sZW5ndGggIT09IGVkaXRvcnMubGVuZ3RoO1xuICAgIH07XG4gICAgY29uc3QgcHVyZ2VEZXN0cm95ZWRFZGl0b3IgPSBlZGl0b3IgPT4ge1xuICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3IuaW5pdGlhbGl6ZWQgJiYgIShlZGl0b3IuZ2V0Q29udGFpbmVyKCkgfHwgZWRpdG9yLmdldEJvZHkoKSkucGFyZW50Tm9kZSkge1xuICAgICAgICByZW1vdmVFZGl0b3JGcm9tTGlzdChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IudW5iaW5kQWxsTmF0aXZlRXZlbnRzKCk7XG4gICAgICAgIGVkaXRvci5kZXN0cm95KHRydWUpO1xuICAgICAgICBlZGl0b3IucmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpc1F1aXJrc01vZGUgPSBkb2N1bWVudC5jb21wYXRNb2RlICE9PSAnQ1NTMUNvbXBhdCc7XG4gICAgY29uc3QgRWRpdG9yTWFuYWdlciA9IHtcbiAgICAgIC4uLk9ic2VydmFibGUsXG4gICAgICBiYXNlVVJJOiBudWxsLFxuICAgICAgYmFzZVVSTDogbnVsbCxcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgIGRvY3VtZW50QmFzZVVSTDogbnVsbCxcbiAgICAgIHN1ZmZpeDogbnVsbCxcbiAgICAgIG1ham9yVmVyc2lvbjogJzYnLFxuICAgICAgbWlub3JWZXJzaW9uOiAnNy4wJyxcbiAgICAgIHJlbGVhc2VEYXRlOiAnMjAyMy0wOC0zMCcsXG4gICAgICBpMThuOiBJMThuLFxuICAgICAgYWN0aXZlRWRpdG9yOiBudWxsLFxuICAgICAgZm9jdXNlZEVkaXRvcjogbnVsbCxcbiAgICAgIHNldHVwKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2VVUkwgPSAnJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgICBsZXQgZG9jdW1lbnRCYXNlVVJMID0gVVJJLmdldERvY3VtZW50QmFzZVVybChkb2N1bWVudC5sb2NhdGlvbik7XG4gICAgICAgIGlmICgvXlteOl0rOlxcL1xcL1xcLz9bXlxcL10rXFwvLy50ZXN0KGRvY3VtZW50QmFzZVVSTCkpIHtcbiAgICAgICAgICBkb2N1bWVudEJhc2VVUkwgPSBkb2N1bWVudEJhc2VVUkwucmVwbGFjZSgvW1xcPyNdLiokLywgJycpLnJlcGxhY2UoL1tcXC9cXFxcXVteXFwvXSskLywgJycpO1xuICAgICAgICAgIGlmICghL1tcXC9cXFxcXSQvLnRlc3QoZG9jdW1lbnRCYXNlVVJMKSkge1xuICAgICAgICAgICAgZG9jdW1lbnRCYXNlVVJMICs9ICcvJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlSW5pdCA9IHdpbmRvdy50aW55bWNlIHx8IHdpbmRvdy50aW55TUNFUHJlSW5pdDtcbiAgICAgICAgaWYgKHByZUluaXQpIHtcbiAgICAgICAgICBiYXNlVVJMID0gcHJlSW5pdC5iYXNlIHx8IHByZUluaXQuYmFzZVVSTDtcbiAgICAgICAgICBzdWZmaXggPSBwcmVJbml0LnN1ZmZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gc2NyaXB0c1tpXS5zcmMgfHwgJyc7XG4gICAgICAgICAgICBpZiAoc3JjID09PSAnJykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNyY1NjcmlwdCA9IHNyYy5zdWJzdHJpbmcoc3JjLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgaWYgKC90aW55bWNlKFxcLmZ1bGx8XFwuanF1ZXJ5fCkoXFwubWlufFxcLmRldnwpXFwuanMvLnRlc3Qoc3JjKSkge1xuICAgICAgICAgICAgICBpZiAoc3JjU2NyaXB0LmluZGV4T2YoJy5taW4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSAnLm1pbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmFzZVVSTCA9IHNyYy5zdWJzdHJpbmcoMCwgc3JjLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFiYXNlVVJMICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICAgICAgICAgICAgaWYgKHNyYy5pbmRleE9mKCcubWluJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN1ZmZpeCA9ICcubWluJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VVUkwgPSBzcmMuc3Vic3RyaW5nKDAsIHNyYy5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5iYXNlVVJMID0gbmV3IFVSSShkb2N1bWVudEJhc2VVUkwpLnRvQWJzb2x1dGUoYmFzZVVSTCk7XG4gICAgICAgIHNlbGYuZG9jdW1lbnRCYXNlVVJMID0gZG9jdW1lbnRCYXNlVVJMO1xuICAgICAgICBzZWxmLmJhc2VVUkkgPSBuZXcgVVJJKHNlbGYuYmFzZVVSTCk7XG4gICAgICAgIHNlbGYuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICBzZXR1cCR2KHNlbGYpO1xuICAgICAgfSxcbiAgICAgIG92ZXJyaWRlRGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGRlZmF1bHRPcHRpb25zLmJhc2VfdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgIHRoaXMuX3NldEJhc2VVcmwoYmFzZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gZGVmYXVsdE9wdGlvbnMuc3VmZml4O1xuICAgICAgICBpZiAoc3VmZml4KSB7XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICBjb25zdCBwbHVnaW5CYXNlVXJscyA9IGRlZmF1bHRPcHRpb25zLnBsdWdpbl9iYXNlX3VybHM7XG4gICAgICAgIGlmIChwbHVnaW5CYXNlVXJscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWFjaCRkKHBsdWdpbkJhc2VVcmxzLCAocGx1Z2luQmFzZVVybCwgcGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICAgICAgQWRkT25NYW5hZ2VyLlBsdWdpbk1hbmFnZXIudXJsc1twbHVnaW5OYW1lXSA9IHBsdWdpbkJhc2VVcmw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGludmFsaWRJbmxpbmVUYXJnZXRzID0gVG9vbHMubWFrZU1hcCgnYXJlYSBiYXNlIGJhc2Vmb250IGJyIGNvbCBmcmFtZSBociBpbWcgaW5wdXQgaXNpbmRleCBsaW5rIG1ldGEgcGFyYW0gZW1iZWQgc291cmNlIHdiciB0cmFjayAnICsgJ2NvbGdyb3VwIG9wdGlvbiB0YWJsZSB0Ym9keSB0Zm9vdCB0aGVhZCB0ciB0aCB0ZCBzY3JpcHQgbm9zY3JpcHQgc3R5bGUgdGV4dGFyZWEgdmlkZW8gYXVkaW8gaWZyYW1lIG9iamVjdCBtZW51JywgJyAnKTtcbiAgICAgICAgY29uc3QgaXNJbnZhbGlkSW5saW5lVGFyZ2V0ID0gKG9wdGlvbnMsIGVsbSkgPT4gb3B0aW9ucy5pbmxpbmUgJiYgZWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSBpbiBpbnZhbGlkSW5saW5lVGFyZ2V0cztcbiAgICAgICAgY29uc3QgY3JlYXRlSWQgPSBlbG0gPT4ge1xuICAgICAgICAgIGxldCBpZCA9IGVsbS5pZDtcbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBpZCA9IGdldCRhKGVsbSwgJ25hbWUnKS5maWx0ZXIobmFtZSA9PiAhRE9NLmdldChuYW1lKSkuZ2V0T3JUaHVuayhET00udW5pcXVlSWQpO1xuICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhlY0NhbGxiYWNrID0gbmFtZSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zW25hbWVdO1xuICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluZFRhcmdldHMgPSBvcHRpb25zID0+IHtcbiAgICAgICAgICBpZiAoRW52LmJyb3dzZXIuaXNJRSgpIHx8IEVudi5icm93c2VyLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICBpbml0RXJyb3IoJ1RpbnlNQ0UgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nLiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCcgKyAnIGJyb3dzZXJzIHBsZWFzZSBzZWU6IGh0dHBzOi8vd3d3LnRpbnkuY2xvdWQvZG9jcy90aW55bWNlLzYvc3VwcG9ydC8jc3VwcG9ydGVkd2ViYnJvd3NlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVpcmtzTW9kZSkge1xuICAgICAgICAgICAgaW5pdEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZWRpdG9yIGFzIHRoZSBkb2N1bWVudCBpcyBub3QgaW4gc3RhbmRhcmRzIG1vZGUuICcgKyAnVGlueU1DRSByZXF1aXJlcyBzdGFuZGFyZHMgbW9kZS4nKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG9wdGlvbnMuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gRE9NLnNlbGVjdChvcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9uTnVsbGFibGUob3B0aW9ucy50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW29wdGlvbnMudGFyZ2V0XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHByb3ZpZGVSZXN1bHRzID0gZWRpdG9ycyA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gZWRpdG9ycztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5pdEVkaXRvcnMgPSAoKSA9PiB7XG4gICAgICAgICAgbGV0IGluaXRDb3VudCA9IDA7XG4gICAgICAgICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgICAgICAgIGxldCB0YXJnZXRzO1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZUVkaXRvciA9IChpZCwgb3B0aW9ucywgdGFyZ2V0RWxtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKGlkLCBvcHRpb25zLCBzZWxmKTtcbiAgICAgICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoKytpbml0Q291bnQgPT09IHRhcmdldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZVJlc3VsdHMoZWRpdG9ycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdG9yLnRhcmdldEVsbSA9IGVkaXRvci50YXJnZXRFbG0gfHwgdGFyZ2V0RWxtO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgRE9NLnVuYmluZCh3aW5kb3csICdyZWFkeScsIGluaXRFZGl0b3JzKTtcbiAgICAgICAgICBleGVjQ2FsbGJhY2soJ29ucGFnZWxvYWQnKTtcbiAgICAgICAgICB0YXJnZXRzID0gdW5pcXVlJDEoZmluZFRhcmdldHMob3B0aW9ucykpO1xuICAgICAgICAgIFRvb2xzLmVhY2godGFyZ2V0cywgZWxtID0+IHtcbiAgICAgICAgICAgIHB1cmdlRGVzdHJveWVkRWRpdG9yKHNlbGYuZ2V0KGVsbS5pZCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldHMgPSBUb29scy5ncmVwKHRhcmdldHMsIGVsbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGYuZ2V0KGVsbS5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwcm92aWRlUmVzdWx0cyhbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhY2godGFyZ2V0cywgZWxtID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZElubGluZVRhcmdldChvcHRpb25zLCBlbG0pKSB7XG4gICAgICAgICAgICAgICAgaW5pdEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBpbmxpbmUgZWRpdG9yIG9uIGludmFsaWQgaW5saW5lIHRhcmdldCBlbGVtZW50JywgZWxtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFZGl0b3IoY3JlYXRlSWQoZWxtKSwgb3B0aW9ucywgZWxtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBET00uYmluZCh3aW5kb3csICdyZWFkeScsIGluaXRFZGl0b3JzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZVJlc3VsdHMgPSBlZGl0b3JzID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShlZGl0b3JzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXQoaWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9ycy5zbGljZSgwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmluZCQyKGVkaXRvcnMsIGVkaXRvciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLmlkID09PSBpZDtcbiAgICAgICAgICB9KS5nZXRPcihudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpZCkpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yc1tpZF0gPyBlZGl0b3JzW2lkXSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGQoZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBleGlzdGluZ0VkaXRvciA9IHNlbGYuZ2V0KGVkaXRvci5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZ0VkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RpbmdFZGl0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVHbG9iYWxFdmVudHModHJ1ZSk7XG4gICAgICAgIHNlbGYuYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBzZWxmLmRpc3BhdGNoKCdBZGRFZGl0b3InLCB7IGVkaXRvciB9KTtcbiAgICAgICAgaWYgKCFiZWZvcmVVbmxvYWREZWxlZ2F0ZSkge1xuICAgICAgICAgIGJlZm9yZVVubG9hZERlbGVnYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHNlbGYuZGlzcGF0Y2goJ0JlZm9yZVVubG9hZCcpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJldHVyblZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgYmVmb3JlVW5sb2FkRGVsZWdhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRWRpdG9yKGlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChuZXcgRWRpdG9yKGlkLCBvcHRpb25zLCB0aGlzKSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlKHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZWRpdG9yO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGVkaXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKGVkaXRvcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGVhY2goRE9NLnNlbGVjdChzZWxlY3RvciksIGVsbSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IgPSBzZWxmLmdldChlbG0uaWQpO1xuICAgICAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgICBzZWxmLnJlbW92ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgaWYgKGlzTnVsbChzZWxmLmdldChlZGl0b3IuaWQpKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1vdmVFZGl0b3JGcm9tTGlzdChlZGl0b3IpKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaCgnUmVtb3ZlRWRpdG9yJywgeyBlZGl0b3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGJlZm9yZVVubG9hZERlbGVnYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIHRvZ2dsZUdsb2JhbEV2ZW50cyhlZGl0b3JzLmxlbmd0aCA+IDApO1xuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgfSxcbiAgICAgIGV4ZWNDb21tYW5kKGNtZCwgdWksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVkaXRvcklkID0gaXNPYmplY3QodmFsdWUpID8gKF9hID0gdmFsdWUuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLmluZGV4IDogdmFsdWU7XG4gICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgJ21jZUFkZEVkaXRvcic6IHtcbiAgICAgICAgICAgIGlmICghc2VsZi5nZXQoZWRpdG9ySWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVkaXRvck9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICAgICAgICBuZXcgRWRpdG9yKGVkaXRvcklkLCBlZGl0b3JPcHRpb25zLCBzZWxmKS5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbWNlUmVtb3ZlRWRpdG9yJzoge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gc2VsZi5nZXQoZWRpdG9ySWQpO1xuICAgICAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21jZVRvZ2dsZUVkaXRvcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHNlbGYuZ2V0KGVkaXRvcklkKTtcbiAgICAgICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICAgIHNlbGYuZXhlY0NvbW1hbmQoJ21jZUFkZEVkaXRvcicsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVkaXRvci5pc0hpZGRlbigpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGl0b3IuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmFjdGl2ZUVkaXRvcikge1xuICAgICAgICAgIHJldHVybiBzZWxmLmFjdGl2ZUVkaXRvci5leGVjQ29tbWFuZChjbWQsIHVpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJTYXZlOiAoKSA9PiB7XG4gICAgICAgIGVhY2goZWRpdG9ycywgZWRpdG9yID0+IHtcbiAgICAgICAgICBlZGl0b3Iuc2F2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRJMThuOiAoY29kZSwgaXRlbXMpID0+IHtcbiAgICAgICAgSTE4bi5hZGQoY29kZSwgaXRlbXMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogdGV4dCA9PiB7XG4gICAgICAgIHJldHVybiBJMThuLnRyYW5zbGF0ZSh0ZXh0KTtcbiAgICAgIH0sXG4gICAgICBzZXRBY3RpdmUoZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVkaXRvciA9IHRoaXMuYWN0aXZlRWRpdG9yO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVFZGl0b3IgIT09IGVkaXRvcikge1xuICAgICAgICAgIGlmIChhY3RpdmVFZGl0b3IpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVkaXRvci5kaXNwYXRjaCgnZGVhY3RpdmF0ZScsIHsgcmVsYXRlZFRhcmdldDogZWRpdG9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2goJ2FjdGl2YXRlJywgeyByZWxhdGVkVGFyZ2V0OiBhY3RpdmVFZGl0b3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgICB9LFxuICAgICAgX3NldEJhc2VVcmwoYmFzZVVybCkge1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBuZXcgVVJJKHRoaXMuZG9jdW1lbnRCYXNlVVJMKS50b0Fic29sdXRlKGJhc2VVcmwucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSBuZXcgVVJJKHRoaXMuYmFzZVVSTCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3JNYW5hZ2VyLnNldHVwKCk7XG5cbiAgICBjb25zdCBzZXR1cCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFWYWx1ZSA9IHZhbHVlJDIoKTtcbiAgICAgIGNvbnN0IEZha2VDbGlwYm9hcmRJdGVtID0gaXRlbXMgPT4gKHtcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHR5cGVzOiBrZXlzKGl0ZW1zKSxcbiAgICAgICAgZ2V0VHlwZTogdHlwZSA9PiBnZXQkYShpdGVtcywgdHlwZSkuZ2V0T3JVbmRlZmluZWQoKVxuICAgICAgfSk7XG4gICAgICBjb25zdCB3cml0ZSA9IGRhdGEgPT4ge1xuICAgICAgICBkYXRhVmFsdWUuc2V0KGRhdGEpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlYWQgPSAoKSA9PiBkYXRhVmFsdWUuZ2V0KCkuZ2V0T3JVbmRlZmluZWQoKTtcbiAgICAgIGNvbnN0IGNsZWFyID0gZGF0YVZhbHVlLmNsZWFyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgRmFrZUNsaXBib2FyZEl0ZW0sXG4gICAgICAgIHdyaXRlLFxuICAgICAgICByZWFkLFxuICAgICAgICBjbGVhclxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IEZha2VDbGlwYm9hcmQgPSBzZXR1cCgpO1xuXG4gICAgY29uc3QgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LCByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IChyZWN0LCB0YXJnZXRSZWN0LCByZWwpID0+IHtcbiAgICAgIGxldCB4ID0gdGFyZ2V0UmVjdC54O1xuICAgICAgbGV0IHkgPSB0YXJnZXRSZWN0Lnk7XG4gICAgICBjb25zdCB3ID0gcmVjdC53O1xuICAgICAgY29uc3QgaCA9IHJlY3QuaDtcbiAgICAgIGNvbnN0IHRhcmdldFcgPSB0YXJnZXRSZWN0Lnc7XG4gICAgICBjb25zdCB0YXJnZXRIID0gdGFyZ2V0UmVjdC5oO1xuICAgICAgY29uc3QgcmVsQ2hhcnMgPSAocmVsIHx8ICcnKS5zcGxpdCgnJyk7XG4gICAgICBpZiAocmVsQ2hhcnNbMF0gPT09ICdiJykge1xuICAgICAgICB5ICs9IHRhcmdldEg7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbMV0gPT09ICdyJykge1xuICAgICAgICB4ICs9IHRhcmdldFc7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbMF0gPT09ICdjJykge1xuICAgICAgICB5ICs9IHJvdW5kKHRhcmdldEggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxDaGFyc1sxXSA9PT0gJ2MnKSB7XG4gICAgICAgIHggKz0gcm91bmQodGFyZ2V0VyAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzNdID09PSAnYicpIHtcbiAgICAgICAgeSAtPSBoO1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzRdID09PSAncicpIHtcbiAgICAgICAgeCAtPSB3O1xuICAgICAgfVxuICAgICAgaWYgKHJlbENoYXJzWzNdID09PSAnYycpIHtcbiAgICAgICAgeSAtPSByb3VuZChoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAocmVsQ2hhcnNbNF0gPT09ICdjJykge1xuICAgICAgICB4IC09IHJvdW5kKHcgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGUkMih4LCB5LCB3LCBoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmRCZXN0UmVsYXRpdmVQb3NpdGlvbiA9IChyZWN0LCB0YXJnZXRSZWN0LCBjb25zdHJhaW5SZWN0LCByZWxzKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9zID0gcmVsYXRpdmVQb3NpdGlvbihyZWN0LCB0YXJnZXRSZWN0LCByZWxzW2ldKTtcbiAgICAgICAgaWYgKHBvcy54ID49IGNvbnN0cmFpblJlY3QueCAmJiBwb3MueCArIHBvcy53IDw9IGNvbnN0cmFpblJlY3QudyArIGNvbnN0cmFpblJlY3QueCAmJiBwb3MueSA+PSBjb25zdHJhaW5SZWN0LnkgJiYgcG9zLnkgKyBwb3MuaCA8PSBjb25zdHJhaW5SZWN0LmggKyBjb25zdHJhaW5SZWN0LnkpIHtcbiAgICAgICAgICByZXR1cm4gcmVsc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBpbmZsYXRlID0gKHJlY3QsIHcsIGgpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGUkMihyZWN0LnggLSB3LCByZWN0LnkgLSBoLCByZWN0LncgKyB3ICogMiwgcmVjdC5oICsgaCAqIDIpO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gKHJlY3QsIGNyb3BSZWN0KSA9PiB7XG4gICAgICBjb25zdCB4MSA9IG1heChyZWN0LngsIGNyb3BSZWN0LngpO1xuICAgICAgY29uc3QgeTEgPSBtYXgocmVjdC55LCBjcm9wUmVjdC55KTtcbiAgICAgIGNvbnN0IHgyID0gbWluKHJlY3QueCArIHJlY3QudywgY3JvcFJlY3QueCArIGNyb3BSZWN0LncpO1xuICAgICAgY29uc3QgeTIgPSBtaW4ocmVjdC55ICsgcmVjdC5oLCBjcm9wUmVjdC55ICsgY3JvcFJlY3QuaCk7XG4gICAgICBpZiAoeDIgLSB4MSA8IDAgfHwgeTIgLSB5MSA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlJDIoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsYW1wID0gKHJlY3QsIGNsYW1wUmVjdCwgZml4ZWRTaXplKSA9PiB7XG4gICAgICBsZXQgeDEgPSByZWN0Lng7XG4gICAgICBsZXQgeTEgPSByZWN0Lnk7XG4gICAgICBsZXQgeDIgPSByZWN0LnggKyByZWN0Lnc7XG4gICAgICBsZXQgeTIgPSByZWN0LnkgKyByZWN0Lmg7XG4gICAgICBjb25zdCBjeDIgPSBjbGFtcFJlY3QueCArIGNsYW1wUmVjdC53O1xuICAgICAgY29uc3QgY3kyID0gY2xhbXBSZWN0LnkgKyBjbGFtcFJlY3QuaDtcbiAgICAgIGNvbnN0IHVuZGVyZmxvd1gxID0gbWF4KDAsIGNsYW1wUmVjdC54IC0geDEpO1xuICAgICAgY29uc3QgdW5kZXJmbG93WTEgPSBtYXgoMCwgY2xhbXBSZWN0LnkgLSB5MSk7XG4gICAgICBjb25zdCBvdmVyZmxvd1gyID0gbWF4KDAsIHgyIC0gY3gyKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WTIgPSBtYXgoMCwgeTIgLSBjeTIpO1xuICAgICAgeDEgKz0gdW5kZXJmbG93WDE7XG4gICAgICB5MSArPSB1bmRlcmZsb3dZMTtcbiAgICAgIGlmIChmaXhlZFNpemUpIHtcbiAgICAgICAgeDIgKz0gdW5kZXJmbG93WDE7XG4gICAgICAgIHkyICs9IHVuZGVyZmxvd1kxO1xuICAgICAgICB4MSAtPSBvdmVyZmxvd1gyO1xuICAgICAgICB5MSAtPSBvdmVyZmxvd1kyO1xuICAgICAgfVxuICAgICAgeDIgLT0gb3ZlcmZsb3dYMjtcbiAgICAgIHkyIC09IG92ZXJmbG93WTI7XG4gICAgICByZXR1cm4gY3JlYXRlJDIoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZSQyID0gKHgsIHksIHcsIGgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHcsXG4gICAgICAgIGhcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBmcm9tQ2xpZW50UmVjdCA9IGNsaWVudFJlY3QgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZSQyKGNsaWVudFJlY3QubGVmdCwgY2xpZW50UmVjdC50b3AsIGNsaWVudFJlY3Qud2lkdGgsIGNsaWVudFJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuICAgIGNvbnN0IFJlY3QgPSB7XG4gICAgICBpbmZsYXRlLFxuICAgICAgcmVsYXRpdmVQb3NpdGlvbixcbiAgICAgIGZpbmRCZXN0UmVsYXRpdmVQb3NpdGlvbixcbiAgICAgIGludGVyc2VjdCxcbiAgICAgIGNsYW1wLFxuICAgICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICAgIGZyb21DbGllbnRSZWN0XG4gICAgfTtcblxuICAgIGNvbnN0IGF3YWl0ZXIgPSAocmVzb2x2ZUNiLCByZWplY3RDYiwgdGltZW91dCA9IDEwMDApID0+IHtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgY29uc3QgY29tcGxldGUgPSBjb21wbGV0ZXIgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByZXNvbHZlID0gY29tcGxldGUocmVzb2x2ZUNiKTtcbiAgICAgIGNvbnN0IHJlamVjdCA9IGNvbXBsZXRlKHJlamVjdENiKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKCFkb25lICYmIHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdC5hcHBseShudWxsLCBhcmdzKSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlJDEgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YXNrcyA9IHt9O1xuICAgICAgY29uc3QgcmVzdWx0Rm5zID0ge307XG4gICAgICBjb25zdCBsb2FkID0gKGlkLCB1cmwpID0+IHtcbiAgICAgICAgY29uc3QgbG9hZEVyck1zZyA9IGBTY3JpcHQgYXQgVVJMIFwiJHsgdXJsIH1cIiBmYWlsZWQgdG8gbG9hZGA7XG4gICAgICAgIGNvbnN0IHJ1bkVyck1zZyA9IGBTY3JpcHQgYXQgVVJMIFwiJHsgdXJsIH1cIiBkaWQgbm90IGNhbGwgXFxgdGlueW1jZS5SZXNvdXJjZS5hZGQoJyR7IGlkIH0nLCBkYXRhKVxcYCB3aXRoaW4gMSBzZWNvbmRgO1xuICAgICAgICBpZiAodGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGFza3NbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWl0ZXIgPSBhd2FpdGVyKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICByZXN1bHRGbnNbaWRdID0gd2FpdGVyLnJlc29sdmU7XG4gICAgICAgICAgICBTY3JpcHRMb2FkZXIuU2NyaXB0TG9hZGVyLmxvYWRTY3JpcHQodXJsKS50aGVuKCgpID0+IHdhaXRlci5zdGFydChydW5FcnJNc2cpLCAoKSA9PiB3YWl0ZXIucmVqZWN0KGxvYWRFcnJNc2cpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXNrc1tpZF0gPSB0YXNrO1xuICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWRkID0gKGlkLCBkYXRhKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRGbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHRGbnNbaWRdKGRhdGEpO1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHRGbnNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHRhc2tzW2lkXSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmxvYWQgPSBpZCA9PiB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc1tpZF07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9hZCxcbiAgICAgICAgYWRkLFxuICAgICAgICB1bmxvYWRcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBSZXNvdXJjZSA9IGNyZWF0ZSQxKCk7XG5cbiAgICBjb25zdCBjcmVhdGUgPSAoKSA9PiAoKCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgIGxldCBrZXlzID0gW107XG4gICAgICBjb25zdCBzdG9yYWdlID0ge1xuICAgICAgICBnZXRJdGVtOiBrZXkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW2tleV07XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBkYXRhW2tleV0gPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBrZXk6IGluZGV4ID0+IHtcbiAgICAgICAgICByZXR1cm4ga2V5c1tpbmRleF07XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IGtleSA9PiB7XG4gICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGsgPT4gayA9PT0ga2V5KTtcbiAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICAgIGtleXMgPSBbXTtcbiAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogMFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yYWdlLCAnbGVuZ3RoJywge1xuICAgICAgICBnZXQ6ICgpID0+IGtleXMubGVuZ3RoLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICB9KSgpO1xuXG4gICAgbGV0IGxvY2FsU3RvcmFnZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVzdCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICAgIGxvY2FsU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvY2FsU3RvcmFnZSA9IGNyZWF0ZSgpO1xuICAgIH1cbiAgICB2YXIgTG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuXG4gICAgY29uc3QgcHVibGljQXBpID0ge1xuICAgICAgZ2VvbTogeyBSZWN0IH0sXG4gICAgICB1dGlsOiB7XG4gICAgICAgIERlbGF5LFxuICAgICAgICBUb29scyxcbiAgICAgICAgVkssXG4gICAgICAgIFVSSSxcbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLFxuICAgICAgICBPYnNlcnZhYmxlLFxuICAgICAgICBJMThuLFxuICAgICAgICBMb2NhbFN0b3JhZ2UsXG4gICAgICAgIEltYWdlVXBsb2FkZXJcbiAgICAgIH0sXG4gICAgICBkb206IHtcbiAgICAgICAgRXZlbnRVdGlscyxcbiAgICAgICAgVHJlZVdhbGtlcjogRG9tVHJlZVdhbGtlcixcbiAgICAgICAgVGV4dFNlZWtlcixcbiAgICAgICAgRE9NVXRpbHMsXG4gICAgICAgIFNjcmlwdExvYWRlcixcbiAgICAgICAgUmFuZ2VVdGlscyxcbiAgICAgICAgU2VyaWFsaXplcjogRG9tU2VyaWFsaXplcixcbiAgICAgICAgU3R5bGVTaGVldExvYWRlcixcbiAgICAgICAgQ29udHJvbFNlbGVjdGlvbixcbiAgICAgICAgQm9va21hcmtNYW5hZ2VyLFxuICAgICAgICBTZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbixcbiAgICAgICAgRXZlbnQ6IEV2ZW50VXRpbHMuRXZlbnRcbiAgICAgIH0sXG4gICAgICBodG1sOiB7XG4gICAgICAgIFN0eWxlcyxcbiAgICAgICAgRW50aXRpZXMsXG4gICAgICAgIE5vZGU6IEFzdE5vZGUsXG4gICAgICAgIFNjaGVtYSxcbiAgICAgICAgRG9tUGFyc2VyLFxuICAgICAgICBXcml0ZXIsXG4gICAgICAgIFNlcmlhbGl6ZXI6IEh0bWxTZXJpYWxpemVyXG4gICAgICB9LFxuICAgICAgRW52LFxuICAgICAgQWRkT25NYW5hZ2VyLFxuICAgICAgQW5ub3RhdG9yLFxuICAgICAgRm9ybWF0dGVyLFxuICAgICAgVW5kb01hbmFnZXIsXG4gICAgICBFZGl0b3JDb21tYW5kcyxcbiAgICAgIFdpbmRvd01hbmFnZXIsXG4gICAgICBOb3RpZmljYXRpb25NYW5hZ2VyLFxuICAgICAgRWRpdG9yT2JzZXJ2YWJsZSxcbiAgICAgIFNob3J0Y3V0cyxcbiAgICAgIEVkaXRvcixcbiAgICAgIEZvY3VzTWFuYWdlcixcbiAgICAgIEVkaXRvck1hbmFnZXIsXG4gICAgICBET006IERPTVV0aWxzLkRPTSxcbiAgICAgIFNjcmlwdExvYWRlcjogU2NyaXB0TG9hZGVyLlNjcmlwdExvYWRlcixcbiAgICAgIFBsdWdpbk1hbmFnZXIsXG4gICAgICBUaGVtZU1hbmFnZXIsXG4gICAgICBNb2RlbE1hbmFnZXIsXG4gICAgICBJY29uTWFuYWdlcixcbiAgICAgIFJlc291cmNlLFxuICAgICAgRmFrZUNsaXBib2FyZCxcbiAgICAgIHRyaW06IFRvb2xzLnRyaW0sXG4gICAgICBpc0FycmF5OiBUb29scy5pc0FycmF5LFxuICAgICAgaXM6IFRvb2xzLmlzLFxuICAgICAgdG9BcnJheTogVG9vbHMudG9BcnJheSxcbiAgICAgIG1ha2VNYXA6IFRvb2xzLm1ha2VNYXAsXG4gICAgICBlYWNoOiBUb29scy5lYWNoLFxuICAgICAgbWFwOiBUb29scy5tYXAsXG4gICAgICBncmVwOiBUb29scy5ncmVwLFxuICAgICAgaW5BcnJheTogVG9vbHMuaW5BcnJheSxcbiAgICAgIGV4dGVuZDogVG9vbHMuZXh0ZW5kLFxuICAgICAgd2FsazogVG9vbHMud2FsayxcbiAgICAgIHJlc29sdmU6IFRvb2xzLnJlc29sdmUsXG4gICAgICBleHBsb2RlOiBUb29scy5leHBsb2RlLFxuICAgICAgX2FkZENhY2hlU3VmZml4OiBUb29scy5fYWRkQ2FjaGVTdWZmaXhcbiAgICB9O1xuICAgIGNvbnN0IHRpbnltY2UgPSBUb29scy5leHRlbmQoRWRpdG9yTWFuYWdlciwgcHVibGljQXBpKTtcblxuICAgIGNvbnN0IGV4cG9ydFRvTW9kdWxlTG9hZGVycyA9IHRpbnltY2UgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0aW55bWNlO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGV4cG9ydFRvV2luZG93R2xvYmFsID0gdGlueW1jZSA9PiB7XG4gICAgICB3aW5kb3cudGlueW1jZSA9IHRpbnltY2U7XG4gICAgICB3aW5kb3cudGlueU1DRSA9IHRpbnltY2U7XG4gICAgfTtcbiAgICBleHBvcnRUb1dpbmRvd0dsb2JhbCh0aW55bWNlKTtcbiAgICBleHBvcnRUb01vZHVsZUxvYWRlcnModGlueW1jZSk7XG5cbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=